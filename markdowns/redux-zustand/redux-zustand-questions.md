# Redux + Zustand Interview Questions & Answers

A comprehensive guide covering Redux and Zustand state management libraries, their differences, use cases, and implementation patterns.

## Table of Contents

1. [What is Redux and what are its core principles?](#1-what-is-redux-and-what-are-its-core-principles)
2. [How do you handle complex state with multiple reducers?](#2-how-do-you-handle-complex-state-with-multiple-reducers)
3. [How does Redux Toolkit simplify Redux development?](#3-how-does-redux-toolkit-simplify-redux-development)
4. [How do you handle async operations with RTK Query?](#4-how-do-you-handle-async-operations-with-rtk-query)
5. [How do you create custom middleware in Redux?](#5-how-do-you-create-custom-middleware-in-redux)
6. [What is Zustand and how does it differ from Redux?](#6-what-is-zustand-and-how-does-it-differ-from-redux)
7. [How do you implement middleware and persistence in Zustand?](#7-how-do-you-implement-middleware-and-persistence-in-zustand)
8. [How do you implement complex state patterns with Zustand?](#8-how-do-you-implement-complex-state-patterns-with-zustand)
9. [When should you choose Redux over Zustand and vice versa?](#9-when-should-you-choose-redux-over-zustand-and-vice-versa)
10. [How do you migrate from Redux to Zustand?](#10-how-do-you-migrate-from-redux-to-zustand)
11. [How do you optimize performance in Redux and Zustand?](#11-how-do-you-optimize-performance-in-redux-and-zustand)
12. [What are the best practices for testing Redux and Zustand stores?](#12-what-are-the-best-practices-for-testing-redux-and-zustand-stores)
13. [What are the key differences between Redux and Zustand, and when should you use each?](#13-what-are-the-key-differences-between-redux-and-zustand-and-when-should-you-use-each)
14. [How do you implement middleware in Redux and Zustand?](#14-how-do-you-implement-middleware-in-redux-and-zustand)
15. [How do you handle complex state patterns and normalization in Redux vs Zustand?](#15-how-do-you-handle-complex-state-patterns-and-normalization-in-redux-vs-zustand)
16. [How do you migrate from Redux to Zustand or vice versa?](#16-how-do-you-migrate-from-redux-to-zustand-or-vice-versa)
17. [How do you optimize performance in Redux and Zustand applications?](#17-how-do-you-optimize-performance-in-redux-and-zustand-applications)
18. [How do you implement TypeScript with Redux and Zustand?](#18-how-do-you-implement-typescript-with-redux-and-zustand)
19. [How do you handle error boundaries and error handling in Redux vs Zustand?](#19-how-do-you-handle-error-boundaries-and-error-handling-in-redux-vs-zustand)
20. [What are the advanced patterns and real-world use cases for Redux vs Zustand?](#20-what-are-the-advanced-patterns-and-real-world-use-cases-for-redux-vs-zustand)
21. [What are Redux actions and action creators? How do you structure them?](#23-what-are-redux-actions-and-action-creators-how-do-you-structure-them)
22. [How do you handle form state management in Redux vs Zustand?](#24-how-do-you-handle-form-state-management-in-redux-vs-zustand)
23. [What are Redux selectors and how do you create reusable selectors?](#25-what-are-redux-selectors-and-how-do-you-create-reusable-selectors)
24. [How do you handle authentication state management in Redux vs Zustand?](#26-how-do-you-handle-authentication-state-management-in-redux-vs-zustand)
25. [How do you use Redux DevTools for debugging and what are its key features?](#27-how-do-you-use-redux-devtools-for-debugging-and-what-are-its-key-features)
26. [How do you handle loading states and error handling patterns in Redux vs Zustand?](#28-how-do-you-handle-loading-states-and-error-handling-patterns-in-redux-vs-zustand)
27. [What are the differences between Redux Thunk and Redux Saga? When would you use each?](#29-what-are-the-differences-between-redux-thunk-and-redux-saga-when-would-you-use-each)
28. [How do you implement optimistic updates in Redux vs Zustand?](#30-how-do-you-implement-optimistic-updates-in-redux-vs-zustand)
29. [What is Redux Observable and how does it compare to Redux Saga?](#31-what-is-redux-observable-and-how-does-it-compare-to-redux-saga)
30. [How do you implement advanced Zustand subscriptions and reactive patterns?](#32-how-do-you-implement-advanced-zustand-subscriptions-and-reactive-patterns)
31. [How do you implement caching strategies and data synchronization in Redux vs Zustand?](#33-how-do-you-implement-caching-strategies-and-data-synchronization-in-redux-vs-zustand)
32. [How do you handle concurrent updates and race conditions in Redux vs Zustand?](#34-how-do-you-handle-concurrent-updates-and-race-conditions-in-redux-vs-zustand)
33. [How do you implement internationalization (i18n) and localization patterns in Redux vs Zustand?](#35-how-do-you-implement-internationalization-i18n-and-localization-patterns-in-redux-vs-zustand)
34. [What are Redux enhancers and how do you create custom ones?](#46-what-are-redux-enhancers-and-how-do-you-create-custom-ones)
35. [How do you handle theme and UI state management?](#47-how-do-you-handle-theme-and-ui-state-management)
36. [What are the best practices for error boundaries with state management?](#48-what-are-the-best-practices-for-error-boundaries-with-state-management)
37. [How do you implement shopping cart state management?](#49-how-do-you-implement-shopping-cart-state-management)
38. [What are the differences between Redux and Context API?](#50-what-are-the-differences-between-redux-and-context-api)
39. [How do you handle WebSocket state management in Redux and Zustand?](#51-how-do-you-handle-websocket-state-management-in-redux-and-zustand)
40. [What are the best practices for testing async actions and effects?](#52-what-are-the-best-practices-for-testing-async-actions-and-effects)
41. [How do you implement notification/toast state management?](#53-how-do-you-implement-notificationtoast-state-management)
42. [What are Redux middlewares and how do you chain them?](#54-what-are-redux-middlewares-and-how-do-you-chain-them)
43. [How do you handle file upload state management?](#55-how-do-you-handle-file-upload-state-management)
44. [What are the performance optimization techniques for large datasets?](#56-what-are-the-performance-optimization-techniques-for-large-datasets)
45. [How do you implement modal and dialog state management?](#57-how-do-you-implement-modal-and-dialog-state-management)
46. [What are the differences between Redux and MobX?](#58-what-are-the-differences-between-redux-and-mobx)
47. [How do you handle routing state integration with Redux and Zustand?](#59-how-do-you-handle-routing-state-integration-with-redux-and-zustand)
48. [What are the best practices for state normalization and denormalization?](#60-what-are-the-best-practices-for-state-normalization-and-denormalization)
49. [How do you implement drag and drop state management?](#61-how-do-you-implement-drag-and-drop-state-management)
50. [What are the advanced TypeScript patterns for Redux and Zustand?](#62-what-are-the-advanced-typescript-patterns-for-redux-and-zustand)
51. [How do you handle multi-tenant application state management?](#63-how-do-you-handle-multi-tenant-application-state-management)
52. [What are the best practices for state hydration from server-side rendering?](#64-what-are-the-best-practices-for-state-hydration-from-server-side-rendering)
53. [How do you implement collaborative editing state management?](#65-how-do-you-implement-collaborative-editing-state-management)
54. [What are the differences between Redux Toolkit Query and Apollo Client?](#66-what-are-the-differences-between-redux-toolkit-query-and-apollo-client)
55. [How do you handle state management in micro-frontends?](#67-how-do-you-handle-state-management-in-micro-frontends)
56. [How do you implement advanced caching and memoization strategies in Redux vs Zustand?](#56-how-do-you-implement-advanced-caching-and-memoization-strategies-in-redux-vs-zustand)
57. [How do you implement advanced error handling and recovery patterns in Redux vs Zustand?](#57-how-do-you-implement-advanced-error-handling-and-recovery-patterns-in-redux-vs-zustand)
58. [How do you implement advanced testing strategies and patterns in Redux vs Zustand?](#58-how-do-you-implement-advanced-testing-strategies-and-patterns-in-redux-vs-zustand)
59. [How do you implement advanced state management patterns for micro-frontends architecture in Redux vs Zustand?](#59-how-do-you-implement-advanced-state-management-patterns-for-micro-frontends-architecture-in-redux-vs-zustand)
60. [What are the best practices for state management in React Native?](#68-what-are-the-best-practices-for-state-management-in-react-native)
61. [How do you implement time-travel debugging effectively?](#69-how-do-you-implement-time-travel-debugging-effectively)
62. [What are the advanced patterns for state composition and modularity?](#70-what-are-the-advanced-patterns-for-state-composition-and-modularity)
63. [How do you handle state management with Web Workers?](#71-how-do-you-handle-state-management-with-web-workers)
64. [What are the best practices for state management testing strategies?](#72-what-are-the-best-practices-for-state-management-testing-strategies)
65. [How do you implement state management for progressive web apps?](#73-how-do-you-implement-state-management-for-progressive-web-apps)
66. [What are the performance monitoring techniques for state management?](#74-what-are-the-performance-monitoring-techniques-for-state-management)
67. [How do you handle state management with GraphQL subscriptions?](#75-how-do-you-handle-state-management-with-graphql-subscriptions)
68. [What are the best practices for state management in Next.js applications?](#76-what-are-the-best-practices-for-state-management-in-nextjs-applications)
69. [How do you implement state management for real-time gaming applications?](#77-how-do-you-implement-state-management-for-real-time-gaming-applications)
70. [What are the advanced debugging techniques for complex state issues?](#78-what-are-the-advanced-debugging-techniques-for-complex-state-issues)
71. [How do you handle state management with service workers?](#79-how-do-you-handle-state-management-with-service-workers)
72. [What are the best practices for state management in large teams?](#80-what-are-the-best-practices-for-state-management-in-large-teams)
73. [How do you implement state management for data visualization applications?](#81-how-do-you-implement-state-management-for-data-visualization-applications)
74. [What are the advanced patterns for state synchronization across tabs?](#82-what-are-the-advanced-patterns-for-state-synchronization-across-tabs)
75. [How do you handle state management with IndexedDB and local storage?](#83-how-do-you-handle-state-management-with-indexeddb-and-local-storage)
76. [What are the best practices for state management in electron applications?](#84-what-are-the-best-practices-for-state-management-in-electron-applications)
77. [How do you implement state management for streaming applications?](#85-how-do-you-implement-state-management-for-streaming-applications)
78. [What are the advanced patterns for state management with concurrent features?](#86-what-are-the-advanced-patterns-for-state-management-with-concurrent-features)
79. [How do you handle state management for machine learning applications?](#87-how-do-you-handle-state-management-for-machine-learning-applications)
80. [What are the best practices for state management in monorepo architectures?](#88-what-are-the-best-practices-for-state-management-in-monorepo-architectures)
81. [How do you implement state management for IoT dashboard applications?](#89-how-do-you-implement-state-management-for-iot-dashboard-applications)
82. [What are the advanced patterns for state management with blockchain integration?](#90-what-are-the-advanced-patterns-for-state-management-with-blockchain-integration)
83. [How do you handle state management for augmented reality applications?](#91-how-do-you-handle-state-management-for-augmented-reality-applications)
84. [What are the best practices for state management in headless commerce?](#92-what-are-the-best-practices-for-state-management-in-headless-commerce)
85. [How do you implement state management for financial trading applications?](#93-how-do-you-implement-state-management-for-financial-trading-applications)
86. [What are the advanced patterns for state management with edge computing?](#94-what-are-the-advanced-patterns-for-state-management-with-edge-computing)
87. [How do you handle state management for social media applications?](#95-how-do-you-handle-state-management-for-social-media-applications)
88. [What are the best practices for state management in healthcare applications?](#96-what-are-the-best-practices-for-state-management-in-healthcare-applications)
89. [How do you implement state management for educational platforms?](#97-how-do-you-implement-state-management-for-educational-platforms)
90. [What are the advanced patterns for state management with AI integration?](#98-what-are-the-advanced-patterns-for-state-management-with-ai-integration)
91. [How do you handle state management for enterprise workflow applications?](#99-how-do-you-handle-state-management-for-enterprise-workflow-applications)
92. [What are the future trends and emerging patterns in state management?](#100-what-are-the-future-trends-and-emerging-patterns-in-state-management)

---

### 36. How do you implement server-side state synchronization in Redux vs Zustand?

**Answer:**

Server-side state synchronization ensures that client state remains consistent with server data through various strategies like polling, WebSocket connections, and optimistic updates with conflict resolution.

#### Redux Implementation with RTK Query

```javascript
// api/syncApi.js
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

const syncApi = createApi({
  reducerPath: "syncApi",
  baseQuery: fetchBaseQuery({
    baseUrl: "/api",
    prepareHeaders: (headers, { getState }) => {
      const token = getState().auth.token;
      if (token) {
        headers.set("authorization", `Bearer ${token}`);
      }
      return headers;
    },
  }),
  tagTypes: ["Document", "User"],
  endpoints: (builder) => ({
    getDocument: builder.query({
      query: (id) => `documents/${id}`,
      providesTags: (result, error, id) => [{ type: "Document", id }],
      // Polling for real-time updates
      pollingInterval: 5000,
    }),
    updateDocument: builder.mutation({
      query: ({ id, ...patch }) => ({
        url: `documents/${id}`,
        method: "PATCH",
        body: patch,
      }),
      invalidatesTags: (result, error, { id }) => [{ type: "Document", id }],
      // Optimistic update
      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {
        const patchResult = dispatch(
          syncApi.util.updateQueryData("getDocument", id, (draft) => {
            Object.assign(draft, patch);
          })
        );
        try {
          await queryFulfilled;
        } catch {
          patchResult.undo();
        }
      },
    }),
    syncWithServer: builder.mutation({
      query: ({ lastSyncTime }) => ({
        url: "sync",
        method: "POST",
        body: { lastSyncTime },
      }),
    }),
  }),
});

export const {
  useGetDocumentQuery,
  useUpdateDocumentMutation,
  useSyncWithServerMutation,
} = syncApi;
```

```javascript
// store/syncSlice.js
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

export const syncWithServer = createAsyncThunk(
  "sync/syncWithServer",
  async (_, { getState, dispatch }) => {
    const { lastSyncTime, pendingChanges } = getState().sync;

    // Send pending changes to server
    const response = await fetch("/api/sync", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ lastSyncTime, pendingChanges }),
    });

    const { serverChanges, conflicts, newSyncTime } = await response.json();

    return { serverChanges, conflicts, newSyncTime };
  }
);

const syncSlice = createSlice({
  name: "sync",
  initialState: {
    lastSyncTime: null,
    pendingChanges: [],
    conflicts: [],
    isOnline: navigator.onLine,
    syncStatus: "idle", // 'idle' | 'syncing' | 'error'
  },
  reducers: {
    addPendingChange: (state, action) => {
      state.pendingChanges.push({
        id: Date.now(),
        timestamp: new Date().toISOString(),
        ...action.payload,
      });
    },
    removePendingChange: (state, action) => {
      state.pendingChanges = state.pendingChanges.filter(
        (change) => change.id !== action.payload
      );
    },
    setOnlineStatus: (state, action) => {
      state.isOnline = action.payload;
    },
    resolveConflict: (state, action) => {
      const { conflictId, resolution } = action.payload;
      state.conflicts = state.conflicts.filter((c) => c.id !== conflictId);
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(syncWithServer.pending, (state) => {
        state.syncStatus = "syncing";
      })
      .addCase(syncWithServer.fulfilled, (state, action) => {
        const { serverChanges, conflicts, newSyncTime } = action.payload;
        state.lastSyncTime = newSyncTime;
        state.conflicts = conflicts;
        state.syncStatus = "idle";
        state.pendingChanges = [];
      })
      .addCase(syncWithServer.rejected, (state) => {
        state.syncStatus = "error";
      });
  },
});

export const {
  addPendingChange,
  removePendingChange,
  setOnlineStatus,
  resolveConflict,
} = syncSlice.actions;
export default syncSlice.reducer;
```

#### Zustand Implementation with Custom Sync

```javascript
// stores/syncStore.js
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

const useSyncStore = create(
  subscribeWithSelector(
    immer((set, get) => ({
      // State
      documents: {},
      lastSyncTime: null,
      pendingChanges: [],
      conflicts: [],
      isOnline: navigator.onLine,
      syncStatus: "idle",

      // Actions
      updateDocument: (id, changes) => {
        set((state) => {
          // Optimistic update
          if (state.documents[id]) {
            Object.assign(state.documents[id], changes);
          }

          // Add to pending changes if offline
          if (!state.isOnline) {
            state.pendingChanges.push({
              id: Date.now(),
              type: "update",
              documentId: id,
              changes,
              timestamp: new Date().toISOString(),
            });
          }
        });

        // Sync with server if online
        if (get().isOnline) {
          get().syncDocument(id, changes);
        }
      },

      syncDocument: async (id, changes) => {
        try {
          const response = await fetch(`/api/documents/${id}`, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(changes),
          });

          if (!response.ok) {
            throw new Error("Sync failed");
          }

          const updatedDocument = await response.json();

          set((state) => {
            state.documents[id] = updatedDocument;
          });
        } catch (error) {
          // Revert optimistic update and add to pending
          set((state) => {
            state.pendingChanges.push({
              id: Date.now(),
              type: "update",
              documentId: id,
              changes,
              timestamp: new Date().toISOString(),
              error: error.message,
            });
          });
        }
      },

      syncWithServer: async () => {
        const { lastSyncTime, pendingChanges } = get();

        set((state) => {
          state.syncStatus = "syncing";
        });

        try {
          const response = await fetch("/api/sync", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ lastSyncTime, pendingChanges }),
          });

          const { serverChanges, conflicts, newSyncTime } =
            await response.json();

          set((state) => {
            // Apply server changes
            serverChanges.forEach((change) => {
              if (change.type === "update") {
                state.documents[change.documentId] = change.document;
              } else if (change.type === "delete") {
                delete state.documents[change.documentId];
              }
            });

            state.lastSyncTime = newSyncTime;
            state.conflicts = conflicts;
            state.pendingChanges = [];
            state.syncStatus = "idle";
          });
        } catch (error) {
          set((state) => {
            state.syncStatus = "error";
          });
        }
      },

      setOnlineStatus: (isOnline) => {
        set((state) => {
          state.isOnline = isOnline;
        });

        // Auto-sync when coming back online
        if (isOnline && get().pendingChanges.length > 0) {
          get().syncWithServer();
        }
      },

      resolveConflict: (conflictId, resolution) => {
        set((state) => {
          const conflict = state.conflicts.find((c) => c.id === conflictId);
          if (conflict) {
            // Apply resolution
            if (resolution === "server") {
              state.documents[conflict.documentId] = conflict.serverVersion;
            } else if (resolution === "client") {
              state.documents[conflict.documentId] = conflict.clientVersion;
            }

            // Remove conflict
            state.conflicts = state.conflicts.filter(
              (c) => c.id !== conflictId
            );
          }
        });
      },
    }))
  )
);

// Auto-sync setup
useSyncStore.subscribe(
  (state) => state.isOnline,
  (isOnline) => {
    if (isOnline) {
      useSyncStore.getState().syncWithServer();
    }
  }
);

// Periodic sync
setInterval(() => {
  if (useSyncStore.getState().isOnline) {
    useSyncStore.getState().syncWithServer();
  }
}, 30000); // Sync every 30 seconds

export default useSyncStore;
```

#### WebSocket Integration for Real-time Sync

```javascript
// utils/websocketSync.js
class WebSocketSync {
  constructor(store, isZustand = false) {
    this.store = store;
    this.isZustand = isZustand;
    this.ws = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
  }

  connect() {
    this.ws = new WebSocket("ws://localhost:8080/sync");

    this.ws.onopen = () => {
      console.log("WebSocket connected");
      this.reconnectAttempts = 0;
    };

    this.ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      this.handleServerMessage(message);
    };

    this.ws.onclose = () => {
      console.log("WebSocket disconnected");
      this.attemptReconnect();
    };

    this.ws.onerror = (error) => {
      console.error("WebSocket error:", error);
    };
  }

  handleServerMessage(message) {
    if (this.isZustand) {
      // Zustand store update
      this.store.getState().applyServerUpdate(message);
    } else {
      // Redux store update
      this.store.dispatch({
        type: "sync/applyServerUpdate",
        payload: message,
      });
    }
  }

  sendMessage(message) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    }
  }

  attemptReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      setTimeout(() => {
        console.log(`Reconnecting... Attempt ${this.reconnectAttempts}`);
        this.connect();
      }, Math.pow(2, this.reconnectAttempts) * 1000);
    }
  }

  disconnect() {
    if (this.ws) {
      this.ws.close();
    }
  }
}

export default WebSocketSync;
```

#### Conflict Resolution Component

```jsx
// components/ConflictResolver.jsx
import React from "react";
import { useSelector, useDispatch } from "react-redux";
import useSyncStore from "../stores/syncStore";

const ConflictResolver = ({ useZustand = false }) => {
  const dispatch = useDispatch();

  // Redux version
  const reduxConflicts = useSelector((state) => state.sync.conflicts);

  // Zustand version
  const { conflicts: zustandConflicts, resolveConflict } = useSyncStore();

  const conflicts = useZustand ? zustandConflicts : reduxConflicts;

  const handleResolveConflict = (conflictId, resolution) => {
    if (useZustand) {
      resolveConflict(conflictId, resolution);
    } else {
      dispatch({
        type: "sync/resolveConflict",
        payload: { conflictId, resolution },
      });
    }
  };

  if (conflicts.length === 0) return null;

  return (
    <div className="conflict-resolver">
      <h3>Resolve Conflicts</h3>
      {conflicts.map((conflict) => (
        <div key={conflict.id} className="conflict-item">
          <h4>Document: {conflict.documentId}</h4>
          <div className="conflict-versions">
            <div className="version">
              <h5>Your Version</h5>
              <pre>{JSON.stringify(conflict.clientVersion, null, 2)}</pre>
              <button
                onClick={() => handleResolveConflict(conflict.id, "client")}
              >
                Use My Version
              </button>
            </div>
            <div className="version">
              <h5>Server Version</h5>
              <pre>{JSON.stringify(conflict.serverVersion, null, 2)}</pre>
              <button
                onClick={() => handleResolveConflict(conflict.id, "server")}
              >
                Use Server Version
              </button>
            </div>
          </div>
        </div>
      ))}
    </div>
  );
};

export default ConflictResolver;
```

#### Best Practices

1. **Conflict Resolution Strategy**:

   - Last-write-wins for simple cases
   - Three-way merge for complex documents
   - User-driven resolution for critical conflicts

2. **Optimistic Updates**:

   - Always provide immediate feedback
   - Implement rollback mechanisms
   - Show sync status to users

3. **Network Resilience**:

   - Queue operations when offline
   - Implement exponential backoff for retries
   - Handle partial sync failures gracefully

4. **Performance Optimization**:
   - Use delta sync for large datasets
   - Implement pagination for sync operations
   - Cache frequently accessed data

**Comparison Summary:**

| Feature               | Redux + RTK Query | Zustand |
| --------------------- | ----------------- | ------- |
| Setup Complexity      | Medium            | Low     |
| Built-in Caching      | Yes               | Manual  |
| Optimistic Updates    | Built-in          | Manual  |
| WebSocket Integration | Manual            | Manual  |
| Conflict Resolution   | Manual            | Manual  |
| Performance           | High              | High    |
| Bundle Size           | Larger            | Smaller |

---

### 37. How do you implement undo/redo functionality in Redux vs Zustand?

**Answer:**

Undo/redo functionality allows users to revert or replay state changes, providing a better user experience for applications like text editors, drawing apps, or form builders.

#### Redux Implementation with Redux-Undo

```javascript
// Install: npm install redux-undo

// store/editorSlice.js
import { createSlice } from "@reduxjs/toolkit";
import undoable, { includeAction, excludeAction } from "redux-undo";

const editorSlice = createSlice({
  name: "editor",
  initialState: {
    content: "",
    selection: { start: 0, end: 0 },
    fontSize: 14,
    fontFamily: "Arial",
  },
  reducers: {
    updateContent: (state, action) => {
      state.content = action.payload;
    },
    updateSelection: (state, action) => {
      state.selection = action.payload;
    },
    updateFontSize: (state, action) => {
      state.fontSize = action.payload;
    },
    updateFontFamily: (state, action) => {
      state.fontFamily = action.payload;
    },
    insertText: (state, action) => {
      const { text, position } = action.payload;
      const content = state.content;
      state.content =
        content.slice(0, position) + text + content.slice(position);
    },
    deleteText: (state, action) => {
      const { start, end } = action.payload;
      const content = state.content;
      state.content = content.slice(0, start) + content.slice(end);
    },
  },
});

export const {
  updateContent,
  updateSelection,
  updateFontSize,
  updateFontFamily,
  insertText,
  deleteText,
} = editorSlice.actions;

// Configure undoable reducer
const undoableEditor = undoable(editorSlice.reducer, {
  limit: 50, // Limit history to 50 states
  filter: includeAction([
    "editor/updateContent",
    "editor/insertText",
    "editor/deleteText",
    "editor/updateFontSize",
    "editor/updateFontFamily",
  ]),
  // Exclude selection updates from undo history
  undoType: "UNDO_EDITOR",
  redoType: "REDO_EDITOR",
  clearHistoryType: "CLEAR_EDITOR_HISTORY",
});

export default undoableEditor;
```

```javascript
// store/index.js
import { configureStore } from "@reduxjs/toolkit";
import editorReducer from "./editorSlice";

const store = configureStore({
  reducer: {
    editor: editorReducer,
  },
});

export default store;
```

```jsx
// components/EditorWithUndo.jsx
import React from "react";
import { useSelector, useDispatch } from "react-redux";
import { ActionCreators } from "redux-undo";
import {
  updateContent,
  updateSelection,
  insertText,
  deleteText,
} from "../store/editorSlice";

const EditorWithUndo = () => {
  const dispatch = useDispatch();
  const {
    past,
    present: editorState,
    future,
  } = useSelector((state) => state.editor);

  const canUndo = past.length > 0;
  const canRedo = future.length > 0;

  const handleUndo = () => {
    if (canUndo) {
      dispatch(ActionCreators.undo());
    }
  };

  const handleRedo = () => {
    if (canRedo) {
      dispatch(ActionCreators.redo());
    }
  };

  const handleClearHistory = () => {
    dispatch(ActionCreators.clearHistory());
  };

  const handleContentChange = (e) => {
    dispatch(updateContent(e.target.value));
  };

  const handleKeyDown = (e) => {
    if (e.ctrlKey || e.metaKey) {
      if (e.key === "z" && !e.shiftKey) {
        e.preventDefault();
        handleUndo();
      } else if ((e.key === "z" && e.shiftKey) || e.key === "y") {
        e.preventDefault();
        handleRedo();
      }
    }
  };

  return (
    <div className="editor-container">
      <div className="toolbar">
        <button onClick={handleUndo} disabled={!canUndo}>
          Undo ({past.length})
        </button>
        <button onClick={handleRedo} disabled={!canRedo}>
          Redo ({future.length})
        </button>
        <button onClick={handleClearHistory}>Clear History</button>
      </div>

      <textarea
        value={editorState.content}
        onChange={handleContentChange}
        onKeyDown={handleKeyDown}
        style={{
          fontSize: editorState.fontSize,
          fontFamily: editorState.fontFamily,
        }}
        placeholder="Start typing..."
      />

      <div className="status">
        History: {past.length} undo, {future.length} redo
      </div>
    </div>
  );
};

export default EditorWithUndo;
```

#### Zustand Implementation with Custom Undo/Redo

```javascript
// stores/editorStore.js
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

// Undo/Redo middleware
const undoRedoMiddleware = (config) => (set, get, api) => {
  const initialState = {
    past: [],
    present: null,
    future: [],
    maxHistorySize: 50,
  };

  const undoRedoActions = {
    undo: () => {
      const { past, present, future } = get();
      if (past.length === 0) return;

      const previous = past[past.length - 1];
      const newPast = past.slice(0, past.length - 1);

      set({
        past: newPast,
        present: previous,
        future: [present, ...future],
      });
    },

    redo: () => {
      const { past, present, future } = get();
      if (future.length === 0) return;

      const next = future[0];
      const newFuture = future.slice(1);

      set({
        past: [...past, present],
        present: next,
        future: newFuture,
      });
    },

    clearHistory: () => {
      set({
        past: [],
        future: [],
      });
    },

    pushToHistory: (newState) => {
      const { past, present, maxHistorySize } = get();
      if (!present) {
        set({ present: newState });
        return;
      }

      const newPast = [...past, present];
      if (newPast.length > maxHistorySize) {
        newPast.shift();
      }

      set({
        past: newPast,
        present: newState,
        future: [], // Clear future when new action is performed
      });
    },
  };

  return config(
    (args) => {
      if (typeof args === "function") {
        set(args);
      } else {
        set(args);
      }
    },
    get,
    {
      ...api,
      ...undoRedoActions,
    }
  );
};

const useEditorStore = create(
  subscribeWithSelector(
    immer(
      undoRedoMiddleware((set, get) => ({
        // History state
        past: [],
        present: {
          content: "",
          selection: { start: 0, end: 0 },
          fontSize: 14,
          fontFamily: "Arial",
        },
        future: [],
        maxHistorySize: 50,

        // Computed properties
        canUndo: () => get().past.length > 0,
        canRedo: () => get().future.length > 0,

        // Actions that should be tracked in history
        updateContent: (content) => {
          const currentState = get().present;
          const newState = { ...currentState, content };
          get().pushToHistory(newState);
        },

        insertText: (text, position) => {
          const currentState = get().present;
          const content = currentState.content;
          const newContent =
            content.slice(0, position) + text + content.slice(position);
          const newState = { ...currentState, content: newContent };
          get().pushToHistory(newState);
        },

        deleteText: (start, end) => {
          const currentState = get().present;
          const content = currentState.content;
          const newContent = content.slice(0, start) + content.slice(end);
          const newState = { ...currentState, content: newContent };
          get().pushToHistory(newState);
        },

        updateFontSize: (fontSize) => {
          const currentState = get().present;
          const newState = { ...currentState, fontSize };
          get().pushToHistory(newState);
        },

        updateFontFamily: (fontFamily) => {
          const currentState = get().present;
          const newState = { ...currentState, fontFamily };
          get().pushToHistory(newState);
        },

        // Actions that should NOT be tracked in history
        updateSelection: (selection) => {
          set((state) => {
            state.present.selection = selection;
          });
        },
      }))
    )
  )
);

export default useEditorStore;
```

```jsx
// components/ZustandEditorWithUndo.jsx
import React, { useEffect } from "react";
import useEditorStore from "../stores/editorStore";

const ZustandEditorWithUndo = () => {
  const {
    past,
    present: editorState,
    future,
    canUndo,
    canRedo,
    undo,
    redo,
    clearHistory,
    updateContent,
    updateSelection,
  } = useEditorStore();

  const handleContentChange = (e) => {
    updateContent(e.target.value);
  };

  const handleKeyDown = (e) => {
    if (e.ctrlKey || e.metaKey) {
      if (e.key === "z" && !e.shiftKey) {
        e.preventDefault();
        if (canUndo()) undo();
      } else if ((e.key === "z" && e.shiftKey) || e.key === "y") {
        e.preventDefault();
        if (canRedo()) redo();
      }
    }
  };

  return (
    <div className="editor-container">
      <div className="toolbar">
        <button onClick={undo} disabled={!canUndo()}>
          Undo ({past.length})
        </button>
        <button onClick={redo} disabled={!canRedo()}>
          Redo ({future.length})
        </button>
        <button onClick={clearHistory}>Clear History</button>
      </div>

      <textarea
        value={editorState.content}
        onChange={handleContentChange}
        onKeyDown={handleKeyDown}
        style={{
          fontSize: editorState.fontSize,
          fontFamily: editorState.fontFamily,
        }}
        placeholder="Start typing..."
      />

      <div className="status">
        History: {past.length} undo, {future.length} redo
      </div>
    </div>
  );
};

export default ZustandEditorWithUndo;
```

#### Advanced Undo/Redo with Branching History

```javascript
// stores/advancedUndoStore.js
import { create } from "zustand";

const useAdvancedUndoStore = create((set, get) => ({
  // Tree-like history structure
  history: {
    nodes: new Map(),
    currentNodeId: null,
    rootNodeId: null,
  },

  // Current state
  present: {
    content: "",
    metadata: {},
  },

  // Create initial history node
  initialize: (initialState) => {
    const nodeId = Date.now().toString();
    const node = {
      id: nodeId,
      state: initialState,
      parentId: null,
      children: [],
      timestamp: new Date().toISOString(),
      action: "INITIAL",
    };

    set({
      history: {
        nodes: new Map([[nodeId, node]]),
        currentNodeId: nodeId,
        rootNodeId: nodeId,
      },
      present: initialState,
    });
  },

  // Add new state to history
  pushState: (newState, actionType) => {
    const { history, present } = get();
    const nodeId = Date.now().toString();
    const currentNode = history.nodes.get(history.currentNodeId);

    const newNode = {
      id: nodeId,
      state: newState,
      parentId: history.currentNodeId,
      children: [],
      timestamp: new Date().toISOString(),
      action: actionType,
    };

    // Add child to current node
    if (currentNode) {
      currentNode.children.push(nodeId);
    }

    // Update history
    const newNodes = new Map(history.nodes);
    newNodes.set(nodeId, newNode);

    set({
      history: {
        ...history,
        nodes: newNodes,
        currentNodeId: nodeId,
      },
      present: newState,
    });
  },

  // Navigate to specific node
  navigateToNode: (nodeId) => {
    const { history } = get();
    const node = history.nodes.get(nodeId);

    if (node) {
      set({
        history: {
          ...history,
          currentNodeId: nodeId,
        },
        present: node.state,
      });
    }
  },

  // Get history path from root to current
  getHistoryPath: () => {
    const { history } = get();
    const path = [];
    let currentId = history.currentNodeId;

    while (currentId) {
      const node = history.nodes.get(currentId);
      if (node) {
        path.unshift(node);
        currentId = node.parentId;
      } else {
        break;
      }
    }

    return path;
  },

  // Get all possible branches from current node
  getBranches: () => {
    const { history } = get();
    const currentNode = history.nodes.get(history.currentNodeId);

    if (!currentNode) return [];

    return currentNode.children.map((childId) => history.nodes.get(childId));
  },
}));

export default useAdvancedUndoStore;
```

#### Performance Optimization for Large Histories

```javascript
// utils/historyOptimization.js
class HistoryOptimizer {
  constructor(maxSize = 100, compressionThreshold = 50) {
    this.maxSize = maxSize;
    this.compressionThreshold = compressionThreshold;
  }

  // Compress history by removing intermediate states
  compressHistory(history) {
    if (history.length <= this.compressionThreshold) {
      return history;
    }

    const compressed = [];
    const step = Math.floor(history.length / this.maxSize);

    for (let i = 0; i < history.length; i += step) {
      compressed.push(history[i]);
    }

    // Always keep the last state
    if (compressed[compressed.length - 1] !== history[history.length - 1]) {
      compressed.push(history[history.length - 1]);
    }

    return compressed;
  }

  // Create diff-based history for memory efficiency
  createDiffHistory(states) {
    const diffs = [];

    for (let i = 1; i < states.length; i++) {
      const diff = this.createDiff(states[i - 1], states[i]);
      diffs.push(diff);
    }

    return {
      base: states[0],
      diffs,
    };
  }

  // Simple diff implementation
  createDiff(oldState, newState) {
    const diff = {};

    for (const key in newState) {
      if (newState[key] !== oldState[key]) {
        diff[key] = newState[key];
      }
    }

    return diff;
  }

  // Apply diff to reconstruct state
  applyDiff(baseState, diff) {
    return { ...baseState, ...diff };
  }
}

export default HistoryOptimizer;
```

#### Best Practices

1. **Memory Management**:

   - Limit history size to prevent memory leaks
   - Use diff-based storage for large states
   - Implement history compression for long sessions

2. **User Experience**:

   - Provide keyboard shortcuts (Ctrl+Z, Ctrl+Y)
   - Show visual indicators for undo/redo availability
   - Group related actions for meaningful undo steps

3. **Performance**:

   - Debounce rapid state changes
   - Exclude non-essential state from history
   - Use shallow comparison for state changes

4. **Persistence**:
   - Save history to localStorage for session recovery
   - Implement history export/import functionality
   - Consider server-side history for collaborative features

**Comparison Summary:**

| Feature            | Redux + Redux-Undo | Zustand Custom |
| ------------------ | ------------------ | -------------- |
| Setup Complexity   | Low                | Medium         |
| Built-in Features  | Rich               | Manual         |
| Memory Efficiency  | Good               | Customizable   |
| Branching History  | Limited            | Full Control   |
| Performance        | Good               | Optimizable    |
| Bundle Size        | Larger             | Smaller        |
| TypeScript Support | Excellent          | Good           |

---

### 38. How do you implement real-time collaboration features in Redux vs Zustand?

**Answer:**

Real-time collaboration allows multiple users to work on the same data simultaneously, with changes synchronized across all clients. This requires handling operational transforms, conflict resolution, and presence awareness.

#### Redux Implementation with Collaborative Features

```javascript
// store/collaborationSlice.js
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

// Operational Transform for text editing
class OperationalTransform {
  static transform(op1, op2) {
    // Simple character-based OT implementation
    if (op1.type === "insert" && op2.type === "insert") {
      if (op1.position <= op2.position) {
        return {
          ...op2,
          position: op2.position + op1.text.length,
        };
      }
      return op2;
    }

    if (op1.type === "delete" && op2.type === "insert") {
      if (op1.position < op2.position) {
        return {
          ...op2,
          position: op2.position - op1.length,
        };
      }
      return op2;
    }

    // Add more transformation rules as needed
    return op2;
  }

  static apply(document, operation) {
    switch (operation.type) {
      case "insert":
        return (
          document.slice(0, operation.position) +
          operation.text +
          document.slice(operation.position)
        );
      case "delete":
        return (
          document.slice(0, operation.position) +
          document.slice(operation.position + operation.length)
        );
      default:
        return document;
    }
  }
}

export const sendOperation = createAsyncThunk(
  "collaboration/sendOperation",
  async (operation, { getState }) => {
    const { documentId, version } = getState().collaboration;

    const response = await fetch("/api/operations", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        documentId,
        operation,
        version,
        clientId: getState().collaboration.clientId,
      }),
    });

    return response.json();
  }
);

const collaborationSlice = createSlice({
  name: "collaboration",
  initialState: {
    documentId: null,
    content: "",
    version: 0,
    clientId: Math.random().toString(36).substr(2, 9),
    pendingOperations: [],
    acknowledgedOperations: [],
    connectedUsers: {},
    cursors: {},
    isConnected: false,
    operationHistory: [],
  },
  reducers: {
    setDocument: (state, action) => {
      const { documentId, content, version } = action.payload;
      state.documentId = documentId;
      state.content = content;
      state.version = version;
    },

    applyLocalOperation: (state, action) => {
      const operation = {
        ...action.payload,
        id: Date.now().toString(),
        clientId: state.clientId,
        version: state.version,
      };

      // Apply operation locally
      state.content = OperationalTransform.apply(state.content, operation);
      state.pendingOperations.push(operation);
      state.operationHistory.push(operation);
    },

    applyRemoteOperation: (state, action) => {
      const remoteOp = action.payload;

      // Transform pending operations against remote operation
      state.pendingOperations = state.pendingOperations.map((pendingOp) =>
        OperationalTransform.transform(remoteOp, pendingOp)
      );

      // Apply remote operation
      state.content = OperationalTransform.apply(state.content, remoteOp);
      state.version = Math.max(state.version, remoteOp.version) + 1;
      state.operationHistory.push(remoteOp);
    },

    acknowledgeOperation: (state, action) => {
      const { operationId } = action.payload;
      state.pendingOperations = state.pendingOperations.filter(
        (op) => op.id !== operationId
      );
    },

    updateUserPresence: (state, action) => {
      const { userId, presence } = action.payload;
      if (presence) {
        state.connectedUsers[userId] = presence;
      } else {
        delete state.connectedUsers[userId];
      }
    },

    updateCursor: (state, action) => {
      const { userId, cursor } = action.payload;
      if (cursor) {
        state.cursors[userId] = cursor;
      } else {
        delete state.cursors[userId];
      }
    },

    setConnectionStatus: (state, action) => {
      state.isConnected = action.payload;
    },
  },
  extraReducers: (builder) => {
    builder.addCase(sendOperation.fulfilled, (state, action) => {
      const { operationId, transformedOperations } = action.payload;

      // Remove acknowledged operation
      state.pendingOperations = state.pendingOperations.filter(
        (op) => op.id !== operationId
      );

      // Apply any transformed operations from server
      transformedOperations?.forEach((op) => {
        state.content = OperationalTransform.apply(state.content, op);
      });
    });
  },
});

export const {
  setDocument,
  applyLocalOperation,
  applyRemoteOperation,
  acknowledgeOperation,
  updateUserPresence,
  updateCursor,
  setConnectionStatus,
} = collaborationSlice.actions;

export default collaborationSlice.reducer;
```

```jsx
// components/CollaborativeEditor.jsx
import React, { useEffect, useRef, useState } from "react";
import { useSelector, useDispatch } from "react-redux";
import {
  applyLocalOperation,
  applyRemoteOperation,
  updateCursor,
  setConnectionStatus,
} from "../store/collaborationSlice";

const CollaborativeEditor = ({ documentId }) => {
  const dispatch = useDispatch();
  const textareaRef = useRef(null);
  const wsRef = useRef(null);

  const { content, connectedUsers, cursors, isConnected, clientId } =
    useSelector((state) => state.collaboration);

  const [localCursor, setLocalCursor] = useState({ start: 0, end: 0 });

  useEffect(() => {
    // Initialize WebSocket connection
    wsRef.current = new WebSocket(
      `ws://localhost:8080/collaborate/${documentId}`
    );

    wsRef.current.onopen = () => {
      dispatch(setConnectionStatus(true));
    };

    wsRef.current.onmessage = (event) => {
      const message = JSON.parse(event.data);

      switch (message.type) {
        case "operation":
          dispatch(applyRemoteOperation(message.operation));
          break;
        case "cursor":
          dispatch(
            updateCursor({
              userId: message.userId,
              cursor: message.cursor,
            })
          );
          break;
        case "user_joined":
        case "user_left":
          // Handle user presence
          break;
      }
    };

    wsRef.current.onclose = () => {
      dispatch(setConnectionStatus(false));
    };

    return () => {
      wsRef.current?.close();
    };
  }, [documentId, dispatch]);

  const handleTextChange = (e) => {
    const newContent = e.target.value;
    const textarea = textareaRef.current;

    // Calculate the operation
    const operation = calculateOperation(
      content,
      newContent,
      textarea.selectionStart
    );

    if (operation) {
      dispatch(applyLocalOperation(operation));

      // Send operation to server
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        wsRef.current.send(
          JSON.stringify({
            type: "operation",
            operation,
          })
        );
      }
    }
  };

  const handleSelectionChange = () => {
    const textarea = textareaRef.current;
    const cursor = {
      start: textarea.selectionStart,
      end: textarea.selectionEnd,
    };

    setLocalCursor(cursor);

    // Send cursor position to other users
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(
        JSON.stringify({
          type: "cursor",
          cursor,
        })
      );
    }
  };

  const calculateOperation = (oldText, newText, cursorPos) => {
    if (oldText === newText) return null;

    if (newText.length > oldText.length) {
      // Text was inserted
      const insertedText = newText.slice(
        cursorPos - (newText.length - oldText.length),
        cursorPos
      );
      return {
        type: "insert",
        position: cursorPos - insertedText.length,
        text: insertedText,
      };
    } else {
      // Text was deleted
      return {
        type: "delete",
        position: cursorPos,
        length: oldText.length - newText.length,
      };
    }
  };

  return (
    <div className="collaborative-editor">
      <div className="editor-header">
        <div className="connection-status">
          Status: {isConnected ? "Connected" : "Disconnected"}
        </div>
        <div className="connected-users">
          {Object.entries(connectedUsers).map(([userId, user]) => (
            <div
              key={userId}
              className="user-avatar"
              style={{ backgroundColor: user.color }}
            >
              {user.name[0]}
            </div>
          ))}
        </div>
      </div>

      <div className="editor-container">
        <textarea
          ref={textareaRef}
          value={content}
          onChange={handleTextChange}
          onSelect={handleSelectionChange}
          className="collaborative-textarea"
        />

        {/* Render other users' cursors */}
        {Object.entries(cursors).map(([userId, cursor]) => {
          if (userId === clientId) return null;

          const user = connectedUsers[userId];
          if (!user) return null;

          return (
            <div
              key={userId}
              className="remote-cursor"
              style={{
                position: "absolute",
                left: calculateCursorPosition(cursor.start).x,
                top: calculateCursorPosition(cursor.start).y,
                borderColor: user.color,
              }}
            >
              <div
                className="cursor-label"
                style={{ backgroundColor: user.color }}
              >
                {user.name}
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
};

// Helper function to calculate cursor position
const calculateCursorPosition = (offset) => {
  // This would need to be implemented based on your text rendering
  // For simplicity, returning mock coordinates
  return { x: 0, y: 0 };
};

export default CollaborativeEditor;
```

#### Zustand Implementation with Collaborative Features

```javascript
// stores/collaborationStore.js
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

// Operational Transform utility (same as Redux version)
class OperationalTransform {
  // ... (same implementation as above)
}

const useCollaborationStore = create(
  subscribeWithSelector(
    immer((set, get) => ({
      // State
      documentId: null,
      content: "",
      version: 0,
      clientId: Math.random().toString(36).substr(2, 9),
      pendingOperations: [],
      connectedUsers: {},
      cursors: {},
      isConnected: false,
      operationHistory: [],
      ws: null,

      // Actions
      connect: (documentId) => {
        const ws = new WebSocket(
          `ws://localhost:8080/collaborate/${documentId}`
        );

        ws.onopen = () => {
          set((state) => {
            state.isConnected = true;
            state.documentId = documentId;
          });
        };

        ws.onmessage = (event) => {
          const message = JSON.parse(event.data);
          get().handleMessage(message);
        };

        ws.onclose = () => {
          set((state) => {
            state.isConnected = false;
          });
        };

        set((state) => {
          state.ws = ws;
        });
      },

      disconnect: () => {
        const { ws } = get();
        if (ws) {
          ws.close();
        }
        set((state) => {
          state.ws = null;
          state.isConnected = false;
        });
      },

      handleMessage: (message) => {
        switch (message.type) {
          case "operation":
            get().applyRemoteOperation(message.operation);
            break;
          case "cursor":
            get().updateRemoteCursor(message.userId, message.cursor);
            break;
          case "user_joined":
            get().addUser(message.user);
            break;
          case "user_left":
            get().removeUser(message.userId);
            break;
          case "document_state":
            get().setDocumentState(message.content, message.version);
            break;
        }
      },

      applyLocalOperation: (operation) => {
        set((state) => {
          const op = {
            ...operation,
            id: Date.now().toString(),
            clientId: state.clientId,
            version: state.version,
          };

          // Apply operation locally
          state.content = OperationalTransform.apply(state.content, op);
          state.pendingOperations.push(op);
          state.operationHistory.push(op);
        });

        // Send to server
        const { ws } = get();
        if (ws?.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({
              type: "operation",
              operation,
            })
          );
        }
      },

      applyRemoteOperation: (remoteOp) => {
        set((state) => {
          // Transform pending operations
          state.pendingOperations = state.pendingOperations.map((pendingOp) =>
            OperationalTransform.transform(remoteOp, pendingOp)
          );

          // Apply remote operation
          state.content = OperationalTransform.apply(state.content, remoteOp);
          state.version = Math.max(state.version, remoteOp.version) + 1;
          state.operationHistory.push(remoteOp);
        });
      },

      updateLocalCursor: (cursor) => {
        const { ws, clientId } = get();

        // Send cursor to other users
        if (ws?.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({
              type: "cursor",
              cursor,
            })
          );
        }
      },

      updateRemoteCursor: (userId, cursor) => {
        set((state) => {
          if (cursor) {
            state.cursors[userId] = cursor;
          } else {
            delete state.cursors[userId];
          }
        });
      },

      addUser: (user) => {
        set((state) => {
          state.connectedUsers[user.id] = user;
        });
      },

      removeUser: (userId) => {
        set((state) => {
          delete state.connectedUsers[userId];
          delete state.cursors[userId];
        });
      },

      setDocumentState: (content, version) => {
        set((state) => {
          state.content = content;
          state.version = version;
        });
      },
    }))
  )
);

export default useCollaborationStore;
```

```jsx
// components/ZustandCollaborativeEditor.jsx
import React, { useEffect, useRef, useState } from "react";
import useCollaborationStore from "../stores/collaborationStore";

const ZustandCollaborativeEditor = ({ documentId }) => {
  const textareaRef = useRef(null);
  const [localCursor, setLocalCursor] = useState({ start: 0, end: 0 });

  const {
    content,
    connectedUsers,
    cursors,
    isConnected,
    clientId,
    connect,
    disconnect,
    applyLocalOperation,
    updateLocalCursor,
  } = useCollaborationStore();

  useEffect(() => {
    connect(documentId);
    return () => disconnect();
  }, [documentId, connect, disconnect]);

  const handleTextChange = (e) => {
    const newContent = e.target.value;
    const textarea = textareaRef.current;

    const operation = calculateOperation(
      content,
      newContent,
      textarea.selectionStart
    );

    if (operation) {
      applyLocalOperation(operation);
    }
  };

  const handleSelectionChange = () => {
    const textarea = textareaRef.current;
    const cursor = {
      start: textarea.selectionStart,
      end: textarea.selectionEnd,
    };

    setLocalCursor(cursor);
    updateLocalCursor(cursor);
  };

  const calculateOperation = (oldText, newText, cursorPos) => {
    if (oldText === newText) return null;

    if (newText.length > oldText.length) {
      const insertedText = newText.slice(
        cursorPos - (newText.length - oldText.length),
        cursorPos
      );
      return {
        type: "insert",
        position: cursorPos - insertedText.length,
        text: insertedText,
      };
    } else {
      return {
        type: "delete",
        position: cursorPos,
        length: oldText.length - newText.length,
      };
    }
  };

  return (
    <div className="collaborative-editor">
      <div className="editor-header">
        <div className="connection-status">
          Status: {isConnected ? "Connected" : "Disconnected"}
        </div>
        <div className="connected-users">
          {Object.entries(connectedUsers).map(([userId, user]) => (
            <div
              key={userId}
              className="user-avatar"
              style={{ backgroundColor: user.color }}
            >
              {user.name[0]}
            </div>
          ))}
        </div>
      </div>

      <div className="editor-container">
        <textarea
          ref={textareaRef}
          value={content}
          onChange={handleTextChange}
          onSelect={handleSelectionChange}
          className="collaborative-textarea"
        />

        {/* Remote cursors */}
        {Object.entries(cursors).map(([userId, cursor]) => {
          if (userId === clientId) return null;

          const user = connectedUsers[userId];
          if (!user) return null;

          return (
            <div key={userId} className="remote-cursor">
              <div
                className="cursor-label"
                style={{ backgroundColor: user.color }}
              >
                {user.name}
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
};

export default ZustandCollaborativeEditor;
```

#### Conflict Resolution and Awareness

```javascript
// utils/conflictResolution.js
class ConflictResolver {
  static resolveTextConflict(localOp, remoteOp) {
    // Implement three-way merge for text conflicts
    if (localOp.type === "insert" && remoteOp.type === "insert") {
      // Both users inserted text at similar positions
      if (Math.abs(localOp.position - remoteOp.position) < 5) {
        return {
          type: "conflict",
          resolution: "merge",
          operations: [
            localOp,
            { ...remoteOp, position: localOp.position + localOp.text.length },
          ],
        };
      }
    }

    return { type: "no_conflict" };
  }

  static createAwarenessInfo(users, cursors) {
    return Object.entries(users).map(([userId, user]) => ({
      ...user,
      cursor: cursors[userId],
      isActive: Date.now() - user.lastSeen < 30000, // 30 seconds
    }));
  }
}

export default ConflictResolver;
```

#### Best Practices

1. **Operational Transform**:

   - Implement proper OT algorithms for your data type
   - Handle edge cases in transformation functions
   - Test with concurrent operations extensively

2. **Network Resilience**:

   - Implement reconnection logic with exponential backoff
   - Queue operations when disconnected
   - Handle partial message delivery

3. **User Experience**:

   - Show real-time cursors and selections
   - Provide visual feedback for conflicts
   - Display user presence and activity status

4. **Performance**:
   - Batch operations when possible
   - Implement operation compression
   - Use efficient diff algorithms

**Comparison Summary:**

| Feature               | Redux      | Zustand  |
| --------------------- | ---------- | -------- |
| Setup Complexity      | Medium     | Low      |
| OT Integration        | Manual     | Manual   |
| WebSocket Handling    | External   | Built-in |
| State Synchronization | Structured | Flexible |
| Conflict Resolution   | Manual     | Manual   |
| Performance           | Good       | Good     |
| Bundle Size           | Larger     | Smaller  |

---

### 39. How do you implement progressive web app (PWA) features with Redux vs Zustand?

**Answer:**

Progressive Web Apps require offline functionality, background sync, push notifications, and app-like behavior. Both Redux and Zustand can be integrated with PWA features through service workers and caching strategies.

#### Redux Implementation with PWA Features

```javascript
// store/pwaSlice.js
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

// Service Worker Registration
export const registerServiceWorker = createAsyncThunk(
  "pwa/registerServiceWorker",
  async (_, { dispatch }) => {
    if ("serviceWorker" in navigator) {
      try {
        const registration = await navigator.serviceWorker.register("/sw.js");

        registration.addEventListener("updatefound", () => {
          dispatch(setUpdateAvailable(true));
        });

        return {
          registered: true,
          registration,
        };
      } catch (error) {
        throw new Error(`Service Worker registration failed: ${error.message}`);
      }
    }
    throw new Error("Service Worker not supported");
  }
);

// Background Sync
export const scheduleBackgroundSync = createAsyncThunk(
  "pwa/scheduleBackgroundSync",
  async (data, { getState }) => {
    const state = getState();

    if (
      "serviceWorker" in navigator &&
      "sync" in window.ServiceWorkerRegistration.prototype
    ) {
      const registration = await navigator.serviceWorker.ready;

      // Store data for background sync
      const syncData = {
        id: Date.now().toString(),
        data,
        timestamp: Date.now(),
        retryCount: 0,
      };

      // Store in IndexedDB for persistence
      await storeOfflineData("background-sync", syncData);

      // Register background sync
      await registration.sync.register("background-sync");

      return syncData;
    }

    throw new Error("Background Sync not supported");
  }
);

// Push Notifications
export const subscribeToPushNotifications = createAsyncThunk(
  "pwa/subscribeToPushNotifications",
  async (_, { getState }) => {
    if ("Notification" in window && "serviceWorker" in navigator) {
      const permission = await Notification.requestPermission();

      if (permission === "granted") {
        const registration = await navigator.serviceWorker.ready;

        const subscription = await registration.pushManager.subscribe({
          userVisibleOnly: true,
          applicationServerKey: process.env.REACT_APP_VAPID_PUBLIC_KEY,
        });

        // Send subscription to server
        await fetch("/api/push-subscription", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(subscription),
        });

        return {
          subscribed: true,
          subscription,
        };
      }

      throw new Error("Notification permission denied");
    }

    throw new Error("Push notifications not supported");
  }
);

const pwaSlice = createSlice({
  name: "pwa",
  initialState: {
    isOnline: navigator.onLine,
    isInstallable: false,
    isInstalled: false,
    updateAvailable: false,
    serviceWorkerRegistered: false,
    pushSubscribed: false,
    backgroundSyncEnabled: false,
    offlineQueue: [],
    syncStatus: "idle", // 'idle' | 'syncing' | 'success' | 'error'
    installPrompt: null,
    cacheStatus: {
      static: "idle",
      dynamic: "idle",
      api: "idle",
    },
  },
  reducers: {
    setOnlineStatus: (state, action) => {
      state.isOnline = action.payload;

      // Process offline queue when coming back online
      if (action.payload && state.offlineQueue.length > 0) {
        state.syncStatus = "syncing";
      }
    },

    setInstallable: (state, action) => {
      state.isInstallable = action.payload.installable;
      state.installPrompt = action.payload.prompt;
    },

    setInstalled: (state, action) => {
      state.isInstalled = action.payload;
      state.isInstallable = false;
      state.installPrompt = null;
    },

    setUpdateAvailable: (state, action) => {
      state.updateAvailable = action.payload;
    },

    addToOfflineQueue: (state, action) => {
      state.offlineQueue.push({
        id: Date.now().toString(),
        ...action.payload,
        timestamp: Date.now(),
      });
    },

    removeFromOfflineQueue: (state, action) => {
      state.offlineQueue = state.offlineQueue.filter(
        (item) => item.id !== action.payload
      );
    },

    clearOfflineQueue: (state) => {
      state.offlineQueue = [];
    },

    setSyncStatus: (state, action) => {
      state.syncStatus = action.payload;
    },

    updateCacheStatus: (state, action) => {
      const { cacheType, status } = action.payload;
      state.cacheStatus[cacheType] = status;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(registerServiceWorker.fulfilled, (state, action) => {
        state.serviceWorkerRegistered = action.payload.registered;
      })
      .addCase(subscribeToPushNotifications.fulfilled, (state, action) => {
        state.pushSubscribed = action.payload.subscribed;
      })
      .addCase(scheduleBackgroundSync.fulfilled, (state, action) => {
        state.backgroundSyncEnabled = true;
      });
  },
});

export const {
  setOnlineStatus,
  setInstallable,
  setInstalled,
  setUpdateAvailable,
  addToOfflineQueue,
  removeFromOfflineQueue,
  clearOfflineQueue,
  setSyncStatus,
  updateCacheStatus,
} = pwaSlice.actions;

export default pwaSlice.reducer;
```

```javascript
// utils/offlineStorage.js
class OfflineStorage {
  constructor() {
    this.dbName = "PWAOfflineDB";
    this.version = 1;
    this.db = null;
  }

  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;

        // Create object stores
        if (!db.objectStoreNames.contains("offline-actions")) {
          db.createObjectStore("offline-actions", { keyPath: "id" });
        }

        if (!db.objectStoreNames.contains("background-sync")) {
          db.createObjectStore("background-sync", { keyPath: "id" });
        }

        if (!db.objectStoreNames.contains("cached-data")) {
          db.createObjectStore("cached-data", { keyPath: "key" });
        }
      };
    });
  }

  async store(storeName, data) {
    if (!this.db) await this.init();

    const transaction = this.db.transaction([storeName], "readwrite");
    const store = transaction.objectStore(storeName);

    return new Promise((resolve, reject) => {
      const request = store.add(data);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async getAll(storeName) {
    if (!this.db) await this.init();

    const transaction = this.db.transaction([storeName], "readonly");
    const store = transaction.objectStore(storeName);

    return new Promise((resolve, reject) => {
      const request = store.getAll();
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async delete(storeName, id) {
    if (!this.db) await this.init();

    const transaction = this.db.transaction([storeName], "readwrite");
    const store = transaction.objectStore(storeName);

    return new Promise((resolve, reject) => {
      const request = store.delete(id);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
}

export const offlineStorage = new OfflineStorage();

export const storeOfflineData = async (storeName, data) => {
  return offlineStorage.store(storeName, data);
};

export const getOfflineData = async (storeName) => {
  return offlineStorage.getAll(storeName);
};

export const deleteOfflineData = async (storeName, id) => {
  return offlineStorage.delete(storeName, id);
};
```

```jsx
// components/PWAManager.jsx
import React, { useEffect } from "react";
import { useSelector, useDispatch } from "react-redux";
import {
  registerServiceWorker,
  subscribeToPushNotifications,
  setOnlineStatus,
  setInstallable,
  setInstalled,
  addToOfflineQueue,
  setSyncStatus,
} from "../store/pwaSlice";

const PWAManager = ({ children }) => {
  const dispatch = useDispatch();
  const {
    isOnline,
    isInstallable,
    updateAvailable,
    installPrompt,
    offlineQueue,
    syncStatus,
  } = useSelector((state) => state.pwa);

  useEffect(() => {
    // Register service worker
    dispatch(registerServiceWorker());

    // Listen for online/offline events
    const handleOnline = () => dispatch(setOnlineStatus(true));
    const handleOffline = () => dispatch(setOnlineStatus(false));

    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);

    // Listen for install prompt
    const handleBeforeInstallPrompt = (e) => {
      e.preventDefault();
      dispatch(setInstallable({ installable: true, prompt: e }));
    };

    window.addEventListener("beforeinstallprompt", handleBeforeInstallPrompt);

    // Listen for app installed
    const handleAppInstalled = () => {
      dispatch(setInstalled(true));
    };

    window.addEventListener("appinstalled", handleAppInstalled);

    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
      window.removeEventListener(
        "beforeinstallprompt",
        handleBeforeInstallPrompt
      );
      window.removeEventListener("appinstalled", handleAppInstalled);
    };
  }, [dispatch]);

  // Process offline queue when coming back online
  useEffect(() => {
    if (isOnline && offlineQueue.length > 0 && syncStatus === "syncing") {
      processOfflineQueue();
    }
  }, [isOnline, offlineQueue.length, syncStatus]);

  const processOfflineQueue = async () => {
    try {
      for (const item of offlineQueue) {
        // Process each queued action
        await fetch(item.url, {
          method: item.method,
          headers: item.headers,
          body: item.body,
        });

        // Remove from queue after successful processing
        dispatch(removeFromOfflineQueue(item.id));
      }

      dispatch(setSyncStatus("success"));
    } catch (error) {
      dispatch(setSyncStatus("error"));
    }
  };

  const handleInstallApp = async () => {
    if (installPrompt) {
      const result = await installPrompt.prompt();
      if (result.outcome === "accepted") {
        dispatch(setInstalled(true));
      }
    }
  };

  const handleEnableNotifications = () => {
    dispatch(subscribeToPushNotifications());
  };

  return (
    <div className="pwa-manager">
      {/* Install Banner */}
      {isInstallable && (
        <div className="install-banner">
          <p>Install this app for a better experience!</p>
          <button onClick={handleInstallApp}>Install</button>
        </div>
      )}

      {/* Update Banner */}
      {updateAvailable && (
        <div className="update-banner">
          <p>A new version is available!</p>
          <button onClick={() => window.location.reload()}>Update</button>
        </div>
      )}

      {/* Offline Indicator */}
      {!isOnline && (
        <div className="offline-indicator">
          <p>You're offline. Changes will be synced when you reconnect.</p>
        </div>
      )}

      {/* Sync Status */}
      {syncStatus === "syncing" && (
        <div className="sync-indicator">
          <p>Syncing offline changes...</p>
        </div>
      )}

      {children}
    </div>
  );
};

export default PWAManager;
```

#### Zustand Implementation with PWA Features

```javascript
// stores/pwaStore.js
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { persist } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

const usePWAStore = create(
  subscribeWithSelector(
    persist(
      immer((set, get) => ({
        // State
        isOnline: navigator.onLine,
        isInstallable: false,
        isInstalled: false,
        updateAvailable: false,
        serviceWorkerRegistered: false,
        pushSubscribed: false,
        backgroundSyncEnabled: false,
        offlineQueue: [],
        syncStatus: "idle",
        installPrompt: null,
        cacheStatus: {
          static: "idle",
          dynamic: "idle",
          api: "idle",
        },

        // Actions
        registerServiceWorker: async () => {
          if ("serviceWorker" in navigator) {
            try {
              const registration = await navigator.serviceWorker.register(
                "/sw.js"
              );

              registration.addEventListener("updatefound", () => {
                get().setUpdateAvailable(true);
              });

              set((state) => {
                state.serviceWorkerRegistered = true;
              });

              return registration;
            } catch (error) {
              console.error("Service Worker registration failed:", error);
              throw error;
            }
          }
          throw new Error("Service Worker not supported");
        },

        subscribeToPushNotifications: async () => {
          if ("Notification" in window && "serviceWorker" in navigator) {
            const permission = await Notification.requestPermission();

            if (permission === "granted") {
              const registration = await navigator.serviceWorker.ready;

              const subscription = await registration.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: process.env.REACT_APP_VAPID_PUBLIC_KEY,
              });

              // Send subscription to server
              await fetch("/api/push-subscription", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(subscription),
              });

              set((state) => {
                state.pushSubscribed = true;
              });

              return subscription;
            }

            throw new Error("Notification permission denied");
          }

          throw new Error("Push notifications not supported");
        },

        scheduleBackgroundSync: async (data) => {
          if (
            "serviceWorker" in navigator &&
            "sync" in window.ServiceWorkerRegistration.prototype
          ) {
            const registration = await navigator.serviceWorker.ready;

            const syncData = {
              id: Date.now().toString(),
              data,
              timestamp: Date.now(),
              retryCount: 0,
            };

            // Store in IndexedDB
            await get().storeOfflineData("background-sync", syncData);

            // Register background sync
            await registration.sync.register("background-sync");

            set((state) => {
              state.backgroundSyncEnabled = true;
            });

            return syncData;
          }

          throw new Error("Background Sync not supported");
        },

        setOnlineStatus: (status) => {
          set((state) => {
            state.isOnline = status;

            if (status && state.offlineQueue.length > 0) {
              state.syncStatus = "syncing";
            }
          });
        },

        setInstallable: (installable, prompt = null) => {
          set((state) => {
            state.isInstallable = installable;
            state.installPrompt = prompt;
          });
        },

        setInstalled: (installed) => {
          set((state) => {
            state.isInstalled = installed;
            state.isInstallable = false;
            state.installPrompt = null;
          });
        },

        setUpdateAvailable: (available) => {
          set((state) => {
            state.updateAvailable = available;
          });
        },

        addToOfflineQueue: (action) => {
          set((state) => {
            state.offlineQueue.push({
              id: Date.now().toString(),
              ...action,
              timestamp: Date.now(),
            });
          });
        },

        removeFromOfflineQueue: (id) => {
          set((state) => {
            state.offlineQueue = state.offlineQueue.filter(
              (item) => item.id !== id
            );
          });
        },

        clearOfflineQueue: () => {
          set((state) => {
            state.offlineQueue = [];
          });
        },

        setSyncStatus: (status) => {
          set((state) => {
            state.syncStatus = status;
          });
        },

        updateCacheStatus: (cacheType, status) => {
          set((state) => {
            state.cacheStatus[cacheType] = status;
          });
        },

        processOfflineQueue: async () => {
          const { offlineQueue } = get();

          try {
            get().setSyncStatus("syncing");

            for (const item of offlineQueue) {
              await fetch(item.url, {
                method: item.method,
                headers: item.headers,
                body: item.body,
              });

              get().removeFromOfflineQueue(item.id);
            }

            get().setSyncStatus("success");
          } catch (error) {
            get().setSyncStatus("error");
            throw error;
          }
        },

        // Offline storage utilities
        storeOfflineData: async (storeName, data) => {
          // Implementation would use IndexedDB
          return Promise.resolve();
        },

        getOfflineData: async (storeName) => {
          // Implementation would use IndexedDB
          return Promise.resolve([]);
        },
      })),
      {
        name: "pwa-storage",
        partialize: (state) => ({
          pushSubscribed: state.pushSubscribed,
          backgroundSyncEnabled: state.backgroundSyncEnabled,
          offlineQueue: state.offlineQueue,
        }),
      }
    )
  )
);

export default usePWAStore;
```

```jsx
// components/ZustandPWAManager.jsx
import React, { useEffect } from "react";
import usePWAStore from "../stores/pwaStore";

const ZustandPWAManager = ({ children }) => {
  const {
    isOnline,
    isInstallable,
    updateAvailable,
    installPrompt,
    offlineQueue,
    syncStatus,
    registerServiceWorker,
    subscribeToPushNotifications,
    setOnlineStatus,
    setInstallable,
    setInstalled,
    processOfflineQueue,
  } = usePWAStore();

  useEffect(() => {
    // Initialize PWA features
    registerServiceWorker();

    // Event listeners
    const handleOnline = () => setOnlineStatus(true);
    const handleOffline = () => setOnlineStatus(false);

    const handleBeforeInstallPrompt = (e) => {
      e.preventDefault();
      setInstallable(true, e);
    };

    const handleAppInstalled = () => setInstalled(true);

    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);
    window.addEventListener("beforeinstallprompt", handleBeforeInstallPrompt);
    window.addEventListener("appinstalled", handleAppInstalled);

    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
      window.removeEventListener(
        "beforeinstallprompt",
        handleBeforeInstallPrompt
      );
      window.removeEventListener("appinstalled", handleAppInstalled);
    };
  }, []);

  // Process offline queue when coming back online
  useEffect(() => {
    if (isOnline && offlineQueue.length > 0 && syncStatus === "syncing") {
      processOfflineQueue();
    }
  }, [isOnline, offlineQueue.length, syncStatus]);

  const handleInstallApp = async () => {
    if (installPrompt) {
      const result = await installPrompt.prompt();
      if (result.outcome === "accepted") {
        setInstalled(true);
      }
    }
  };

  return (
    <div className="pwa-manager">
      {/* Install Banner */}
      {isInstallable && (
        <div className="install-banner">
          <p>Install this app for a better experience!</p>
          <button onClick={handleInstallApp}>Install</button>
        </div>
      )}

      {/* Update Banner */}
      {updateAvailable && (
        <div className="update-banner">
          <p>A new version is available!</p>
          <button onClick={() => window.location.reload()}>Update</button>
        </div>
      )}

      {/* Offline Indicator */}
      {!isOnline && (
        <div className="offline-indicator">
          <p>You're offline. Changes will be synced when you reconnect.</p>
        </div>
      )}

      {/* Sync Status */}
      {syncStatus === "syncing" && (
        <div className="sync-indicator">
          <p>Syncing offline changes...</p>
        </div>
      )}

      {children}
    </div>
  );
};

export default ZustandPWAManager;
```

#### Service Worker Implementation

```javascript
// public/sw.js
const CACHE_NAME = "pwa-cache-v1";
const STATIC_CACHE = "static-cache-v1";
const DYNAMIC_CACHE = "dynamic-cache-v1";

const STATIC_ASSETS = [
  "/",
  "/static/js/bundle.js",
  "/static/css/main.css",
  "/manifest.json",
];

// Install event
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches
      .open(STATIC_CACHE)
      .then((cache) => cache.addAll(STATIC_ASSETS))
      .then(() => self.skipWaiting())
  );
});

// Activate event
self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches
      .keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames
            .filter(
              (cacheName) =>
                cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE
            )
            .map((cacheName) => caches.delete(cacheName))
        );
      })
      .then(() => self.clients.claim())
  );
});

// Fetch event
self.addEventListener("fetch", (event) => {
  if (event.request.url.includes("/api/")) {
    // API requests - Network first, then cache
    event.respondWith(
      fetch(event.request)
        .then((response) => {
          const responseClone = response.clone();
          caches
            .open(DYNAMIC_CACHE)
            .then((cache) => cache.put(event.request, responseClone));
          return response;
        })
        .catch(() => caches.match(event.request))
    );
  } else {
    // Static assets - Cache first, then network
    event.respondWith(
      caches.match(event.request).then((response) => {
        return (
          response ||
          fetch(event.request).then((fetchResponse) => {
            const responseClone = fetchResponse.clone();
            caches
              .open(DYNAMIC_CACHE)
              .then((cache) => cache.put(event.request, responseClone));
            return fetchResponse;
          })
        );
      })
    );
  }
});

// Background sync
self.addEventListener("sync", (event) => {
  if (event.tag === "background-sync") {
    event.waitUntil(doBackgroundSync());
  }
});

// Push notifications
self.addEventListener("push", (event) => {
  const options = {
    body: event.data ? event.data.text() : "New notification",
    icon: "/icon-192x192.png",
    badge: "/badge-72x72.png",
    vibrate: [100, 50, 100],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: 1,
    },
    actions: [
      {
        action: "explore",
        title: "Explore",
        icon: "/icon-explore.png",
      },
      {
        action: "close",
        title: "Close",
        icon: "/icon-close.png",
      },
    ],
  };

  event.waitUntil(
    self.registration.showNotification("PWA Notification", options)
  );
});

// Background sync implementation
async function doBackgroundSync() {
  try {
    // Get pending sync data from IndexedDB
    const syncData = await getSyncData();

    for (const item of syncData) {
      try {
        await fetch("/api/sync", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(item.data),
        });

        // Remove from IndexedDB after successful sync
        await deleteSyncData(item.id);
      } catch (error) {
        // Retry logic could be implemented here
        console.error("Sync failed for item:", item.id, error);
      }
    }
  } catch (error) {
    console.error("Background sync failed:", error);
  }
}

// IndexedDB helpers
function getSyncData() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("PWAOfflineDB", 1);
    request.onsuccess = () => {
      const db = request.result;
      const transaction = db.transaction(["background-sync"], "readonly");
      const store = transaction.objectStore("background-sync");
      const getAllRequest = store.getAll();

      getAllRequest.onsuccess = () => resolve(getAllRequest.result);
      getAllRequest.onerror = () => reject(getAllRequest.error);
    };
    request.onerror = () => reject(request.error);
  });
}

function deleteSyncData(id) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("PWAOfflineDB", 1);
    request.onsuccess = () => {
      const db = request.result;
      const transaction = db.transaction(["background-sync"], "readwrite");
      const store = transaction.objectStore("background-sync");
      const deleteRequest = store.delete(id);

      deleteRequest.onsuccess = () => resolve();
      deleteRequest.onerror = () => reject(deleteRequest.error);
    };
    request.onerror = () => reject(request.error);
  });
}
```

#### Best Practices

1. **Caching Strategy**:

   - Use appropriate caching strategies for different resource types
   - Implement cache versioning and cleanup
   - Consider cache size limits

2. **Offline Experience**:

   - Provide meaningful offline pages
   - Queue actions for background sync
   - Show clear offline indicators

3. **Performance**:

   - Lazy load non-critical resources
   - Implement efficient update mechanisms
   - Use compression and minification

4. **User Experience**:
   - Provide install prompts at appropriate times
   - Show update notifications
   - Handle network state changes gracefully

**Comparison Summary:**

| Feature                    | Redux         | Zustand  |
| -------------------------- | ------------- | -------- |
| Setup Complexity           | Medium        | Low      |
| Service Worker Integration | External      | External |
| Offline Queue Management   | Structured    | Flexible |
| Background Sync            | Manual        | Manual   |
| Push Notifications         | Manual        | Manual   |
| State Persistence          | Redux Persist | Built-in |
| Bundle Size                | Larger        | Smaller  |
| PWA Middleware             | Available     | Custom   |

---

### 40. How do you implement micro-frontend architecture with Redux vs Zustand?

**Answer:**

Micro-frontend architecture allows teams to develop, deploy, and maintain frontend applications independently. State management becomes crucial for communication between micro-frontends and shared state coordination.

#### Redux Implementation for Micro-Frontends

```javascript
// shared/store/federatedStore.js
import { configureStore, createSlice } from "@reduxjs/toolkit";
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

// Shared API slice for cross-micro-frontend communication
export const sharedApi = createApi({
  reducerPath: "sharedApi",
  baseQuery: fetchBaseQuery({
    baseUrl: "/api/shared/",
    prepareHeaders: (headers, { getState }) => {
      const token = getState().auth?.token;
      if (token) {
        headers.set("authorization", `Bearer ${token}`);
      }
      return headers;
    },
  }),
  tagTypes: ["User", "Notification", "SharedData"],
  endpoints: (builder) => ({
    getSharedData: builder.query({
      query: () => "data",
      providesTags: ["SharedData"],
    }),
    updateSharedData: builder.mutation({
      query: (data) => ({
        url: "data",
        method: "PUT",
        body: data,
      }),
      invalidatesTags: ["SharedData"],
    }),
  }),
});

// Shared state slice for cross-micro-frontend state
const sharedSlice = createSlice({
  name: "shared",
  initialState: {
    user: null,
    theme: "light",
    language: "en",
    notifications: [],
    globalLoading: false,
    crossMfeEvents: [],
  },
  reducers: {
    setUser: (state, action) => {
      state.user = action.payload;
    },
    setTheme: (state, action) => {
      state.theme = action.payload;
      // Broadcast theme change to other micro-frontends
      window.dispatchEvent(
        new CustomEvent("theme-changed", {
          detail: { theme: action.payload },
        })
      );
    },
    setLanguage: (state, action) => {
      state.language = action.payload;
      window.dispatchEvent(
        new CustomEvent("language-changed", {
          detail: { language: action.payload },
        })
      );
    },
    addNotification: (state, action) => {
      state.notifications.push({
        id: Date.now().toString(),
        ...action.payload,
        timestamp: Date.now(),
      });
    },
    removeNotification: (state, action) => {
      state.notifications = state.notifications.filter(
        (notification) => notification.id !== action.payload
      );
    },
    setGlobalLoading: (state, action) => {
      state.globalLoading = action.payload;
    },
    addCrossMfeEvent: (state, action) => {
      state.crossMfeEvents.push({
        id: Date.now().toString(),
        ...action.payload,
        timestamp: Date.now(),
      });
    },
  },
});

export const {
  setUser,
  setTheme,
  setLanguage,
  addNotification,
  removeNotification,
  setGlobalLoading,
  addCrossMfeEvent,
} = sharedSlice.actions;

// Create federated store factory
export const createFederatedStore = (microFrontendSlices = {}) => {
  return configureStore({
    reducer: {
      shared: sharedSlice.reducer,
      sharedApi: sharedApi.reducer,
      ...microFrontendSlices,
    },
    middleware: (getDefaultMiddleware) =>
      getDefaultMiddleware({
        serializableCheck: {
          ignoredActions: ["persist/PERSIST", "persist/REHYDRATE"],
        },
      }).concat(sharedApi.middleware),
    devTools: process.env.NODE_ENV !== "production",
  });
};

export default sharedSlice.reducer;
```

```javascript
// shared/communication/eventBus.js
class MicroFrontendEventBus {
  constructor() {
    this.events = new Map();
    this.setupGlobalEventListeners();
  }

  // Subscribe to events from other micro-frontends
  subscribe(eventType, callback) {
    if (!this.events.has(eventType)) {
      this.events.set(eventType, new Set());
    }
    this.events.get(eventType).add(callback);

    // Return unsubscribe function
    return () => {
      const callbacks = this.events.get(eventType);
      if (callbacks) {
        callbacks.delete(callback);
        if (callbacks.size === 0) {
          this.events.delete(eventType);
        }
      }
    };
  }

  // Emit events to other micro-frontends
  emit(eventType, data) {
    // Local event handling
    const callbacks = this.events.get(eventType);
    if (callbacks) {
      callbacks.forEach((callback) => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in event callback for ${eventType}:`, error);
        }
      });
    }

    // Global event for cross-micro-frontend communication
    window.dispatchEvent(
      new CustomEvent(`mfe:${eventType}`, {
        detail: data,
      })
    );
  }

  // Setup global event listeners for cross-MFE communication
  setupGlobalEventListeners() {
    window.addEventListener("message", (event) => {
      if (event.data && event.data.type && event.data.type.startsWith("mfe:")) {
        const eventType = event.data.type.replace("mfe:", "");
        this.handleGlobalEvent(eventType, event.data.payload);
      }
    });
  }

  handleGlobalEvent(eventType, data) {
    const callbacks = this.events.get(eventType);
    if (callbacks) {
      callbacks.forEach((callback) => {
        try {
          callback(data);
        } catch (error) {
          console.error(
            `Error in global event callback for ${eventType}:`,
            error
          );
        }
      });
    }
  }

  // Send message to specific micro-frontend
  sendToMicroFrontend(targetOrigin, eventType, data) {
    window.postMessage(
      {
        type: `mfe:${eventType}`,
        payload: data,
        source: window.location.origin,
      },
      targetOrigin
    );
  }
}

export const eventBus = new MicroFrontendEventBus();

// Redux middleware for event bus integration
export const eventBusMiddleware = (store) => (next) => (action) => {
  const result = next(action);

  // Emit certain actions as events to other micro-frontends
  if (action.type.startsWith("shared/")) {
    eventBus.emit("redux-action", {
      type: action.type,
      payload: action.payload,
      timestamp: Date.now(),
    });
  }

  return result;
};
```

```jsx
// micro-frontend-1/src/App.jsx (Header MFE)
import React, { useEffect } from "react";
import { Provider, useSelector, useDispatch } from "react-redux";
import {
  createFederatedStore,
  setTheme,
  setLanguage,
} from "@shared/store/federatedStore";
import { eventBus } from "@shared/communication/eventBus";

// Header-specific slice
const headerSlice = createSlice({
  name: "header",
  initialState: {
    menuOpen: false,
    searchQuery: "",
    userMenuOpen: false,
  },
  reducers: {
    toggleMenu: (state) => {
      state.menuOpen = !state.menuOpen;
    },
    setSearchQuery: (state, action) => {
      state.searchQuery = action.payload;
    },
    toggleUserMenu: (state) => {
      state.userMenuOpen = !state.userMenuOpen;
    },
  },
});

const store = createFederatedStore({
  header: headerSlice.reducer,
});

const Header = () => {
  const dispatch = useDispatch();
  const { user, theme, language } = useSelector((state) => state.shared);
  const { menuOpen, searchQuery } = useSelector((state) => state.header);

  useEffect(() => {
    // Listen for navigation events from other micro-frontends
    const unsubscribe = eventBus.subscribe("navigate", (data) => {
      console.log("Navigation event received:", data);
      // Handle navigation state changes
    });

    return unsubscribe;
  }, []);

  const handleThemeChange = (newTheme) => {
    dispatch(setTheme(newTheme));
    // This will automatically broadcast to other MFEs
  };

  const handleSearch = (query) => {
    dispatch(headerSlice.actions.setSearchQuery(query));
    // Emit search event to other micro-frontends
    eventBus.emit("search", { query, timestamp: Date.now() });
  };

  return (
    <header className={`header theme-${theme}`}>
      <div className="header-content">
        <button onClick={() => dispatch(headerSlice.actions.toggleMenu())}>
          Menu
        </button>

        <input
          type="text"
          value={searchQuery}
          onChange={(e) => handleSearch(e.target.value)}
          placeholder="Search..."
        />

        <div className="user-section">
          <select
            value={theme}
            onChange={(e) => handleThemeChange(e.target.value)}
          >
            <option value="light">Light</option>
            <option value="dark">Dark</option>
          </select>

          {user && <div className="user-info">Welcome, {user.name}</div>}
        </div>
      </div>
    </header>
  );
};

const HeaderApp = () => (
  <Provider store={store}>
    <Header />
  </Provider>
);

export default HeaderApp;
```

#### Zustand Implementation for Micro-Frontends

```javascript
// shared/stores/federatedStore.js
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { persist } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

// Shared store for cross-micro-frontend state
const useSharedStore = create(
  subscribeWithSelector(
    persist(
      immer((set, get) => ({
        // Shared state
        user: null,
        theme: "light",
        language: "en",
        notifications: [],
        globalLoading: false,
        crossMfeEvents: [],

        // Actions
        setUser: (user) => {
          set((state) => {
            state.user = user;
          });

          // Broadcast user change
          window.dispatchEvent(
            new CustomEvent("mfe:user-changed", {
              detail: { user },
            })
          );
        },

        setTheme: (theme) => {
          set((state) => {
            state.theme = theme;
          });

          // Broadcast theme change
          window.dispatchEvent(
            new CustomEvent("mfe:theme-changed", {
              detail: { theme },
            })
          );
        },

        setLanguage: (language) => {
          set((state) => {
            state.language = language;
          });

          window.dispatchEvent(
            new CustomEvent("mfe:language-changed", {
              detail: { language },
            })
          );
        },

        addNotification: (notification) => {
          set((state) => {
            state.notifications.push({
              id: Date.now().toString(),
              ...notification,
              timestamp: Date.now(),
            });
          });
        },

        removeNotification: (id) => {
          set((state) => {
            state.notifications = state.notifications.filter(
              (notification) => notification.id !== id
            );
          });
        },

        setGlobalLoading: (loading) => {
          set((state) => {
            state.globalLoading = loading;
          });
        },

        addCrossMfeEvent: (event) => {
          set((state) => {
            state.crossMfeEvents.push({
              id: Date.now().toString(),
              ...event,
              timestamp: Date.now(),
            });
          });
        },

        // Cross-MFE communication
        emitEvent: (eventType, data) => {
          const event = {
            type: eventType,
            data,
            timestamp: Date.now(),
            source: window.location.origin,
          };

          get().addCrossMfeEvent(event);

          // Broadcast to other micro-frontends
          window.dispatchEvent(
            new CustomEvent(`mfe:${eventType}`, {
              detail: data,
            })
          );
        },

        // Subscribe to cross-MFE events
        subscribeToMfeEvents: (eventType, callback) => {
          const handler = (event) => {
            callback(event.detail);
          };

          window.addEventListener(`mfe:${eventType}`, handler);

          // Return cleanup function
          return () => {
            window.removeEventListener(`mfe:${eventType}`, handler);
          };
        },
      })),
      {
        name: "shared-mfe-storage",
        partialize: (state) => ({
          user: state.user,
          theme: state.theme,
          language: state.language,
        }),
      }
    )
  )
);

export default useSharedStore;
```

```javascript
// shared/hooks/useMicroFrontendCommunication.js
import { useEffect, useCallback } from "react";
import useSharedStore from "../stores/federatedStore";

export const useMicroFrontendCommunication = () => {
  const { emitEvent, subscribeToMfeEvents, addNotification } = useSharedStore();

  // Setup global event listeners
  useEffect(() => {
    const cleanupFunctions = [];

    // Listen for navigation events
    cleanupFunctions.push(
      subscribeToMfeEvents("navigate", (data) => {
        console.log("Navigation event received:", data);
        // Handle navigation
      })
    );

    // Listen for error events
    cleanupFunctions.push(
      subscribeToMfeEvents("error", (data) => {
        addNotification({
          type: "error",
          message: data.message,
          source: data.source,
        });
      })
    );

    // Listen for data updates
    cleanupFunctions.push(
      subscribeToMfeEvents("data-updated", (data) => {
        console.log("Data updated in another MFE:", data);
        // Refresh local data if needed
      })
    );

    return () => {
      cleanupFunctions.forEach((cleanup) => cleanup());
    };
  }, [subscribeToMfeEvents, addNotification]);

  // Communication utilities
  const navigate = useCallback(
    (path, data = {}) => {
      emitEvent("navigate", { path, data });
    },
    [emitEvent]
  );

  const notifyError = useCallback(
    (error, source) => {
      emitEvent("error", {
        message: error.message,
        stack: error.stack,
        source,
      });
    },
    [emitEvent]
  );

  const notifyDataUpdate = useCallback(
    (entityType, data) => {
      emitEvent("data-updated", {
        entityType,
        data,
        source: window.location.origin,
      });
    },
    [emitEvent]
  );

  return {
    navigate,
    notifyError,
    notifyDataUpdate,
    emitEvent,
  };
};
```

```jsx
// micro-frontend-2/src/App.jsx (Dashboard MFE)
import React, { useEffect } from "react";
import useSharedStore from "@shared/stores/federatedStore";
import { useMicroFrontendCommunication } from "@shared/hooks/useMicroFrontendCommunication";
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";

// Dashboard-specific store
const useDashboardStore = create(
  immer((set, get) => ({
    widgets: [],
    selectedWidget: null,
    dashboardLayout: "grid",
    filters: {},

    addWidget: (widget) => {
      set((state) => {
        state.widgets.push({
          id: Date.now().toString(),
          ...widget,
          createdAt: Date.now(),
        });
      });
    },

    removeWidget: (id) => {
      set((state) => {
        state.widgets = state.widgets.filter((widget) => widget.id !== id);
      });
    },

    selectWidget: (id) => {
      set((state) => {
        state.selectedWidget = id;
      });
    },

    setLayout: (layout) => {
      set((state) => {
        state.dashboardLayout = layout;
      });
    },

    updateFilters: (filters) => {
      set((state) => {
        state.filters = { ...state.filters, ...filters };
      });
    },
  }))
);

const Dashboard = () => {
  const { theme, user } = useSharedStore();
  const { widgets, dashboardLayout } = useDashboardStore();
  const { navigate, notifyDataUpdate } = useMicroFrontendCommunication();

  useEffect(() => {
    // Listen for search events from header MFE
    const cleanup = useSharedStore
      .getState()
      .subscribeToMfeEvents("search", (data) => {
        console.log("Search query received:", data.query);
        // Apply search filters to dashboard
        useDashboardStore.getState().updateFilters({
          search: data.query,
        });
      });

    return cleanup;
  }, []);

  const handleWidgetUpdate = (widgetId, data) => {
    // Update local widget
    useDashboardStore.getState().updateWidget(widgetId, data);

    // Notify other MFEs about the update
    notifyDataUpdate("widget", { id: widgetId, data });
  };

  const handleNavigateToDetails = (itemId) => {
    navigate(`/details/${itemId}`, { source: "dashboard" });
  };

  return (
    <div className={`dashboard theme-${theme}`}>
      <div className="dashboard-header">
        <h1>Dashboard</h1>
        {user && <p>Welcome back, {user.name}!</p>}
      </div>

      <div className={`dashboard-content layout-${dashboardLayout}`}>
        {widgets.map((widget) => (
          <div key={widget.id} className="widget">
            <h3>{widget.title}</h3>
            <div className="widget-content">{widget.content}</div>
            <button onClick={() => handleNavigateToDetails(widget.id)}>
              View Details
            </button>
          </div>
        ))}
      </div>
    </div>
  );
};

export default Dashboard;
```

#### Module Federation Configuration

```javascript
// webpack.config.js (Shell Application)
const ModuleFederationPlugin = require("@module-federation/webpack");

module.exports = {
  mode: "development",
  devServer: {
    port: 3000,
  },
  plugins: [
    new ModuleFederationPlugin({
      name: "shell",
      remotes: {
        header: "header@http://localhost:3001/remoteEntry.js",
        dashboard: "dashboard@http://localhost:3002/remoteEntry.js",
        sidebar: "sidebar@http://localhost:3003/remoteEntry.js",
      },
      shared: {
        react: { singleton: true },
        "react-dom": { singleton: true },
        "@reduxjs/toolkit": { singleton: true },
        "react-redux": { singleton: true },
        zustand: { singleton: true },
      },
    }),
  ],
};
```

```javascript
// webpack.config.js (Header MFE)
const ModuleFederationPlugin = require("@module-federation/webpack");

module.exports = {
  mode: "development",
  devServer: {
    port: 3001,
  },
  plugins: [
    new ModuleFederationPlugin({
      name: "header",
      filename: "remoteEntry.js",
      exposes: {
        "./Header": "./src/App",
      },
      shared: {
        react: { singleton: true },
        "react-dom": { singleton: true },
        "@reduxjs/toolkit": { singleton: true },
        "react-redux": { singleton: true },
        zustand: { singleton: true },
      },
    }),
  ],
};
```

#### Best Practices

1. **State Isolation**:

   - Keep micro-frontend specific state separate
   - Share only necessary global state
   - Use clear boundaries between shared and local state

2. **Communication Patterns**:

   - Use event-driven architecture for loose coupling
   - Implement proper error handling for cross-MFE communication
   - Avoid direct dependencies between micro-frontends

3. **Performance**:

   - Lazy load micro-frontends when needed
   - Share common dependencies to reduce bundle size
   - Implement proper caching strategies

4. **Development Experience**:
   - Use TypeScript for better type safety across MFEs
   - Implement proper testing strategies for integration
   - Use consistent coding standards across teams

**Comparison Summary:**

| Feature                 | Redux         | Zustand              |
| ----------------------- | ------------- | -------------------- |
| Setup Complexity        | High          | Medium               |
| Cross-MFE Communication | Structured    | Flexible             |
| State Sharing           | Redux Toolkit | Custom Events        |
| Bundle Size             | Larger        | Smaller              |
| Type Safety             | Good with RTK | Good with TypeScript |
| DevTools                | Excellent     | Basic                |
| Learning Curve          | Steep         | Moderate             |
| Team Coordination       | Structured    | Flexible             |

---

### 41. How do you implement advanced form handling and validation in Redux vs Zustand?

**Answer:**

Advanced form handling involves complex validation, field dependencies, dynamic forms, and optimized performance. Both Redux and Zustand can handle sophisticated form scenarios with different approaches.

#### Redux Implementation with Advanced Form Handling

```javascript
// store/formSlice.js
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

// Async validation thunk
export const validateFieldAsync = createAsyncThunk(
  "form/validateFieldAsync",
  async ({ fieldName, value, formData }, { rejectWithValue }) => {
    try {
      const response = await fetch("/api/validate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ field: fieldName, value, context: formData }),
      });

      if (!response.ok) {
        throw new Error("Validation failed");
      }

      const result = await response.json();
      return { fieldName, isValid: result.valid, message: result.message };
    } catch (error) {
      return rejectWithValue({ fieldName, error: error.message });
    }
  }
);

// Submit form thunk
export const submitForm = createAsyncThunk(
  "form/submitForm",
  async (formData, { getState, rejectWithValue }) => {
    try {
      const state = getState();
      const { fields, isValid } = state.form;

      if (!isValid) {
        throw new Error("Form validation failed");
      }

      const response = await fetch("/api/submit", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });

      if (!response.ok) {
        throw new Error("Submission failed");
      }

      return await response.json();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const formSlice = createSlice({
  name: "form",
  initialState: {
    fields: {},
    errors: {},
    touched: {},
    isSubmitting: false,
    isValid: false,
    submitCount: 0,
    validationRules: {},
    fieldDependencies: {},
    dynamicFields: [],
    validationDebounceTimers: {},
  },
  reducers: {
    // Initialize form with schema
    initializeForm: (state, action) => {
      const { schema, initialValues = {} } = action.payload;

      state.fields = { ...initialValues };
      state.validationRules = schema.rules || {};
      state.fieldDependencies = schema.dependencies || {};
      state.dynamicFields = schema.dynamicFields || [];
      state.errors = {};
      state.touched = {};
      state.isValid = false;
    },

    // Update field value
    updateField: (state, action) => {
      const { name, value } = action.payload;
      state.fields[name] = value;

      // Clear error when user starts typing
      if (state.errors[name]) {
        delete state.errors[name];
      }

      // Handle field dependencies
      const dependencies = state.fieldDependencies[name];
      if (dependencies) {
        dependencies.forEach((depField) => {
          // Clear dependent field errors
          if (state.errors[depField]) {
            delete state.errors[depField];
          }
        });
      }
    },

    // Set field as touched
    setFieldTouched: (state, action) => {
      const { name } = action.payload;
      state.touched[name] = true;
    },

    // Set field error
    setFieldError: (state, action) => {
      const { name, error } = action.payload;
      if (error) {
        state.errors[name] = error;
      } else {
        delete state.errors[name];
      }

      // Update form validity
      state.isValid = Object.keys(state.errors).length === 0;
    },

    // Validate single field
    validateField: (state, action) => {
      const { name, value } = action.payload;
      const rules = state.validationRules[name];

      if (!rules) return;

      let error = null;

      // Required validation
      if (rules.required && (!value || value.toString().trim() === "")) {
        error = rules.requiredMessage || `${name} is required`;
      }

      // Min length validation
      if (
        !error &&
        rules.minLength &&
        value &&
        value.length < rules.minLength
      ) {
        error =
          rules.minLengthMessage ||
          `${name} must be at least ${rules.minLength} characters`;
      }

      // Max length validation
      if (
        !error &&
        rules.maxLength &&
        value &&
        value.length > rules.maxLength
      ) {
        error =
          rules.maxLengthMessage ||
          `${name} must be no more than ${rules.maxLength} characters`;
      }

      // Pattern validation
      if (!error && rules.pattern && value && !rules.pattern.test(value)) {
        error = rules.patternMessage || `${name} format is invalid`;
      }

      // Custom validation
      if (!error && rules.custom && value) {
        const customResult = rules.custom(value, state.fields);
        if (customResult !== true) {
          error = customResult;
        }
      }

      // Set error
      if (error) {
        state.errors[name] = error;
      } else {
        delete state.errors[name];
      }

      // Update form validity
      state.isValid = Object.keys(state.errors).length === 0;
    },

    // Validate all fields
    validateAllFields: (state) => {
      Object.keys(state.fields).forEach((fieldName) => {
        const value = state.fields[fieldName];
        formSlice.caseReducers.validateField(state, {
          payload: { name: fieldName, value },
        });
      });
    },

    // Add dynamic field
    addDynamicField: (state, action) => {
      const { fieldConfig } = action.payload;
      const fieldId = `dynamic_${Date.now()}`;

      state.fields[fieldId] = fieldConfig.defaultValue || "";
      state.validationRules[fieldId] = fieldConfig.rules || {};
      state.dynamicFields.push({
        id: fieldId,
        ...fieldConfig,
      });
    },

    // Remove dynamic field
    removeDynamicField: (state, action) => {
      const { fieldId } = action.payload;

      delete state.fields[fieldId];
      delete state.errors[fieldId];
      delete state.touched[fieldId];
      delete state.validationRules[fieldId];

      state.dynamicFields = state.dynamicFields.filter(
        (field) => field.id !== fieldId
      );
    },

    // Reset form
    resetForm: (state) => {
      state.fields = {};
      state.errors = {};
      state.touched = {};
      state.isSubmitting = false;
      state.isValid = false;
      state.submitCount = 0;
      state.dynamicFields = [];
    },
  },
  extraReducers: (builder) => {
    builder
      // Async validation
      .addCase(validateFieldAsync.pending, (state, action) => {
        const { fieldName } = action.meta.arg;
        // Could add loading state for specific field
      })
      .addCase(validateFieldAsync.fulfilled, (state, action) => {
        const { fieldName, isValid, message } = action.payload;
        if (!isValid) {
          state.errors[fieldName] = message;
        } else {
          delete state.errors[fieldName];
        }
        state.isValid = Object.keys(state.errors).length === 0;
      })
      .addCase(validateFieldAsync.rejected, (state, action) => {
        const { fieldName, error } = action.payload;
        state.errors[fieldName] = error;
        state.isValid = false;
      })

      // Form submission
      .addCase(submitForm.pending, (state) => {
        state.isSubmitting = true;
      })
      .addCase(submitForm.fulfilled, (state) => {
        state.isSubmitting = false;
        state.submitCount += 1;
        // Could reset form or show success message
      })
      .addCase(submitForm.rejected, (state, action) => {
        state.isSubmitting = false;
        state.submitCount += 1;
        // Could set global form error
      });
  },
});

export const {
  initializeForm,
  updateField,
  setFieldTouched,
  setFieldError,
  validateField,
  validateAllFields,
  addDynamicField,
  removeDynamicField,
  resetForm,
} = formSlice.actions;

export default formSlice.reducer;
```

```jsx
// components/AdvancedForm.jsx
import React, { useEffect, useCallback } from "react";
import { useSelector, useDispatch } from "react-redux";
import {
  initializeForm,
  updateField,
  setFieldTouched,
  validateField,
  validateFieldAsync,
  validateAllFields,
  submitForm,
  addDynamicField,
  removeDynamicField,
} from "../store/formSlice";

const AdvancedForm = () => {
  const dispatch = useDispatch();
  const { fields, errors, touched, isSubmitting, isValid, dynamicFields } =
    useSelector((state) => state.form);

  // Form schema
  const formSchema = {
    rules: {
      email: {
        required: true,
        pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
        patternMessage: "Please enter a valid email address",
      },
      password: {
        required: true,
        minLength: 8,
        custom: (value, allFields) => {
          if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(value)) {
            return "Password must contain at least one lowercase, uppercase, and number";
          }
          return true;
        },
      },
      confirmPassword: {
        required: true,
        custom: (value, allFields) => {
          if (value !== allFields.password) {
            return "Passwords do not match";
          }
          return true;
        },
      },
      username: {
        required: true,
        minLength: 3,
        maxLength: 20,
        pattern: /^[a-zA-Z0-9_]+$/,
        patternMessage:
          "Username can only contain letters, numbers, and underscores",
      },
    },
    dependencies: {
      password: ["confirmPassword"],
    },
  };

  // Initialize form
  useEffect(() => {
    dispatch(
      initializeForm({
        schema: formSchema,
        initialValues: {
          email: "",
          password: "",
          confirmPassword: "",
          username: "",
        },
      })
    );
  }, [dispatch]);

  // Debounced validation
  const debouncedValidation = useCallback(
    debounce((fieldName, value) => {
      dispatch(validateField({ name: fieldName, value }));

      // Async validation for username
      if (fieldName === "username" && value.length >= 3) {
        dispatch(
          validateFieldAsync({
            fieldName,
            value,
            formData: fields,
          })
        );
      }
    }, 300),
    [dispatch, fields]
  );

  const handleFieldChange = (fieldName, value) => {
    dispatch(updateField({ name: fieldName, value }));
    debouncedValidation(fieldName, value);
  };

  const handleFieldBlur = (fieldName) => {
    dispatch(setFieldTouched({ name: fieldName }));
    const value = fields[fieldName];
    dispatch(validateField({ name: fieldName, value }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();

    // Validate all fields before submission
    dispatch(validateAllFields());

    if (isValid) {
      dispatch(submitForm(fields));
    }
  };

  const handleAddDynamicField = () => {
    dispatch(
      addDynamicField({
        fieldConfig: {
          type: "text",
          label: "Additional Info",
          defaultValue: "",
          rules: {
            maxLength: 100,
          },
        },
      })
    );
  };

  const renderField = (fieldName, fieldConfig = {}) => {
    const value = fields[fieldName] || "";
    const error = errors[fieldName];
    const isTouched = touched[fieldName];
    const showError = error && isTouched;

    return (
      <div key={fieldName} className="form-field">
        <label htmlFor={fieldName}>
          {fieldConfig.label || fieldName}
          {formSchema.rules[fieldName]?.required && (
            <span className="required">*</span>
          )}
        </label>

        <input
          id={fieldName}
          type={fieldConfig.type || "text"}
          value={value}
          onChange={(e) => handleFieldChange(fieldName, e.target.value)}
          onBlur={() => handleFieldBlur(fieldName)}
          className={showError ? "error" : ""}
          placeholder={fieldConfig.placeholder}
        />

        {showError && <span className="error-message">{error}</span>}
      </div>
    );
  };

  return (
    <form onSubmit={handleSubmit} className="advanced-form">
      <h2>Advanced Form Example</h2>

      {renderField("email", {
        type: "email",
        label: "Email Address",
        placeholder: "Enter your email",
      })}

      {renderField("username", {
        label: "Username",
        placeholder: "Choose a username",
      })}

      {renderField("password", {
        type: "password",
        label: "Password",
        placeholder: "Enter a strong password",
      })}

      {renderField("confirmPassword", {
        type: "password",
        label: "Confirm Password",
        placeholder: "Confirm your password",
      })}

      {/* Dynamic fields */}
      {dynamicFields.map((field) => (
        <div key={field.id} className="dynamic-field">
          {renderField(field.id, field)}
          <button
            type="button"
            onClick={() => dispatch(removeDynamicField({ fieldId: field.id }))}
            className="remove-field"
          >
            Remove
          </button>
        </div>
      ))}

      <button
        type="button"
        onClick={handleAddDynamicField}
        className="add-field"
      >
        Add Dynamic Field
      </button>

      <div className="form-actions">
        <button
          type="submit"
          disabled={!isValid || isSubmitting}
          className="submit-button"
        >
          {isSubmitting ? "Submitting..." : "Submit"}
        </button>
      </div>

      {/* Form debug info */}
      <div className="form-debug">
        <p>Form Valid: {isValid ? "Yes" : "No"}</p>
        <p>Errors: {Object.keys(errors).length}</p>
      </div>
    </form>
  );
};

// Debounce utility
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

export default AdvancedForm;
```

#### Zustand Implementation with Advanced Form Handling

```javascript
// stores/formStore.js
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

const useFormStore = create(
  subscribeWithSelector(
    immer((set, get) => ({
      // Form state
      fields: {},
      errors: {},
      touched: {},
      isSubmitting: false,
      isValid: false,
      submitCount: 0,
      validationRules: {},
      fieldDependencies: {},
      dynamicFields: [],
      validationTimers: {},

      // Actions
      initializeForm: (schema, initialValues = {}) => {
        set((state) => {
          state.fields = { ...initialValues };
          state.validationRules = schema.rules || {};
          state.fieldDependencies = schema.dependencies || {};
          state.dynamicFields = schema.dynamicFields || [];
          state.errors = {};
          state.touched = {};
          state.isValid = false;
        });
      },

      updateField: (name, value) => {
        set((state) => {
          state.fields[name] = value;

          // Clear error when user starts typing
          if (state.errors[name]) {
            delete state.errors[name];
          }

          // Handle field dependencies
          const dependencies = state.fieldDependencies[name];
          if (dependencies) {
            dependencies.forEach((depField) => {
              if (state.errors[depField]) {
                delete state.errors[depField];
              }
            });
          }
        });

        // Trigger debounced validation
        get().debouncedValidation(name, value);
      },

      setFieldTouched: (name) => {
        set((state) => {
          state.touched[name] = true;
        });
      },

      setFieldError: (name, error) => {
        set((state) => {
          if (error) {
            state.errors[name] = error;
          } else {
            delete state.errors[name];
          }

          // Update form validity
          state.isValid = Object.keys(state.errors).length === 0;
        });
      },

      validateField: (name, value) => {
        const { validationRules, fields } = get();
        const rules = validationRules[name];

        if (!rules) return;

        let error = null;

        // Required validation
        if (rules.required && (!value || value.toString().trim() === "")) {
          error = rules.requiredMessage || `${name} is required`;
        }

        // Min length validation
        if (
          !error &&
          rules.minLength &&
          value &&
          value.length < rules.minLength
        ) {
          error =
            rules.minLengthMessage ||
            `${name} must be at least ${rules.minLength} characters`;
        }

        // Max length validation
        if (
          !error &&
          rules.maxLength &&
          value &&
          value.length > rules.maxLength
        ) {
          error =
            rules.maxLengthMessage ||
            `${name} must be no more than ${rules.maxLength} characters`;
        }

        // Pattern validation
        if (!error && rules.pattern && value && !rules.pattern.test(value)) {
          error = rules.patternMessage || `${name} format is invalid`;
        }

        // Custom validation
        if (!error && rules.custom && value) {
          const customResult = rules.custom(value, fields);
          if (customResult !== true) {
            error = customResult;
          }
        }

        get().setFieldError(name, error);
      },

      validateFieldAsync: async (fieldName, value, formData) => {
        try {
          const response = await fetch("/api/validate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              field: fieldName,
              value,
              context: formData,
            }),
          });

          if (!response.ok) {
            throw new Error("Validation failed");
          }

          const result = await response.json();

          if (!result.valid) {
            get().setFieldError(fieldName, result.message);
          } else {
            get().setFieldError(fieldName, null);
          }
        } catch (error) {
          get().setFieldError(fieldName, error.message);
        }
      },

      debouncedValidation: (fieldName, value) => {
        const { validationTimers } = get();

        // Clear existing timer
        if (validationTimers[fieldName]) {
          clearTimeout(validationTimers[fieldName]);
        }

        // Set new timer
        const timer = setTimeout(() => {
          get().validateField(fieldName, value);

          // Async validation for specific fields
          if (fieldName === "username" && value.length >= 3) {
            get().validateFieldAsync(fieldName, value, get().fields);
          }
        }, 300);

        set((state) => {
          state.validationTimers[fieldName] = timer;
        });
      },

      validateAllFields: () => {
        const { fields } = get();
        Object.keys(fields).forEach((fieldName) => {
          const value = fields[fieldName];
          get().validateField(fieldName, value);
        });
      },

      addDynamicField: (fieldConfig) => {
        const fieldId = `dynamic_${Date.now()}`;

        set((state) => {
          state.fields[fieldId] = fieldConfig.defaultValue || "";
          state.validationRules[fieldId] = fieldConfig.rules || {};
          state.dynamicFields.push({
            id: fieldId,
            ...fieldConfig,
          });
        });
      },

      removeDynamicField: (fieldId) => {
        set((state) => {
          delete state.fields[fieldId];
          delete state.errors[fieldId];
          delete state.touched[fieldId];
          delete state.validationRules[fieldId];

          state.dynamicFields = state.dynamicFields.filter(
            (field) => field.id !== fieldId
          );
        });
      },

      submitForm: async () => {
        const { fields, isValid } = get();

        // Validate all fields first
        get().validateAllFields();

        if (!get().isValid) {
          throw new Error("Form validation failed");
        }

        set((state) => {
          state.isSubmitting = true;
        });

        try {
          const response = await fetch("/api/submit", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(fields),
          });

          if (!response.ok) {
            throw new Error("Submission failed");
          }

          const result = await response.json();

          set((state) => {
            state.isSubmitting = false;
            state.submitCount += 1;
          });

          return result;
        } catch (error) {
          set((state) => {
            state.isSubmitting = false;
            state.submitCount += 1;
          });
          throw error;
        }
      },

      resetForm: () => {
        set((state) => {
          state.fields = {};
          state.errors = {};
          state.touched = {};
          state.isSubmitting = false;
          state.isValid = false;
          state.submitCount = 0;
          state.dynamicFields = [];

          // Clear validation timers
          Object.values(state.validationTimers).forEach((timer) => {
            clearTimeout(timer);
          });
          state.validationTimers = {};
        });
      },
    }))
  )
);

export default useFormStore;
```

```jsx
// components/ZustandAdvancedForm.jsx
import React, { useEffect } from "react";
import useFormStore from "../stores/formStore";

const ZustandAdvancedForm = () => {
  const {
    fields,
    errors,
    touched,
    isSubmitting,
    isValid,
    dynamicFields,
    initializeForm,
    updateField,
    setFieldTouched,
    validateField,
    addDynamicField,
    removeDynamicField,
    submitForm,
  } = useFormStore();

  // Form schema
  const formSchema = {
    rules: {
      email: {
        required: true,
        pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
        patternMessage: "Please enter a valid email address",
      },
      password: {
        required: true,
        minLength: 8,
        custom: (value, allFields) => {
          if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(value)) {
            return "Password must contain at least one lowercase, uppercase, and number";
          }
          return true;
        },
      },
      confirmPassword: {
        required: true,
        custom: (value, allFields) => {
          if (value !== allFields.password) {
            return "Passwords do not match";
          }
          return true;
        },
      },
      username: {
        required: true,
        minLength: 3,
        maxLength: 20,
        pattern: /^[a-zA-Z0-9_]+$/,
        patternMessage:
          "Username can only contain letters, numbers, and underscores",
      },
    },
    dependencies: {
      password: ["confirmPassword"],
    },
  };

  // Initialize form
  useEffect(() => {
    initializeForm(formSchema, {
      email: "",
      password: "",
      confirmPassword: "",
      username: "",
    });
  }, [initializeForm]);

  const handleFieldChange = (fieldName, value) => {
    updateField(fieldName, value);
  };

  const handleFieldBlur = (fieldName) => {
    setFieldTouched(fieldName);
    const value = fields[fieldName];
    validateField(fieldName, value);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      await submitForm();
      alert("Form submitted successfully!");
    } catch (error) {
      alert(`Submission failed: ${error.message}`);
    }
  };

  const handleAddDynamicField = () => {
    addDynamicField({
      type: "text",
      label: "Additional Info",
      defaultValue: "",
      rules: {
        maxLength: 100,
      },
    });
  };

  const renderField = (fieldName, fieldConfig = {}) => {
    const value = fields[fieldName] || "";
    const error = errors[fieldName];
    const isTouched = touched[fieldName];
    const showError = error && isTouched;

    return (
      <div key={fieldName} className="form-field">
        <label htmlFor={fieldName}>
          {fieldConfig.label || fieldName}
          {formSchema.rules[fieldName]?.required && (
            <span className="required">*</span>
          )}
        </label>

        <input
          id={fieldName}
          type={fieldConfig.type || "text"}
          value={value}
          onChange={(e) => handleFieldChange(fieldName, e.target.value)}
          onBlur={() => handleFieldBlur(fieldName)}
          className={showError ? "error" : ""}
          placeholder={fieldConfig.placeholder}
        />

        {showError && <span className="error-message">{error}</span>}
      </div>
    );
  };

  return (
    <form onSubmit={handleSubmit} className="advanced-form">
      <h2>Zustand Advanced Form</h2>

      {renderField("email", {
        type: "email",
        label: "Email Address",
        placeholder: "Enter your email",
      })}

      {renderField("username", {
        label: "Username",
        placeholder: "Choose a username",
      })}

      {renderField("password", {
        type: "password",
        label: "Password",
        placeholder: "Enter a strong password",
      })}

      {renderField("confirmPassword", {
        type: "password",
        label: "Confirm Password",
        placeholder: "Confirm your password",
      })}

      {/* Dynamic fields */}
      {dynamicFields.map((field) => (
        <div key={field.id} className="dynamic-field">
          {renderField(field.id, field)}
          <button
            type="button"
            onClick={() => removeDynamicField(field.id)}
            className="remove-field"
          >
            Remove
          </button>
        </div>
      ))}

      <button
        type="button"
        onClick={handleAddDynamicField}
        className="add-field"
      >
        Add Dynamic Field
      </button>

      <div className="form-actions">
        <button
          type="submit"
          disabled={!isValid || isSubmitting}
          className="submit-button"
        >
          {isSubmitting ? "Submitting..." : "Submit"}
        </button>
      </div>

      {/* Form debug info */}
      <div className="form-debug">
        <p>Form Valid: {isValid ? "Yes" : "No"}</p>
        <p>Errors: {Object.keys(errors).length}</p>
      </div>
    </form>
  );
};

export default ZustandAdvancedForm;
```

#### Best Practices

1. **Validation Strategy**:

   - Implement both client-side and server-side validation
   - Use debounced validation for better UX
   - Validate on blur for immediate feedback

2. **Performance Optimization**:

   - Debounce validation to avoid excessive API calls
   - Use memoization for complex validation rules
   - Implement field-level updates to minimize re-renders

3. **User Experience**:

   - Show errors only after field interaction
   - Provide clear, actionable error messages
   - Implement progressive disclosure for complex forms

4. **Accessibility**:
   - Use proper ARIA attributes
   - Ensure keyboard navigation works
   - Provide screen reader friendly error messages

**Comparison Summary:**

| Feature            | Redux         | Zustand       |
| ------------------ | ------------- | ------------- |
| Setup Complexity   | High          | Medium        |
| Async Validation   | RTK Thunks    | Custom Async  |
| Field Dependencies | Structured    | Flexible      |
| Dynamic Forms      | Slice-based   | Store Actions |
| Validation Rules   | Schema-driven | Schema-driven |
| Performance        | Good with RTK | Excellent     |
| DevTools           | Excellent     | Basic         |
| Type Safety        | Good with RTK | Good with TS  |

---

### 42. How do you implement advanced data visualization and charting state management in Redux vs Zustand?

**Answer:**

Data visualization applications require complex state management for chart data, interactions, filters, real-time updates, and user customizations. Both Redux and Zustand can handle sophisticated charting scenarios with different approaches.

#### Redux Implementation for Data Visualization

```javascript
// store/chartSlice.js
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

// Async thunks for data fetching
export const fetchChartData = createAsyncThunk(
  "chart/fetchChartData",
  async ({ chartId, params }, { rejectWithValue }) => {
    try {
      const response = await fetch(`/api/charts/${chartId}/data`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(params),
      });

      if (!response.ok) {
        throw new Error("Failed to fetch chart data");
      }

      const data = await response.json();
      return { chartId, data };
    } catch (error) {
      return rejectWithValue({ chartId, error: error.message });
    }
  }
);

export const fetchRealTimeData = createAsyncThunk(
  "chart/fetchRealTimeData",
  async ({ chartId, timestamp }, { getState }) => {
    const state = getState();
    const chart = state.charts.charts[chartId];

    if (!chart || !chart.realTimeEnabled) {
      return null;
    }

    const response = await fetch(
      `/api/charts/${chartId}/realtime?since=${timestamp}`
    );
    const data = await response.json();

    return { chartId, data, timestamp: Date.now() };
  }
);

const chartSlice = createSlice({
  name: "charts",
  initialState: {
    charts: {},
    selectedChart: null,
    globalFilters: {},
    interactions: {
      zoom: {},
      selection: {},
      hover: {},
    },
    realTimeConnections: {},
    performance: {
      renderTimes: {},
      dataProcessingTimes: {},
    },
    customizations: {
      themes: {},
      layouts: {},
    },
    loading: {},
    errors: {},
  },
  reducers: {
    // Chart management
    createChart: (state, action) => {
      const { chartId, config } = action.payload;
      state.charts[chartId] = {
        id: chartId,
        type: config.type,
        data: [],
        config: {
          ...config,
          createdAt: Date.now(),
          updatedAt: Date.now(),
        },
        filters: {},
        interactions: {
          zoom: null,
          selection: null,
          hover: null,
        },
        realTimeEnabled: false,
        customizations: {},
        performance: {
          lastRenderTime: 0,
          dataPoints: 0,
        },
      };
    },

    updateChartConfig: (state, action) => {
      const { chartId, config } = action.payload;
      if (state.charts[chartId]) {
        state.charts[chartId].config = {
          ...state.charts[chartId].config,
          ...config,
          updatedAt: Date.now(),
        };
      }
    },

    deleteChart: (state, action) => {
      const { chartId } = action.payload;
      delete state.charts[chartId];
      delete state.loading[chartId];
      delete state.errors[chartId];
      delete state.realTimeConnections[chartId];

      if (state.selectedChart === chartId) {
        state.selectedChart = null;
      }
    },

    selectChart: (state, action) => {
      state.selectedChart = action.payload;
    },

    // Data management
    setChartData: (state, action) => {
      const { chartId, data, append = false } = action.payload;
      if (state.charts[chartId]) {
        if (append) {
          state.charts[chartId].data = [...state.charts[chartId].data, ...data];
        } else {
          state.charts[chartId].data = data;
        }
        state.charts[chartId].performance.dataPoints =
          state.charts[chartId].data.length;
      }
    },

    updateDataPoint: (state, action) => {
      const { chartId, index, data } = action.payload;
      if (state.charts[chartId] && state.charts[chartId].data[index]) {
        state.charts[chartId].data[index] = {
          ...state.charts[chartId].data[index],
          ...data,
        };
      }
    },

    // Filtering
    setChartFilter: (state, action) => {
      const { chartId, filterKey, filterValue } = action.payload;
      if (state.charts[chartId]) {
        state.charts[chartId].filters[filterKey] = filterValue;
      }
    },

    setGlobalFilter: (state, action) => {
      const { filterKey, filterValue } = action.payload;
      state.globalFilters[filterKey] = filterValue;
    },

    clearFilters: (state, action) => {
      const { chartId, global = false } = action.payload;

      if (global) {
        state.globalFilters = {};
      }

      if (chartId && state.charts[chartId]) {
        state.charts[chartId].filters = {};
      }
    },

    // Interactions
    setChartInteraction: (state, action) => {
      const { chartId, interactionType, data } = action.payload;
      if (state.charts[chartId]) {
        state.charts[chartId].interactions[interactionType] = data;
      }
    },

    setGlobalInteraction: (state, action) => {
      const { interactionType, data } = action.payload;
      state.interactions[interactionType] = data;
    },

    // Real-time management
    enableRealTime: (state, action) => {
      const { chartId, config } = action.payload;
      if (state.charts[chartId]) {
        state.charts[chartId].realTimeEnabled = true;
        state.realTimeConnections[chartId] = {
          ...config,
          lastUpdate: Date.now(),
          status: "connecting",
        };
      }
    },

    disableRealTime: (state, action) => {
      const { chartId } = action.payload;
      if (state.charts[chartId]) {
        state.charts[chartId].realTimeEnabled = false;
        delete state.realTimeConnections[chartId];
      }
    },

    updateRealTimeStatus: (state, action) => {
      const { chartId, status } = action.payload;
      if (state.realTimeConnections[chartId]) {
        state.realTimeConnections[chartId].status = status;
        state.realTimeConnections[chartId].lastUpdate = Date.now();
      }
    },

    // Customizations
    setChartCustomization: (state, action) => {
      const { chartId, customizationType, data } = action.payload;
      if (state.charts[chartId]) {
        state.charts[chartId].customizations[customizationType] = data;
      }
    },

    setGlobalCustomization: (state, action) => {
      const { customizationType, data } = action.payload;
      state.customizations[customizationType] = data;
    },

    // Performance tracking
    recordRenderTime: (state, action) => {
      const { chartId, renderTime } = action.payload;
      if (state.charts[chartId]) {
        state.charts[chartId].performance.lastRenderTime = renderTime;
      }
      state.performance.renderTimes[chartId] = renderTime;
    },

    recordDataProcessingTime: (state, action) => {
      const { chartId, processingTime } = action.payload;
      state.performance.dataProcessingTimes[chartId] = processingTime;
    },
  },
  extraReducers: (builder) => {
    builder
      // Fetch chart data
      .addCase(fetchChartData.pending, (state, action) => {
        const { chartId } = action.meta.arg;
        state.loading[chartId] = true;
        delete state.errors[chartId];
      })
      .addCase(fetchChartData.fulfilled, (state, action) => {
        const { chartId, data } = action.payload;
        state.loading[chartId] = false;

        if (state.charts[chartId]) {
          state.charts[chartId].data = data;
          state.charts[chartId].performance.dataPoints = data.length;
        }
      })
      .addCase(fetchChartData.rejected, (state, action) => {
        const { chartId, error } = action.payload;
        state.loading[chartId] = false;
        state.errors[chartId] = error;
      })

      // Real-time data updates
      .addCase(fetchRealTimeData.fulfilled, (state, action) => {
        if (action.payload) {
          const { chartId, data, timestamp } = action.payload;

          if (state.charts[chartId] && state.charts[chartId].realTimeEnabled) {
            // Append new data points
            state.charts[chartId].data = [
              ...state.charts[chartId].data,
              ...data,
            ];

            // Update connection status
            if (state.realTimeConnections[chartId]) {
              state.realTimeConnections[chartId].lastUpdate = timestamp;
              state.realTimeConnections[chartId].status = "connected";
            }
          }
        }
      });
  },
});

export const {
  createChart,
  updateChartConfig,
  deleteChart,
  selectChart,
  setChartData,
  updateDataPoint,
  setChartFilter,
  setGlobalFilter,
  clearFilters,
  setChartInteraction,
  setGlobalInteraction,
  enableRealTime,
  disableRealTime,
  updateRealTimeStatus,
  setChartCustomization,
  setGlobalCustomization,
  recordRenderTime,
  recordDataProcessingTime,
} = chartSlice.actions;

// Selectors
export const selectChart = (state, chartId) => state.charts.charts[chartId];
export const selectChartData = (state, chartId) => {
  const chart = state.charts.charts[chartId];
  if (!chart) return [];

  let data = chart.data;

  // Apply chart-specific filters
  Object.entries(chart.filters).forEach(([key, value]) => {
    if (value !== null && value !== undefined) {
      data = data.filter((item) => item[key] === value);
    }
  });

  // Apply global filters
  Object.entries(state.charts.globalFilters).forEach(([key, value]) => {
    if (value !== null && value !== undefined) {
      data = data.filter((item) => item[key] === value);
    }
  });

  return data;
};

export const selectChartPerformance = (state, chartId) => {
  const chart = state.charts.charts[chartId];
  return chart ? chart.performance : null;
};

export default chartSlice.reducer;
```

```jsx
// components/AdvancedChart.jsx
import React, { useEffect, useRef, useCallback } from "react";
import { useSelector, useDispatch } from "react-redux";
import * as d3 from "d3";
import {
  fetchChartData,
  setChartInteraction,
  recordRenderTime,
  enableRealTime,
  disableRealTime,
  selectChart,
  selectChartData,
} from "../store/chartSlice";

const AdvancedChart = ({ chartId, width = 800, height = 400 }) => {
  const dispatch = useDispatch();
  const svgRef = useRef();
  const chart = useSelector((state) => selectChart(state, chartId));
  const chartData = useSelector((state) => selectChartData(state, chartId));
  const isLoading = useSelector((state) => state.charts.loading[chartId]);

  // Fetch initial data
  useEffect(() => {
    if (chart && !chart.data.length) {
      dispatch(
        fetchChartData({
          chartId,
          params: chart.config.dataParams || {},
        })
      );
    }
  }, [dispatch, chartId, chart]);

  // Real-time data updates
  useEffect(() => {
    if (chart?.realTimeEnabled) {
      const interval = setInterval(() => {
        dispatch(
          fetchRealTimeData({
            chartId,
            timestamp: Date.now(),
          })
        );
      }, chart.config.realTimeInterval || 5000);

      return () => clearInterval(interval);
    }
  }, [
    dispatch,
    chartId,
    chart?.realTimeEnabled,
    chart?.config.realTimeInterval,
  ]);

  // Chart rendering
  const renderChart = useCallback(() => {
    if (!chartData.length || !svgRef.current) return;

    const startTime = performance.now();

    const svg = d3.select(svgRef.current);
    svg.selectAll("*").remove();

    const margin = { top: 20, right: 30, bottom: 40, left: 40 };
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;

    const g = svg
      .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    // Scales
    const xScale = d3
      .scaleTime()
      .domain(d3.extent(chartData, (d) => new Date(d.timestamp)))
      .range([0, innerWidth]);

    const yScale = d3
      .scaleLinear()
      .domain(d3.extent(chartData, (d) => d.value))
      .nice()
      .range([innerHeight, 0]);

    // Line generator
    const line = d3
      .line()
      .x((d) => xScale(new Date(d.timestamp)))
      .y((d) => yScale(d.value))
      .curve(d3.curveMonotoneX);

    // Add axes
    g.append("g")
      .attr("transform", `translate(0,${innerHeight})`)
      .call(d3.axisBottom(xScale));

    g.append("g").call(d3.axisLeft(yScale));

    // Add line
    g.append("path")
      .datum(chartData)
      .attr("fill", "none")
      .attr("stroke", chart.config.color || "steelblue")
      .attr("stroke-width", 2)
      .attr("d", line);

    // Add interactive dots
    g.selectAll(".dot")
      .data(chartData)
      .enter()
      .append("circle")
      .attr("class", "dot")
      .attr("cx", (d) => xScale(new Date(d.timestamp)))
      .attr("cy", (d) => yScale(d.value))
      .attr("r", 4)
      .attr("fill", chart.config.color || "steelblue")
      .on("mouseover", (event, d) => {
        dispatch(
          setChartInteraction({
            chartId,
            interactionType: "hover",
            data: {
              point: d,
              position: { x: event.offsetX, y: event.offsetY },
            },
          })
        );
      })
      .on("mouseout", () => {
        dispatch(
          setChartInteraction({
            chartId,
            interactionType: "hover",
            data: null,
          })
        );
      });

    // Zoom behavior
    const zoom = d3
      .zoom()
      .scaleExtent([1, 10])
      .on("zoom", (event) => {
        const { transform } = event;

        // Update scales
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Update axes
        g.select(".x-axis").call(d3.axisBottom(newXScale));
        g.select(".y-axis").call(d3.axisLeft(newYScale));

        // Update line
        const newLine = d3
          .line()
          .x((d) => newXScale(new Date(d.timestamp)))
          .y((d) => newYScale(d.value))
          .curve(d3.curveMonotoneX);

        g.select("path").attr("d", newLine);

        // Update dots
        g.selectAll(".dot")
          .attr("cx", (d) => newXScale(new Date(d.timestamp)))
          .attr("cy", (d) => newYScale(d.value));

        // Store zoom state
        dispatch(
          setChartInteraction({
            chartId,
            interactionType: "zoom",
            data: {
              transform: { k: transform.k, x: transform.x, y: transform.y },
            },
          })
        );
      });

    svg.call(zoom);

    // Record render time
    const renderTime = performance.now() - startTime;
    dispatch(recordRenderTime({ chartId, renderTime }));
  }, [chartData, chart, chartId, dispatch, width, height]);

  // Re-render when data changes
  useEffect(() => {
    renderChart();
  }, [renderChart]);

  const handleToggleRealTime = () => {
    if (chart.realTimeEnabled) {
      dispatch(disableRealTime({ chartId }));
    } else {
      dispatch(
        enableRealTime({
          chartId,
          config: { interval: 5000 },
        })
      );
    }
  };

  if (isLoading) {
    return <div className="chart-loading">Loading chart data...</div>;
  }

  return (
    <div className="advanced-chart">
      <div className="chart-controls">
        <button onClick={handleToggleRealTime}>
          {chart?.realTimeEnabled ? "Disable" : "Enable"} Real-time
        </button>
        <span className="data-points">Data Points: {chartData.length}</span>
      </div>

      <svg ref={svgRef} width={width} height={height} className="chart-svg" />

      {chart?.interactions.hover && (
        <div
          className="chart-tooltip"
          style={{
            position: "absolute",
            left: chart.interactions.hover.position.x,
            top: chart.interactions.hover.position.y,
            background: "rgba(0,0,0,0.8)",
            color: "white",
            padding: "8px",
            borderRadius: "4px",
            pointerEvents: "none",
          }}
        >
          <div>Value: {chart.interactions.hover.point.value}</div>
          <div>
            Time:{" "}
            {new Date(
              chart.interactions.hover.point.timestamp
            ).toLocaleString()}
          </div>
        </div>
      )}
    </div>
  );
};

export default AdvancedChart;
```

#### Zustand Implementation for Data Visualization

```javascript
// stores/chartStore.js
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";
import { persist } from "zustand/middleware";

const useChartStore = create(
  subscribeWithSelector(
    persist(
      immer((set, get) => ({
        // State
        charts: {},
        selectedChart: null,
        globalFilters: {},
        interactions: {
          zoom: {},
          selection: {},
          hover: {},
        },
        realTimeConnections: {},
        performance: {
          renderTimes: {},
          dataProcessingTimes: {},
        },
        customizations: {
          themes: {},
          layouts: {},
        },
        loading: {},
        errors: {},

        // Actions
        createChart: (chartId, config) => {
          set((state) => {
            state.charts[chartId] = {
              id: chartId,
              type: config.type,
              data: [],
              config: {
                ...config,
                createdAt: Date.now(),
                updatedAt: Date.now(),
              },
              filters: {},
              interactions: {
                zoom: null,
                selection: null,
                hover: null,
              },
              realTimeEnabled: false,
              customizations: {},
              performance: {
                lastRenderTime: 0,
                dataPoints: 0,
              },
            };
          });
        },

        updateChartConfig: (chartId, config) => {
          set((state) => {
            if (state.charts[chartId]) {
              state.charts[chartId].config = {
                ...state.charts[chartId].config,
                ...config,
                updatedAt: Date.now(),
              };
            }
          });
        },

        deleteChart: (chartId) => {
          set((state) => {
            delete state.charts[chartId];
            delete state.loading[chartId];
            delete state.errors[chartId];
            delete state.realTimeConnections[chartId];

            if (state.selectedChart === chartId) {
              state.selectedChart = null;
            }
          });
        },

        selectChart: (chartId) => {
          set((state) => {
            state.selectedChart = chartId;
          });
        },

        setChartData: (chartId, data, append = false) => {
          set((state) => {
            if (state.charts[chartId]) {
              if (append) {
                state.charts[chartId].data = [
                  ...state.charts[chartId].data,
                  ...data,
                ];
              } else {
                state.charts[chartId].data = data;
              }
              state.charts[chartId].performance.dataPoints =
                state.charts[chartId].data.length;
            }
          });
        },

        fetchChartData: async (chartId, params) => {
          set((state) => {
            state.loading[chartId] = true;
            delete state.errors[chartId];
          });

          try {
            const response = await fetch(`/api/charts/${chartId}/data`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(params),
            });

            if (!response.ok) {
              throw new Error("Failed to fetch chart data");
            }

            const data = await response.json();

            set((state) => {
              state.loading[chartId] = false;
              if (state.charts[chartId]) {
                state.charts[chartId].data = data;
                state.charts[chartId].performance.dataPoints = data.length;
              }
            });

            return data;
          } catch (error) {
            set((state) => {
              state.loading[chartId] = false;
              state.errors[chartId] = error.message;
            });
            throw error;
          }
        },

        setChartFilter: (chartId, filterKey, filterValue) => {
          set((state) => {
            if (state.charts[chartId]) {
              state.charts[chartId].filters[filterKey] = filterValue;
            }
          });
        },

        setGlobalFilter: (filterKey, filterValue) => {
          set((state) => {
            state.globalFilters[filterKey] = filterValue;
          });
        },

        setChartInteraction: (chartId, interactionType, data) => {
          set((state) => {
            if (state.charts[chartId]) {
              state.charts[chartId].interactions[interactionType] = data;
            }
          });
        },

        enableRealTime: (chartId, config) => {
          set((state) => {
            if (state.charts[chartId]) {
              state.charts[chartId].realTimeEnabled = true;
              state.realTimeConnections[chartId] = {
                ...config,
                lastUpdate: Date.now(),
                status: "connecting",
              };
            }
          });

          // Start real-time updates
          get().startRealTimeUpdates(chartId);
        },

        disableRealTime: (chartId) => {
          set((state) => {
            if (state.charts[chartId]) {
              state.charts[chartId].realTimeEnabled = false;
              delete state.realTimeConnections[chartId];
            }
          });

          // Stop real-time updates
          get().stopRealTimeUpdates(chartId);
        },

        startRealTimeUpdates: (chartId) => {
          const chart = get().charts[chartId];
          if (!chart || !chart.realTimeEnabled) return;

          const interval = setInterval(async () => {
            try {
              const response = await fetch(
                `/api/charts/${chartId}/realtime?since=${Date.now()}`
              );
              const data = await response.json();

              if (data.length > 0) {
                get().setChartData(chartId, data, true);

                set((state) => {
                  if (state.realTimeConnections[chartId]) {
                    state.realTimeConnections[chartId].lastUpdate = Date.now();
                    state.realTimeConnections[chartId].status = "connected";
                  }
                });
              }
            } catch (error) {
              set((state) => {
                if (state.realTimeConnections[chartId]) {
                  state.realTimeConnections[chartId].status = "error";
                }
              });
            }
          }, chart.config.realTimeInterval || 5000);

          // Store interval ID for cleanup
          set((state) => {
            if (state.realTimeConnections[chartId]) {
              state.realTimeConnections[chartId].intervalId = interval;
            }
          });
        },

        stopRealTimeUpdates: (chartId) => {
          const connection = get().realTimeConnections[chartId];
          if (connection && connection.intervalId) {
            clearInterval(connection.intervalId);
          }
        },

        recordRenderTime: (chartId, renderTime) => {
          set((state) => {
            if (state.charts[chartId]) {
              state.charts[chartId].performance.lastRenderTime = renderTime;
            }
            state.performance.renderTimes[chartId] = renderTime;
          });
        },

        // Computed selectors
        getFilteredChartData: (chartId) => {
          const { charts, globalFilters } = get();
          const chart = charts[chartId];

          if (!chart) return [];

          let data = chart.data;

          // Apply chart-specific filters
          Object.entries(chart.filters).forEach(([key, value]) => {
            if (value !== null && value !== undefined) {
              data = data.filter((item) => item[key] === value);
            }
          });

          // Apply global filters
          Object.entries(globalFilters).forEach(([key, value]) => {
            if (value !== null && value !== undefined) {
              data = data.filter((item) => item[key] === value);
            }
          });

          return data;
        },

        getChartPerformance: (chartId) => {
          const chart = get().charts[chartId];
          return chart ? chart.performance : null;
        },
      })),
      {
        name: "chart-storage",
        partialize: (state) => ({
          charts: state.charts,
          globalFilters: state.globalFilters,
          customizations: state.customizations,
        }),
      }
    )
  )
);

export default useChartStore;
```

```jsx
// components/ZustandAdvancedChart.jsx
import React, { useEffect, useRef, useCallback } from "react";
import * as d3 from "d3";
import useChartStore from "../stores/chartStore";

const ZustandAdvancedChart = ({ chartId, width = 800, height = 400 }) => {
  const svgRef = useRef();

  const {
    charts,
    loading,
    fetchChartData,
    setChartInteraction,
    recordRenderTime,
    enableRealTime,
    disableRealTime,
    getFilteredChartData,
  } = useChartStore();

  const chart = charts[chartId];
  const chartData = getFilteredChartData(chartId);
  const isLoading = loading[chartId];

  // Fetch initial data
  useEffect(() => {
    if (chart && !chart.data.length) {
      fetchChartData(chartId, chart.config.dataParams || {});
    }
  }, [fetchChartData, chartId, chart]);

  // Chart rendering
  const renderChart = useCallback(() => {
    if (!chartData.length || !svgRef.current) return;

    const startTime = performance.now();

    const svg = d3.select(svgRef.current);
    svg.selectAll("*").remove();

    const margin = { top: 20, right: 30, bottom: 40, left: 40 };
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;

    const g = svg
      .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    // Scales
    const xScale = d3
      .scaleTime()
      .domain(d3.extent(chartData, (d) => new Date(d.timestamp)))
      .range([0, innerWidth]);

    const yScale = d3
      .scaleLinear()
      .domain(d3.extent(chartData, (d) => d.value))
      .nice()
      .range([innerHeight, 0]);

    // Line generator
    const line = d3
      .line()
      .x((d) => xScale(new Date(d.timestamp)))
      .y((d) => yScale(d.value))
      .curve(d3.curveMonotoneX);

    // Add axes
    g.append("g")
      .attr("transform", `translate(0,${innerHeight})`)
      .call(d3.axisBottom(xScale));

    g.append("g").call(d3.axisLeft(yScale));

    // Add line
    g.append("path")
      .datum(chartData)
      .attr("fill", "none")
      .attr("stroke", chart.config.color || "steelblue")
      .attr("stroke-width", 2)
      .attr("d", line);

    // Add interactive dots
    g.selectAll(".dot")
      .data(chartData)
      .enter()
      .append("circle")
      .attr("class", "dot")
      .attr("cx", (d) => xScale(new Date(d.timestamp)))
      .attr("cy", (d) => yScale(d.value))
      .attr("r", 4)
      .attr("fill", chart.config.color || "steelblue")
      .on("mouseover", (event, d) => {
        setChartInteraction(chartId, "hover", {
          point: d,
          position: { x: event.offsetX, y: event.offsetY },
        });
      })
      .on("mouseout", () => {
        setChartInteraction(chartId, "hover", null);
      });

    // Record render time
    const renderTime = performance.now() - startTime;
    recordRenderTime(chartId, renderTime);
  }, [
    chartData,
    chart,
    chartId,
    setChartInteraction,
    recordRenderTime,
    width,
    height,
  ]);

  // Re-render when data changes
  useEffect(() => {
    renderChart();
  }, [renderChart]);

  const handleToggleRealTime = () => {
    if (chart.realTimeEnabled) {
      disableRealTime(chartId);
    } else {
      enableRealTime(chartId, { interval: 5000 });
    }
  };

  if (isLoading) {
    return <div className="chart-loading">Loading chart data...</div>;
  }

  return (
    <div className="advanced-chart">
      <div className="chart-controls">
        <button onClick={handleToggleRealTime}>
          {chart?.realTimeEnabled ? "Disable" : "Enable"} Real-time
        </button>
        <span className="data-points">Data Points: {chartData.length}</span>
      </div>

      <svg ref={svgRef} width={width} height={height} className="chart-svg" />

      {chart?.interactions.hover && (
        <div
          className="chart-tooltip"
          style={{
            position: "absolute",
            left: chart.interactions.hover.position.x,
            top: chart.interactions.hover.position.y,
            background: "rgba(0,0,0,0.8)",
            color: "white",
            padding: "8px",
            borderRadius: "4px",
            pointerEvents: "none",
          }}
        >
          <div>Value: {chart.interactions.hover.point.value}</div>
          <div>
            Time:{" "}
            {new Date(
              chart.interactions.hover.point.timestamp
            ).toLocaleString()}
          </div>
        </div>
      )}
    </div>
  );
};

export default ZustandAdvancedChart;
```

#### Best Practices

1. **Performance Optimization**:

   - Use virtualization for large datasets
   - Implement data sampling for real-time updates
   - Debounce interaction events
   - Use memoization for expensive calculations

2. **Real-time Data Management**:

   - Implement proper connection management
   - Handle network failures gracefully
   - Use WebSockets for efficient real-time updates
   - Implement data buffering strategies

3. **User Experience**:

   - Provide loading states and error handling
   - Implement smooth transitions and animations
   - Support keyboard navigation and accessibility
   - Offer customization options

4. **Data Processing**:
   - Implement efficient filtering and aggregation
   - Use web workers for heavy computations
   - Cache processed data when appropriate
   - Support multiple data formats

**Comparison Summary:**

| Feature              | Redux        | Zustand      |
| -------------------- | ------------ | ------------ |
| Setup Complexity     | High         | Medium       |
| Real-time Updates    | RTK Thunks   | Custom Async |
| Data Processing      | Structured   | Flexible     |
| Performance Tracking | Built-in     | Custom       |
| Filtering            | Selectors    | Computed     |
| Interactions         | Action-based | Direct       |
| DevTools             | Excellent    | Basic        |
| Bundle Size          | Larger       | Smaller      |

---

### 43. How do you implement advanced caching strategies and cache invalidation in Redux vs Zustand?

**Answer:**

Advanced caching strategies are crucial for optimizing application performance, reducing network requests, and providing better user experiences. Both Redux and Zustand can implement sophisticated caching mechanisms with different approaches.

#### Redux Implementation for Advanced Caching

```javascript
// store/cacheSlice.js
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

// Cache configuration
const CACHE_CONFIG = {
  DEFAULT_TTL: 5 * 60 * 1000, // 5 minutes
  MAX_CACHE_SIZE: 100,
  STALE_WHILE_REVALIDATE: true,
};

// Async thunks for data fetching with caching
export const fetchWithCache = createAsyncThunk(
  "cache/fetchWithCache",
  async ({ key, url, options = {} }, { getState, rejectWithValue }) => {
    const state = getState();
    const cacheEntry = state.cache.entries[key];
    const now = Date.now();

    // Check if cache is valid
    if (cacheEntry && !isCacheExpired(cacheEntry, now)) {
      // Return cached data immediately
      return {
        key,
        data: cacheEntry.data,
        fromCache: true,
        timestamp: cacheEntry.timestamp,
      };
    }

    // Check if stale-while-revalidate is enabled and we have stale data
    if (CACHE_CONFIG.STALE_WHILE_REVALIDATE && cacheEntry) {
      // Return stale data immediately and fetch fresh data in background
      setTimeout(() => {
        fetchFreshData(key, url, options);
      }, 0);

      return {
        key,
        data: cacheEntry.data,
        fromCache: true,
        stale: true,
        timestamp: cacheEntry.timestamp,
      };
    }

    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          "Content-Type": "application/json",
          ...options.headers,
        },
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();

      return {
        key,
        data,
        fromCache: false,
        timestamp: now,
        etag: response.headers.get("etag"),
        lastModified: response.headers.get("last-modified"),
      };
    } catch (error) {
      // If we have stale data, return it as fallback
      if (cacheEntry) {
        return {
          key,
          data: cacheEntry.data,
          fromCache: true,
          stale: true,
          error: error.message,
          timestamp: cacheEntry.timestamp,
        };
      }

      return rejectWithValue({ key, error: error.message });
    }
  }
);

export const invalidateCache = createAsyncThunk(
  "cache/invalidateCache",
  async ({ keys, pattern }, { getState }) => {
    const state = getState();
    const keysToInvalidate = [];

    if (keys) {
      keysToInvalidate.push(...keys);
    }

    if (pattern) {
      const regex = new RegExp(pattern);
      Object.keys(state.cache.entries).forEach((key) => {
        if (regex.test(key)) {
          keysToInvalidate.push(key);
        }
      });
    }

    return { keys: keysToInvalidate, timestamp: Date.now() };
  }
);

// Helper functions
const isCacheExpired = (cacheEntry, now) => {
  const ttl = cacheEntry.ttl || CACHE_CONFIG.DEFAULT_TTL;
  return now - cacheEntry.timestamp > ttl;
};

const fetchFreshData = async (key, url, options) => {
  try {
    const response = await fetch(url, options);
    const data = await response.json();

    // Dispatch action to update cache with fresh data
    store.dispatch(
      updateCacheEntry({
        key,
        data,
        timestamp: Date.now(),
        etag: response.headers.get("etag"),
        lastModified: response.headers.get("last-modified"),
      })
    );
  } catch (error) {
    console.warn(`Failed to fetch fresh data for ${key}:`, error);
  }
};

const cacheSlice = createSlice({
  name: "cache",
  initialState: {
    entries: {},
    metadata: {
      totalSize: 0,
      hitRate: 0,
      missRate: 0,
      totalRequests: 0,
      cacheHits: 0,
    },
    invalidationRules: {},
    loading: {},
    errors: {},
  },
  reducers: {
    setCacheEntry: (state, action) => {
      const { key, data, ttl, tags = [], dependencies = [] } = action.payload;
      const timestamp = Date.now();

      // Remove oldest entries if cache is full
      if (Object.keys(state.entries).length >= CACHE_CONFIG.MAX_CACHE_SIZE) {
        const oldestKey = Object.keys(state.entries).sort(
          (a, b) =>
            state.entries[a].lastAccessed - state.entries[b].lastAccessed
        )[0];
        delete state.entries[oldestKey];
      }

      state.entries[key] = {
        data,
        timestamp,
        lastAccessed: timestamp,
        ttl: ttl || CACHE_CONFIG.DEFAULT_TTL,
        tags,
        dependencies,
        accessCount: 1,
        size: JSON.stringify(data).length,
      };

      state.metadata.totalSize += state.entries[key].size;
    },

    updateCacheEntry: (state, action) => {
      const { key, data, etag, lastModified } = action.payload;

      if (state.entries[key]) {
        state.entries[key] = {
          ...state.entries[key],
          data,
          timestamp: Date.now(),
          lastAccessed: Date.now(),
          etag,
          lastModified,
          accessCount: state.entries[key].accessCount + 1,
        };
      }
    },

    accessCacheEntry: (state, action) => {
      const { key } = action.payload;

      if (state.entries[key]) {
        state.entries[key].lastAccessed = Date.now();
        state.entries[key].accessCount += 1;

        // Update hit rate
        state.metadata.totalRequests += 1;
        state.metadata.cacheHits += 1;
        state.metadata.hitRate =
          state.metadata.cacheHits / state.metadata.totalRequests;
      } else {
        // Cache miss
        state.metadata.totalRequests += 1;
        state.metadata.missRate =
          1 - state.metadata.cacheHits / state.metadata.totalRequests;
      }
    },

    removeCacheEntry: (state, action) => {
      const { key } = action.payload;

      if (state.entries[key]) {
        state.metadata.totalSize -= state.entries[key].size;
        delete state.entries[key];
      }
    },

    clearCache: (state) => {
      state.entries = {};
      state.metadata.totalSize = 0;
    },

    setInvalidationRule: (state, action) => {
      const { name, pattern, dependencies, ttl } = action.payload;

      state.invalidationRules[name] = {
        pattern,
        dependencies,
        ttl,
        createdAt: Date.now(),
      };
    },

    removeInvalidationRule: (state, action) => {
      const { name } = action.payload;
      delete state.invalidationRules[name];
    },

    invalidateByTags: (state, action) => {
      const { tags } = action.payload;
      const keysToRemove = [];

      Object.entries(state.entries).forEach(([key, entry]) => {
        if (entry.tags && entry.tags.some((tag) => tags.includes(tag))) {
          keysToRemove.push(key);
        }
      });

      keysToRemove.forEach((key) => {
        state.metadata.totalSize -= state.entries[key].size;
        delete state.entries[key];
      });
    },

    invalidateByDependencies: (state, action) => {
      const { dependencies } = action.payload;
      const keysToRemove = [];

      Object.entries(state.entries).forEach(([key, entry]) => {
        if (
          entry.dependencies &&
          entry.dependencies.some((dep) => dependencies.includes(dep))
        ) {
          keysToRemove.push(key);
        }
      });

      keysToRemove.forEach((key) => {
        state.metadata.totalSize -= state.entries[key].size;
        delete state.entries[key];
      });
    },

    cleanupExpiredEntries: (state) => {
      const now = Date.now();
      const keysToRemove = [];

      Object.entries(state.entries).forEach(([key, entry]) => {
        if (isCacheExpired(entry, now)) {
          keysToRemove.push(key);
        }
      });

      keysToRemove.forEach((key) => {
        state.metadata.totalSize -= state.entries[key].size;
        delete state.entries[key];
      });
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchWithCache.pending, (state, action) => {
        const { key } = action.meta.arg;
        state.loading[key] = true;
        delete state.errors[key];
      })
      .addCase(fetchWithCache.fulfilled, (state, action) => {
        const { key, data, fromCache, timestamp, etag, lastModified } =
          action.payload;
        state.loading[key] = false;

        if (!fromCache) {
          // Store new data in cache
          state.entries[key] = {
            data,
            timestamp,
            lastAccessed: timestamp,
            ttl: CACHE_CONFIG.DEFAULT_TTL,
            tags: [],
            dependencies: [],
            accessCount: 1,
            size: JSON.stringify(data).length,
            etag,
            lastModified,
          };

          state.metadata.totalSize += state.entries[key].size;
        } else {
          // Update access statistics
          if (state.entries[key]) {
            state.entries[key].lastAccessed = Date.now();
            state.entries[key].accessCount += 1;
          }
        }

        // Update cache statistics
        state.metadata.totalRequests += 1;
        if (fromCache) {
          state.metadata.cacheHits += 1;
        }
        state.metadata.hitRate =
          state.metadata.cacheHits / state.metadata.totalRequests;
        state.metadata.missRate = 1 - state.metadata.hitRate;
      })
      .addCase(fetchWithCache.rejected, (state, action) => {
        const { key, error } = action.payload;
        state.loading[key] = false;
        state.errors[key] = error;
      })
      .addCase(invalidateCache.fulfilled, (state, action) => {
        const { keys } = action.payload;

        keys.forEach((key) => {
          if (state.entries[key]) {
            state.metadata.totalSize -= state.entries[key].size;
            delete state.entries[key];
          }
        });
      });
  },
});

export const {
  setCacheEntry,
  updateCacheEntry,
  accessCacheEntry,
  removeCacheEntry,
  clearCache,
  setInvalidationRule,
  removeInvalidationRule,
  invalidateByTags,
  invalidateByDependencies,
  cleanupExpiredEntries,
} = cacheSlice.actions;

// Selectors
export const selectCacheEntry = (state, key) => {
  const entry = state.cache.entries[key];
  if (!entry) return null;

  const now = Date.now();
  if (isCacheExpired(entry, now)) {
    return null;
  }

  return entry;
};

export const selectCacheMetadata = (state) => state.cache.metadata;
export const selectCacheSize = (state) =>
  Object.keys(state.cache.entries).length;

export default cacheSlice.reducer;
```

```jsx
// hooks/useAdvancedCache.js
import { useSelector, useDispatch } from "react-redux";
import { useCallback, useEffect } from "react";
import {
  fetchWithCache,
  invalidateCache,
  setCacheEntry,
  invalidateByTags,
  cleanupExpiredEntries,
  selectCacheEntry,
} from "../store/cacheSlice";

export const useAdvancedCache = () => {
  const dispatch = useDispatch();

  // Cleanup expired entries periodically
  useEffect(() => {
    const interval = setInterval(() => {
      dispatch(cleanupExpiredEntries());
    }, 60000); // Every minute

    return () => clearInterval(interval);
  }, [dispatch]);

  const fetchData = useCallback(
    async (key, url, options = {}) => {
      const result = await dispatch(fetchWithCache({ key, url, options }));
      return result.payload;
    },
    [dispatch]
  );

  const invalidate = useCallback(
    (keys, pattern) => {
      return dispatch(invalidateCache({ keys, pattern }));
    },
    [dispatch]
  );

  const invalidateByTag = useCallback(
    (tags) => {
      return dispatch(invalidateByTags({ tags }));
    },
    [dispatch]
  );

  const setCache = useCallback(
    (key, data, options = {}) => {
      return dispatch(setCacheEntry({ key, data, ...options }));
    },
    [dispatch]
  );

  const getCacheEntry = useCallback((key) => {
    return useSelector((state) => selectCacheEntry(state, key));
  }, []);

  return {
    fetchData,
    invalidate,
    invalidateByTag,
    setCache,
    getCacheEntry,
  };
};

// Higher-order component for automatic caching
export const withCache = (WrappedComponent, cacheConfig = {}) => {
  return function CachedComponent(props) {
    const { fetchData, getCacheEntry } = useAdvancedCache();
    const { cacheKey, url, ...restProps } = props;

    const cachedData = getCacheEntry(cacheKey);

    useEffect(() => {
      if (!cachedData && url) {
        fetchData(cacheKey, url, cacheConfig);
      }
    }, [cacheKey, url, cachedData, fetchData]);

    return (
      <WrappedComponent
        {...restProps}
        data={cachedData?.data}
        loading={!cachedData}
        fromCache={cachedData?.fromCache}
      />
    );
  };
};
```

#### Zustand Implementation for Advanced Caching

```javascript
// stores/cacheStore.js
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";
import { persist } from "zustand/middleware";

const CACHE_CONFIG = {
  DEFAULT_TTL: 5 * 60 * 1000, // 5 minutes
  MAX_CACHE_SIZE: 100,
  STALE_WHILE_REVALIDATE: true,
};

const useCacheStore = create(
  subscribeWithSelector(
    persist(
      immer((set, get) => ({
        // State
        entries: {},
        metadata: {
          totalSize: 0,
          hitRate: 0,
          missRate: 0,
          totalRequests: 0,
          cacheHits: 0,
        },
        invalidationRules: {},
        loading: {},
        errors: {},

        // Actions
        fetchWithCache: async (key, url, options = {}) => {
          const state = get();
          const cacheEntry = state.entries[key];
          const now = Date.now();

          // Update loading state
          set((draft) => {
            draft.loading[key] = true;
            delete draft.errors[key];
          });

          // Check if cache is valid
          if (cacheEntry && !get().isCacheExpired(cacheEntry, now)) {
            set((draft) => {
              draft.loading[key] = false;
              draft.metadata.totalRequests += 1;
              draft.metadata.cacheHits += 1;
              draft.metadata.hitRate =
                draft.metadata.cacheHits / draft.metadata.totalRequests;

              if (draft.entries[key]) {
                draft.entries[key].lastAccessed = now;
                draft.entries[key].accessCount += 1;
              }
            });

            return {
              key,
              data: cacheEntry.data,
              fromCache: true,
              timestamp: cacheEntry.timestamp,
            };
          }

          // Check stale-while-revalidate
          if (CACHE_CONFIG.STALE_WHILE_REVALIDATE && cacheEntry) {
            // Return stale data and fetch fresh in background
            setTimeout(() => {
              get().fetchFreshData(key, url, options);
            }, 0);

            set((draft) => {
              draft.loading[key] = false;
            });

            return {
              key,
              data: cacheEntry.data,
              fromCache: true,
              stale: true,
              timestamp: cacheEntry.timestamp,
            };
          }

          try {
            const response = await fetch(url, {
              ...options,
              headers: {
                "Content-Type": "application/json",
                ...options.headers,
              },
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            const etag = response.headers.get("etag");
            const lastModified = response.headers.get("last-modified");

            // Update cache
            set((draft) => {
              draft.loading[key] = false;

              // Remove oldest entries if cache is full
              if (
                Object.keys(draft.entries).length >= CACHE_CONFIG.MAX_CACHE_SIZE
              ) {
                const oldestKey = Object.keys(draft.entries).sort(
                  (a, b) =>
                    draft.entries[a].lastAccessed -
                    draft.entries[b].lastAccessed
                )[0];
                draft.metadata.totalSize -= draft.entries[oldestKey].size;
                delete draft.entries[oldestKey];
              }

              const size = JSON.stringify(data).length;
              draft.entries[key] = {
                data,
                timestamp: now,
                lastAccessed: now,
                ttl: CACHE_CONFIG.DEFAULT_TTL,
                tags: [],
                dependencies: [],
                accessCount: 1,
                size,
                etag,
                lastModified,
              };

              draft.metadata.totalSize += size;
              draft.metadata.totalRequests += 1;
              draft.metadata.hitRate =
                draft.metadata.cacheHits / draft.metadata.totalRequests;
              draft.metadata.missRate = 1 - draft.metadata.hitRate;
            });

            return {
              key,
              data,
              fromCache: false,
              timestamp: now,
              etag,
              lastModified,
            };
          } catch (error) {
            // If we have stale data, return it as fallback
            if (cacheEntry) {
              set((draft) => {
                draft.loading[key] = false;
              });

              return {
                key,
                data: cacheEntry.data,
                fromCache: true,
                stale: true,
                error: error.message,
                timestamp: cacheEntry.timestamp,
              };
            }

            set((draft) => {
              draft.loading[key] = false;
              draft.errors[key] = error.message;
            });

            throw error;
          }
        },

        fetchFreshData: async (key, url, options) => {
          try {
            const response = await fetch(url, options);
            const data = await response.json();
            const etag = response.headers.get("etag");
            const lastModified = response.headers.get("last-modified");

            set((draft) => {
              if (draft.entries[key]) {
                draft.entries[key] = {
                  ...draft.entries[key],
                  data,
                  timestamp: Date.now(),
                  lastAccessed: Date.now(),
                  etag,
                  lastModified,
                  accessCount: draft.entries[key].accessCount + 1,
                };
              }
            });
          } catch (error) {
            console.warn(`Failed to fetch fresh data for ${key}:`, error);
          }
        },

        setCacheEntry: (key, data, options = {}) => {
          const { ttl, tags = [], dependencies = [] } = options;
          const timestamp = Date.now();

          set((draft) => {
            // Remove oldest entries if cache is full
            if (
              Object.keys(draft.entries).length >= CACHE_CONFIG.MAX_CACHE_SIZE
            ) {
              const oldestKey = Object.keys(draft.entries).sort(
                (a, b) =>
                  draft.entries[a].lastAccessed - draft.entries[b].lastAccessed
              )[0];
              draft.metadata.totalSize -= draft.entries[oldestKey].size;
              delete draft.entries[oldestKey];
            }

            const size = JSON.stringify(data).length;
            draft.entries[key] = {
              data,
              timestamp,
              lastAccessed: timestamp,
              ttl: ttl || CACHE_CONFIG.DEFAULT_TTL,
              tags,
              dependencies,
              accessCount: 1,
              size,
            };

            draft.metadata.totalSize += size;
          });
        },

        invalidateCache: (keys, pattern) => {
          const keysToInvalidate = [];

          if (keys) {
            keysToInvalidate.push(...keys);
          }

          if (pattern) {
            const regex = new RegExp(pattern);
            Object.keys(get().entries).forEach((key) => {
              if (regex.test(key)) {
                keysToInvalidate.push(key);
              }
            });
          }

          set((draft) => {
            keysToInvalidate.forEach((key) => {
              if (draft.entries[key]) {
                draft.metadata.totalSize -= draft.entries[key].size;
                delete draft.entries[key];
              }
            });
          });

          return keysToInvalidate;
        },

        invalidateByTags: (tags) => {
          set((draft) => {
            const keysToRemove = [];

            Object.entries(draft.entries).forEach(([key, entry]) => {
              if (entry.tags && entry.tags.some((tag) => tags.includes(tag))) {
                keysToRemove.push(key);
              }
            });

            keysToRemove.forEach((key) => {
              draft.metadata.totalSize -= draft.entries[key].size;
              delete draft.entries[key];
            });
          });
        },

        cleanupExpiredEntries: () => {
          const now = Date.now();

          set((draft) => {
            const keysToRemove = [];

            Object.entries(draft.entries).forEach(([key, entry]) => {
              if (get().isCacheExpired(entry, now)) {
                keysToRemove.push(key);
              }
            });

            keysToRemove.forEach((key) => {
              draft.metadata.totalSize -= draft.entries[key].size;
              delete draft.entries[key];
            });
          });
        },

        clearCache: () => {
          set((draft) => {
            draft.entries = {};
            draft.metadata.totalSize = 0;
          });
        },

        // Helper functions
        isCacheExpired: (cacheEntry, now) => {
          const ttl = cacheEntry.ttl || CACHE_CONFIG.DEFAULT_TTL;
          return now - cacheEntry.timestamp > ttl;
        },

        getCacheEntry: (key) => {
          const entry = get().entries[key];
          if (!entry) return null;

          const now = Date.now();
          if (get().isCacheExpired(entry, now)) {
            return null;
          }

          return entry;
        },

        getCacheMetadata: () => get().metadata,
        getCacheSize: () => Object.keys(get().entries).length,
      })),
      {
        name: "cache-storage",
        partialize: (state) => ({
          entries: state.entries,
          metadata: state.metadata,
        }),
      }
    )
  )
);

export default useCacheStore;
```

```jsx
// hooks/useZustandCache.js
import { useEffect, useCallback } from "react";
import useCacheStore from "../stores/cacheStore";

export const useZustandCache = () => {
  const {
    fetchWithCache,
    invalidateCache,
    invalidateByTags,
    setCacheEntry,
    cleanupExpiredEntries,
    getCacheEntry,
    getCacheMetadata,
  } = useCacheStore();

  // Cleanup expired entries periodically
  useEffect(() => {
    const interval = setInterval(() => {
      cleanupExpiredEntries();
    }, 60000); // Every minute

    return () => clearInterval(interval);
  }, [cleanupExpiredEntries]);

  const fetchData = useCallback(
    async (key, url, options = {}) => {
      return await fetchWithCache(key, url, options);
    },
    [fetchWithCache]
  );

  const invalidate = useCallback(
    (keys, pattern) => {
      return invalidateCache(keys, pattern);
    },
    [invalidateCache]
  );

  const invalidateByTag = useCallback(
    (tags) => {
      return invalidateByTags(tags);
    },
    [invalidateByTags]
  );

  const setCache = useCallback(
    (key, data, options = {}) => {
      return setCacheEntry(key, data, options);
    },
    [setCacheEntry]
  );

  return {
    fetchData,
    invalidate,
    invalidateByTag,
    setCache,
    getCacheEntry,
    getCacheMetadata,
  };
};

// React hook for cached data fetching
export const useCachedData = (key, url, options = {}) => {
  const { fetchData, getCacheEntry } = useZustandCache();
  const cachedData = getCacheEntry(key);
  const loading = useCacheStore((state) => state.loading[key]);
  const error = useCacheStore((state) => state.errors[key]);

  useEffect(() => {
    if (!cachedData && url) {
      fetchData(key, url, options);
    }
  }, [key, url, cachedData, fetchData]);

  return {
    data: cachedData?.data,
    loading: loading || false,
    error,
    fromCache: cachedData?.fromCache,
    stale: cachedData?.stale,
    refetch: () => fetchData(key, url, { ...options, forceRefresh: true }),
  };
};
```

#### Best Practices

1. **Cache Strategy Selection**:

   - Use cache-first for static data
   - Use stale-while-revalidate for frequently changing data
   - Implement cache-aside for complex data transformations
   - Use write-through for critical data consistency

2. **Invalidation Strategies**:

   - Tag-based invalidation for related data
   - Time-based expiration for time-sensitive data
   - Event-driven invalidation for real-time updates
   - Pattern-based invalidation for bulk operations

3. **Performance Optimization**:

   - Implement cache size limits
   - Use LRU eviction policies
   - Compress large cache entries
   - Monitor cache hit rates

4. **Error Handling**:
   - Graceful fallback to stale data
   - Retry mechanisms for failed requests
   - Circuit breaker patterns for unreliable services
   - Proper error propagation

**Comparison Summary:**

| Feature                | Redux        | Zustand  |
| ---------------------- | ------------ | -------- |
| Setup Complexity       | High         | Medium   |
| Cache Invalidation     | Action-based | Direct   |
| TTL Management         | Built-in     | Custom   |
| Stale-while-revalidate | Thunk-based  | Async    |
| Tag-based Invalidation | Structured   | Flexible |
| Performance Monitoring | Detailed     | Basic    |
| DevTools               | Excellent    | Limited  |
| Bundle Size            | Larger       | Smaller  |

---

### 44. How do you implement advanced authentication and authorization patterns in Redux vs Zustand?

**Answer:**

Advanced authentication and authorization patterns are critical for securing applications and managing user access control. Both Redux and Zustand can implement sophisticated auth systems with different architectural approaches.

#### Redux Implementation for Advanced Authentication

```javascript
// store/authSlice.js
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import { jwtDecode } from "jwt-decode";

// Auth configuration
const AUTH_CONFIG = {
  TOKEN_REFRESH_THRESHOLD: 5 * 60 * 1000, // 5 minutes before expiry
  MAX_RETRY_ATTEMPTS: 3,
  REFRESH_RETRY_DELAY: 1000,
  STORAGE_KEY: "auth_tokens",
};

// Async thunks for authentication
export const login = createAsyncThunk(
  "auth/login",
  async ({ email, password, rememberMe = false }, { rejectWithValue }) => {
    try {
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password, rememberMe }),
      });

      if (!response.ok) {
        const error = await response.json();
        return rejectWithValue(error);
      }

      const data = await response.json();
      const { accessToken, refreshToken, user } = data;

      // Decode token to get expiry
      const decodedToken = jwtDecode(accessToken);

      // Store tokens in appropriate storage
      const storage = rememberMe ? localStorage : sessionStorage;
      storage.setItem(
        AUTH_CONFIG.STORAGE_KEY,
        JSON.stringify({
          accessToken,
          refreshToken,
          expiresAt: decodedToken.exp * 1000,
        })
      );

      return {
        user,
        accessToken,
        refreshToken,
        expiresAt: decodedToken.exp * 1000,
        rememberMe,
      };
    } catch (error) {
      return rejectWithValue({ message: error.message });
    }
  }
);

export const refreshToken = createAsyncThunk(
  "auth/refreshToken",
  async (_, { getState, rejectWithValue }) => {
    const { auth } = getState();

    if (!auth.refreshToken) {
      return rejectWithValue({ message: "No refresh token available" });
    }

    try {
      const response = await fetch("/api/auth/refresh", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${auth.refreshToken}`,
        },
      });

      if (!response.ok) {
        const error = await response.json();
        return rejectWithValue(error);
      }

      const data = await response.json();
      const { accessToken, refreshToken: newRefreshToken } = data;

      const decodedToken = jwtDecode(accessToken);

      // Update stored tokens
      const storage = auth.rememberMe ? localStorage : sessionStorage;
      const storedData = JSON.parse(
        storage.getItem(AUTH_CONFIG.STORAGE_KEY) || "{}"
      );
      storage.setItem(
        AUTH_CONFIG.STORAGE_KEY,
        JSON.stringify({
          ...storedData,
          accessToken,
          refreshToken: newRefreshToken,
          expiresAt: decodedToken.exp * 1000,
        })
      );

      return {
        accessToken,
        refreshToken: newRefreshToken,
        expiresAt: decodedToken.exp * 1000,
      };
    } catch (error) {
      return rejectWithValue({ message: error.message });
    }
  }
);

export const logout = createAsyncThunk(
  "auth/logout",
  async (_, { getState }) => {
    const { auth } = getState();

    try {
      // Notify server about logout
      await fetch("/api/auth/logout", {
        method: "POST",
        headers: {
          Authorization: `Bearer ${auth.accessToken}`,
        },
      });
    } catch (error) {
      console.warn("Logout request failed:", error);
    }

    // Clear stored tokens
    localStorage.removeItem(AUTH_CONFIG.STORAGE_KEY);
    sessionStorage.removeItem(AUTH_CONFIG.STORAGE_KEY);

    return {};
  }
);

export const validatePermissions = createAsyncThunk(
  "auth/validatePermissions",
  async ({ resource, action }, { getState, rejectWithValue }) => {
    const { auth } = getState();

    if (!auth.user) {
      return rejectWithValue({ message: "User not authenticated" });
    }

    try {
      const response = await fetch("/api/auth/permissions/validate", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${auth.accessToken}`,
        },
        body: JSON.stringify({ resource, action }),
      });

      if (!response.ok) {
        const error = await response.json();
        return rejectWithValue(error);
      }

      const data = await response.json();
      return {
        resource,
        action,
        allowed: data.allowed,
        permissions: data.permissions,
      };
    } catch (error) {
      return rejectWithValue({ message: error.message });
    }
  }
);

export const updateUserProfile = createAsyncThunk(
  "auth/updateUserProfile",
  async (profileData, { getState, rejectWithValue }) => {
    const { auth } = getState();

    try {
      const response = await fetch("/api/user/profile", {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${auth.accessToken}`,
        },
        body: JSON.stringify(profileData),
      });

      if (!response.ok) {
        const error = await response.json();
        return rejectWithValue(error);
      }

      const updatedUser = await response.json();
      return updatedUser;
    } catch (error) {
      return rejectWithValue({ message: error.message });
    }
  }
);

const authSlice = createSlice({
  name: "auth",
  initialState: {
    user: null,
    accessToken: null,
    refreshToken: null,
    expiresAt: null,
    rememberMe: false,
    isAuthenticated: false,
    isLoading: false,
    error: null,
    permissions: {},
    roles: [],
    sessionInfo: {
      loginTime: null,
      lastActivity: null,
      deviceInfo: null,
    },
    refreshAttempts: 0,
    isRefreshing: false,
  },
  reducers: {
    clearError: (state) => {
      state.error = null;
    },

    updateLastActivity: (state) => {
      state.sessionInfo.lastActivity = Date.now();
    },

    setDeviceInfo: (state, action) => {
      state.sessionInfo.deviceInfo = action.payload;
    },

    updatePermissions: (state, action) => {
      const { resource, action: permAction, allowed } = action.payload;
      if (!state.permissions[resource]) {
        state.permissions[resource] = {};
      }
      state.permissions[resource][permAction] = allowed;
    },

    clearPermissions: (state) => {
      state.permissions = {};
    },

    setRoles: (state, action) => {
      state.roles = action.payload;
    },

    initializeFromStorage: (state) => {
      try {
        const localData = localStorage.getItem(AUTH_CONFIG.STORAGE_KEY);
        const sessionData = sessionStorage.getItem(AUTH_CONFIG.STORAGE_KEY);

        const storedData = localData
          ? JSON.parse(localData)
          : sessionData
          ? JSON.parse(sessionData)
          : null;

        if (storedData && storedData.expiresAt > Date.now()) {
          state.accessToken = storedData.accessToken;
          state.refreshToken = storedData.refreshToken;
          state.expiresAt = storedData.expiresAt;
          state.rememberMe = !!localData;
          state.isAuthenticated = true;

          // Decode token to get user info
          try {
            const decodedToken = jwtDecode(storedData.accessToken);
            state.user = decodedToken.user || null;
            state.roles = decodedToken.roles || [];
          } catch (error) {
            console.warn("Failed to decode stored token:", error);
          }
        }
      } catch (error) {
        console.warn("Failed to initialize auth from storage:", error);
      }
    },

    resetRefreshAttempts: (state) => {
      state.refreshAttempts = 0;
    },
  },
  extraReducers: (builder) => {
    builder
      // Login
      .addCase(login.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(login.fulfilled, (state, action) => {
        const { user, accessToken, refreshToken, expiresAt, rememberMe } =
          action.payload;

        state.isLoading = false;
        state.user = user;
        state.accessToken = accessToken;
        state.refreshToken = refreshToken;
        state.expiresAt = expiresAt;
        state.rememberMe = rememberMe;
        state.isAuthenticated = true;
        state.roles = user.roles || [];
        state.sessionInfo.loginTime = Date.now();
        state.sessionInfo.lastActivity = Date.now();
        state.refreshAttempts = 0;
      })
      .addCase(login.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload;
        state.isAuthenticated = false;
      })

      // Refresh Token
      .addCase(refreshToken.pending, (state) => {
        state.isRefreshing = true;
      })
      .addCase(refreshToken.fulfilled, (state, action) => {
        const {
          accessToken,
          refreshToken: newRefreshToken,
          expiresAt,
        } = action.payload;

        state.isRefreshing = false;
        state.accessToken = accessToken;
        state.refreshToken = newRefreshToken;
        state.expiresAt = expiresAt;
        state.refreshAttempts = 0;
        state.sessionInfo.lastActivity = Date.now();
      })
      .addCase(refreshToken.rejected, (state, action) => {
        state.isRefreshing = false;
        state.refreshAttempts += 1;

        // If max attempts reached, logout
        if (state.refreshAttempts >= AUTH_CONFIG.MAX_RETRY_ATTEMPTS) {
          state.user = null;
          state.accessToken = null;
          state.refreshToken = null;
          state.expiresAt = null;
          state.isAuthenticated = false;
          state.permissions = {};
          state.roles = [];
          state.error = { message: "Session expired. Please login again." };
        }
      })

      // Logout
      .addCase(logout.fulfilled, (state) => {
        state.user = null;
        state.accessToken = null;
        state.refreshToken = null;
        state.expiresAt = null;
        state.rememberMe = false;
        state.isAuthenticated = false;
        state.permissions = {};
        state.roles = [];
        state.sessionInfo = {
          loginTime: null,
          lastActivity: null,
          deviceInfo: null,
        };
        state.refreshAttempts = 0;
        state.error = null;
      })

      // Validate Permissions
      .addCase(validatePermissions.fulfilled, (state, action) => {
        const { resource, action: permAction, allowed } = action.payload;
        if (!state.permissions[resource]) {
          state.permissions[resource] = {};
        }
        state.permissions[resource][permAction] = allowed;
      })

      // Update User Profile
      .addCase(updateUserProfile.fulfilled, (state, action) => {
        state.user = { ...state.user, ...action.payload };
      });
  },
});

export const {
  clearError,
  updateLastActivity,
  setDeviceInfo,
  updatePermissions,
  clearPermissions,
  setRoles,
  initializeFromStorage,
  resetRefreshAttempts,
} = authSlice.actions;

// Selectors
export const selectAuth = (state) => state.auth;
export const selectUser = (state) => state.auth.user;
export const selectIsAuthenticated = (state) => state.auth.isAuthenticated;
export const selectUserRoles = (state) => state.auth.roles;
export const selectPermissions = (state) => state.auth.permissions;
export const selectIsTokenExpiring = (state) => {
  const { expiresAt } = state.auth;
  if (!expiresAt) return false;
  return Date.now() > expiresAt - AUTH_CONFIG.TOKEN_REFRESH_THRESHOLD;
};

export const selectHasPermission = (state, resource, action) => {
  const permissions = state.auth.permissions;
  return permissions[resource]?.[action] === true;
};

export const selectHasRole = (state, role) => {
  return state.auth.roles.includes(role);
};

export const selectHasAnyRole = (state, roles) => {
  return roles.some((role) => state.auth.roles.includes(role));
};

export default authSlice.reducer;
```

```jsx
// hooks/useAuth.js
import { useSelector, useDispatch } from "react-redux";
import { useCallback, useEffect } from "react";
import {
  login,
  logout,
  refreshToken,
  validatePermissions,
  updateUserProfile,
  updateLastActivity,
  initializeFromStorage,
  selectAuth,
  selectIsTokenExpiring,
  selectHasPermission,
  selectHasRole,
} from "../store/authSlice";

export const useAuth = () => {
  const dispatch = useDispatch();
  const auth = useSelector(selectAuth);
  const isTokenExpiring = useSelector(selectIsTokenExpiring);

  // Initialize auth from storage on mount
  useEffect(() => {
    dispatch(initializeFromStorage());
  }, [dispatch]);

  // Auto-refresh token when expiring
  useEffect(() => {
    if (auth.isAuthenticated && isTokenExpiring && !auth.isRefreshing) {
      dispatch(refreshToken());
    }
  }, [auth.isAuthenticated, isTokenExpiring, auth.isRefreshing, dispatch]);

  // Update last activity on user interaction
  useEffect(() => {
    const updateActivity = () => {
      if (auth.isAuthenticated) {
        dispatch(updateLastActivity());
      }
    };

    const events = ["mousedown", "keydown", "scroll", "touchstart"];
    events.forEach((event) => {
      document.addEventListener(event, updateActivity, { passive: true });
    });

    return () => {
      events.forEach((event) => {
        document.removeEventListener(event, updateActivity);
      });
    };
  }, [auth.isAuthenticated, dispatch]);

  const loginUser = useCallback(
    async (credentials) => {
      const result = await dispatch(login(credentials));
      return result;
    },
    [dispatch]
  );

  const logoutUser = useCallback(() => {
    return dispatch(logout());
  }, [dispatch]);

  const checkPermission = useCallback(
    async (resource, action) => {
      const result = await dispatch(validatePermissions({ resource, action }));
      return result.payload?.allowed || false;
    },
    [dispatch]
  );

  const updateProfile = useCallback(
    (profileData) => {
      return dispatch(updateUserProfile(profileData));
    },
    [dispatch]
  );

  return {
    ...auth,
    login: loginUser,
    logout: logoutUser,
    checkPermission,
    updateProfile,
    isTokenExpiring,
  };
};

// Permission hook
export const usePermission = (resource, action) => {
  const hasPermission = useSelector((state) =>
    selectHasPermission(state, resource, action)
  );
  const dispatch = useDispatch();

  useEffect(() => {
    if (hasPermission === undefined) {
      dispatch(validatePermissions({ resource, action }));
    }
  }, [resource, action, hasPermission, dispatch]);

  return hasPermission;
};

// Role hook
export const useRole = (role) => {
  return useSelector((state) => selectHasRole(state, role));
};
```

#### Zustand Implementation for Advanced Authentication

```javascript
// stores/authStore.js
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { persist } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";
import { jwtDecode } from "jwt-decode";

const AUTH_CONFIG = {
  TOKEN_REFRESH_THRESHOLD: 5 * 60 * 1000, // 5 minutes before expiry
  MAX_RETRY_ATTEMPTS: 3,
  REFRESH_RETRY_DELAY: 1000,
};

const useAuthStore = create(
  subscribeWithSelector(
    persist(
      immer((set, get) => ({
        // State
        user: null,
        accessToken: null,
        refreshToken: null,
        expiresAt: null,
        rememberMe: false,
        isAuthenticated: false,
        isLoading: false,
        error: null,
        permissions: {},
        roles: [],
        sessionInfo: {
          loginTime: null,
          lastActivity: null,
          deviceInfo: null,
        },
        refreshAttempts: 0,
        isRefreshing: false,

        // Actions
        login: async (credentials) => {
          const { email, password, rememberMe = false } = credentials;

          set((draft) => {
            draft.isLoading = true;
            draft.error = null;
          });

          try {
            const response = await fetch("/api/auth/login", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ email, password, rememberMe }),
            });

            if (!response.ok) {
              const error = await response.json();
              throw new Error(error.message || "Login failed");
            }

            const data = await response.json();
            const { accessToken, refreshToken, user } = data;

            // Decode token to get expiry
            const decodedToken = jwtDecode(accessToken);

            set((draft) => {
              draft.isLoading = false;
              draft.user = user;
              draft.accessToken = accessToken;
              draft.refreshToken = refreshToken;
              draft.expiresAt = decodedToken.exp * 1000;
              draft.rememberMe = rememberMe;
              draft.isAuthenticated = true;
              draft.roles = user.roles || [];
              draft.sessionInfo.loginTime = Date.now();
              draft.sessionInfo.lastActivity = Date.now();
              draft.refreshAttempts = 0;
            });

            return { success: true, user };
          } catch (error) {
            set((draft) => {
              draft.isLoading = false;
              draft.error = { message: error.message };
              draft.isAuthenticated = false;
            });

            throw error;
          }
        },

        refreshToken: async () => {
          const state = get();

          if (!state.refreshToken) {
            throw new Error("No refresh token available");
          }

          set((draft) => {
            draft.isRefreshing = true;
          });

          try {
            const response = await fetch("/api/auth/refresh", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${state.refreshToken}`,
              },
            });

            if (!response.ok) {
              const error = await response.json();
              throw new Error(error.message || "Token refresh failed");
            }

            const data = await response.json();
            const { accessToken, refreshToken: newRefreshToken } = data;

            const decodedToken = jwtDecode(accessToken);

            set((draft) => {
              draft.isRefreshing = false;
              draft.accessToken = accessToken;
              draft.refreshToken = newRefreshToken;
              draft.expiresAt = decodedToken.exp * 1000;
              draft.refreshAttempts = 0;
              draft.sessionInfo.lastActivity = Date.now();
            });

            return { success: true };
          } catch (error) {
            set((draft) => {
              draft.isRefreshing = false;
              draft.refreshAttempts += 1;

              // If max attempts reached, logout
              if (draft.refreshAttempts >= AUTH_CONFIG.MAX_RETRY_ATTEMPTS) {
                draft.user = null;
                draft.accessToken = null;
                draft.refreshToken = null;
                draft.expiresAt = null;
                draft.isAuthenticated = false;
                draft.permissions = {};
                draft.roles = [];
                draft.error = {
                  message: "Session expired. Please login again.",
                };
              }
            });

            throw error;
          }
        },

        logout: async () => {
          const state = get();

          try {
            // Notify server about logout
            await fetch("/api/auth/logout", {
              method: "POST",
              headers: {
                Authorization: `Bearer ${state.accessToken}`,
              },
            });
          } catch (error) {
            console.warn("Logout request failed:", error);
          }

          set((draft) => {
            draft.user = null;
            draft.accessToken = null;
            draft.refreshToken = null;
            draft.expiresAt = null;
            draft.rememberMe = false;
            draft.isAuthenticated = false;
            draft.permissions = {};
            draft.roles = [];
            draft.sessionInfo = {
              loginTime: null,
              lastActivity: null,
              deviceInfo: null,
            };
            draft.refreshAttempts = 0;
            draft.error = null;
          });
        },

        validatePermissions: async (resource, action) => {
          const state = get();

          if (!state.user) {
            throw new Error("User not authenticated");
          }

          try {
            const response = await fetch("/api/auth/permissions/validate", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${state.accessToken}`,
              },
              body: JSON.stringify({ resource, action }),
            });

            if (!response.ok) {
              const error = await response.json();
              throw new Error(error.message || "Permission validation failed");
            }

            const data = await response.json();

            set((draft) => {
              if (!draft.permissions[resource]) {
                draft.permissions[resource] = {};
              }
              draft.permissions[resource][action] = data.allowed;
            });

            return data.allowed;
          } catch (error) {
            console.warn("Permission validation failed:", error);
            return false;
          }
        },

        updateUserProfile: async (profileData) => {
          const state = get();

          try {
            const response = await fetch("/api/user/profile", {
              method: "PUT",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${state.accessToken}`,
              },
              body: JSON.stringify(profileData),
            });

            if (!response.ok) {
              const error = await response.json();
              throw new Error(error.message || "Profile update failed");
            }

            const updatedUser = await response.json();

            set((draft) => {
              draft.user = { ...draft.user, ...updatedUser };
            });

            return updatedUser;
          } catch (error) {
            throw error;
          }
        },

        // Helper methods
        clearError: () => {
          set((draft) => {
            draft.error = null;
          });
        },

        updateLastActivity: () => {
          set((draft) => {
            draft.sessionInfo.lastActivity = Date.now();
          });
        },

        setDeviceInfo: (deviceInfo) => {
          set((draft) => {
            draft.sessionInfo.deviceInfo = deviceInfo;
          });
        },

        hasPermission: (resource, action) => {
          const state = get();
          return state.permissions[resource]?.[action] === true;
        },

        hasRole: (role) => {
          const state = get();
          return state.roles.includes(role);
        },

        hasAnyRole: (roles) => {
          const state = get();
          return roles.some((role) => state.roles.includes(role));
        },

        isTokenExpiring: () => {
          const state = get();
          if (!state.expiresAt) return false;
          return (
            Date.now() > state.expiresAt - AUTH_CONFIG.TOKEN_REFRESH_THRESHOLD
          );
        },
      })),
      {
        name: "auth-storage",
        partialize: (state) => ({
          accessToken: state.accessToken,
          refreshToken: state.refreshToken,
          expiresAt: state.expiresAt,
          user: state.user,
          rememberMe: state.rememberMe,
          roles: state.roles,
        }),
        storage: {
          getItem: (name) => {
            const localData = localStorage.getItem(name);
            const sessionData = sessionStorage.getItem(name);
            return localData || sessionData;
          },
          setItem: (name, value) => {
            const data = JSON.parse(value);
            const storage = data.state?.rememberMe
              ? localStorage
              : sessionStorage;
            storage.setItem(name, value);
          },
          removeItem: (name) => {
            localStorage.removeItem(name);
            sessionStorage.removeItem(name);
          },
        },
      }
    )
  )
);

// Auto-refresh token subscription
useAuthStore.subscribe(
  (state) => ({
    isAuthenticated: state.isAuthenticated,
    isTokenExpiring: state.isTokenExpiring(),
  }),
  ({ isAuthenticated, isTokenExpiring }) => {
    if (
      isAuthenticated &&
      isTokenExpiring &&
      !useAuthStore.getState().isRefreshing
    ) {
      useAuthStore.getState().refreshToken().catch(console.error);
    }
  },
  {
    equalityFn: (a, b) =>
      a.isAuthenticated === b.isAuthenticated &&
      a.isTokenExpiring === b.isTokenExpiring,
  }
);

export default useAuthStore;
```

```jsx
// hooks/useZustandAuth.js
import { useEffect, useCallback } from "react";
import useAuthStore from "../stores/authStore";

export const useZustandAuth = () => {
  const {
    user,
    isAuthenticated,
    isLoading,
    error,
    login,
    logout,
    validatePermissions,
    updateUserProfile,
    updateLastActivity,
    clearError,
    hasPermission,
    hasRole,
    hasAnyRole,
    isTokenExpiring,
  } = useAuthStore();

  // Update last activity on user interaction
  useEffect(() => {
    const updateActivity = () => {
      if (isAuthenticated) {
        updateLastActivity();
      }
    };

    const events = ["mousedown", "keydown", "scroll", "touchstart"];
    events.forEach((event) => {
      document.addEventListener(event, updateActivity, { passive: true });
    });

    return () => {
      events.forEach((event) => {
        document.removeEventListener(event, updateActivity);
      });
    };
  }, [isAuthenticated, updateLastActivity]);

  const checkPermission = useCallback(
    async (resource, action) => {
      return await validatePermissions(resource, action);
    },
    [validatePermissions]
  );

  return {
    user,
    isAuthenticated,
    isLoading,
    error,
    login,
    logout,
    checkPermission,
    updateProfile: updateUserProfile,
    clearError,
    hasPermission,
    hasRole,
    hasAnyRole,
    isTokenExpiring: isTokenExpiring(),
  };
};

// Permission hook
export const useZustandPermission = (resource, action) => {
  const { hasPermission, validatePermissions } = useAuthStore();
  const permission = hasPermission(resource, action);

  useEffect(() => {
    if (permission === undefined) {
      validatePermissions(resource, action);
    }
  }, [resource, action, permission, validatePermissions]);

  return permission;
};

// Role hook
export const useZustandRole = (role) => {
  const hasRole = useAuthStore((state) => state.hasRole(role));
  return hasRole;
};
```

#### Best Practices

1. **Token Management**:

   - Implement automatic token refresh
   - Use secure storage for sensitive data
   - Handle token expiration gracefully
   - Implement proper logout procedures

2. **Permission System**:

   - Cache permissions for performance
   - Validate permissions on both client and server
   - Use role-based access control (RBAC)
   - Implement fine-grained permissions

3. **Security Considerations**:

   - Use HTTPS for all authentication requests
   - Implement CSRF protection
   - Use secure, httpOnly cookies for refresh tokens
   - Implement rate limiting for auth endpoints

4. **User Experience**:
   - Provide clear error messages
   - Implement loading states
   - Handle offline scenarios
   - Maintain session across page refreshes

**Comparison Summary:**

| Feature             | Redux       | Zustand      |
| ------------------- | ----------- | ------------ |
| Setup Complexity    | High        | Medium       |
| Token Management    | Thunk-based | Direct       |
| Permission Caching  | Structured  | Flexible     |
| Auto-refresh        | Middleware  | Subscription |
| Storage Integration | Manual      | Built-in     |
| DevTools            | Excellent   | Limited      |
| Bundle Size         | Larger      | Smaller      |
| Type Safety         | Good        | Excellent    |

---

### 45. How do you implement advanced error handling and recovery patterns in Redux vs Zustand?

**Answer:**

Advanced error handling and recovery patterns are essential for building resilient applications that can gracefully handle failures and provide meaningful feedback to users. Both Redux and Zustand offer different approaches to implementing comprehensive error management systems.

#### Redux Implementation for Advanced Error Handling

```javascript
// store/errorSlice.js
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

// Error types and severity levels
export const ERROR_TYPES = {
  NETWORK: "NETWORK",
  VALIDATION: "VALIDATION",
  AUTHENTICATION: "AUTHENTICATION",
  AUTHORIZATION: "AUTHORIZATION",
  SERVER: "SERVER",
  CLIENT: "CLIENT",
  TIMEOUT: "TIMEOUT",
  RATE_LIMIT: "RATE_LIMIT",
};

export const ERROR_SEVERITY = {
  LOW: "LOW",
  MEDIUM: "MEDIUM",
  HIGH: "HIGH",
  CRITICAL: "CRITICAL",
};

const ERROR_CONFIG = {
  MAX_RETRY_ATTEMPTS: 3,
  RETRY_DELAYS: [1000, 2000, 4000], // Exponential backoff
  TIMEOUT_DURATION: 30000,
  MAX_ERROR_HISTORY: 50,
  AUTO_DISMISS_DELAY: 5000,
};

// Enhanced async thunk with error handling
export const createAsyncThunkWithErrorHandling = (
  typePrefix,
  payloadCreator,
  options = {}
) => {
  return createAsyncThunk(
    typePrefix,
    async (arg, { dispatch, rejectWithValue, signal }) => {
      const {
        maxRetries = ERROR_CONFIG.MAX_RETRY_ATTEMPTS,
        retryDelays = ERROR_CONFIG.RETRY_DELAYS,
        timeout = ERROR_CONFIG.TIMEOUT_DURATION,
        onRetry,
        onError,
      } = options;

      let lastError;

      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          // Set up timeout
          const timeoutId = setTimeout(() => {
            if (!signal.aborted) {
              signal.abort();
            }
          }, timeout);

          const result = await payloadCreator(arg, { dispatch, signal });
          clearTimeout(timeoutId);

          // Clear any previous errors for this action
          dispatch(clearActionError(typePrefix));

          return result;
        } catch (error) {
          lastError = error;

          // Check if we should retry
          const shouldRetry = attempt < maxRetries && isRetryableError(error);

          if (shouldRetry) {
            const delay =
              retryDelays[Math.min(attempt, retryDelays.length - 1)];

            // Notify about retry
            if (onRetry) {
              onRetry(error, attempt + 1, delay);
            }

            dispatch(
              addRetryAttempt({
                action: typePrefix,
                attempt: attempt + 1,
                error: serializeError(error),
                nextRetryIn: delay,
              })
            );

            // Wait before retry
            await new Promise((resolve) => setTimeout(resolve, delay));
            continue;
          }

          // No more retries, handle the error
          const serializedError = serializeError(error);

          if (onError) {
            onError(serializedError);
          }

          dispatch(
            addError({
              id: generateErrorId(),
              type: classifyError(error),
              severity: getSeverity(error),
              message: error.message || "An unexpected error occurred",
              details: serializedError,
              action: typePrefix,
              timestamp: Date.now(),
              context: arg,
              retryCount: attempt,
            })
          );

          return rejectWithValue(serializedError);
        }
      }
    }
  );
};

// Error classification utilities
const isRetryableError = (error) => {
  const retryableStatuses = [408, 429, 500, 502, 503, 504];
  const retryableTypes = [
    ERROR_TYPES.NETWORK,
    ERROR_TYPES.TIMEOUT,
    ERROR_TYPES.RATE_LIMIT,
  ];

  return (
    retryableStatuses.includes(error.status) ||
    retryableTypes.includes(error.type) ||
    error.name === "NetworkError" ||
    error.name === "TimeoutError"
  );
};

const classifyError = (error) => {
  if (error.name === "NetworkError" || !navigator.onLine) {
    return ERROR_TYPES.NETWORK;
  }

  if (error.name === "TimeoutError") {
    return ERROR_TYPES.TIMEOUT;
  }

  if (error.status === 401) {
    return ERROR_TYPES.AUTHENTICATION;
  }

  if (error.status === 403) {
    return ERROR_TYPES.AUTHORIZATION;
  }

  if (error.status === 429) {
    return ERROR_TYPES.RATE_LIMIT;
  }

  if (error.status >= 400 && error.status < 500) {
    return ERROR_TYPES.CLIENT;
  }

  if (error.status >= 500) {
    return ERROR_TYPES.SERVER;
  }

  if (error.validationErrors) {
    return ERROR_TYPES.VALIDATION;
  }

  return ERROR_TYPES.CLIENT;
};

const getSeverity = (error) => {
  if (error.status === 401 || error.status === 403) {
    return ERROR_SEVERITY.HIGH;
  }

  if (error.status >= 500) {
    return ERROR_SEVERITY.CRITICAL;
  }

  if (error.status === 429 || error.name === "NetworkError") {
    return ERROR_SEVERITY.MEDIUM;
  }

  return ERROR_SEVERITY.LOW;
};

const serializeError = (error) => {
  return {
    name: error.name,
    message: error.message,
    status: error.status,
    statusText: error.statusText,
    stack: error.stack,
    validationErrors: error.validationErrors,
    timestamp: Date.now(),
  };
};

const generateErrorId = () => {
  return `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
};

// Error slice
const errorSlice = createSlice({
  name: "error",
  initialState: {
    errors: [],
    actionErrors: {}, // Errors by action type
    retryAttempts: {},
    globalError: null,
    isOnline: navigator.onLine,
    errorStats: {
      totalErrors: 0,
      errorsByType: {},
      errorsBySeverity: {},
      recentErrors: [],
    },
  },
  reducers: {
    addError: (state, action) => {
      const error = action.payload;

      // Add to errors list
      state.errors.unshift(error);

      // Maintain max history
      if (state.errors.length > ERROR_CONFIG.MAX_ERROR_HISTORY) {
        state.errors = state.errors.slice(0, ERROR_CONFIG.MAX_ERROR_HISTORY);
      }

      // Update action-specific errors
      if (error.action) {
        state.actionErrors[error.action] = error;
      }

      // Update statistics
      state.errorStats.totalErrors += 1;
      state.errorStats.errorsByType[error.type] =
        (state.errorStats.errorsByType[error.type] || 0) + 1;
      state.errorStats.errorsBySeverity[error.severity] =
        (state.errorStats.errorsBySeverity[error.severity] || 0) + 1;

      // Add to recent errors (last 10)
      state.errorStats.recentErrors.unshift({
        id: error.id,
        type: error.type,
        severity: error.severity,
        timestamp: error.timestamp,
      });

      if (state.errorStats.recentErrors.length > 10) {
        state.errorStats.recentErrors = state.errorStats.recentErrors.slice(
          0,
          10
        );
      }

      // Set global error for critical errors
      if (error.severity === ERROR_SEVERITY.CRITICAL) {
        state.globalError = error;
      }
    },

    removeError: (state, action) => {
      const errorId = action.payload;
      state.errors = state.errors.filter((error) => error.id !== errorId);
    },

    clearActionError: (state, action) => {
      const actionType = action.payload;
      delete state.actionErrors[actionType];
    },

    clearAllErrors: (state) => {
      state.errors = [];
      state.actionErrors = {};
      state.globalError = null;
    },

    setGlobalError: (state, action) => {
      state.globalError = action.payload;
    },

    clearGlobalError: (state) => {
      state.globalError = null;
    },

    addRetryAttempt: (state, action) => {
      const {
        action: actionType,
        attempt,
        error,
        nextRetryIn,
      } = action.payload;

      if (!state.retryAttempts[actionType]) {
        state.retryAttempts[actionType] = [];
      }

      state.retryAttempts[actionType].push({
        attempt,
        error,
        timestamp: Date.now(),
        nextRetryIn,
      });
    },

    clearRetryAttempts: (state, action) => {
      const actionType = action.payload;
      delete state.retryAttempts[actionType];
    },

    setOnlineStatus: (state, action) => {
      state.isOnline = action.payload;
    },

    updateErrorStats: (state, action) => {
      state.errorStats = { ...state.errorStats, ...action.payload };
    },
  },
});

export const {
  addError,
  removeError,
  clearActionError,
  clearAllErrors,
  setGlobalError,
  clearGlobalError,
  addRetryAttempt,
  clearRetryAttempts,
  setOnlineStatus,
  updateErrorStats,
} = errorSlice.actions;

// Selectors
export const selectErrors = (state) => state.error.errors;
export const selectActionError = (state, actionType) =>
  state.error.actionErrors[actionType];
export const selectGlobalError = (state) => state.error.globalError;
export const selectIsOnline = (state) => state.error.isOnline;
export const selectErrorStats = (state) => state.error.errorStats;
export const selectRetryAttempts = (state, actionType) =>
  state.error.retryAttempts[actionType] || [];

export const selectErrorsByType = (state, errorType) => {
  return state.error.errors.filter((error) => error.type === errorType);
};

export const selectErrorsBySeverity = (state, severity) => {
  return state.error.errors.filter((error) => error.severity === severity);
};

export const selectRecentErrors = (state, limit = 5) => {
  return state.error.errors.slice(0, limit);
};

export default errorSlice.reducer;
```

```jsx
// hooks/useErrorHandler.js
import { useSelector, useDispatch } from "react-redux";
import { useCallback, useEffect } from "react";
import {
  addError,
  removeError,
  clearActionError,
  clearAllErrors,
  setGlobalError,
  clearGlobalError,
  setOnlineStatus,
  selectErrors,
  selectActionError,
  selectGlobalError,
  selectIsOnline,
  selectErrorStats,
  ERROR_TYPES,
  ERROR_SEVERITY,
} from "../store/errorSlice";

export const useErrorHandler = () => {
  const dispatch = useDispatch();
  const errors = useSelector(selectErrors);
  const globalError = useSelector(selectGlobalError);
  const isOnline = useSelector(selectIsOnline);
  const errorStats = useSelector(selectErrorStats);

  // Monitor online status
  useEffect(() => {
    const handleOnline = () => dispatch(setOnlineStatus(true));
    const handleOffline = () => dispatch(setOnlineStatus(false));

    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);

    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
    };
  }, [dispatch]);

  // Auto-dismiss non-critical errors
  useEffect(() => {
    const timer = setInterval(() => {
      const now = Date.now();
      errors.forEach((error) => {
        if (
          error.severity !== ERROR_SEVERITY.CRITICAL &&
          now - error.timestamp > 5000 // 5 seconds
        ) {
          dispatch(removeError(error.id));
        }
      });
    }, 1000);

    return () => clearInterval(timer);
  }, [errors, dispatch]);

  const handleError = useCallback(
    (error, context = {}) => {
      const errorPayload = {
        id: `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        type: error.type || ERROR_TYPES.CLIENT,
        severity: error.severity || ERROR_SEVERITY.MEDIUM,
        message: error.message || "An unexpected error occurred",
        details: error,
        timestamp: Date.now(),
        context,
      };

      dispatch(addError(errorPayload));

      // Log to external service in production
      if (process.env.NODE_ENV === "production") {
        logErrorToService(errorPayload);
      }

      return errorPayload;
    },
    [dispatch]
  );

  const dismissError = useCallback(
    (errorId) => {
      dispatch(removeError(errorId));
    },
    [dispatch]
  );

  const clearActionErrors = useCallback(
    (actionType) => {
      dispatch(clearActionError(actionType));
    },
    [dispatch]
  );

  const clearAll = useCallback(() => {
    dispatch(clearAllErrors());
  }, [dispatch]);

  const setGlobal = useCallback(
    (error) => {
      dispatch(setGlobalError(error));
    },
    [dispatch]
  );

  const clearGlobal = useCallback(() => {
    dispatch(clearGlobalError());
  }, [dispatch]);

  return {
    errors,
    globalError,
    isOnline,
    errorStats,
    handleError,
    dismissError,
    clearActionErrors,
    clearAll,
    setGlobal,
    clearGlobal,
  };
};

// Hook for specific action errors
export const useActionError = (actionType) => {
  const error = useSelector((state) => selectActionError(state, actionType));
  const dispatch = useDispatch();

  const clearError = useCallback(() => {
    dispatch(clearActionError(actionType));
  }, [actionType, dispatch]);

  return { error, clearError };
};

// External error logging
const logErrorToService = async (error) => {
  try {
    await fetch("/api/errors", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(error),
    });
  } catch (logError) {
    console.error("Failed to log error to service:", logError);
  }
};
```

#### Zustand Implementation for Advanced Error Handling

```javascript
// stores/errorStore.js
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

const ERROR_TYPES = {
  NETWORK: "NETWORK",
  VALIDATION: "VALIDATION",
  AUTHENTICATION: "AUTHENTICATION",
  AUTHORIZATION: "AUTHORIZATION",
  SERVER: "SERVER",
  CLIENT: "CLIENT",
  TIMEOUT: "TIMEOUT",
  RATE_LIMIT: "RATE_LIMIT",
};

const ERROR_SEVERITY = {
  LOW: "LOW",
  MEDIUM: "MEDIUM",
  HIGH: "HIGH",
  CRITICAL: "CRITICAL",
};

const ERROR_CONFIG = {
  MAX_RETRY_ATTEMPTS: 3,
  RETRY_DELAYS: [1000, 2000, 4000],
  TIMEOUT_DURATION: 30000,
  MAX_ERROR_HISTORY: 50,
  AUTO_DISMISS_DELAY: 5000,
};

const useErrorStore = create(
  subscribeWithSelector(
    immer((set, get) => ({
      // State
      errors: [],
      actionErrors: {},
      retryAttempts: {},
      globalError: null,
      isOnline: navigator.onLine,
      errorStats: {
        totalErrors: 0,
        errorsByType: {},
        errorsBySeverity: {},
        recentErrors: [],
      },

      // Actions
      addError: (error) => {
        set((draft) => {
          const errorWithId = {
            ...error,
            id:
              error.id ||
              `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            timestamp: error.timestamp || Date.now(),
          };

          // Add to errors list
          draft.errors.unshift(errorWithId);

          // Maintain max history
          if (draft.errors.length > ERROR_CONFIG.MAX_ERROR_HISTORY) {
            draft.errors = draft.errors.slice(
              0,
              ERROR_CONFIG.MAX_ERROR_HISTORY
            );
          }

          // Update action-specific errors
          if (errorWithId.action) {
            draft.actionErrors[errorWithId.action] = errorWithId;
          }

          // Update statistics
          draft.errorStats.totalErrors += 1;
          draft.errorStats.errorsByType[errorWithId.type] =
            (draft.errorStats.errorsByType[errorWithId.type] || 0) + 1;
          draft.errorStats.errorsBySeverity[errorWithId.severity] =
            (draft.errorStats.errorsBySeverity[errorWithId.severity] || 0) + 1;

          // Add to recent errors
          draft.errorStats.recentErrors.unshift({
            id: errorWithId.id,
            type: errorWithId.type,
            severity: errorWithId.severity,
            timestamp: errorWithId.timestamp,
          });

          if (draft.errorStats.recentErrors.length > 10) {
            draft.errorStats.recentErrors = draft.errorStats.recentErrors.slice(
              0,
              10
            );
          }

          // Set global error for critical errors
          if (errorWithId.severity === ERROR_SEVERITY.CRITICAL) {
            draft.globalError = errorWithId;
          }
        });

        // Log to external service in production
        if (process.env.NODE_ENV === "production") {
          get().logErrorToService(error);
        }
      },

      removeError: (errorId) => {
        set((draft) => {
          draft.errors = draft.errors.filter((error) => error.id !== errorId);
        });
      },

      clearActionError: (actionType) => {
        set((draft) => {
          delete draft.actionErrors[actionType];
        });
      },

      clearAllErrors: () => {
        set((draft) => {
          draft.errors = [];
          draft.actionErrors = {};
          draft.globalError = null;
        });
      },

      setGlobalError: (error) => {
        set((draft) => {
          draft.globalError = error;
        });
      },

      clearGlobalError: () => {
        set((draft) => {
          draft.globalError = null;
        });
      },

      addRetryAttempt: (actionType, attempt, error, nextRetryIn) => {
        set((draft) => {
          if (!draft.retryAttempts[actionType]) {
            draft.retryAttempts[actionType] = [];
          }

          draft.retryAttempts[actionType].push({
            attempt,
            error,
            timestamp: Date.now(),
            nextRetryIn,
          });
        });
      },

      clearRetryAttempts: (actionType) => {
        set((draft) => {
          delete draft.retryAttempts[actionType];
        });
      },

      setOnlineStatus: (isOnline) => {
        set((draft) => {
          draft.isOnline = isOnline;
        });
      },

      // Enhanced async action with error handling
      executeWithErrorHandling: async (actionName, asyncFn, options = {}) => {
        const {
          maxRetries = ERROR_CONFIG.MAX_RETRY_ATTEMPTS,
          retryDelays = ERROR_CONFIG.RETRY_DELAYS,
          timeout = ERROR_CONFIG.TIMEOUT_DURATION,
          onRetry,
          onError,
        } = options;

        let lastError;

        for (let attempt = 0; attempt <= maxRetries; attempt++) {
          try {
            // Clear any previous errors for this action
            get().clearActionError(actionName);

            // Execute with timeout
            const result = await Promise.race([
              asyncFn(),
              new Promise((_, reject) =>
                setTimeout(() => reject(new Error("Request timeout")), timeout)
              ),
            ]);

            // Clear retry attempts on success
            get().clearRetryAttempts(actionName);

            return result;
          } catch (error) {
            lastError = error;

            // Check if we should retry
            const shouldRetry =
              attempt < maxRetries && get().isRetryableError(error);

            if (shouldRetry) {
              const delay =
                retryDelays[Math.min(attempt, retryDelays.length - 1)];

              // Notify about retry
              if (onRetry) {
                onRetry(error, attempt + 1, delay);
              }

              get().addRetryAttempt(
                actionName,
                attempt + 1,
                get().serializeError(error),
                delay
              );

              // Wait before retry
              await new Promise((resolve) => setTimeout(resolve, delay));
              continue;
            }

            // No more retries, handle the error
            const serializedError = get().serializeError(error);

            if (onError) {
              onError(serializedError);
            }

            get().addError({
              type: get().classifyError(error),
              severity: get().getSeverity(error),
              message: error.message || "An unexpected error occurred",
              details: serializedError,
              action: actionName,
              retryCount: attempt,
            });

            throw error;
          }
        }
      },

      // Utility methods
      isRetryableError: (error) => {
        const retryableStatuses = [408, 429, 500, 502, 503, 504];
        const retryableTypes = [
          ERROR_TYPES.NETWORK,
          ERROR_TYPES.TIMEOUT,
          ERROR_TYPES.RATE_LIMIT,
        ];

        return (
          retryableStatuses.includes(error.status) ||
          retryableTypes.includes(error.type) ||
          error.name === "NetworkError" ||
          error.name === "TimeoutError"
        );
      },

      classifyError: (error) => {
        if (error.name === "NetworkError" || !navigator.onLine) {
          return ERROR_TYPES.NETWORK;
        }

        if (error.name === "TimeoutError") {
          return ERROR_TYPES.TIMEOUT;
        }

        if (error.status === 401) {
          return ERROR_TYPES.AUTHENTICATION;
        }

        if (error.status === 403) {
          return ERROR_TYPES.AUTHORIZATION;
        }

        if (error.status === 429) {
          return ERROR_TYPES.RATE_LIMIT;
        }

        if (error.status >= 400 && error.status < 500) {
          return ERROR_TYPES.CLIENT;
        }

        if (error.status >= 500) {
          return ERROR_TYPES.SERVER;
        }

        if (error.validationErrors) {
          return ERROR_TYPES.VALIDATION;
        }

        return ERROR_TYPES.CLIENT;
      },

      getSeverity: (error) => {
        if (error.status === 401 || error.status === 403) {
          return ERROR_SEVERITY.HIGH;
        }

        if (error.status >= 500) {
          return ERROR_SEVERITY.CRITICAL;
        }

        if (error.status === 429 || error.name === "NetworkError") {
          return ERROR_SEVERITY.MEDIUM;
        }

        return ERROR_SEVERITY.LOW;
      },

      serializeError: (error) => {
        return {
          name: error.name,
          message: error.message,
          status: error.status,
          statusText: error.statusText,
          stack: error.stack,
          validationErrors: error.validationErrors,
          timestamp: Date.now(),
        };
      },

      logErrorToService: async (error) => {
        try {
          await fetch("/api/errors", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(error),
          });
        } catch (logError) {
          console.error("Failed to log error to service:", logError);
        }
      },

      // Selectors
      getErrorsByType: (errorType) => {
        return get().errors.filter((error) => error.type === errorType);
      },

      getErrorsBySeverity: (severity) => {
        return get().errors.filter((error) => error.severity === severity);
      },

      getRecentErrors: (limit = 5) => {
        return get().errors.slice(0, limit);
      },

      getActionError: (actionType) => {
        return get().actionErrors[actionType];
      },

      getRetryAttempts: (actionType) => {
        return get().retryAttempts[actionType] || [];
      },
    }))
  )
);

// Auto-dismiss errors subscription
useErrorStore.subscribe(
  (state) => state.errors,
  (errors) => {
    const now = Date.now();
    errors.forEach((error) => {
      if (
        error.severity !== ERROR_SEVERITY.CRITICAL &&
        now - error.timestamp > ERROR_CONFIG.AUTO_DISMISS_DELAY
      ) {
        setTimeout(() => {
          useErrorStore.getState().removeError(error.id);
        }, 100);
      }
    });
  }
);

// Online status monitoring
if (typeof window !== "undefined") {
  window.addEventListener("online", () => {
    useErrorStore.getState().setOnlineStatus(true);
  });

  window.addEventListener("offline", () => {
    useErrorStore.getState().setOnlineStatus(false);
  });
}

export { ERROR_TYPES, ERROR_SEVERITY };
export default useErrorStore;
```

```jsx
// hooks/useZustandErrorHandler.js
import { useCallback } from "react";
import useErrorStore, {
  ERROR_TYPES,
  ERROR_SEVERITY,
} from "../stores/errorStore";

export const useZustandErrorHandler = () => {
  const {
    errors,
    globalError,
    isOnline,
    errorStats,
    addError,
    removeError,
    clearActionError,
    clearAllErrors,
    setGlobalError,
    clearGlobalError,
    executeWithErrorHandling,
  } = useErrorStore();

  const handleError = useCallback(
    (error, context = {}) => {
      const errorPayload = {
        type: error.type || ERROR_TYPES.CLIENT,
        severity: error.severity || ERROR_SEVERITY.MEDIUM,
        message: error.message || "An unexpected error occurred",
        details: error,
        context,
      };

      addError(errorPayload);
      return errorPayload;
    },
    [addError]
  );

  const dismissError = useCallback(
    (errorId) => {
      removeError(errorId);
    },
    [removeError]
  );

  const clearActionErrors = useCallback(
    (actionType) => {
      clearActionError(actionType);
    },
    [clearActionError]
  );

  const clearAll = useCallback(() => {
    clearAllErrors();
  }, [clearAllErrors]);

  const setGlobal = useCallback(
    (error) => {
      setGlobalError(error);
    },
    [setGlobalError]
  );

  const clearGlobal = useCallback(() => {
    clearGlobalError();
  }, [clearGlobalError]);

  const executeWithRetry = useCallback(
    (actionName, asyncFn, options) => {
      return executeWithErrorHandling(actionName, asyncFn, options);
    },
    [executeWithErrorHandling]
  );

  return {
    errors,
    globalError,
    isOnline,
    errorStats,
    handleError,
    dismissError,
    clearActionErrors,
    clearAll,
    setGlobal,
    clearGlobal,
    executeWithRetry,
  };
};

// Hook for specific action errors
export const useZustandActionError = (actionType) => {
  const getActionError = useErrorStore((state) => state.getActionError);
  const clearActionError = useErrorStore((state) => state.clearActionError);

  const error = getActionError(actionType);

  const clearError = useCallback(() => {
    clearActionError(actionType);
  }, [actionType, clearActionError]);

  return { error, clearError };
};
```

#### Best Practices

1. **Error Classification**:

   - Categorize errors by type and severity
   - Implement appropriate retry strategies
   - Use consistent error formats
   - Provide meaningful error messages

2. **Recovery Strategies**:

   - Implement exponential backoff for retries
   - Handle network connectivity issues
   - Provide fallback mechanisms
   - Cache data for offline scenarios

3. **User Experience**:

   - Show appropriate loading states
   - Provide clear error messages
   - Offer retry options for recoverable errors
   - Auto-dismiss non-critical errors

4. **Monitoring and Logging**:
   - Log errors to external services
   - Track error statistics
   - Monitor error trends
   - Set up alerts for critical errors

**Comparison Summary:**

| Feature              | Redux       | Zustand    |
| -------------------- | ----------- | ---------- |
| Setup Complexity     | High        | Medium     |
| Error Classification | Structured  | Flexible   |
| Retry Logic          | Thunk-based | Direct     |
| Auto-recovery        | Middleware  | Built-in   |
| Error Statistics     | Manual      | Integrated |
| DevTools             | Excellent   | Limited    |
| Bundle Size          | Larger      | Smaller    |
| Type Safety          | Good        | Excellent  |

---

### 46. How do you implement advanced search and filtering capabilities in Redux vs Zustand?

**Answer:**

Advanced search and filtering capabilities are crucial for applications dealing with large datasets. Both Redux and Zustand provide different approaches to implementing efficient, scalable search functionality with features like debouncing, faceted search, real-time filtering, and search history.

#### Redux Implementation for Advanced Search

```javascript
// store/searchSlice.js
import {
  createSlice,
  createAsyncThunk,
  createSelector,
} from "@reduxjs/toolkit";
import { debounce } from "lodash";

// Search configuration
const SEARCH_CONFIG = {
  DEBOUNCE_DELAY: 300,
  MIN_QUERY_LENGTH: 2,
  MAX_RESULTS: 100,
  MAX_HISTORY: 10,
  CACHE_DURATION: 5 * 60 * 1000, // 5 minutes
};

// Search types
export const SEARCH_TYPES = {
  FULL_TEXT: "FULL_TEXT",
  FUZZY: "FUZZY",
  EXACT: "EXACT",
  REGEX: "REGEX",
};

// Sort options
export const SORT_OPTIONS = {
  RELEVANCE: "RELEVANCE",
  DATE_ASC: "DATE_ASC",
  DATE_DESC: "DATE_DESC",
  TITLE_ASC: "TITLE_ASC",
  TITLE_DESC: "TITLE_DESC",
  POPULARITY: "POPULARITY",
};

// Async thunk for search with caching
export const performSearch = createAsyncThunk(
  "search/performSearch",
  async (
    { query, filters, searchType, sortBy, page = 1 },
    { getState, rejectWithValue }
  ) => {
    try {
      const state = getState();
      const cacheKey = generateCacheKey({
        query,
        filters,
        searchType,
        sortBy,
        page,
      });

      // Check cache first
      const cachedResult = state.search.cache[cacheKey];
      if (
        cachedResult &&
        Date.now() - cachedResult.timestamp < SEARCH_CONFIG.CACHE_DURATION
      ) {
        return { ...cachedResult.data, fromCache: true };
      }

      // Perform actual search
      const response = await fetch("/api/search", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          query,
          filters,
          searchType,
          sortBy,
          page,
          limit: SEARCH_CONFIG.MAX_RESULTS,
        }),
      });

      if (!response.ok) {
        throw new Error(`Search failed: ${response.statusText}`);
      }

      const data = await response.json();

      return {
        ...data,
        cacheKey,
        fromCache: false,
      };
    } catch (error) {
      return rejectWithValue({
        message: error.message,
        query,
        timestamp: Date.now(),
      });
    }
  }
);

// Async thunk for search suggestions
export const fetchSuggestions = createAsyncThunk(
  "search/fetchSuggestions",
  async ({ query }, { rejectWithValue }) => {
    try {
      const response = await fetch(
        `/api/search/suggestions?q=${encodeURIComponent(query)}`
      );

      if (!response.ok) {
        throw new Error("Failed to fetch suggestions");
      }

      const suggestions = await response.json();
      return suggestions;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Utility functions
const generateCacheKey = ({ query, filters, searchType, sortBy, page }) => {
  return `${query}_${JSON.stringify(filters)}_${searchType}_${sortBy}_${page}`;
};

const normalizeQuery = (query) => {
  return query.trim().toLowerCase();
};

const createSearchIndex = (items, fields) => {
  const index = new Map();

  items.forEach((item, itemIndex) => {
    fields.forEach((field) => {
      const value = item[field];
      if (value) {
        const words = value.toLowerCase().split(/\s+/);
        words.forEach((word) => {
          if (!index.has(word)) {
            index.set(word, new Set());
          }
          index.get(word).add(itemIndex);
        });
      }
    });
  });

  return index;
};

// Search slice
const searchSlice = createSlice({
  name: "search",
  initialState: {
    // Current search state
    query: "",
    filters: {},
    searchType: SEARCH_TYPES.FULL_TEXT,
    sortBy: SORT_OPTIONS.RELEVANCE,
    currentPage: 1,

    // Results
    results: [],
    totalResults: 0,
    totalPages: 0,
    hasMore: false,

    // UI state
    isSearching: false,
    isLoadingMore: false,
    error: null,

    // Suggestions
    suggestions: [],
    isFetchingSuggestions: false,
    showSuggestions: false,

    // History and cache
    searchHistory: [],
    cache: {},

    // Facets and aggregations
    facets: {},
    availableFilters: {},

    // Search index for client-side search
    searchIndex: null,
    indexedItems: [],

    // Advanced features
    savedSearches: [],
    searchAlerts: [],
    recentQueries: [],
  },
  reducers: {
    setQuery: (state, action) => {
      state.query = action.payload;
      state.currentPage = 1;
    },

    setFilters: (state, action) => {
      state.filters = { ...state.filters, ...action.payload };
      state.currentPage = 1;
    },

    removeFilter: (state, action) => {
      const { filterKey, filterValue } = action.payload;
      if (state.filters[filterKey]) {
        if (Array.isArray(state.filters[filterKey])) {
          state.filters[filterKey] = state.filters[filterKey].filter(
            (v) => v !== filterValue
          );
          if (state.filters[filterKey].length === 0) {
            delete state.filters[filterKey];
          }
        } else {
          delete state.filters[filterKey];
        }
      }
      state.currentPage = 1;
    },

    clearFilters: (state) => {
      state.filters = {};
      state.currentPage = 1;
    },

    setSearchType: (state, action) => {
      state.searchType = action.payload;
      state.currentPage = 1;
    },

    setSortBy: (state, action) => {
      state.sortBy = action.payload;
      state.currentPage = 1;
    },

    setCurrentPage: (state, action) => {
      state.currentPage = action.payload;
    },

    clearResults: (state) => {
      state.results = [];
      state.totalResults = 0;
      state.totalPages = 0;
      state.hasMore = false;
    },

    showSuggestions: (state) => {
      state.showSuggestions = true;
    },

    hideSuggestions: (state) => {
      state.showSuggestions = false;
    },

    addToHistory: (state, action) => {
      const { query, filters, timestamp } = action.payload;

      // Remove duplicate if exists
      state.searchHistory = state.searchHistory.filter(
        (item) =>
          !(
            item.query === query &&
            JSON.stringify(item.filters) === JSON.stringify(filters)
          )
      );

      // Add to beginning
      state.searchHistory.unshift({ query, filters, timestamp });

      // Maintain max history
      if (state.searchHistory.length > SEARCH_CONFIG.MAX_HISTORY) {
        state.searchHistory = state.searchHistory.slice(
          0,
          SEARCH_CONFIG.MAX_HISTORY
        );
      }
    },

    clearHistory: (state) => {
      state.searchHistory = [];
    },

    addRecentQuery: (state, action) => {
      const query = action.payload;

      // Remove if already exists
      state.recentQueries = state.recentQueries.filter((q) => q !== query);

      // Add to beginning
      state.recentQueries.unshift(query);

      // Maintain max recent queries
      if (state.recentQueries.length > 5) {
        state.recentQueries = state.recentQueries.slice(0, 5);
      }
    },

    saveSearch: (state, action) => {
      const { name, query, filters } = action.payload;
      const savedSearch = {
        id: Date.now().toString(),
        name,
        query,
        filters,
        createdAt: Date.now(),
      };

      state.savedSearches.push(savedSearch);
    },

    removeSavedSearch: (state, action) => {
      const searchId = action.payload;
      state.savedSearches = state.savedSearches.filter(
        (search) => search.id !== searchId
      );
    },

    createSearchIndex: (state, action) => {
      const { items, fields } = action.payload;
      state.searchIndex = createSearchIndex(items, fields);
      state.indexedItems = items;
    },

    updateCache: (state, action) => {
      const { cacheKey, data } = action.payload;
      state.cache[cacheKey] = {
        data,
        timestamp: Date.now(),
      };

      // Clean old cache entries
      const now = Date.now();
      Object.keys(state.cache).forEach((key) => {
        if (now - state.cache[key].timestamp > SEARCH_CONFIG.CACHE_DURATION) {
          delete state.cache[key];
        }
      });
    },

    clearCache: (state) => {
      state.cache = {};
    },

    setError: (state, action) => {
      state.error = action.payload;
    },

    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Perform search
      .addCase(performSearch.pending, (state, action) => {
        const { page } = action.meta.arg;
        if (page === 1) {
          state.isSearching = true;
          state.error = null;
        } else {
          state.isLoadingMore = true;
        }
      })
      .addCase(performSearch.fulfilled, (state, action) => {
        const {
          results,
          totalResults,
          totalPages,
          facets,
          cacheKey,
          fromCache,
        } = action.payload;
        const { query, filters, page } = action.meta.arg;

        state.isSearching = false;
        state.isLoadingMore = false;
        state.error = null;

        if (page === 1) {
          state.results = results;
        } else {
          state.results = [...state.results, ...results];
        }

        state.totalResults = totalResults;
        state.totalPages = totalPages;
        state.hasMore = page < totalPages;

        if (facets) {
          state.facets = facets;
        }

        // Cache the result if not from cache
        if (!fromCache && cacheKey) {
          state.cache[cacheKey] = {
            data: action.payload,
            timestamp: Date.now(),
          };
        }

        // Add to history
        if (query && query.length >= SEARCH_CONFIG.MIN_QUERY_LENGTH) {
          const historyEntry = {
            query,
            filters,
            timestamp: Date.now(),
          };

          // Remove duplicate if exists
          state.searchHistory = state.searchHistory.filter(
            (item) =>
              !(
                item.query === query &&
                JSON.stringify(item.filters) === JSON.stringify(filters)
              )
          );

          state.searchHistory.unshift(historyEntry);

          if (state.searchHistory.length > SEARCH_CONFIG.MAX_HISTORY) {
            state.searchHistory = state.searchHistory.slice(
              0,
              SEARCH_CONFIG.MAX_HISTORY
            );
          }
        }
      })
      .addCase(performSearch.rejected, (state, action) => {
        state.isSearching = false;
        state.isLoadingMore = false;
        state.error = action.payload;
      })

      // Fetch suggestions
      .addCase(fetchSuggestions.pending, (state) => {
        state.isFetchingSuggestions = true;
      })
      .addCase(fetchSuggestions.fulfilled, (state, action) => {
        state.isFetchingSuggestions = false;
        state.suggestions = action.payload;
      })
      .addCase(fetchSuggestions.rejected, (state) => {
        state.isFetchingSuggestions = false;
        state.suggestions = [];
      });
  },
});

export const {
  setQuery,
  setFilters,
  removeFilter,
  clearFilters,
  setSearchType,
  setSortBy,
  setCurrentPage,
  clearResults,
  showSuggestions,
  hideSuggestions,
  addToHistory,
  clearHistory,
  addRecentQuery,
  saveSearch,
  removeSavedSearch,
  createSearchIndex,
  updateCache,
  clearCache,
  setError,
  clearError,
} = searchSlice.actions;

// Selectors
export const selectSearchState = (state) => state.search;
export const selectQuery = (state) => state.search.query;
export const selectFilters = (state) => state.search.filters;
export const selectResults = (state) => state.search.results;
export const selectIsSearching = (state) => state.search.isSearching;
export const selectSuggestions = (state) => state.search.suggestions;
export const selectSearchHistory = (state) => state.search.searchHistory;
export const selectFacets = (state) => state.search.facets;

// Memoized selectors
export const selectFilteredResults = createSelector(
  [selectResults, selectFilters],
  (results, filters) => {
    if (Object.keys(filters).length === 0) {
      return results;
    }

    return results.filter((item) => {
      return Object.entries(filters).every(([key, value]) => {
        if (Array.isArray(value)) {
          return value.some((v) => item[key] === v);
        }
        return item[key] === value;
      });
    });
  }
);

export const selectActiveFiltersCount = createSelector(
  [selectFilters],
  (filters) => {
    return Object.values(filters).reduce((count, value) => {
      if (Array.isArray(value)) {
        return count + value.length;
      }
      return count + 1;
    }, 0);
  }
);

export const selectSearchSummary = createSelector(
  [selectQuery, selectResults, selectIsSearching, selectActiveFiltersCount],
  (query, results, isSearching, filterCount) => {
    return {
      query,
      resultCount: results.length,
      isSearching,
      hasFilters: filterCount > 0,
      filterCount,
    };
  }
);

export default searchSlice.reducer;
```

```jsx
// hooks/useAdvancedSearch.js
import { useSelector, useDispatch } from "react-redux";
import { useCallback, useEffect, useMemo } from "react";
import { debounce } from "lodash";
import {
  performSearch,
  fetchSuggestions,
  setQuery,
  setFilters,
  removeFilter,
  clearFilters,
  setSearchType,
  setSortBy,
  setCurrentPage,
  showSuggestions,
  hideSuggestions,
  addRecentQuery,
  saveSearch,
  selectSearchState,
  selectFilteredResults,
  selectSearchSummary,
  SEARCH_TYPES,
  SORT_OPTIONS,
} from "../store/searchSlice";

const SEARCH_CONFIG = {
  DEBOUNCE_DELAY: 300,
  MIN_QUERY_LENGTH: 2,
};

export const useAdvancedSearch = () => {
  const dispatch = useDispatch();
  const searchState = useSelector(selectSearchState);
  const filteredResults = useSelector(selectFilteredResults);
  const searchSummary = useSelector(selectSearchSummary);

  // Debounced search function
  const debouncedSearch = useMemo(
    () =>
      debounce((searchParams) => {
        if (searchParams.query.length >= SEARCH_CONFIG.MIN_QUERY_LENGTH) {
          dispatch(performSearch(searchParams));
          dispatch(addRecentQuery(searchParams.query));
        }
      }, SEARCH_CONFIG.DEBOUNCE_DELAY),
    [dispatch]
  );

  // Debounced suggestions fetch
  const debouncedFetchSuggestions = useMemo(
    () =>
      debounce((query) => {
        if (query.length >= SEARCH_CONFIG.MIN_QUERY_LENGTH) {
          dispatch(fetchSuggestions({ query }));
        }
      }, 150),
    [dispatch]
  );

  // Search function
  const search = useCallback(
    (searchParams = {}) => {
      const params = {
        query: searchState.query,
        filters: searchState.filters,
        searchType: searchState.searchType,
        sortBy: searchState.sortBy,
        page: 1,
        ...searchParams,
      };

      debouncedSearch(params);
    },
    [searchState, debouncedSearch]
  );

  // Load more results
  const loadMore = useCallback(() => {
    if (searchState.hasMore && !searchState.isLoadingMore) {
      dispatch(
        performSearch({
          query: searchState.query,
          filters: searchState.filters,
          searchType: searchState.searchType,
          sortBy: searchState.sortBy,
          page: searchState.currentPage + 1,
        })
      );
      dispatch(setCurrentPage(searchState.currentPage + 1));
    }
  }, [searchState, dispatch]);

  // Update query
  const updateQuery = useCallback(
    (query) => {
      dispatch(setQuery(query));

      if (query.length >= SEARCH_CONFIG.MIN_QUERY_LENGTH) {
        debouncedFetchSuggestions(query);
        dispatch(showSuggestions());
      } else {
        dispatch(hideSuggestions());
      }
    },
    [dispatch, debouncedFetchSuggestions]
  );

  // Update filters
  const updateFilters = useCallback(
    (filters) => {
      dispatch(setFilters(filters));
      search({ filters: { ...searchState.filters, ...filters } });
    },
    [dispatch, search, searchState.filters]
  );

  // Remove filter
  const removeFilterValue = useCallback(
    (filterKey, filterValue) => {
      dispatch(removeFilter({ filterKey, filterValue }));

      // Trigger new search with updated filters
      const updatedFilters = { ...searchState.filters };
      if (updatedFilters[filterKey]) {
        if (Array.isArray(updatedFilters[filterKey])) {
          updatedFilters[filterKey] = updatedFilters[filterKey].filter(
            (v) => v !== filterValue
          );
          if (updatedFilters[filterKey].length === 0) {
            delete updatedFilters[filterKey];
          }
        } else {
          delete updatedFilters[filterKey];
        }
      }

      search({ filters: updatedFilters });
    },
    [dispatch, search, searchState.filters]
  );

  // Clear all filters
  const clearAllFilters = useCallback(() => {
    dispatch(clearFilters());
    search({ filters: {} });
  }, [dispatch, search]);

  // Update search type
  const updateSearchType = useCallback(
    (searchType) => {
      dispatch(setSearchType(searchType));
      search({ searchType });
    },
    [dispatch, search]
  );

  // Update sort
  const updateSort = useCallback(
    (sortBy) => {
      dispatch(setSortBy(sortBy));
      search({ sortBy });
    },
    [dispatch, search]
  );

  // Save current search
  const saveCurrentSearch = useCallback(
    (name) => {
      dispatch(
        saveSearch({
          name,
          query: searchState.query,
          filters: searchState.filters,
        })
      );
    },
    [dispatch, searchState]
  );

  // Hide suggestions
  const hideSuggestionsPanel = useCallback(() => {
    dispatch(hideSuggestions());
  }, [dispatch]);

  // Auto-search effect
  useEffect(() => {
    if (searchState.query.length >= SEARCH_CONFIG.MIN_QUERY_LENGTH) {
      search();
    }
  }, [searchState.searchType, searchState.sortBy]);

  return {
    // State
    ...searchState,
    filteredResults,
    searchSummary,

    // Actions
    search,
    loadMore,
    updateQuery,
    updateFilters,
    removeFilter: removeFilterValue,
    clearFilters: clearAllFilters,
    updateSearchType,
    updateSort,
    saveCurrentSearch,
    hideSuggestions: hideSuggestionsPanel,

    // Constants
    SEARCH_TYPES,
    SORT_OPTIONS,
  };
};
```

#### Zustand Implementation for Advanced Search

```javascript
// stores/searchStore.js
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";
import { persist } from "zustand/middleware";
import { debounce } from "lodash";

const SEARCH_CONFIG = {
  DEBOUNCE_DELAY: 300,
  MIN_QUERY_LENGTH: 2,
  MAX_RESULTS: 100,
  MAX_HISTORY: 10,
  CACHE_DURATION: 5 * 60 * 1000,
};

const SEARCH_TYPES = {
  FULL_TEXT: "FULL_TEXT",
  FUZZY: "FUZZY",
  EXACT: "EXACT",
  REGEX: "REGEX",
};

const SORT_OPTIONS = {
  RELEVANCE: "RELEVANCE",
  DATE_ASC: "DATE_ASC",
  DATE_DESC: "DATE_DESC",
  TITLE_ASC: "TITLE_ASC",
  TITLE_DESC: "TITLE_DESC",
  POPULARITY: "POPULARITY",
};

const useSearchStore = create(
  persist(
    subscribeWithSelector(
      immer((set, get) => ({
        // Current search state
        query: "",
        filters: {},
        searchType: SEARCH_TYPES.FULL_TEXT,
        sortBy: SORT_OPTIONS.RELEVANCE,
        currentPage: 1,

        // Results
        results: [],
        totalResults: 0,
        totalPages: 0,
        hasMore: false,

        // UI state
        isSearching: false,
        isLoadingMore: false,
        error: null,

        // Suggestions
        suggestions: [],
        isFetchingSuggestions: false,
        showSuggestions: false,

        // History and cache
        searchHistory: [],
        cache: {},

        // Facets and aggregations
        facets: {},
        availableFilters: {},

        // Search index for client-side search
        searchIndex: null,
        indexedItems: [],

        // Advanced features
        savedSearches: [],
        recentQueries: [],

        // Actions
        setQuery: (query) => {
          set((draft) => {
            draft.query = query;
            draft.currentPage = 1;
          });
        },

        setFilters: (filters) => {
          set((draft) => {
            draft.filters = { ...draft.filters, ...filters };
            draft.currentPage = 1;
          });
        },

        removeFilter: (filterKey, filterValue) => {
          set((draft) => {
            if (draft.filters[filterKey]) {
              if (Array.isArray(draft.filters[filterKey])) {
                draft.filters[filterKey] = draft.filters[filterKey].filter(
                  (v) => v !== filterValue
                );
                if (draft.filters[filterKey].length === 0) {
                  delete draft.filters[filterKey];
                }
              } else {
                delete draft.filters[filterKey];
              }
            }
            draft.currentPage = 1;
          });
        },

        clearFilters: () => {
          set((draft) => {
            draft.filters = {};
            draft.currentPage = 1;
          });
        },

        setSearchType: (searchType) => {
          set((draft) => {
            draft.searchType = searchType;
            draft.currentPage = 1;
          });
        },

        setSortBy: (sortBy) => {
          set((draft) => {
            draft.sortBy = sortBy;
            draft.currentPage = 1;
          });
        },

        setCurrentPage: (page) => {
          set((draft) => {
            draft.currentPage = page;
          });
        },

        clearResults: () => {
          set((draft) => {
            draft.results = [];
            draft.totalResults = 0;
            draft.totalPages = 0;
            draft.hasMore = false;
          });
        },

        showSuggestionsPanel: () => {
          set((draft) => {
            draft.showSuggestions = true;
          });
        },

        hideSuggestionsPanel: () => {
          set((draft) => {
            draft.showSuggestions = false;
          });
        },

        // Search execution
        performSearch: async (searchParams = {}) => {
          const state = get();
          const params = {
            query: state.query,
            filters: state.filters,
            searchType: state.searchType,
            sortBy: state.sortBy,
            page: 1,
            ...searchParams,
          };

          const { query, filters, searchType, sortBy, page } = params;

          try {
            // Check cache first
            const cacheKey = get().generateCacheKey(params);
            const cachedResult = state.cache[cacheKey];

            if (
              cachedResult &&
              Date.now() - cachedResult.timestamp < SEARCH_CONFIG.CACHE_DURATION
            ) {
              set((draft) => {
                if (page === 1) {
                  draft.results = cachedResult.data.results;
                } else {
                  draft.results = [
                    ...draft.results,
                    ...cachedResult.data.results,
                  ];
                }
                draft.totalResults = cachedResult.data.totalResults;
                draft.totalPages = cachedResult.data.totalPages;
                draft.hasMore = page < cachedResult.data.totalPages;
                draft.facets = cachedResult.data.facets || {};
                draft.isSearching = false;
                draft.isLoadingMore = false;
                draft.error = null;
              });
              return;
            }

            // Set loading state
            set((draft) => {
              if (page === 1) {
                draft.isSearching = true;
                draft.error = null;
              } else {
                draft.isLoadingMore = true;
              }
            });

            // Perform search
            const response = await fetch("/api/search", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                query,
                filters,
                searchType,
                sortBy,
                page,
                limit: SEARCH_CONFIG.MAX_RESULTS,
              }),
            });

            if (!response.ok) {
              throw new Error(`Search failed: ${response.statusText}`);
            }

            const data = await response.json();

            set((draft) => {
              if (page === 1) {
                draft.results = data.results;
              } else {
                draft.results = [...draft.results, ...data.results];
              }

              draft.totalResults = data.totalResults;
              draft.totalPages = data.totalPages;
              draft.hasMore = page < data.totalPages;
              draft.facets = data.facets || {};
              draft.isSearching = false;
              draft.isLoadingMore = false;
              draft.error = null;

              // Cache the result
              draft.cache[cacheKey] = {
                data,
                timestamp: Date.now(),
              };

              // Add to history
              if (query && query.length >= SEARCH_CONFIG.MIN_QUERY_LENGTH) {
                const historyEntry = {
                  query,
                  filters,
                  timestamp: Date.now(),
                };

                // Remove duplicate if exists
                draft.searchHistory = draft.searchHistory.filter(
                  (item) =>
                    !(
                      item.query === query &&
                      JSON.stringify(item.filters) === JSON.stringify(filters)
                    )
                );

                draft.searchHistory.unshift(historyEntry);

                if (draft.searchHistory.length > SEARCH_CONFIG.MAX_HISTORY) {
                  draft.searchHistory = draft.searchHistory.slice(
                    0,
                    SEARCH_CONFIG.MAX_HISTORY
                  );
                }
              }
            });
          } catch (error) {
            set((draft) => {
              draft.isSearching = false;
              draft.isLoadingMore = false;
              draft.error = {
                message: error.message,
                query,
                timestamp: Date.now(),
              };
            });
          }
        },

        // Fetch suggestions
        fetchSuggestions: async (query) => {
          try {
            set((draft) => {
              draft.isFetchingSuggestions = true;
            });

            const response = await fetch(
              `/api/search/suggestions?q=${encodeURIComponent(query)}`
            );

            if (!response.ok) {
              throw new Error("Failed to fetch suggestions");
            }

            const suggestions = await response.json();

            set((draft) => {
              draft.suggestions = suggestions;
              draft.isFetchingSuggestions = false;
            });
          } catch (error) {
            set((draft) => {
              draft.suggestions = [];
              draft.isFetchingSuggestions = false;
            });
          }
        },

        // Load more results
        loadMore: () => {
          const state = get();
          if (state.hasMore && !state.isLoadingMore) {
            get().performSearch({
              page: state.currentPage + 1,
            });
            get().setCurrentPage(state.currentPage + 1);
          }
        },

        // Add to recent queries
        addRecentQuery: (query) => {
          set((draft) => {
            // Remove if already exists
            draft.recentQueries = draft.recentQueries.filter(
              (q) => q !== query
            );

            // Add to beginning
            draft.recentQueries.unshift(query);

            // Maintain max recent queries
            if (draft.recentQueries.length > 5) {
              draft.recentQueries = draft.recentQueries.slice(0, 5);
            }
          });
        },

        // Save search
        saveSearch: (name, query, filters) => {
          set((draft) => {
            const savedSearch = {
              id: Date.now().toString(),
              name,
              query,
              filters,
              createdAt: Date.now(),
            };

            draft.savedSearches.push(savedSearch);
          });
        },

        // Remove saved search
        removeSavedSearch: (searchId) => {
          set((draft) => {
            draft.savedSearches = draft.savedSearches.filter(
              (search) => search.id !== searchId
            );
          });
        },

        // Utility methods
        generateCacheKey: ({ query, filters, searchType, sortBy, page }) => {
          return `${query}_${JSON.stringify(
            filters
          )}_${searchType}_${sortBy}_${page}`;
        },

        // Client-side search index
        createSearchIndex: (items, fields) => {
          const index = new Map();

          items.forEach((item, itemIndex) => {
            fields.forEach((field) => {
              const value = item[field];
              if (value) {
                const words = value.toLowerCase().split(/\s+/);
                words.forEach((word) => {
                  if (!index.has(word)) {
                    index.set(word, new Set());
                  }
                  index.get(word).add(itemIndex);
                });
              }
            });
          });

          set((draft) => {
            draft.searchIndex = index;
            draft.indexedItems = items;
          });
        },

        // Client-side search
        searchLocal: (query, fields = []) => {
          const state = get();
          if (!state.searchIndex || !query) {
            return [];
          }

          const words = query.toLowerCase().split(/\s+/);
          const matchingIndices = new Set();

          words.forEach((word) => {
            if (state.searchIndex.has(word)) {
              state.searchIndex.get(word).forEach((index) => {
                matchingIndices.add(index);
              });
            }
          });

          return Array.from(matchingIndices).map(
            (index) => state.indexedItems[index]
          );
        },

        // Clear cache
        clearCache: () => {
          set((draft) => {
            draft.cache = {};
          });
        },

        // Clear history
        clearHistory: () => {
          set((draft) => {
            draft.searchHistory = [];
          });
        },

        // Selectors
        getFilteredResults: () => {
          const state = get();
          const { results, filters } = state;

          if (Object.keys(filters).length === 0) {
            return results;
          }

          return results.filter((item) => {
            return Object.entries(filters).every(([key, value]) => {
              if (Array.isArray(value)) {
                return value.some((v) => item[key] === v);
              }
              return item[key] === value;
            });
          });
        },

        getActiveFiltersCount: () => {
          const state = get();
          return Object.values(state.filters).reduce((count, value) => {
            if (Array.isArray(value)) {
              return count + value.length;
            }
            return count + 1;
          }, 0);
        },

        getSearchSummary: () => {
          const state = get();
          return {
            query: state.query,
            resultCount: state.results.length,
            isSearching: state.isSearching,
            hasFilters: state.getActiveFiltersCount() > 0,
            filterCount: state.getActiveFiltersCount(),
          };
        },
      }))
    ),
    {
      name: "search-store",
      partialize: (state) => ({
        searchHistory: state.searchHistory,
        savedSearches: state.savedSearches,
        recentQueries: state.recentQueries,
      }),
    }
  )
);

// Create debounced search function
const createDebouncedSearch = (store) => {
  return debounce((searchParams) => {
    if (
      searchParams.query &&
      searchParams.query.length >= SEARCH_CONFIG.MIN_QUERY_LENGTH
    ) {
      store.getState().performSearch(searchParams);
      store.getState().addRecentQuery(searchParams.query);
    }
  }, SEARCH_CONFIG.DEBOUNCE_DELAY);
};

// Create debounced suggestions fetch
const createDebouncedSuggestions = (store) => {
  return debounce((query) => {
    if (query.length >= SEARCH_CONFIG.MIN_QUERY_LENGTH) {
      store.getState().fetchSuggestions(query);
    }
  }, 150);
};

export { SEARCH_TYPES, SORT_OPTIONS };
export default useSearchStore;
export { createDebouncedSearch, createDebouncedSuggestions };
```

```jsx
// hooks/useZustandAdvancedSearch.js
import { useCallback, useEffect, useMemo } from "react";
import useSearchStore, {
  createDebouncedSearch,
  createDebouncedSuggestions,
  SEARCH_TYPES,
  SORT_OPTIONS,
} from "../stores/searchStore";

const SEARCH_CONFIG = {
  MIN_QUERY_LENGTH: 2,
};

export const useZustandAdvancedSearch = () => {
  const {
    // State
    query,
    filters,
    searchType,
    sortBy,
    currentPage,
    results,
    totalResults,
    totalPages,
    hasMore,
    isSearching,
    isLoadingMore,
    error,
    suggestions,
    isFetchingSuggestions,
    showSuggestions,
    searchHistory,
    facets,
    savedSearches,
    recentQueries,

    // Actions
    setQuery,
    setFilters,
    removeFilter,
    clearFilters,
    setSearchType,
    setSortBy,
    performSearch,
    loadMore,
    showSuggestionsPanel,
    hideSuggestionsPanel,
    addRecentQuery,
    saveSearch,
    removeSavedSearch,

    // Selectors
    getFilteredResults,
    getActiveFiltersCount,
    getSearchSummary,
  } = useSearchStore();

  // Create debounced functions
  const debouncedSearch = useMemo(
    () => createDebouncedSearch(useSearchStore),
    []
  );

  const debouncedFetchSuggestions = useMemo(
    () => createDebouncedSuggestions(useSearchStore),
    []
  );

  // Search function
  const search = useCallback(
    (searchParams = {}) => {
      const params = {
        query,
        filters,
        searchType,
        sortBy,
        page: 1,
        ...searchParams,
      };

      debouncedSearch(params);
    },
    [query, filters, searchType, sortBy, debouncedSearch]
  );

  // Update query with suggestions
  const updateQuery = useCallback(
    (newQuery) => {
      setQuery(newQuery);

      if (newQuery.length >= SEARCH_CONFIG.MIN_QUERY_LENGTH) {
        debouncedFetchSuggestions(newQuery);
        showSuggestionsPanel();
      } else {
        hideSuggestionsPanel();
      }
    },
    [
      setQuery,
      debouncedFetchSuggestions,
      showSuggestionsPanel,
      hideSuggestionsPanel,
    ]
  );

  // Update filters with search
  const updateFilters = useCallback(
    (newFilters) => {
      setFilters(newFilters);
      search({ filters: { ...filters, ...newFilters } });
    },
    [setFilters, search, filters]
  );

  // Remove filter with search
  const removeFilterValue = useCallback(
    (filterKey, filterValue) => {
      removeFilter(filterKey, filterValue);

      // Calculate updated filters
      const updatedFilters = { ...filters };
      if (updatedFilters[filterKey]) {
        if (Array.isArray(updatedFilters[filterKey])) {
          updatedFilters[filterKey] = updatedFilters[filterKey].filter(
            (v) => v !== filterValue
          );
          if (updatedFilters[filterKey].length === 0) {
            delete updatedFilters[filterKey];
          }
        } else {
          delete updatedFilters[filterKey];
        }
      }

      search({ filters: updatedFilters });
    },
    [removeFilter, search, filters]
  );

  // Clear all filters with search
  const clearAllFilters = useCallback(() => {
    clearFilters();
    search({ filters: {} });
  }, [clearFilters, search]);

  // Update search type with search
  const updateSearchType = useCallback(
    (newSearchType) => {
      setSearchType(newSearchType);
      search({ searchType: newSearchType });
    },
    [setSearchType, search]
  );

  // Update sort with search
  const updateSort = useCallback(
    (newSortBy) => {
      setSortBy(newSortBy);
      search({ sortBy: newSortBy });
    },
    [setSortBy, search]
  );

  // Save current search
  const saveCurrentSearch = useCallback(
    (name) => {
      saveSearch(name, query, filters);
    },
    [saveSearch, query, filters]
  );

  // Get computed values
  const filteredResults = useMemo(
    () => getFilteredResults(),
    [getFilteredResults]
  );
  const activeFiltersCount = useMemo(
    () => getActiveFiltersCount(),
    [getActiveFiltersCount]
  );
  const searchSummary = useMemo(() => getSearchSummary(), [getSearchSummary]);

  // Auto-search effect
  useEffect(() => {
    if (query.length >= SEARCH_CONFIG.MIN_QUERY_LENGTH) {
      search();
    }
  }, [searchType, sortBy]);

  return {
    // State
    query,
    filters,
    searchType,
    sortBy,
    currentPage,
    results,
    totalResults,
    totalPages,
    hasMore,
    isSearching,
    isLoadingMore,
    error,
    suggestions,
    isFetchingSuggestions,
    showSuggestions,
    searchHistory,
    facets,
    savedSearches,
    recentQueries,
    filteredResults,
    activeFiltersCount,
    searchSummary,

    // Actions
    search,
    loadMore,
    updateQuery,
    updateFilters,
    removeFilter: removeFilterValue,
    clearFilters: clearAllFilters,
    updateSearchType,
    updateSort,
    saveCurrentSearch,
    removeSavedSearch,
    hideSuggestions: hideSuggestionsPanel,

    // Constants
    SEARCH_TYPES,
    SORT_OPTIONS,
  };
};
```

#### Best Practices

1. **Performance Optimization**:

   - Implement debouncing for search queries
   - Use caching for repeated searches
   - Implement virtual scrolling for large result sets
   - Optimize search indices for client-side search

2. **User Experience**:

   - Provide real-time search suggestions
   - Show search progress indicators
   - Implement search history and saved searches
   - Offer faceted filtering options

3. **Search Quality**:

   - Support multiple search types (fuzzy, exact, regex)
   - Implement relevance scoring
   - Provide search result highlighting
   - Handle typos and synonyms

4. **Scalability**:
   - Implement server-side pagination
   - Use search indices for large datasets
   - Implement search analytics
   - Cache frequently searched queries

**Comparison Summary:**

| Feature            | Redux      | Zustand    |
| ------------------ | ---------- | ---------- |
| Setup Complexity   | High       | Medium     |
| Search Caching     | Manual     | Integrated |
| Debouncing         | External   | Built-in   |
| History Management | Structured | Flexible   |
| Real-time Updates  | Middleware | Direct     |
| DevTools           | Excellent  | Limited    |
| Bundle Size        | Larger     | Smaller    |
| Type Safety        | Good       | Excellent  |

---

### 47. How do you implement advanced routing and navigation state management in Redux vs Zustand?

**Answer:**

Advanced routing and navigation state management involves handling complex navigation flows, route parameters, query strings, navigation guards, breadcrumbs, and deep linking. Both Redux and Zustand offer different approaches to managing routing state alongside application state.

#### Redux Implementation for Advanced Routing

```javascript
// store/routingSlice.js
import {
  createSlice,
  createAsyncThunk,
  createSelector,
} from "@reduxjs/toolkit";
import { createBrowserHistory } from "history";

// Create history instance
export const history = createBrowserHistory();

// Route configuration
const ROUTES = {
  HOME: "/",
  DASHBOARD: "/dashboard",
  PROFILE: "/profile/:userId",
  SETTINGS: "/settings",
  ADMIN: "/admin",
  PRODUCTS: "/products",
  PRODUCT_DETAIL: "/products/:productId",
  CHECKOUT: "/checkout",
  ORDER_HISTORY: "/orders",
  NOT_FOUND: "/404",
};

// Navigation permissions
const ROUTE_PERMISSIONS = {
  [ROUTES.ADMIN]: ["admin"],
  [ROUTES.DASHBOARD]: ["user", "admin"],
  [ROUTES.PROFILE]: ["user", "admin"],
  [ROUTES.SETTINGS]: ["user", "admin"],
  [ROUTES.CHECKOUT]: ["user", "admin"],
  [ROUTES.ORDER_HISTORY]: ["user", "admin"],
};

// Async thunk for navigation with guards
export const navigateWithGuards = createAsyncThunk(
  "routing/navigateWithGuards",
  async (
    { path, replace = false, state = null },
    { getState, rejectWithValue }
  ) => {
    try {
      const currentState = getState();
      const { auth, routing } = currentState;

      // Check authentication
      if (!auth.isAuthenticated && requiresAuth(path)) {
        // Redirect to login with return path
        const loginPath = `/login?returnTo=${encodeURIComponent(path)}`;
        if (replace) {
          history.replace(loginPath, state);
        } else {
          history.push(loginPath, state);
        }
        return {
          path: loginPath,
          blocked: true,
          reason: "authentication_required",
        };
      }

      // Check permissions
      const requiredPermissions = getRoutePermissions(path);
      if (requiredPermissions.length > 0) {
        const hasPermission = requiredPermissions.some((permission) =>
          auth.user?.permissions?.includes(permission)
        );

        if (!hasPermission) {
          const forbiddenPath = "/403";
          if (replace) {
            history.replace(forbiddenPath, state);
          } else {
            history.push(forbiddenPath, state);
          }
          return {
            path: forbiddenPath,
            blocked: true,
            reason: "insufficient_permissions",
          };
        }
      }

      // Check if leaving current route requires confirmation
      if (routing.hasUnsavedChanges && routing.currentPath !== path) {
        const confirmed = await showConfirmDialog(
          "You have unsaved changes. Are you sure you want to leave?"
        );

        if (!confirmed) {
          return {
            path: routing.currentPath,
            blocked: true,
            reason: "user_cancelled",
          };
        }
      }

      // Perform navigation
      if (replace) {
        history.replace(path, state);
      } else {
        history.push(path, state);
      }

      return {
        path,
        blocked: false,
        timestamp: Date.now(),
      };
    } catch (error) {
      return rejectWithValue({
        message: error.message,
        path,
        timestamp: Date.now(),
      });
    }
  }
);

// Async thunk for loading route data
export const loadRouteData = createAsyncThunk(
  "routing/loadRouteData",
  async ({ path, params, query }, { getState, rejectWithValue }) => {
    try {
      const routeConfig = getRouteConfig(path);

      if (!routeConfig?.dataLoader) {
        return { data: null };
      }

      const data = await routeConfig.dataLoader({ params, query, getState });

      return {
        path,
        data,
        timestamp: Date.now(),
      };
    } catch (error) {
      return rejectWithValue({
        message: error.message,
        path,
        timestamp: Date.now(),
      });
    }
  }
);

// Utility functions
const requiresAuth = (path) => {
  const publicRoutes = [ROUTES.HOME, "/login", "/register", "/forgot-password"];
  return !publicRoutes.some((route) => path.startsWith(route));
};

const getRoutePermissions = (path) => {
  for (const [route, permissions] of Object.entries(ROUTE_PERMISSIONS)) {
    if (matchRoute(route, path)) {
      return permissions;
    }
  }
  return [];
};

const matchRoute = (pattern, path) => {
  const patternParts = pattern.split("/");
  const pathParts = path.split("/");

  if (patternParts.length !== pathParts.length) {
    return false;
  }

  return patternParts.every((part, index) => {
    return part.startsWith(":") || part === pathParts[index];
  });
};

const extractParams = (pattern, path) => {
  const patternParts = pattern.split("/");
  const pathParts = path.split("/");
  const params = {};

  patternParts.forEach((part, index) => {
    if (part.startsWith(":")) {
      const paramName = part.slice(1);
      params[paramName] = pathParts[index];
    }
  });

  return params;
};

const parseQueryString = (search) => {
  const params = new URLSearchParams(search);
  const query = {};

  for (const [key, value] of params.entries()) {
    if (query[key]) {
      if (Array.isArray(query[key])) {
        query[key].push(value);
      } else {
        query[key] = [query[key], value];
      }
    } else {
      query[key] = value;
    }
  }

  return query;
};

const buildQueryString = (query) => {
  const params = new URLSearchParams();

  Object.entries(query).forEach(([key, value]) => {
    if (Array.isArray(value)) {
      value.forEach((v) => params.append(key, v));
    } else if (value !== null && value !== undefined) {
      params.append(key, value);
    }
  });

  return params.toString();
};

const showConfirmDialog = (message) => {
  return new Promise((resolve) => {
    const confirmed = window.confirm(message);
    resolve(confirmed);
  });
};

const getRouteConfig = (path) => {
  // This would typically come from a route configuration
  const routeConfigs = {
    [ROUTES.DASHBOARD]: {
      dataLoader: async ({ params, query, getState }) => {
        const response = await fetch("/api/dashboard-data");
        return response.json();
      },
    },
    [ROUTES.PRODUCT_DETAIL]: {
      dataLoader: async ({ params, query, getState }) => {
        const response = await fetch(`/api/products/${params.productId}`);
        return response.json();
      },
    },
  };

  for (const [route, config] of Object.entries(routeConfigs)) {
    if (matchRoute(route, path)) {
      return config;
    }
  }

  return null;
};

// Routing slice
const routingSlice = createSlice({
  name: "routing",
  initialState: {
    // Current location
    currentPath: "/",
    previousPath: null,
    params: {},
    query: {},
    hash: "",
    state: null,

    // Navigation state
    isNavigating: false,
    navigationError: null,

    // Route data
    routeData: {},
    isLoadingRouteData: false,
    routeDataError: null,

    // Navigation history
    navigationHistory: [],
    historyIndex: -1,

    // Breadcrumbs
    breadcrumbs: [],

    // Navigation guards
    hasUnsavedChanges: false,
    blockedNavigation: null,

    // Deep linking
    pendingDeepLink: null,

    // Route metadata
    routeMetadata: {},

    // Tab management
    tabs: [],
    activeTabId: null,
  },
  reducers: {
    setCurrentLocation: (state, action) => {
      const { pathname, search, hash, state: locationState } = action.payload;

      state.previousPath = state.currentPath;
      state.currentPath = pathname;
      state.query = parseQueryString(search);
      state.hash = hash;
      state.state = locationState;

      // Extract params based on current route pattern
      const matchedRoute = findMatchingRoute(pathname);
      if (matchedRoute) {
        state.params = extractParams(matchedRoute.pattern, pathname);
      } else {
        state.params = {};
      }

      // Update breadcrumbs
      state.breadcrumbs = generateBreadcrumbs(pathname, state.params);

      // Add to navigation history
      const historyEntry = {
        path: pathname,
        query: state.query,
        timestamp: Date.now(),
      };

      // Remove entries after current index (for back/forward navigation)
      state.navigationHistory = state.navigationHistory.slice(
        0,
        state.historyIndex + 1
      );
      state.navigationHistory.push(historyEntry);
      state.historyIndex = state.navigationHistory.length - 1;

      // Limit history size
      if (state.navigationHistory.length > 50) {
        state.navigationHistory = state.navigationHistory.slice(-50);
        state.historyIndex = state.navigationHistory.length - 1;
      }
    },

    updateQuery: (state, action) => {
      const { query, replace = false } = action.payload;

      if (replace) {
        state.query = query;
      } else {
        state.query = { ...state.query, ...query };
      }

      // Update URL
      const queryString = buildQueryString(state.query);
      const newUrl = state.currentPath + (queryString ? `?${queryString}` : "");
      history.replace(newUrl);
    },

    removeQueryParam: (state, action) => {
      const paramKey = action.payload;
      delete state.query[paramKey];

      // Update URL
      const queryString = buildQueryString(state.query);
      const newUrl = state.currentPath + (queryString ? `?${queryString}` : "");
      history.replace(newUrl);
    },

    setUnsavedChanges: (state, action) => {
      state.hasUnsavedChanges = action.payload;
    },

    setPendingDeepLink: (state, action) => {
      state.pendingDeepLink = action.payload;
    },

    clearPendingDeepLink: (state) => {
      state.pendingDeepLink = null;
    },

    setRouteMetadata: (state, action) => {
      const { path, metadata } = action.payload;
      state.routeMetadata[path] = metadata;
    },

    addTab: (state, action) => {
      const { id, title, path, closable = true } = action.payload;

      // Check if tab already exists
      const existingTab = state.tabs.find((tab) => tab.id === id);
      if (existingTab) {
        state.activeTabId = id;
        return;
      }

      const newTab = {
        id,
        title,
        path,
        closable,
        createdAt: Date.now(),
      };

      state.tabs.push(newTab);
      state.activeTabId = id;
    },

    removeTab: (state, action) => {
      const tabId = action.payload;
      const tabIndex = state.tabs.findIndex((tab) => tab.id === tabId);

      if (tabIndex === -1) return;

      state.tabs.splice(tabIndex, 1);

      // Update active tab if removed tab was active
      if (state.activeTabId === tabId) {
        if (state.tabs.length > 0) {
          // Activate previous tab or first tab
          const newActiveIndex = Math.max(0, tabIndex - 1);
          state.activeTabId = state.tabs[newActiveIndex]?.id || null;
        } else {
          state.activeTabId = null;
        }
      }
    },

    setActiveTab: (state, action) => {
      const tabId = action.payload;
      const tab = state.tabs.find((t) => t.id === tabId);

      if (tab) {
        state.activeTabId = tabId;
      }
    },

    clearNavigationError: (state) => {
      state.navigationError = null;
    },

    clearRouteDataError: (state) => {
      state.routeDataError = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Navigate with guards
      .addCase(navigateWithGuards.pending, (state) => {
        state.isNavigating = true;
        state.navigationError = null;
      })
      .addCase(navigateWithGuards.fulfilled, (state, action) => {
        state.isNavigating = false;

        if (action.payload.blocked) {
          state.blockedNavigation = {
            targetPath: action.payload.path,
            reason: action.payload.reason,
            timestamp: action.payload.timestamp,
          };
        } else {
          state.blockedNavigation = null;
        }
      })
      .addCase(navigateWithGuards.rejected, (state, action) => {
        state.isNavigating = false;
        state.navigationError = action.payload;
      })

      // Load route data
      .addCase(loadRouteData.pending, (state) => {
        state.isLoadingRouteData = true;
        state.routeDataError = null;
      })
      .addCase(loadRouteData.fulfilled, (state, action) => {
        state.isLoadingRouteData = false;

        if (action.payload.data) {
          state.routeData[action.payload.path] = {
            data: action.payload.data,
            timestamp: action.payload.timestamp,
          };
        }
      })
      .addCase(loadRouteData.rejected, (state, action) => {
        state.isLoadingRouteData = false;
        state.routeDataError = action.payload;
      });
  },
});

// Helper functions
const findMatchingRoute = (pathname) => {
  const routes = [
    { pattern: ROUTES.HOME, exact: true },
    { pattern: ROUTES.DASHBOARD, exact: true },
    { pattern: ROUTES.PROFILE, exact: false },
    { pattern: ROUTES.SETTINGS, exact: true },
    { pattern: ROUTES.ADMIN, exact: true },
    { pattern: ROUTES.PRODUCTS, exact: true },
    { pattern: ROUTES.PRODUCT_DETAIL, exact: false },
    { pattern: ROUTES.CHECKOUT, exact: true },
    { pattern: ROUTES.ORDER_HISTORY, exact: true },
  ];

  return routes.find((route) => {
    if (route.exact) {
      return route.pattern === pathname;
    }
    return matchRoute(route.pattern, pathname);
  });
};

const generateBreadcrumbs = (pathname, params) => {
  const breadcrumbs = [];
  const pathParts = pathname.split("/").filter(Boolean);

  let currentPath = "";

  pathParts.forEach((part, index) => {
    currentPath += `/${part}`;

    const breadcrumb = {
      path: currentPath,
      label: getBreadcrumbLabel(currentPath, params),
      isLast: index === pathParts.length - 1,
    };

    breadcrumbs.push(breadcrumb);
  });

  return breadcrumbs;
};

const getBreadcrumbLabel = (path, params) => {
  const labelMap = {
    "/dashboard": "Dashboard",
    "/profile": "Profile",
    "/settings": "Settings",
    "/admin": "Admin",
    "/products": "Products",
    "/checkout": "Checkout",
    "/orders": "Order History",
  };

  // Handle parameterized routes
  if (path.includes("/profile/") && params.userId) {
    return `Profile - ${params.userId}`;
  }

  if (path.includes("/products/") && params.productId) {
    return `Product - ${params.productId}`;
  }

  return labelMap[path] || path.split("/").pop();
};

export const {
  setCurrentLocation,
  updateQuery,
  removeQueryParam,
  setUnsavedChanges,
  setPendingDeepLink,
  clearPendingDeepLink,
  setRouteMetadata,
  addTab,
  removeTab,
  setActiveTab,
  clearNavigationError,
  clearRouteDataError,
} = routingSlice.actions;

// Selectors
export const selectRoutingState = (state) => state.routing;
export const selectCurrentPath = (state) => state.routing.currentPath;
export const selectCurrentParams = (state) => state.routing.params;
export const selectCurrentQuery = (state) => state.routing.query;
export const selectBreadcrumbs = (state) => state.routing.breadcrumbs;
export const selectNavigationHistory = (state) =>
  state.routing.navigationHistory;
export const selectTabs = (state) => state.routing.tabs;
export const selectActiveTab = (state) => {
  const { tabs, activeTabId } = state.routing;
  return tabs.find((tab) => tab.id === activeTabId) || null;
};

// Memoized selectors
export const selectCurrentRoute = createSelector(
  [selectCurrentPath, selectCurrentParams, selectCurrentQuery],
  (path, params, query) => ({
    path,
    params,
    query,
    fullPath:
      path +
      (Object.keys(query).length > 0 ? `?${buildQueryString(query)}` : ""),
  })
);

export const selectRouteData = createSelector(
  [(state) => state.routing.routeData, selectCurrentPath],
  (routeData, currentPath) => routeData[currentPath]?.data || null
);

export const selectCanGoBack = createSelector(
  [(state) => state.routing.historyIndex],
  (historyIndex) => historyIndex > 0
);

export const selectCanGoForward = createSelector(
  [
    (state) => state.routing.navigationHistory,
    (state) => state.routing.historyIndex,
  ],
  (history, historyIndex) => historyIndex < history.length - 1
);

export default routingSlice.reducer;
```

```jsx
// hooks/useAdvancedRouting.js
import { useSelector, useDispatch } from "react-redux";
import { useCallback, useEffect } from "react";
import { useLocation, useNavigate, useParams } from "react-router-dom";
import {
  navigateWithGuards,
  loadRouteData,
  setCurrentLocation,
  updateQuery,
  removeQueryParam,
  setUnsavedChanges,
  addTab,
  removeTab,
  setActiveTab,
  selectRoutingState,
  selectCurrentRoute,
  selectRouteData,
  selectCanGoBack,
  selectCanGoForward,
  selectActiveTab,
  history,
} from "../store/routingSlice";

export const useAdvancedRouting = () => {
  const dispatch = useDispatch();
  const location = useLocation();
  const navigate = useNavigate();
  const params = useParams();

  const routingState = useSelector(selectRoutingState);
  const currentRoute = useSelector(selectCurrentRoute);
  const routeData = useSelector(selectRouteData);
  const canGoBack = useSelector(selectCanGoBack);
  const canGoForward = useSelector(selectCanGoForward);
  const activeTab = useSelector(selectActiveTab);

  // Sync location with Redux state
  useEffect(() => {
    dispatch(
      setCurrentLocation({
        pathname: location.pathname,
        search: location.search,
        hash: location.hash,
        state: location.state,
      })
    );

    // Load route data if needed
    dispatch(
      loadRouteData({
        path: location.pathname,
        params,
        query: routingState.query,
      })
    );
  }, [location, dispatch, params]);

  // Navigation functions
  const navigateTo = useCallback(
    (path, options = {}) => {
      const { replace = false, state = null, withGuards = true } = options;

      if (withGuards) {
        dispatch(navigateWithGuards({ path, replace, state }));
      } else {
        if (replace) {
          navigate(path, { replace: true, state });
        } else {
          navigate(path, { state });
        }
      }
    },
    [dispatch, navigate]
  );

  const goBack = useCallback(() => {
    if (canGoBack) {
      history.back();
    }
  }, [canGoBack]);

  const goForward = useCallback(() => {
    if (canGoForward) {
      history.forward();
    }
  }, [canGoForward]);

  const goToHistoryIndex = useCallback(
    (index) => {
      const targetIndex = routingState.historyIndex - index;
      history.go(targetIndex);
    },
    [routingState.historyIndex]
  );

  // Query parameter management
  const setQueryParam = useCallback(
    (key, value) => {
      dispatch(updateQuery({ query: { [key]: value } }));
    },
    [dispatch]
  );

  const setQueryParams = useCallback(
    (params, replace = false) => {
      dispatch(updateQuery({ query: params, replace }));
    },
    [dispatch]
  );

  const removeQuery = useCallback(
    (key) => {
      dispatch(removeQueryParam(key));
    },
    [dispatch]
  );

  // Unsaved changes management
  const setHasUnsavedChanges = useCallback(
    (hasChanges) => {
      dispatch(setUnsavedChanges(hasChanges));
    },
    [dispatch]
  );

  // Tab management
  const openTab = useCallback(
    (id, title, path, closable = true) => {
      dispatch(addTab({ id, title, path, closable }));
    },
    [dispatch]
  );

  const closeTab = useCallback(
    (tabId) => {
      dispatch(removeTab(tabId));
    },
    [dispatch]
  );

  const switchToTab = useCallback(
    (tabId) => {
      dispatch(setActiveTab(tabId));
      const tab = routingState.tabs.find((t) => t.id === tabId);
      if (tab) {
        navigateTo(tab.path, { withGuards: false });
      }
    },
    [dispatch, routingState.tabs, navigateTo]
  );

  // Route utilities
  const isCurrentRoute = useCallback(
    (path) => {
      return currentRoute.path === path;
    },
    [currentRoute.path]
  );

  const matchesRoute = useCallback(
    (pattern) => {
      const patternParts = pattern.split("/");
      const pathParts = currentRoute.path.split("/");

      if (patternParts.length !== pathParts.length) {
        return false;
      }

      return patternParts.every((part, index) => {
        return part.startsWith(":") || part === pathParts[index];
      });
    },
    [currentRoute.path]
  );

  const buildPath = useCallback((pattern, params = {}, query = {}) => {
    let path = pattern;

    // Replace parameters
    Object.entries(params).forEach(([key, value]) => {
      path = path.replace(`:${key}`, value);
    });

    // Add query string
    const queryString = new URLSearchParams(query).toString();
    if (queryString) {
      path += `?${queryString}`;
    }

    return path;
  }, []);

  return {
    // State
    ...routingState,
    currentRoute,
    routeData,
    canGoBack,
    canGoForward,
    activeTab,

    // Navigation
    navigateTo,
    goBack,
    goForward,
    goToHistoryIndex,

    // Query management
    setQueryParam,
    setQueryParams,
    removeQuery,

    // State management
    setHasUnsavedChanges,

    // Tab management
    openTab,
    closeTab,
    switchToTab,

    // Utilities
    isCurrentRoute,
    matchesRoute,
    buildPath,
  };
};
```

#### Zustand Implementation for Advanced Routing

```javascript
// stores/routingStore.js
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";
import { persist } from "zustand/middleware";
import { createBrowserHistory } from "history";

// Create history instance
export const history = createBrowserHistory();

const ROUTES = {
  HOME: "/",
  DASHBOARD: "/dashboard",
  PROFILE: "/profile/:userId",
  SETTINGS: "/settings",
  ADMIN: "/admin",
  PRODUCTS: "/products",
  PRODUCT_DETAIL: "/products/:productId",
  CHECKOUT: "/checkout",
  ORDER_HISTORY: "/orders",
  NOT_FOUND: "/404",
};

const ROUTE_PERMISSIONS = {
  [ROUTES.ADMIN]: ["admin"],
  [ROUTES.DASHBOARD]: ["user", "admin"],
  [ROUTES.PROFILE]: ["user", "admin"],
  [ROUTES.SETTINGS]: ["user", "admin"],
  [ROUTES.CHECKOUT]: ["user", "admin"],
  [ROUTES.ORDER_HISTORY]: ["user", "admin"],
};

const useRoutingStore = create(
  persist(
    subscribeWithSelector(
      immer((set, get) => ({
        // Current location
        currentPath: "/",
        previousPath: null,
        params: {},
        query: {},
        hash: "",
        state: null,

        // Navigation state
        isNavigating: false,
        navigationError: null,

        // Route data
        routeData: {},
        isLoadingRouteData: false,
        routeDataError: null,

        // Navigation history
        navigationHistory: [],
        historyIndex: -1,

        // Breadcrumbs
        breadcrumbs: [],

        // Navigation guards
        hasUnsavedChanges: false,
        blockedNavigation: null,

        // Deep linking
        pendingDeepLink: null,

        // Route metadata
        routeMetadata: {},

        // Tab management
        tabs: [],
        activeTabId: null,

        // Actions
        setCurrentLocation: (location) => {
          set((draft) => {
            const { pathname, search, hash, state: locationState } = location;

            draft.previousPath = draft.currentPath;
            draft.currentPath = pathname;
            draft.query = get().parseQueryString(search);
            draft.hash = hash;
            draft.state = locationState;

            // Extract params
            const matchedRoute = get().findMatchingRoute(pathname);
            if (matchedRoute) {
              draft.params = get().extractParams(
                matchedRoute.pattern,
                pathname
              );
            } else {
              draft.params = {};
            }

            // Update breadcrumbs
            draft.breadcrumbs = get().generateBreadcrumbs(
              pathname,
              draft.params
            );

            // Add to navigation history
            const historyEntry = {
              path: pathname,
              query: draft.query,
              timestamp: Date.now(),
            };

            draft.navigationHistory = draft.navigationHistory.slice(
              0,
              draft.historyIndex + 1
            );
            draft.navigationHistory.push(historyEntry);
            draft.historyIndex = draft.navigationHistory.length - 1;

            if (draft.navigationHistory.length > 50) {
              draft.navigationHistory = draft.navigationHistory.slice(-50);
              draft.historyIndex = draft.navigationHistory.length - 1;
            }
          });
        },

        navigateWithGuards: async (path, replace = false, state = null) => {
          try {
            set((draft) => {
              draft.isNavigating = true;
              draft.navigationError = null;
            });

            const currentState = get();

            // Get auth state (assuming it's available globally or passed)
            const authState = window.__AUTH_STATE__ || {
              isAuthenticated: false,
              user: null,
            };

            // Check authentication
            if (!authState.isAuthenticated && get().requiresAuth(path)) {
              const loginPath = `/login?returnTo=${encodeURIComponent(path)}`;
              if (replace) {
                history.replace(loginPath, state);
              } else {
                history.push(loginPath, state);
              }

              set((draft) => {
                draft.isNavigating = false;
                draft.blockedNavigation = {
                  targetPath: loginPath,
                  reason: "authentication_required",
                  timestamp: Date.now(),
                };
              });
              return;
            }

            // Check permissions
            const requiredPermissions = get().getRoutePermissions(path);
            if (requiredPermissions.length > 0) {
              const hasPermission = requiredPermissions.some((permission) =>
                authState.user?.permissions?.includes(permission)
              );

              if (!hasPermission) {
                const forbiddenPath = "/403";
                if (replace) {
                  history.replace(forbiddenPath, state);
                } else {
                  history.push(forbiddenPath, state);
                }

                set((draft) => {
                  draft.isNavigating = false;
                  draft.blockedNavigation = {
                    targetPath: forbiddenPath,
                    reason: "insufficient_permissions",
                    timestamp: Date.now(),
                  };
                });
                return;
              }
            }

            // Check unsaved changes
            if (
              currentState.hasUnsavedChanges &&
              currentState.currentPath !== path
            ) {
              const confirmed = await get().showConfirmDialog(
                "You have unsaved changes. Are you sure you want to leave?"
              );

              if (!confirmed) {
                set((draft) => {
                  draft.isNavigating = false;
                  draft.blockedNavigation = {
                    targetPath: currentState.currentPath,
                    reason: "user_cancelled",
                    timestamp: Date.now(),
                  };
                });
                return;
              }
            }

            // Perform navigation
            if (replace) {
              history.replace(path, state);
            } else {
              history.push(path, state);
            }

            set((draft) => {
              draft.isNavigating = false;
              draft.blockedNavigation = null;
            });
          } catch (error) {
            set((draft) => {
              draft.isNavigating = false;
              draft.navigationError = {
                message: error.message,
                path,
                timestamp: Date.now(),
              };
            });
          }
        },

        loadRouteData: async (path, params, query) => {
          try {
            set((draft) => {
              draft.isLoadingRouteData = true;
              draft.routeDataError = null;
            });

            const routeConfig = get().getRouteConfig(path);

            if (!routeConfig?.dataLoader) {
              set((draft) => {
                draft.isLoadingRouteData = false;
              });
              return;
            }

            const data = await routeConfig.dataLoader({
              params,
              query,
              getState: get,
            });

            set((draft) => {
              draft.isLoadingRouteData = false;
              draft.routeData[path] = {
                data,
                timestamp: Date.now(),
              };
            });
          } catch (error) {
            set((draft) => {
              draft.isLoadingRouteData = false;
              draft.routeDataError = {
                message: error.message,
                path,
                timestamp: Date.now(),
              };
            });
          }
        },

        updateQuery: (query, replace = false) => {
          set((draft) => {
            if (replace) {
              draft.query = query;
            } else {
              draft.query = { ...draft.query, ...query };
            }

            // Update URL
            const queryString = get().buildQueryString(draft.query);
            const newUrl =
              draft.currentPath + (queryString ? `?${queryString}` : "");
            history.replace(newUrl);
          });
        },

        removeQueryParam: (paramKey) => {
          set((draft) => {
            delete draft.query[paramKey];

            const queryString = get().buildQueryString(draft.query);
            const newUrl =
              draft.currentPath + (queryString ? `?${queryString}` : "");
            history.replace(newUrl);
          });
        },

        setUnsavedChanges: (hasChanges) => {
          set((draft) => {
            draft.hasUnsavedChanges = hasChanges;
          });
        },

        addTab: (id, title, path, closable = true) => {
          set((draft) => {
            const existingTab = draft.tabs.find((tab) => tab.id === id);
            if (existingTab) {
              draft.activeTabId = id;
              return;
            }

            const newTab = {
              id,
              title,
              path,
              closable,
              createdAt: Date.now(),
            };

            draft.tabs.push(newTab);
            draft.activeTabId = id;
          });
        },

        removeTab: (tabId) => {
          set((draft) => {
            const tabIndex = draft.tabs.findIndex((tab) => tab.id === tabId);

            if (tabIndex === -1) return;

            draft.tabs.splice(tabIndex, 1);

            if (draft.activeTabId === tabId) {
              if (draft.tabs.length > 0) {
                const newActiveIndex = Math.max(0, tabIndex - 1);
                draft.activeTabId = draft.tabs[newActiveIndex]?.id || null;
              } else {
                draft.activeTabId = null;
              }
            }
          });
        },

        setActiveTab: (tabId) => {
          set((draft) => {
            const tab = draft.tabs.find((t) => t.id === tabId);
            if (tab) {
              draft.activeTabId = tabId;
            }
          });
        },

        // Utility methods
        parseQueryString: (search) => {
          const params = new URLSearchParams(search);
          const query = {};

          for (const [key, value] of params.entries()) {
            if (query[key]) {
              if (Array.isArray(query[key])) {
                query[key].push(value);
              } else {
                query[key] = [query[key], value];
              }
            } else {
              query[key] = value;
            }
          }

          return query;
        },

        buildQueryString: (query) => {
          const params = new URLSearchParams();

          Object.entries(query).forEach(([key, value]) => {
            if (Array.isArray(value)) {
              value.forEach((v) => params.append(key, v));
            } else if (value !== null && value !== undefined) {
              params.append(key, value);
            }
          });

          return params.toString();
        },

        requiresAuth: (path) => {
          const publicRoutes = [
            ROUTES.HOME,
            "/login",
            "/register",
            "/forgot-password",
          ];
          return !publicRoutes.some((route) => path.startsWith(route));
        },

        getRoutePermissions: (path) => {
          for (const [route, permissions] of Object.entries(
            ROUTE_PERMISSIONS
          )) {
            if (get().matchRoute(route, path)) {
              return permissions;
            }
          }
          return [];
        },

        matchRoute: (pattern, path) => {
          const patternParts = pattern.split("/");
          const pathParts = path.split("/");

          if (patternParts.length !== pathParts.length) {
            return false;
          }

          return patternParts.every((part, index) => {
            return part.startsWith(":") || part === pathParts[index];
          });
        },

        extractParams: (pattern, path) => {
          const patternParts = pattern.split("/");
          const pathParts = path.split("/");
          const params = {};

          patternParts.forEach((part, index) => {
            if (part.startsWith(":")) {
              const paramName = part.slice(1);
              params[paramName] = pathParts[index];
            }
          });

          return params;
        },

        findMatchingRoute: (pathname) => {
          const routes = [
            { pattern: ROUTES.HOME, exact: true },
            { pattern: ROUTES.DASHBOARD, exact: true },
            { pattern: ROUTES.PROFILE, exact: false },
            { pattern: ROUTES.SETTINGS, exact: true },
            { pattern: ROUTES.ADMIN, exact: true },
            { pattern: ROUTES.PRODUCTS, exact: true },
            { pattern: ROUTES.PRODUCT_DETAIL, exact: false },
            { pattern: ROUTES.CHECKOUT, exact: true },
            { pattern: ROUTES.ORDER_HISTORY, exact: true },
          ];

          return routes.find((route) => {
            if (route.exact) {
              return route.pattern === pathname;
            }
            return get().matchRoute(route.pattern, pathname);
          });
        },

        generateBreadcrumbs: (pathname, params) => {
          const breadcrumbs = [];
          const pathParts = pathname.split("/").filter(Boolean);

          let currentPath = "";

          pathParts.forEach((part, index) => {
            currentPath += `/${part}`;

            const breadcrumb = {
              path: currentPath,
              label: get().getBreadcrumbLabel(currentPath, params),
              isLast: index === pathParts.length - 1,
            };

            breadcrumbs.push(breadcrumb);
          });

          return breadcrumbs;
        },

        getBreadcrumbLabel: (path, params) => {
          const labelMap = {
            "/dashboard": "Dashboard",
            "/profile": "Profile",
            "/settings": "Settings",
            "/admin": "Admin",
            "/products": "Products",
            "/checkout": "Checkout",
            "/orders": "Order History",
          };

          if (path.includes("/profile/") && params.userId) {
            return `Profile - ${params.userId}`;
          }

          if (path.includes("/products/") && params.productId) {
            return `Product - ${params.productId}`;
          }

          return labelMap[path] || path.split("/").pop();
        },

        getRouteConfig: (path) => {
          const routeConfigs = {
            [ROUTES.DASHBOARD]: {
              dataLoader: async ({ params, query, getState }) => {
                const response = await fetch("/api/dashboard-data");
                return response.json();
              },
            },
            [ROUTES.PRODUCT_DETAIL]: {
              dataLoader: async ({ params, query, getState }) => {
                const response = await fetch(
                  `/api/products/${params.productId}`
                );
                return response.json();
              },
            },
          };

          for (const [route, config] of Object.entries(routeConfigs)) {
            if (get().matchRoute(route, path)) {
              return config;
            }
          }

          return null;
        },

        showConfirmDialog: (message) => {
          return new Promise((resolve) => {
            const confirmed = window.confirm(message);
            resolve(confirmed);
          });
        },

        // Selectors
        getCurrentRoute: () => {
          const state = get();
          return {
            path: state.currentPath,
            params: state.params,
            query: state.query,
            fullPath:
              state.currentPath +
              (Object.keys(state.query).length > 0
                ? `?${state.buildQueryString(state.query)}`
                : ""),
          };
        },

        getRouteData: () => {
          const state = get();
          return state.routeData[state.currentPath]?.data || null;
        },

        getCanGoBack: () => {
          const state = get();
          return state.historyIndex > 0;
        },

        getCanGoForward: () => {
          const state = get();
          return state.historyIndex < state.navigationHistory.length - 1;
        },

        getActiveTab: () => {
          const state = get();
          return state.tabs.find((tab) => tab.id === state.activeTabId) || null;
        },
      }))
    ),
    {
      name: "routing-store",
      partialize: (state) => ({
        navigationHistory: state.navigationHistory,
        tabs: state.tabs,
        routeMetadata: state.routeMetadata,
      }),
    }
  )
);

export { ROUTES, ROUTE_PERMISSIONS };
export default useRoutingStore;
```

```jsx
// hooks/useZustandAdvancedRouting.js
import { useCallback, useEffect } from "react";
import { useLocation, useNavigate, useParams } from "react-router-dom";
import useRoutingStore, { history } from "../stores/routingStore";

export const useZustandAdvancedRouting = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const params = useParams();

  const {
    // State
    currentPath,
    previousPath,
    params: routeParams,
    query,
    hash,
    state,
    isNavigating,
    navigationError,
    routeData,
    isLoadingRouteData,
    routeDataError,
    navigationHistory,
    historyIndex,
    breadcrumbs,
    hasUnsavedChanges,
    blockedNavigation,
    pendingDeepLink,
    routeMetadata,
    tabs,
    activeTabId,

    // Actions
    setCurrentLocation,
    navigateWithGuards,
    loadRouteData,
    updateQuery,
    removeQueryParam,
    setUnsavedChanges,
    addTab,
    removeTab,
    setActiveTab,

    // Selectors
    getCurrentRoute,
    getRouteData,
    getCanGoBack,
    getCanGoForward,
    getActiveTab,
  } = useRoutingStore();

  // Sync location with store
  useEffect(() => {
    setCurrentLocation({
      pathname: location.pathname,
      search: location.search,
      hash: location.hash,
      state: location.state,
    });

    // Load route data if needed
    loadRouteData(location.pathname, params, query);
  }, [location, setCurrentLocation, loadRouteData, params, query]);

  // Navigation functions
  const navigateTo = useCallback(
    (path, options = {}) => {
      const { replace = false, state = null, withGuards = true } = options;

      if (withGuards) {
        navigateWithGuards(path, replace, state);
      } else {
        if (replace) {
          navigate(path, { replace: true, state });
        } else {
          navigate(path, { state });
        }
      }
    },
    [navigateWithGuards, navigate]
  );

  const goBack = useCallback(() => {
    if (getCanGoBack()) {
      history.back();
    }
  }, [getCanGoBack]);

  const goForward = useCallback(() => {
    if (getCanGoForward()) {
      history.forward();
    }
  }, [getCanGoForward]);

  const goToHistoryIndex = useCallback(
    (index) => {
      const targetIndex = historyIndex - index;
      history.go(targetIndex);
    },
    [historyIndex]
  );

  // Query parameter management
  const setQueryParam = useCallback(
    (key, value) => {
      updateQuery({ [key]: value });
    },
    [updateQuery]
  );

  const setQueryParams = useCallback(
    (params, replace = false) => {
      updateQuery(params, replace);
    },
    [updateQuery]
  );

  const removeQuery = useCallback(
    (key) => {
      removeQueryParam(key);
    },
    [removeQueryParam]
  );

  // Tab management
  const openTab = useCallback(
    (id, title, path, closable = true) => {
      addTab(id, title, path, closable);
    },
    [addTab]
  );

  const closeTab = useCallback(
    (tabId) => {
      removeTab(tabId);
    },
    [removeTab]
  );

  const switchToTab = useCallback(
    (tabId) => {
      setActiveTab(tabId);
      const tab = tabs.find((t) => t.id === tabId);
      if (tab) {
        navigateTo(tab.path, { withGuards: false });
      }
    },
    [setActiveTab, tabs, navigateTo]
  );

  // Route utilities
  const isCurrentRoute = useCallback(
    (path) => {
      return currentPath === path;
    },
    [currentPath]
  );

  const matchesRoute = useCallback(
    (pattern) => {
      const patternParts = pattern.split("/");
      const pathParts = currentPath.split("/");

      if (patternParts.length !== pathParts.length) {
        return false;
      }

      return patternParts.every((part, index) => {
        return part.startsWith(":") || part === pathParts[index];
      });
    },
    [currentPath]
  );

  const buildPath = useCallback((pattern, params = {}, query = {}) => {
    let path = pattern;

    // Replace parameters
    Object.entries(params).forEach(([key, value]) => {
      path = path.replace(`:${key}`, value);
    });

    // Add query string
    const queryString = new URLSearchParams(query).toString();
    if (queryString) {
      path += `?${queryString}`;
    }

    return path;
  }, []);

  return {
    // State
    currentPath,
    previousPath,
    params: routeParams,
    query,
    hash,
    state,
    isNavigating,
    navigationError,
    routeData: getRouteData(),
    isLoadingRouteData,
    routeDataError,
    navigationHistory,
    historyIndex,
    breadcrumbs,
    hasUnsavedChanges,
    blockedNavigation,
    pendingDeepLink,
    routeMetadata,
    tabs,
    activeTabId,
    currentRoute: getCurrentRoute(),
    canGoBack: getCanGoBack(),
    canGoForward: getCanGoForward(),
    activeTab: getActiveTab(),

    // Navigation
    navigateTo,
    goBack,
    goForward,
    goToHistoryIndex,

    // Query management
    setQueryParam,
    setQueryParams,
    removeQuery,

    // State management
    setHasUnsavedChanges: setUnsavedChanges,

    // Tab management
    openTab,
    closeTab,
    switchToTab,

    // Utilities
    isCurrentRoute,
    matchesRoute,
    buildPath,
  };
};
```

#### Best Practices

1. **Navigation Guards**:

   - Implement authentication and authorization checks
   - Handle unsaved changes confirmation
   - Provide clear error messages for blocked navigation
   - Support async guard functions

2. **Route Data Management**:

   - Implement route-level data loading
   - Cache route data appropriately
   - Handle loading and error states
   - Support data prefetching

3. **Query Parameter Handling**:

   - Provide utilities for query manipulation
   - Support complex query structures
   - Maintain query state consistency
   - Handle URL encoding/decoding

4. **Navigation History**:
   - Track navigation history for analytics
   - Support programmatic history navigation
   - Implement breadcrumb generation
   - Handle browser back/forward buttons

**Comparison Summary:**

| Feature            | Redux         | Zustand      |
| ------------------ | ------------- | ------------ |
| Setup Complexity   | High          | Medium       |
| Navigation Guards  | Structured    | Flexible     |
| Route Data Loading | Async Thunks  | Direct Async |
| History Management | Detailed      | Simplified   |
| Query Handling     | Comprehensive | Streamlined  |
| DevTools           | Excellent     | Limited      |
| Bundle Size        | Larger        | Smaller      |
| Type Safety        | Good          | Excellent    |

---

### 48. How do you implement advanced testing strategies for Redux vs Zustand applications?

**Answer:**

Advanced testing strategies for state management involve unit testing, integration testing, end-to-end testing, mocking, test utilities, and performance testing. Both Redux and Zustand require different approaches for comprehensive testing coverage.

#### Redux Testing Implementation

```javascript
// __tests__/store/userSlice.test.js
import { configureStore } from "@reduxjs/toolkit";
import { renderHook, act } from "@testing-library/react";
import { Provider } from "react-redux";
import userSlice, {
  fetchUser,
  updateUser,
  deleteUser,
  selectUser,
  selectUserStatus,
} from "../../store/userSlice";
import { setupServer } from "msw/node";
import { rest } from "msw";

// Mock server setup
const server = setupServer(
  rest.get("/api/users/:id", (req, res, ctx) => {
    const { id } = req.params;
    return res(
      ctx.json({
        id,
        name: "John Doe",
        email: "john@example.com",
        role: "user",
      })
    );
  }),

  rest.put("/api/users/:id", (req, res, ctx) => {
    return res(
      ctx.json({
        id: req.params.id,
        ...req.body,
        updatedAt: new Date().toISOString(),
      })
    );
  }),

  rest.delete("/api/users/:id", (req, res, ctx) => {
    return res(ctx.status(204));
  })
);

// Test utilities
const createTestStore = (preloadedState = {}) => {
  return configureStore({
    reducer: {
      user: userSlice,
    },
    preloadedState,
    middleware: (getDefaultMiddleware) =>
      getDefaultMiddleware({
        serializableCheck: false,
      }),
  });
};

const renderWithProvider = (
  ui,
  {
    preloadedState = {},
    store = createTestStore(preloadedState),
    ...renderOptions
  } = {}
) => {
  const Wrapper = ({ children }) => (
    <Provider store={store}>{children}</Provider>
  );

  return {
    store,
    ...render(ui, { wrapper: Wrapper, ...renderOptions }),
  };
};

const createMockDispatch = () => {
  const dispatch = jest.fn();
  dispatch.mockImplementation((action) => {
    if (typeof action === "function") {
      return action(dispatch, () => ({}), undefined);
    }
    return action;
  });
  return dispatch;
};

// Setup and teardown
beforeAll(() => server.listen());
afterEach(() => {
  server.resetHandlers();
  jest.clearAllMocks();
});
afterAll(() => server.close());

describe("userSlice", () => {
  describe("reducers", () => {
    it("should handle initial state", () => {
      const initialState = userSlice.reducer(undefined, { type: "unknown" });

      expect(initialState).toEqual({
        data: null,
        status: "idle",
        error: null,
        lastUpdated: null,
        cache: {},
      });
    });

    it("should handle setUser", () => {
      const user = { id: "1", name: "John Doe", email: "john@example.com" };
      const action = { type: "user/setUser", payload: user };
      const state = userSlice.reducer(undefined, action);

      expect(state.data).toEqual(user);
      expect(state.lastUpdated).toBeDefined();
    });

    it("should handle clearUser", () => {
      const initialState = {
        data: { id: "1", name: "John Doe" },
        status: "succeeded",
        error: null,
        lastUpdated: Date.now(),
        cache: {},
      };

      const action = { type: "user/clearUser" };
      const state = userSlice.reducer(initialState, action);

      expect(state.data).toBeNull();
      expect(state.status).toBe("idle");
      expect(state.error).toBeNull();
    });
  });

  describe("async thunks", () => {
    it("should handle fetchUser.pending", () => {
      const action = { type: fetchUser.pending.type };
      const state = userSlice.reducer(undefined, action);

      expect(state.status).toBe("loading");
      expect(state.error).toBeNull();
    });

    it("should handle fetchUser.fulfilled", () => {
      const user = { id: "1", name: "John Doe", email: "john@example.com" };
      const action = {
        type: fetchUser.fulfilled.type,
        payload: user,
      };
      const state = userSlice.reducer(undefined, action);

      expect(state.status).toBe("succeeded");
      expect(state.data).toEqual(user);
      expect(state.error).toBeNull();
    });

    it("should handle fetchUser.rejected", () => {
      const error = "Failed to fetch user";
      const action = {
        type: fetchUser.rejected.type,
        payload: error,
      };
      const state = userSlice.reducer(undefined, action);

      expect(state.status).toBe("failed");
      expect(state.error).toBe(error);
      expect(state.data).toBeNull();
    });
  });

  describe("selectors", () => {
    const mockState = {
      user: {
        data: { id: "1", name: "John Doe", email: "john@example.com" },
        status: "succeeded",
        error: null,
        lastUpdated: Date.now(),
        cache: {},
      },
    };

    it("should select user data", () => {
      const result = selectUser(mockState);
      expect(result).toEqual(mockState.user.data);
    });

    it("should select user status", () => {
      const result = selectUserStatus(mockState);
      expect(result).toBe("succeeded");
    });

    it("should return null for empty user data", () => {
      const emptyState = {
        user: {
          data: null,
          status: "idle",
          error: null,
          lastUpdated: null,
          cache: {},
        },
      };

      const result = selectUser(emptyState);
      expect(result).toBeNull();
    });
  });
});

describe("async thunk integration", () => {
  let store;

  beforeEach(() => {
    store = createTestStore();
  });

  it("should fetch user successfully", async () => {
    const userId = "1";

    await store.dispatch(fetchUser(userId));

    const state = store.getState();
    expect(state.user.status).toBe("succeeded");
    expect(state.user.data).toEqual({
      id: userId,
      name: "John Doe",
      email: "john@example.com",
      role: "user",
    });
  });

  it("should handle fetch user error", async () => {
    server.use(
      rest.get("/api/users/:id", (req, res, ctx) => {
        return res(ctx.status(404), ctx.json({ message: "User not found" }));
      })
    );

    await store.dispatch(fetchUser("999"));

    const state = store.getState();
    expect(state.user.status).toBe("failed");
    expect(state.user.error).toBeDefined();
  });

  it("should update user successfully", async () => {
    // First fetch a user
    await store.dispatch(fetchUser("1"));

    const updateData = { name: "Jane Doe", email: "jane@example.com" };
    await store.dispatch(updateUser({ id: "1", ...updateData }));

    const state = store.getState();
    expect(state.user.data.name).toBe("Jane Doe");
    expect(state.user.data.email).toBe("jane@example.com");
  });

  it("should delete user successfully", async () => {
    // First fetch a user
    await store.dispatch(fetchUser("1"));

    await store.dispatch(deleteUser("1"));

    const state = store.getState();
    expect(state.user.data).toBeNull();
    expect(state.user.status).toBe("idle");
  });
});

// Performance testing
describe("performance tests", () => {
  it("should handle large state updates efficiently", () => {
    const largeUserList = Array.from({ length: 1000 }, (_, i) => ({
      id: i.toString(),
      name: `User ${i}`,
      email: `user${i}@example.com`,
    }));

    const startTime = performance.now();

    let state = userSlice.reducer(undefined, { type: "unknown" });

    largeUserList.forEach((user) => {
      state = userSlice.reducer(state, {
        type: "user/setUser",
        payload: user,
      });
    });

    const endTime = performance.now();
    const duration = endTime - startTime;

    expect(duration).toBeLessThan(100); // Should complete in less than 100ms
  });

  it("should handle rapid state changes", () => {
    const store = createTestStore();
    const iterations = 100;

    const startTime = performance.now();

    for (let i = 0; i < iterations; i++) {
      store.dispatch({
        type: "user/setUser",
        payload: {
          id: i.toString(),
          name: `User ${i}`,
          email: `user${i}@example.com`,
        },
      });
    }

    const endTime = performance.now();
    const duration = endTime - startTime;

    expect(duration).toBeLessThan(50); // Should complete in less than 50ms
  });
});

// Memory leak testing
describe("memory leak tests", () => {
  it("should not leak memory with repeated store creation", () => {
    const initialMemory = process.memoryUsage().heapUsed;

    for (let i = 0; i < 100; i++) {
      const store = createTestStore();
      store.dispatch({ type: "user/setUser", payload: { id: i.toString() } });
    }

    // Force garbage collection if available
    if (global.gc) {
      global.gc();
    }

    const finalMemory = process.memoryUsage().heapUsed;
    const memoryIncrease = finalMemory - initialMemory;

    // Memory increase should be reasonable (less than 10MB)
    expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024);
  });
});
```

```javascript
// __tests__/hooks/useUser.test.js
import { renderHook, act } from "@testing-library/react";
import { Provider } from "react-redux";
import { configureStore } from "@reduxjs/toolkit";
import userSlice from "../../store/userSlice";
import { useUser } from "../../hooks/useUser";

const createWrapper = (preloadedState = {}) => {
  const store = configureStore({
    reducer: { user: userSlice },
    preloadedState,
  });

  return ({ children }) => <Provider store={store}>{children}</Provider>;
};

describe("useUser hook", () => {
  it("should return initial state", () => {
    const wrapper = createWrapper();
    const { result } = renderHook(() => useUser(), { wrapper });

    expect(result.current.user).toBeNull();
    expect(result.current.status).toBe("idle");
    expect(result.current.error).toBeNull();
    expect(result.current.isLoading).toBe(false);
  });

  it("should return user data when available", () => {
    const userData = {
      id: "1",
      name: "John Doe",
      email: "john@example.com",
    };

    const wrapper = createWrapper({
      user: {
        data: userData,
        status: "succeeded",
        error: null,
        lastUpdated: Date.now(),
        cache: {},
      },
    });

    const { result } = renderHook(() => useUser(), { wrapper });

    expect(result.current.user).toEqual(userData);
    expect(result.current.status).toBe("succeeded");
    expect(result.current.isLoading).toBe(false);
  });

  it("should handle loading state", () => {
    const wrapper = createWrapper({
      user: {
        data: null,
        status: "loading",
        error: null,
        lastUpdated: null,
        cache: {},
      },
    });

    const { result } = renderHook(() => useUser(), { wrapper });

    expect(result.current.isLoading).toBe(true);
    expect(result.current.status).toBe("loading");
  });

  it("should handle error state", () => {
    const errorMessage = "Failed to fetch user";
    const wrapper = createWrapper({
      user: {
        data: null,
        status: "failed",
        error: errorMessage,
        lastUpdated: null,
        cache: {},
      },
    });

    const { result } = renderHook(() => useUser(), { wrapper });

    expect(result.current.error).toBe(errorMessage);
    expect(result.current.status).toBe("failed");
    expect(result.current.isLoading).toBe(false);
  });
});
```

#### Zustand Testing Implementation

```javascript
// __tests__/stores/userStore.test.js
import { act, renderHook } from "@testing-library/react";
import { create } from "zustand";
import { setupServer } from "msw/node";
import { rest } from "msw";
import useUserStore from "../../stores/userStore";

// Mock server setup
const server = setupServer(
  rest.get("/api/users/:id", (req, res, ctx) => {
    const { id } = req.params;
    return res(
      ctx.json({
        id,
        name: "John Doe",
        email: "john@example.com",
        role: "user",
      })
    );
  }),

  rest.put("/api/users/:id", (req, res, ctx) => {
    return res(
      ctx.json({
        id: req.params.id,
        ...req.body,
        updatedAt: new Date().toISOString(),
      })
    );
  }),

  rest.delete("/api/users/:id", (req, res, ctx) => {
    return res(ctx.status(204));
  })
);

// Test utilities
const createTestStore = (initialState = {}) => {
  return create((set, get) => ({
    // Default state
    user: null,
    status: "idle",
    error: null,
    lastUpdated: null,
    cache: {},

    // Override with initial state
    ...initialState,

    // Actions
    setUser: (user) => set({ user, lastUpdated: Date.now() }),
    clearUser: () => set({ user: null, status: "idle", error: null }),
    setStatus: (status) => set({ status }),
    setError: (error) => set({ error, status: "failed" }),

    fetchUser: async (id) => {
      set({ status: "loading", error: null });
      try {
        const response = await fetch(`/api/users/${id}`);
        if (!response.ok) {
          throw new Error("Failed to fetch user");
        }
        const user = await response.json();
        set({
          user,
          status: "succeeded",
          error: null,
          lastUpdated: Date.now(),
        });
        return user;
      } catch (error) {
        set({ error: error.message, status: "failed" });
        throw error;
      }
    },

    updateUser: async (userData) => {
      set({ status: "loading", error: null });
      try {
        const response = await fetch(`/api/users/${userData.id}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(userData),
        });
        if (!response.ok) {
          throw new Error("Failed to update user");
        }
        const updatedUser = await response.json();
        set({
          user: updatedUser,
          status: "succeeded",
          error: null,
          lastUpdated: Date.now(),
        });
        return updatedUser;
      } catch (error) {
        set({ error: error.message, status: "failed" });
        throw error;
      }
    },

    deleteUser: async (id) => {
      set({ status: "loading", error: null });
      try {
        const response = await fetch(`/api/users/${id}`, {
          method: "DELETE",
        });
        if (!response.ok) {
          throw new Error("Failed to delete user");
        }
        set({ user: null, status: "idle", error: null });
      } catch (error) {
        set({ error: error.message, status: "failed" });
        throw error;
      }
    },
  }));
};

// Setup and teardown
beforeAll(() => server.listen());
afterEach(() => {
  server.resetHandlers();
  jest.clearAllMocks();
});
afterAll(() => server.close());

describe("userStore", () => {
  let useStore;

  beforeEach(() => {
    useStore = createTestStore();
  });

  describe("initial state", () => {
    it("should have correct initial state", () => {
      const { result } = renderHook(() => useStore());

      expect(result.current.user).toBeNull();
      expect(result.current.status).toBe("idle");
      expect(result.current.error).toBeNull();
      expect(result.current.lastUpdated).toBeNull();
    });
  });

  describe("actions", () => {
    it("should set user", () => {
      const { result } = renderHook(() => useStore());
      const user = { id: "1", name: "John Doe", email: "john@example.com" };

      act(() => {
        result.current.setUser(user);
      });

      expect(result.current.user).toEqual(user);
      expect(result.current.lastUpdated).toBeDefined();
    });

    it("should clear user", () => {
      const { result } = renderHook(() => useStore());
      const user = { id: "1", name: "John Doe", email: "john@example.com" };

      act(() => {
        result.current.setUser(user);
      });

      expect(result.current.user).toEqual(user);

      act(() => {
        result.current.clearUser();
      });

      expect(result.current.user).toBeNull();
      expect(result.current.status).toBe("idle");
      expect(result.current.error).toBeNull();
    });

    it("should set status", () => {
      const { result } = renderHook(() => useStore());

      act(() => {
        result.current.setStatus("loading");
      });

      expect(result.current.status).toBe("loading");
    });

    it("should set error", () => {
      const { result } = renderHook(() => useStore());
      const errorMessage = "Something went wrong";

      act(() => {
        result.current.setError(errorMessage);
      });

      expect(result.current.error).toBe(errorMessage);
      expect(result.current.status).toBe("failed");
    });
  });

  describe("async actions", () => {
    it("should fetch user successfully", async () => {
      const { result } = renderHook(() => useStore());

      await act(async () => {
        await result.current.fetchUser("1");
      });

      expect(result.current.status).toBe("succeeded");
      expect(result.current.user).toEqual({
        id: "1",
        name: "John Doe",
        email: "john@example.com",
        role: "user",
      });
      expect(result.current.error).toBeNull();
    });

    it("should handle fetch user error", async () => {
      server.use(
        rest.get("/api/users/:id", (req, res, ctx) => {
          return res(ctx.status(404), ctx.json({ message: "User not found" }));
        })
      );

      const { result } = renderHook(() => useStore());

      await act(async () => {
        try {
          await result.current.fetchUser("999");
        } catch (error) {
          // Expected to throw
        }
      });

      expect(result.current.status).toBe("failed");
      expect(result.current.error).toBeDefined();
      expect(result.current.user).toBeNull();
    });

    it("should update user successfully", async () => {
      const { result } = renderHook(() => useStore());

      // First set a user
      act(() => {
        result.current.setUser({
          id: "1",
          name: "John Doe",
          email: "john@example.com",
        });
      });

      const updateData = {
        id: "1",
        name: "Jane Doe",
        email: "jane@example.com",
      };

      await act(async () => {
        await result.current.updateUser(updateData);
      });

      expect(result.current.user.name).toBe("Jane Doe");
      expect(result.current.user.email).toBe("jane@example.com");
      expect(result.current.status).toBe("succeeded");
    });

    it("should delete user successfully", async () => {
      const { result } = renderHook(() => useStore());

      // First set a user
      act(() => {
        result.current.setUser({
          id: "1",
          name: "John Doe",
          email: "john@example.com",
        });
      });

      await act(async () => {
        await result.current.deleteUser("1");
      });

      expect(result.current.user).toBeNull();
      expect(result.current.status).toBe("idle");
    });
  });
});

// Selector testing
describe("userStore selectors", () => {
  let useStore;

  beforeEach(() => {
    useStore = createTestStore({
      user: { id: "1", name: "John Doe", email: "john@example.com" },
      status: "succeeded",
      error: null,
      lastUpdated: Date.now(),
    });
  });

  it("should select user data", () => {
    const { result } = renderHook(() => useStore((state) => state.user));

    expect(result.current).toEqual({
      id: "1",
      name: "John Doe",
      email: "john@example.com",
    });
  });

  it("should select loading state", () => {
    const { result } = renderHook(() =>
      useStore((state) => state.status === "loading")
    );

    expect(result.current).toBe(false);
  });

  it("should select error state", () => {
    const { result } = renderHook(() => useStore((state) => state.error));

    expect(result.current).toBeNull();
  });
});

// Performance testing
describe("performance tests", () => {
  it("should handle rapid state updates efficiently", () => {
    const useStore = createTestStore();
    const { result } = renderHook(() => useStore());

    const startTime = performance.now();

    act(() => {
      for (let i = 0; i < 1000; i++) {
        result.current.setUser({
          id: i.toString(),
          name: `User ${i}`,
          email: `user${i}@example.com`,
        });
      }
    });

    const endTime = performance.now();
    const duration = endTime - startTime;

    expect(duration).toBeLessThan(100); // Should complete in less than 100ms
  });

  it("should handle large state objects efficiently", () => {
    const largeUser = {
      id: "1",
      name: "John Doe",
      email: "john@example.com",
      metadata: Array.from({ length: 1000 }, (_, i) => ({
        key: `key${i}`,
        value: `value${i}`,
      })),
    };

    const useStore = createTestStore();
    const { result } = renderHook(() => useStore());

    const startTime = performance.now();

    act(() => {
      result.current.setUser(largeUser);
    });

    const endTime = performance.now();
    const duration = endTime - startTime;

    expect(duration).toBeLessThan(50); // Should complete in less than 50ms
    expect(result.current.user).toEqual(largeUser);
  });
});

// Subscription testing
describe("subscription tests", () => {
  it("should notify subscribers on state changes", () => {
    const useStore = createTestStore();
    const subscriber = jest.fn();

    const unsubscribe = useStore.subscribe(subscriber);

    const { result } = renderHook(() => useStore());

    act(() => {
      result.current.setUser({ id: "1", name: "John Doe" });
    });

    expect(subscriber).toHaveBeenCalled();

    unsubscribe();
  });

  it("should not notify unsubscribed listeners", () => {
    const useStore = createTestStore();
    const subscriber = jest.fn();

    const unsubscribe = useStore.subscribe(subscriber);
    unsubscribe();

    const { result } = renderHook(() => useStore());

    act(() => {
      result.current.setUser({ id: "1", name: "John Doe" });
    });

    expect(subscriber).not.toHaveBeenCalled();
  });
});
```

```javascript
// __tests__/integration/userFlow.test.js
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import { Provider } from "react-redux";
import { configureStore } from "@reduxjs/toolkit";
import userSlice from "../../store/userSlice";
import UserProfile from "../../components/UserProfile";
import { setupServer } from "msw/node";
import { rest } from "msw";

// Integration test for complete user flow
const server = setupServer(
  rest.get("/api/users/:id", (req, res, ctx) => {
    return res(
      ctx.json({
        id: req.params.id,
        name: "John Doe",
        email: "john@example.com",
        role: "user",
      })
    );
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

const createTestStore = () => {
  return configureStore({
    reducer: {
      user: userSlice,
    },
  });
};

const renderWithProvider = (ui, { store = createTestStore() } = {}) => {
  return {
    store,
    ...render(<Provider store={store}>{ui}</Provider>),
  };
};

describe("User Profile Integration", () => {
  it("should load and display user profile", async () => {
    const { store } = renderWithProvider(<UserProfile userId="1" />);

    // Should show loading state initially
    expect(screen.getByText(/loading/i)).toBeInTheDocument();

    // Wait for user data to load
    await waitFor(() => {
      expect(screen.getByText("John Doe")).toBeInTheDocument();
    });

    expect(screen.getByText("john@example.com")).toBeInTheDocument();

    // Check store state
    const state = store.getState();
    expect(state.user.status).toBe("succeeded");
    expect(state.user.data.name).toBe("John Doe");
  });

  it("should handle edit user flow", async () => {
    server.use(
      rest.put("/api/users/:id", (req, res, ctx) => {
        return res(
          ctx.json({
            id: req.params.id,
            name: "Jane Doe",
            email: "jane@example.com",
            role: "user",
          })
        );
      })
    );

    const { store } = renderWithProvider(<UserProfile userId="1" />);

    // Wait for initial load
    await waitFor(() => {
      expect(screen.getByText("John Doe")).toBeInTheDocument();
    });

    // Click edit button
    fireEvent.click(screen.getByText(/edit/i));

    // Update name
    const nameInput = screen.getByDisplayValue("John Doe");
    fireEvent.change(nameInput, { target: { value: "Jane Doe" } });

    // Save changes
    fireEvent.click(screen.getByText(/save/i));

    // Wait for update to complete
    await waitFor(() => {
      expect(screen.getByText("Jane Doe")).toBeInTheDocument();
    });

    // Check store state
    const state = store.getState();
    expect(state.user.data.name).toBe("Jane Doe");
  });
});
```

#### Best Practices

1. **Test Structure**:

   - Organize tests by feature/slice
   - Use descriptive test names
   - Group related tests with describe blocks
   - Follow AAA pattern (Arrange, Act, Assert)

2. **Mocking and Isolation**:

   - Mock external dependencies
   - Use MSW for API mocking
   - Isolate units under test
   - Avoid testing implementation details

3. **Test Coverage**:

   - Test reducers/actions separately
   - Test selectors with various state shapes
   - Test async operations and error handling
   - Include integration tests for user flows

4. **Performance Testing**:
   - Test with large datasets
   - Measure execution time
   - Check for memory leaks
   - Test rapid state changes

**Comparison Summary:**

| Feature        | Redux              | Zustand            |
| -------------- | ------------------ | ------------------ |
| Test Setup     | Complex            | Simple             |
| Mocking        | Provider Required  | Direct Store       |
| Async Testing  | Thunk Testing      | Promise Testing    |
| Integration    | Store + Components | Hook + Components  |
| Performance    | DevTools Support   | Manual Measurement |
| Coverage       | Detailed           | Straightforward    |
| Debugging      | Excellent          | Good               |
| Test Utilities | Rich Ecosystem     | Minimal Setup      |

---

### 49. How do you implement advanced debugging and development tools for Redux vs Zustand?

**Answer:**

Advanced debugging and development tools are crucial for maintaining complex state management applications. Both Redux and Zustand offer different approaches to debugging, monitoring, and development tooling.

#### Redux Debugging Implementation

```javascript
// store/debugStore.js
import { configureStore } from "@reduxjs/toolkit";
import { createLogger } from "redux-logger";
import { persistStore, persistReducer } from "redux-persist";
import storage from "redux-persist/lib/storage";
import userSlice from "./userSlice";
import appSlice from "./appSlice";

// Enhanced logger middleware
const logger = createLogger({
  predicate: (getState, action) => {
    // Only log in development
    return process.env.NODE_ENV === "development";
  },
  collapsed: (getState, action, logEntry) => !logEntry.error,
  duration: true,
  timestamp: true,
  level: "info",
  colors: {
    title: () => "#139BFE",
    prevState: () => "#1C5FAF",
    action: () => "#149945",
    nextState: () => "#A47104",
    error: () => "#ff0005",
  },
  diff: true,
  diffPredicate: (getState, action) => {
    const blacklist = ["@@redux-form", "@@router"];
    return blacklist.every((entry) => !action.type.includes(entry));
  },
});

// Custom debugging middleware
const debugMiddleware = (store) => (next) => (action) => {
  const startTime = performance.now();
  const prevState = store.getState();

  // Log action details
  console.group(` Action: ${action.type}`);
  console.log("Payload:", action.payload);
  console.log("Previous State:", prevState);

  const result = next(action);

  const nextState = store.getState();
  const duration = performance.now() - startTime;

  console.log("Next State:", nextState);
  console.log(` Duration: ${duration.toFixed(2)}ms`);

  // Detect state mutations
  if (prevState === nextState && action.type !== "@@INIT") {
    console.warn(" State not updated - possible mutation or missing reducer");
  }

  // Performance warnings
  if (duration > 16) {
    console.warn(
      ` Slow action detected: ${action.type} took ${duration.toFixed(2)}ms`
    );
  }

  console.groupEnd();

  return result;
};

// State snapshot middleware
const snapshotMiddleware = (store) => (next) => (action) => {
  const result = next(action);

  // Save state snapshots for time travel debugging
  if (typeof window !== "undefined" && window.__REDUX_SNAPSHOTS__) {
    window.__REDUX_SNAPSHOTS__.push({
      action,
      state: store.getState(),
      timestamp: Date.now(),
    });

    // Keep only last 50 snapshots
    if (window.__REDUX_SNAPSHOTS__.length > 50) {
      window.__REDUX_SNAPSHOTS__.shift();
    }
  }

  return result;
};

// Error boundary middleware
const errorMiddleware = (store) => (next) => (action) => {
  try {
    return next(action);
  } catch (error) {
    console.error(" Redux Error:", {
      action,
      error: error.message,
      stack: error.stack,
      state: store.getState(),
    });

    // Send error to monitoring service
    if (typeof window !== "undefined" && window.Sentry) {
      window.Sentry.captureException(error, {
        tags: {
          section: "redux",
          action: action.type,
        },
        extra: {
          action,
          state: store.getState(),
        },
      });
    }

    throw error;
  }
};

// Persist configuration
const persistConfig = {
  key: "root",
  storage,
  whitelist: ["user"], // Only persist user state
  debug: process.env.NODE_ENV === "development",
};

const rootReducer = {
  user: userSlice,
  app: appSlice,
};

const persistedReducer = persistReducer(persistConfig, rootReducer);

// Store configuration with debugging tools
export const store = configureStore({
  reducer: persistedReducer,
  middleware: (getDefaultMiddleware) => {
    const middleware = getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ["persist/PERSIST", "persist/REHYDRATE"],
      },
    });

    if (process.env.NODE_ENV === "development") {
      middleware.concat(
        logger,
        debugMiddleware,
        snapshotMiddleware,
        errorMiddleware
      );
    }

    return middleware;
  },
  devTools: process.env.NODE_ENV === "development" && {
    name: "My App",
    trace: true,
    traceLimit: 25,
    actionSanitizer: (action) => ({
      ...action,
      // Sanitize sensitive data
      payload: action.type.includes("password") ? "[REDACTED]" : action.payload,
    }),
    stateSanitizer: (state) => ({
      ...state,
      // Sanitize sensitive state
      user: state.user
        ? {
            ...state.user,
            password: "[REDACTED]",
            token: state.user.token ? "[REDACTED]" : null,
          }
        : null,
    }),
  },
});

export const persistor = persistStore(store);

// Development tools
if (process.env.NODE_ENV === "development") {
  // Initialize snapshots array
  window.__REDUX_SNAPSHOTS__ = [];

  // Global debugging helpers
  window.__REDUX_STORE__ = store;
  window.__REDUX_DEBUG__ = {
    getState: () => store.getState(),
    dispatch: (action) => store.dispatch(action),
    getSnapshots: () => window.__REDUX_SNAPSHOTS__,
    clearSnapshots: () => {
      window.__REDUX_SNAPSHOTS__ = [];
    },
    timeTravel: (index) => {
      const snapshot = window.__REDUX_SNAPSHOTS__[index];
      if (snapshot) {
        console.log("Time traveling to:", snapshot);
        // Note: This would require implementing time travel functionality
      }
    },
    exportState: () => {
      const state = store.getState();
      const blob = new Blob([JSON.stringify(state, null, 2)], {
        type: "application/json",
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `redux-state-${Date.now()}.json`;
      a.click();
    },
    importState: (stateJson) => {
      try {
        const state = JSON.parse(stateJson);
        store.dispatch({ type: "@@IMPORT_STATE", payload: state });
      } catch (error) {
        console.error("Failed to import state:", error);
      }
    },
  };
}
```

```javascript
// hooks/useReduxDebug.js
import { useEffect, useRef } from "react";
import { useSelector, useStore } from "react-redux";

export const useReduxDebug = (componentName, dependencies = []) => {
  const store = useStore();
  const state = useSelector((state) => state);
  const prevState = useRef(state);
  const renderCount = useRef(0);

  useEffect(() => {
    renderCount.current += 1;

    if (process.env.NODE_ENV === "development") {
      console.group(` ${componentName} Debug Info`);
      console.log("Render Count:", renderCount.current);
      console.log("Current State:", state);
      console.log("Previous State:", prevState.current);
      console.log("Dependencies:", dependencies);

      // Detect unnecessary re-renders
      if (JSON.stringify(prevState.current) === JSON.stringify(state)) {
        console.warn(" Unnecessary re-render detected");
      }

      // Show state diff
      const diff = getStateDiff(prevState.current, state);
      if (Object.keys(diff).length > 0) {
        console.log("State Changes:", diff);
      }

      console.groupEnd();

      prevState.current = state;
    }
  });

  return {
    renderCount: renderCount.current,
    state,
    store,
  };
};

const getStateDiff = (prev, current) => {
  const diff = {};

  Object.keys(current).forEach((key) => {
    if (JSON.stringify(prev[key]) !== JSON.stringify(current[key])) {
      diff[key] = {
        from: prev[key],
        to: current[key],
      };
    }
  });

  return diff;
};

export const useActionLogger = () => {
  const store = useStore();

  return {
    logAction: (actionType, payload) => {
      console.log(` Dispatching: ${actionType}`, payload);
      store.dispatch({ type: actionType, payload });
    },
    logAsyncAction: async (asyncAction) => {
      console.log(" Dispatching async action:", asyncAction.type);
      const startTime = performance.now();

      try {
        const result = await store.dispatch(asyncAction);
        const duration = performance.now() - startTime;
        console.log(
          ` Async action completed in ${duration.toFixed(2)}ms:`,
          result
        );
        return result;
      } catch (error) {
        const duration = performance.now() - startTime;
        console.error(
          ` Async action failed after ${duration.toFixed(2)}ms:`,
          error
        );
        throw error;
      }
    },
  };
};
```

#### Zustand Debugging Implementation

```javascript
// stores/debugStore.js
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { persist } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

// Debug middleware
const debugMiddleware = (config) => (set, get, api) => {
  const originalSet = set;

  const debugSet = (partial, replace) => {
    const prevState = get();
    const startTime = performance.now();

    // Call original set
    const result = originalSet(partial, replace);

    const nextState = get();
    const duration = performance.now() - startTime;

    if (process.env.NODE_ENV === "development") {
      console.group(" Zustand State Update");
      console.log("Previous State:", prevState);
      console.log(
        "Update:",
        typeof partial === "function" ? "Function" : partial
      );
      console.log("Next State:", nextState);
      console.log(` Duration: ${duration.toFixed(2)}ms`);

      // Performance warning
      if (duration > 16) {
        console.warn(` Slow state update detected: ${duration.toFixed(2)}ms`);
      }

      // State diff
      const diff = getStateDiff(prevState, nextState);
      if (Object.keys(diff).length > 0) {
        console.log("Changes:", diff);
      }

      console.groupEnd();

      // Save snapshot
      if (window.__ZUSTAND_SNAPSHOTS__) {
        window.__ZUSTAND_SNAPSHOTS__.push({
          prevState,
          nextState,
          update: partial,
          timestamp: Date.now(),
          duration,
        });

        // Keep only last 50 snapshots
        if (window.__ZUSTAND_SNAPSHOTS__.length > 50) {
          window.__ZUSTAND_SNAPSHOTS__.shift();
        }
      }
    }

    return result;
  };

  return config(debugSet, get, api);
};

// Error handling middleware
const errorMiddleware = (config) => (set, get, api) => {
  const originalSet = set;

  const errorSet = (partial, replace) => {
    try {
      return originalSet(partial, replace);
    } catch (error) {
      console.error(" Zustand Error:", {
        error: error.message,
        stack: error.stack,
        state: get(),
        update: partial,
      });

      // Send error to monitoring service
      if (typeof window !== "undefined" && window.Sentry) {
        window.Sentry.captureException(error, {
          tags: {
            section: "zustand",
          },
          extra: {
            state: get(),
            update: partial,
          },
        });
      }

      throw error;
    }
  };

  return config(errorSet, get, api);
};

// Logger middleware
const loggerMiddleware = (config) => (set, get, api) => {
  if (process.env.NODE_ENV !== "development") {
    return config(set, get, api);
  }

  const loggedSet = (partial, replace) => {
    console.log(" Zustand Update:", {
      update: typeof partial === "function" ? "Function" : partial,
      replace,
      timestamp: new Date().toISOString(),
    });

    return set(partial, replace);
  };

  return config(loggedSet, get, api);
};

// Create store with debugging
const useDebugStore = create(
  subscribeWithSelector(
    persist(
      immer(
        debugMiddleware(
          errorMiddleware(
            loggerMiddleware((set, get) => ({
              // State
              user: null,
              status: "idle",
              error: null,
              debugInfo: {
                actionCount: 0,
                lastAction: null,
                performance: [],
              },

              // Actions
              setUser: (user) =>
                set((state) => {
                  state.user = user;
                  state.debugInfo.actionCount += 1;
                  state.debugInfo.lastAction = {
                    type: "setUser",
                    payload: user,
                    timestamp: Date.now(),
                  };
                }),

              clearUser: () =>
                set((state) => {
                  state.user = null;
                  state.status = "idle";
                  state.error = null;
                  state.debugInfo.actionCount += 1;
                  state.debugInfo.lastAction = {
                    type: "clearUser",
                    timestamp: Date.now(),
                  };
                }),

              setStatus: (status) =>
                set((state) => {
                  state.status = status;
                  state.debugInfo.actionCount += 1;
                  state.debugInfo.lastAction = {
                    type: "setStatus",
                    payload: status,
                    timestamp: Date.now(),
                  };
                }),

              // Debug actions
              getDebugInfo: () => get().debugInfo,

              resetDebugInfo: () =>
                set((state) => {
                  state.debugInfo = {
                    actionCount: 0,
                    lastAction: null,
                    performance: [],
                  };
                }),

              exportState: () => {
                const state = get();
                const blob = new Blob([JSON.stringify(state, null, 2)], {
                  type: "application/json",
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = `zustand-state-${Date.now()}.json`;
                a.click();
              },

              importState: (stateJson) => {
                try {
                  const newState = JSON.parse(stateJson);
                  set(newState);
                } catch (error) {
                  console.error("Failed to import state:", error);
                }
              },
            }))
          )
        )
      ),
      {
        name: "debug-store",
        partialize: (state) => ({
          user: state.user,
          // Don't persist debug info
        }),
      }
    )
  )
);

// Development tools
if (process.env.NODE_ENV === "development") {
  // Initialize snapshots array
  window.__ZUSTAND_SNAPSHOTS__ = [];

  // Global debugging helpers
  window.__ZUSTAND_DEBUG__ = {
    getState: () => useDebugStore.getState(),
    setState: (partial) => useDebugStore.setState(partial),
    getSnapshots: () => window.__ZUSTAND_SNAPSHOTS__,
    clearSnapshots: () => {
      window.__ZUSTAND_SNAPSHOTS__ = [];
    },
    subscribe: (listener) => useDebugStore.subscribe(listener),
    exportState: () => useDebugStore.getState().exportState(),
    importState: (stateJson) => useDebugStore.getState().importState(stateJson),
  };
}

const getStateDiff = (prev, current) => {
  const diff = {};

  Object.keys(current).forEach((key) => {
    if (JSON.stringify(prev[key]) !== JSON.stringify(current[key])) {
      diff[key] = {
        from: prev[key],
        to: current[key],
      };
    }
  });

  return diff;
};

export default useDebugStore;
```

```javascript
// hooks/useZustandDebug.js
import { useEffect, useRef } from "react";

export const useZustandDebug = (store, componentName, dependencies = []) => {
  const state = store();
  const prevState = useRef(state);
  const renderCount = useRef(0);

  useEffect(() => {
    renderCount.current += 1;

    if (process.env.NODE_ENV === "development") {
      console.group(` ${componentName} Debug Info`);
      console.log("Render Count:", renderCount.current);
      console.log("Current State:", state);
      console.log("Previous State:", prevState.current);
      console.log("Dependencies:", dependencies);

      // Detect unnecessary re-renders
      if (JSON.stringify(prevState.current) === JSON.stringify(state)) {
        console.warn(" Unnecessary re-render detected");
      }

      // Show state diff
      const diff = getStateDiff(prevState.current, state);
      if (Object.keys(diff).length > 0) {
        console.log("State Changes:", diff);
      }

      console.groupEnd();

      prevState.current = state;
    }
  });

  return {
    renderCount: renderCount.current,
    state,
  };
};

export const useStoreSubscription = (store, selector, componentName) => {
  useEffect(() => {
    if (process.env.NODE_ENV === "development") {
      const unsubscribe = store.subscribe(
        selector,
        (selectedState, previousSelectedState) => {
          console.log(` ${componentName} Subscription:`, {
            previous: previousSelectedState,
            current: selectedState,
            timestamp: new Date().toISOString(),
          });
        }
      );

      return unsubscribe;
    }
  }, [store, selector, componentName]);
};

const getStateDiff = (prev, current) => {
  const diff = {};

  Object.keys(current).forEach((key) => {
    if (JSON.stringify(prev[key]) !== JSON.stringify(current[key])) {
      diff[key] = {
        from: prev[key],
        to: current[key],
      };
    }
  });

  return diff;
};
```

```javascript
// components/DebugPanel.jsx
import React, { useState, useEffect } from "react";
import { useSelector } from "react-redux";
import useDebugStore from "../stores/debugStore";

const DebugPanel = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [activeTab, setActiveTab] = useState("redux");
  const [snapshots, setSnapshots] = useState([]);

  // Redux state
  const reduxState = useSelector((state) => state);

  // Zustand state
  const zustandState = useDebugStore();

  useEffect(() => {
    const interval = setInterval(() => {
      if (activeTab === "redux" && window.__REDUX_SNAPSHOTS__) {
        setSnapshots([...window.__REDUX_SNAPSHOTS__]);
      } else if (activeTab === "zustand" && window.__ZUSTAND_SNAPSHOTS__) {
        setSnapshots([...window.__ZUSTAND_SNAPSHOTS__]);
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [activeTab]);

  if (process.env.NODE_ENV !== "development") {
    return null;
  }

  return (
    <div className={`debug-panel ${isOpen ? "open" : "closed"}`}>
      <button className="debug-toggle" onClick={() => setIsOpen(!isOpen)}>
         Debug
      </button>

      {isOpen && (
        <div className="debug-content">
          <div className="debug-tabs">
            <button
              className={activeTab === "redux" ? "active" : ""}
              onClick={() => setActiveTab("redux")}
            >
              Redux
            </button>
            <button
              className={activeTab === "zustand" ? "active" : ""}
              onClick={() => setActiveTab("zustand")}
            >
              Zustand
            </button>
            <button
              className={activeTab === "performance" ? "active" : ""}
              onClick={() => setActiveTab("performance")}
            >
              Performance
            </button>
          </div>

          <div className="debug-body">
            {activeTab === "redux" && (
              <div>
                <h3>Redux State</h3>
                <pre>{JSON.stringify(reduxState, null, 2)}</pre>

                <h3>Actions History ({snapshots.length})</h3>
                <div className="snapshots">
                  {snapshots.slice(-10).map((snapshot, index) => (
                    <div key={index} className="snapshot">
                      <strong>{snapshot.action.type}</strong>
                      <small>
                        {new Date(snapshot.timestamp).toLocaleTimeString()}
                      </small>
                    </div>
                  ))}
                </div>

                <div className="debug-actions">
                  <button onClick={() => window.__REDUX_DEBUG__.exportState()}>
                    Export State
                  </button>
                  <button
                    onClick={() => window.__REDUX_DEBUG__.clearSnapshots()}
                  >
                    Clear History
                  </button>
                </div>
              </div>
            )}

            {activeTab === "zustand" && (
              <div>
                <h3>Zustand State</h3>
                <pre>{JSON.stringify(zustandState, null, 2)}</pre>

                <h3>Updates History ({snapshots.length})</h3>
                <div className="snapshots">
                  {snapshots.slice(-10).map((snapshot, index) => (
                    <div key={index} className="snapshot">
                      <strong>State Update</strong>
                      <small>
                        {new Date(snapshot.timestamp).toLocaleTimeString()}
                      </small>
                      <small>{snapshot.duration.toFixed(2)}ms</small>
                    </div>
                  ))}
                </div>

                <div className="debug-actions">
                  <button onClick={() => zustandState.exportState()}>
                    Export State
                  </button>
                  <button
                    onClick={() => window.__ZUSTAND_DEBUG__.clearSnapshots()}
                  >
                    Clear History
                  </button>
                </div>
              </div>
            )}

            {activeTab === "performance" && (
              <div>
                <h3>Performance Metrics</h3>
                <div className="metrics">
                  <div>
                    Redux Actions: {window.__REDUX_SNAPSHOTS__?.length || 0}
                  </div>
                  <div>
                    Zustand Updates: {window.__ZUSTAND_SNAPSHOTS__?.length || 0}
                  </div>
                  <div>
                    Memory Usage:{" "}
                    {(performance.memory?.usedJSHeapSize / 1024 / 1024).toFixed(
                      2
                    )}{" "}
                    MB
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default DebugPanel;
```

#### Best Practices

1. **Development vs Production**:

   - Only enable debugging in development
   - Remove debug code in production builds
   - Use environment variables for configuration
   - Sanitize sensitive data in logs

2. **Performance Monitoring**:

   - Track action/update duration
   - Monitor memory usage
   - Detect unnecessary re-renders
   - Profile large state updates

3. **Error Handling**:

   - Implement error boundaries
   - Log errors with context
   - Send errors to monitoring services
   - Provide fallback states

4. **State Inspection**:
   - Implement state export/import
   - Track state history
   - Provide time travel debugging
   - Show state diffs

**Comparison Summary:**

| Feature        | Redux                      | Zustand               |
| -------------- | -------------------------- | --------------------- |
| DevTools       | Excellent (Redux DevTools) | Manual Implementation |
| Logging        | Rich Middleware Ecosystem  | Custom Middleware     |
| Time Travel    | Built-in Support           | Manual Implementation |
| State Export   | DevTools Integration       | Custom Implementation |
| Performance    | DevTools Profiling         | Manual Monitoring     |
| Error Handling | Middleware Support         | Custom Error Handling |
| Debugging UI   | Third-party Tools          | Custom Components     |
| Learning Curve | Moderate                   | Simple                |

---

### 50. How do you implement advanced state synchronization across multiple browser tabs in Redux vs Zustand?

**Answer:**

State synchronization across multiple browser tabs is essential for maintaining consistency in applications where users might have multiple tabs open. Both Redux and Zustand offer different approaches to achieve cross-tab state synchronization.

#### Redux Cross-Tab Synchronization Implementation

```javascript
// store/syncStore.js
import { configureStore } from "@reduxjs/toolkit";
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

// Cross-tab sync slice
const syncSlice = createSlice({
  name: "sync",
  initialState: {
    user: null,
    preferences: {},
    notifications: [],
    lastSync: null,
    tabId: null,
    activeTabs: [],
    isLeader: false,
    syncStatus: "idle",
  },
  reducers: {
    setTabId: (state, action) => {
      state.tabId = action.payload;
    },
    setLeader: (state, action) => {
      state.isLeader = action.payload;
    },
    updateActiveTabs: (state, action) => {
      state.activeTabs = action.payload;
    },
    syncStateFromTab: (state, action) => {
      const { user, preferences, notifications } = action.payload;
      state.user = user;
      state.preferences = preferences;
      state.notifications = notifications;
      state.lastSync = Date.now();
    },
    setSyncStatus: (state, action) => {
      state.syncStatus = action.payload;
    },
    addNotification: (state, action) => {
      state.notifications.push({
        id: Date.now(),
        ...action.payload,
        timestamp: Date.now(),
      });
    },
    removeNotification: (state, action) => {
      state.notifications = state.notifications.filter(
        (notification) => notification.id !== action.payload
      );
    },
    updatePreferences: (state, action) => {
      state.preferences = { ...state.preferences, ...action.payload };
    },
    setUser: (state, action) => {
      state.user = action.payload;
    },
  },
});

export const {
  setTabId,
  setLeader,
  updateActiveTabs,
  syncStateFromTab,
  setSyncStatus,
  addNotification,
  removeNotification,
  updatePreferences,
  setUser,
} = syncSlice.actions;

// Cross-tab communication middleware
const crossTabMiddleware = (store) => (next) => (action) => {
  const result = next(action);

  // Actions that should be synchronized across tabs
  const syncActions = [
    "sync/setUser",
    "sync/addNotification",
    "sync/removeNotification",
    "sync/updatePreferences",
  ];

  if (syncActions.includes(action.type)) {
    // Broadcast to other tabs
    const state = store.getState().sync;
    const syncData = {
      type: "REDUX_SYNC",
      action,
      state: {
        user: state.user,
        preferences: state.preferences,
        notifications: state.notifications,
      },
      tabId: state.tabId,
      timestamp: Date.now(),
    };

    // Use BroadcastChannel for modern browsers
    if (typeof BroadcastChannel !== "undefined") {
      const channel = new BroadcastChannel("redux-sync");
      channel.postMessage(syncData);
    } else {
      // Fallback to localStorage events
      localStorage.setItem("redux-sync-event", JSON.stringify(syncData));
      localStorage.removeItem("redux-sync-event");
    }
  }

  return result;
};

// Leader election middleware
const leaderElectionMiddleware = (store) => (next) => (action) => {
  const result = next(action);

  if (action.type === "sync/setTabId") {
    // Start leader election process
    startLeaderElection(store);
  }

  return result;
};

// Store configuration
export const store = configureStore({
  reducer: {
    sync: syncSlice.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(crossTabMiddleware, leaderElectionMiddleware),
});

// Leader election implementation
let leaderElectionInterval;
let heartbeatInterval;

const startLeaderElection = (store) => {
  const tabId = store.getState().sync.tabId;

  // Clear existing intervals
  if (leaderElectionInterval) clearInterval(leaderElectionInterval);
  if (heartbeatInterval) clearInterval(heartbeatInterval);

  // Leader election using localStorage
  const electLeader = () => {
    const now = Date.now();
    const leaderData = JSON.parse(localStorage.getItem("redux-leader") || "{}");

    // Check if current leader is still alive (heartbeat within 5 seconds)
    if (!leaderData.tabId || now - leaderData.lastHeartbeat > 5000) {
      // Become leader
      const newLeaderData = {
        tabId,
        lastHeartbeat: now,
      };

      localStorage.setItem("redux-leader", JSON.stringify(newLeaderData));
      store.dispatch(setLeader(true));

      // Start heartbeat
      heartbeatInterval = setInterval(() => {
        const currentLeader = JSON.parse(
          localStorage.getItem("redux-leader") || "{}"
        );
        if (currentLeader.tabId === tabId) {
          localStorage.setItem(
            "redux-leader",
            JSON.stringify({
              tabId,
              lastHeartbeat: Date.now(),
            })
          );
        }
      }, 2000);
    } else if (leaderData.tabId !== tabId) {
      // Not leader
      store.dispatch(setLeader(false));
    }
  };

  // Run election immediately and then every 3 seconds
  electLeader();
  leaderElectionInterval = setInterval(electLeader, 3000);
};

// Initialize cross-tab communication
export const initializeCrossTabSync = () => {
  const tabId = `tab-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  store.dispatch(setTabId(tabId));

  // Listen for cross-tab messages
  if (typeof BroadcastChannel !== "undefined") {
    const channel = new BroadcastChannel("redux-sync");

    channel.addEventListener("message", (event) => {
      const { type, action, state, tabId: senderTabId } = event.data;

      if (type === "REDUX_SYNC" && senderTabId !== tabId) {
        // Apply state from other tab
        store.dispatch(syncStateFromTab(state));
      }
    });
  } else {
    // Fallback to localStorage events
    window.addEventListener("storage", (event) => {
      if (event.key === "redux-sync-event" && event.newValue) {
        try {
          const {
            type,
            action,
            state,
            tabId: senderTabId,
          } = JSON.parse(event.newValue);

          if (type === "REDUX_SYNC" && senderTabId !== tabId) {
            store.dispatch(syncStateFromTab(state));
          }
        } catch (error) {
          console.error("Failed to parse sync event:", error);
        }
      }
    });
  }

  // Handle tab visibility changes
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible") {
      // Tab became visible, sync state
      const syncData = localStorage.getItem("redux-sync-state");
      if (syncData) {
        try {
          const state = JSON.parse(syncData);
          store.dispatch(syncStateFromTab(state));
        } catch (error) {
          console.error("Failed to sync state on visibility change:", error);
        }
      }
    }
  });

  // Cleanup on page unload
  window.addEventListener("beforeunload", () => {
    const state = store.getState().sync;
    if (state.isLeader) {
      // Remove leader status
      localStorage.removeItem("redux-leader");
    }

    // Clear intervals
    if (leaderElectionInterval) clearInterval(leaderElectionInterval);
    if (heartbeatInterval) clearInterval(heartbeatInterval);
  });
};
```

```javascript
// hooks/useCrossTabSync.js
import { useEffect, useCallback } from "react";
import { useSelector, useDispatch } from "react-redux";
import { setSyncStatus } from "../store/syncStore";

export const useCrossTabSync = () => {
  const dispatch = useDispatch();
  const { tabId, isLeader, lastSync, syncStatus } = useSelector(
    (state) => state.sync
  );

  const syncToStorage = useCallback(
    (data) => {
      try {
        localStorage.setItem("redux-sync-state", JSON.stringify(data));
        dispatch(setSyncStatus("synced"));
      } catch (error) {
        console.error("Failed to sync to storage:", error);
        dispatch(setSyncStatus("error"));
      }
    },
    [dispatch]
  );

  const syncFromStorage = useCallback(() => {
    try {
      const data = localStorage.getItem("redux-sync-state");
      if (data) {
        return JSON.parse(data);
      }
    } catch (error) {
      console.error("Failed to sync from storage:", error);
    }
    return null;
  }, []);

  const broadcastToTabs = useCallback(
    (message) => {
      if (typeof BroadcastChannel !== "undefined") {
        const channel = new BroadcastChannel("redux-sync");
        channel.postMessage({
          ...message,
          tabId,
          timestamp: Date.now(),
        });
      }
    },
    [tabId]
  );

  return {
    tabId,
    isLeader,
    lastSync,
    syncStatus,
    syncToStorage,
    syncFromStorage,
    broadcastToTabs,
  };
};

export const useTabVisibility = () => {
  const [isVisible, setIsVisible] = useState(!document.hidden);

  useEffect(() => {
    const handleVisibilityChange = () => {
      setIsVisible(!document.hidden);
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);

    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, []);

  return isVisible;
};
```

#### Zustand Cross-Tab Synchronization Implementation

```javascript
// stores/syncStore.js
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { persist } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

// Cross-tab sync middleware
const crossTabMiddleware = (config) => (set, get, api) => {
  const originalSet = set;

  const syncSet = (partial, replace) => {
    const result = originalSet(partial, replace);

    // Get updated state
    const state = get();

    // Broadcast changes to other tabs
    const syncData = {
      type: "ZUSTAND_SYNC",
      state: {
        user: state.user,
        preferences: state.preferences,
        notifications: state.notifications,
      },
      tabId: state.tabId,
      timestamp: Date.now(),
    };

    // Use BroadcastChannel for modern browsers
    if (typeof BroadcastChannel !== "undefined") {
      const channel = new BroadcastChannel("zustand-sync");
      channel.postMessage(syncData);
    } else {
      // Fallback to localStorage events
      localStorage.setItem("zustand-sync-event", JSON.stringify(syncData));
      localStorage.removeItem("zustand-sync-event");
    }

    return result;
  };

  return config(syncSet, get, api);
};

// Leader election middleware
const leaderElectionMiddleware = (config) => (set, get, api) => {
  let leaderElectionInterval;
  let heartbeatInterval;

  const startLeaderElection = () => {
    const { tabId } = get();

    // Clear existing intervals
    if (leaderElectionInterval) clearInterval(leaderElectionInterval);
    if (heartbeatInterval) clearInterval(heartbeatInterval);

    const electLeader = () => {
      const now = Date.now();
      const leaderData = JSON.parse(
        localStorage.getItem("zustand-leader") || "{}"
      );

      // Check if current leader is still alive
      if (!leaderData.tabId || now - leaderData.lastHeartbeat > 5000) {
        // Become leader
        const newLeaderData = {
          tabId,
          lastHeartbeat: now,
        };

        localStorage.setItem("zustand-leader", JSON.stringify(newLeaderData));
        set((state) => ({ ...state, isLeader: true }));

        // Start heartbeat
        heartbeatInterval = setInterval(() => {
          const currentLeader = JSON.parse(
            localStorage.getItem("zustand-leader") || "{}"
          );
          if (currentLeader.tabId === tabId) {
            localStorage.setItem(
              "zustand-leader",
              JSON.stringify({
                tabId,
                lastHeartbeat: Date.now(),
              })
            );
          }
        }, 2000);
      } else if (leaderData.tabId !== tabId) {
        // Not leader
        set((state) => ({ ...state, isLeader: false }));
      }
    };

    // Run election immediately and then every 3 seconds
    electLeader();
    leaderElectionInterval = setInterval(electLeader, 3000);
  };

  // Cleanup function
  api.destroy = () => {
    if (leaderElectionInterval) clearInterval(leaderElectionInterval);
    if (heartbeatInterval) clearInterval(heartbeatInterval);
  };

  const originalConfig = config(set, get, api);

  // Start leader election when tab ID is set
  if (originalConfig.tabId) {
    startLeaderElection();
  }

  return {
    ...originalConfig,
    startLeaderElection,
  };
};

// Create store with cross-tab sync
const useSyncStore = create(
  subscribeWithSelector(
    persist(
      immer(
        crossTabMiddleware(
          leaderElectionMiddleware((set, get) => ({
            // State
            user: null,
            preferences: {},
            notifications: [],
            tabId: null,
            activeTabs: [],
            isLeader: false,
            lastSync: null,
            syncStatus: "idle",

            // Actions
            setTabId: (tabId) =>
              set((state) => {
                state.tabId = tabId;
              }),

            setUser: (user) =>
              set((state) => {
                state.user = user;
                state.lastSync = Date.now();
              }),

            updatePreferences: (preferences) =>
              set((state) => {
                state.preferences = { ...state.preferences, ...preferences };
                state.lastSync = Date.now();
              }),

            addNotification: (notification) =>
              set((state) => {
                state.notifications.push({
                  id: Date.now(),
                  ...notification,
                  timestamp: Date.now(),
                });
                state.lastSync = Date.now();
              }),

            removeNotification: (id) =>
              set((state) => {
                state.notifications = state.notifications.filter(
                  (notification) => notification.id !== id
                );
                state.lastSync = Date.now();
              }),

            syncFromTab: (syncData) =>
              set((state) => {
                state.user = syncData.user;
                state.preferences = syncData.preferences;
                state.notifications = syncData.notifications;
                state.lastSync = Date.now();
                state.syncStatus = "synced";
              }),

            setSyncStatus: (status) =>
              set((state) => {
                state.syncStatus = status;
              }),

            // Cross-tab utilities
            broadcastToTabs: (message) => {
              const { tabId } = get();

              if (typeof BroadcastChannel !== "undefined") {
                const channel = new BroadcastChannel("zustand-sync");
                channel.postMessage({
                  ...message,
                  tabId,
                  timestamp: Date.now(),
                });
              }
            },

            syncToStorage: () => {
              const state = get();
              try {
                localStorage.setItem(
                  "zustand-sync-state",
                  JSON.stringify({
                    user: state.user,
                    preferences: state.preferences,
                    notifications: state.notifications,
                  })
                );
                set((state) => {
                  state.syncStatus = "synced";
                });
              } catch (error) {
                console.error("Failed to sync to storage:", error);
                set((state) => {
                  state.syncStatus = "error";
                });
              }
            },

            syncFromStorage: () => {
              try {
                const data = localStorage.getItem("zustand-sync-state");
                if (data) {
                  const syncData = JSON.parse(data);
                  get().syncFromTab(syncData);
                }
              } catch (error) {
                console.error("Failed to sync from storage:", error);
              }
            },
          }))
        )
      ),
      {
        name: "sync-store",
        partialize: (state) => ({
          user: state.user,
          preferences: state.preferences,
          // Don't persist tab-specific data
        }),
      }
    )
  )
);

// Initialize cross-tab communication
export const initializeZustandCrossTabSync = () => {
  const tabId = `tab-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  useSyncStore.getState().setTabId(tabId);
  useSyncStore.getState().startLeaderElection();

  // Listen for cross-tab messages
  if (typeof BroadcastChannel !== "undefined") {
    const channel = new BroadcastChannel("zustand-sync");

    channel.addEventListener("message", (event) => {
      const { type, state, tabId: senderTabId } = event.data;

      if (type === "ZUSTAND_SYNC" && senderTabId !== tabId) {
        // Apply state from other tab
        useSyncStore.getState().syncFromTab(state);
      }
    });
  } else {
    // Fallback to localStorage events
    window.addEventListener("storage", (event) => {
      if (event.key === "zustand-sync-event" && event.newValue) {
        try {
          const {
            type,
            state,
            tabId: senderTabId,
          } = JSON.parse(event.newValue);

          if (type === "ZUSTAND_SYNC" && senderTabId !== tabId) {
            useSyncStore.getState().syncFromTab(state);
          }
        } catch (error) {
          console.error("Failed to parse sync event:", error);
        }
      }
    });
  }

  // Handle tab visibility changes
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible") {
      // Tab became visible, sync state
      useSyncStore.getState().syncFromStorage();
    }
  });

  // Cleanup on page unload
  window.addEventListener("beforeunload", () => {
    const state = useSyncStore.getState();
    if (state.isLeader) {
      // Remove leader status
      localStorage.removeItem("zustand-leader");
    }
  });
};

export default useSyncStore;
```

```javascript
// hooks/useZustandCrossTabSync.js
import { useEffect, useState } from "react";
import useSyncStore from "../stores/syncStore";

export const useZustandCrossTabSync = () => {
  const {
    tabId,
    isLeader,
    lastSync,
    syncStatus,
    broadcastToTabs,
    syncToStorage,
    syncFromStorage,
  } = useSyncStore();

  return {
    tabId,
    isLeader,
    lastSync,
    syncStatus,
    broadcastToTabs,
    syncToStorage,
    syncFromStorage,
  };
};

export const useTabActivity = () => {
  const [isActive, setIsActive] = useState(true);
  const [lastActivity, setLastActivity] = useState(Date.now());

  useEffect(() => {
    const updateActivity = () => {
      setLastActivity(Date.now());
      setIsActive(true);
    };

    const handleVisibilityChange = () => {
      setIsActive(!document.hidden);
    };

    // Track user activity
    const events = [
      "mousedown",
      "mousemove",
      "keypress",
      "scroll",
      "touchstart",
    ];
    events.forEach((event) => {
      document.addEventListener(event, updateActivity, true);
    });

    document.addEventListener("visibilitychange", handleVisibilityChange);

    // Check for inactivity
    const inactivityTimer = setInterval(() => {
      if (Date.now() - lastActivity > 300000) {
        // 5 minutes
        setIsActive(false);
      }
    }, 60000); // Check every minute

    return () => {
      events.forEach((event) => {
        document.removeEventListener(event, updateActivity, true);
      });
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      clearInterval(inactivityTimer);
    };
  }, [lastActivity]);

  return { isActive, lastActivity };
};
```

#### Best Practices

1. **Communication Methods**:

   - Use BroadcastChannel API for modern browsers
   - Fallback to localStorage events for older browsers
   - Consider WebSocket for real-time sync
   - Implement proper error handling

2. **Leader Election**:

   - Implement heartbeat mechanism
   - Handle leader failures gracefully
   - Use timestamps for conflict resolution
   - Clean up on tab close

3. **Performance Optimization**:

   - Debounce sync operations
   - Only sync necessary state
   - Use selective synchronization
   - Implement conflict resolution

4. **Data Consistency**:
   - Handle race conditions
   - Implement optimistic updates
   - Use version numbers for conflict detection
   - Provide manual sync options

**Comparison Summary:**

| Feature        | Redux                  | Zustand               |
| -------------- | ---------------------- | --------------------- |
| Implementation | Middleware-based       | Custom Middleware     |
| Complexity     | Higher                 | Lower                 |
| DevTools       | Built-in Support       | Manual Implementation |
| Performance    | Good with Optimization | Excellent             |
| Flexibility    | High                   | Very High             |
| Learning Curve | Steep                  | Gentle                |
| Bundle Size    | Larger                 | Smaller               |
| Type Safety    | Excellent              | Good                  |

---

### 51. How do you implement advanced internationalization (i18n) and localization with Redux vs Zustand?

**Answer:**

Internationalization (i18n) and localization are crucial for global applications. Both Redux and Zustand can effectively manage language preferences, translations, and locale-specific data with different approaches.

#### Redux i18n Implementation

```javascript
// store/i18nSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// Async thunk for loading translations
export const loadTranslations = createAsyncThunk(
  'i18n/loadTranslations',
  async ({ locale, namespace = 'common' }, { rejectWithValue }) => {
    try {
      // Dynamic import for code splitting
      const translations = await import(`../locales/${locale}/${namespace}.json`);
      return {
        locale,
        namespace,
        translations: translations.default,
      };
    } catch (error) {
      return rejectWithValue({
        message: `Failed to load translations for ${locale}/${namespace}`,
        locale,
        namespace,
      });
    }
  }
);

// Async thunk for detecting user locale
export const detectUserLocale = createAsyncThunk(
  'i18n/detectUserLocale',
  async (_, { dispatch }) => {
    // Check localStorage first
    const savedLocale = localStorage.getItem('preferred-locale');
    if (savedLocale) {
      return savedLocale;
    }
    
    // Check browser language
    const browserLocale = navigator.language.split('-')[0];
    const supportedLocales = ['en', 'es', 'fr', 'de', 'ja', 'zh'];
    
    if (supportedLocales.includes(browserLocale)) {
      return browserLocale;
    }
    
    // Default to English
    return 'en';
  }
);

// Async thunk for changing locale
export const changeLocale = createAsyncThunk(
  'i18n/changeLocale',
  async (locale, { dispatch, getState }) => {
    const { i18n } = getState();
    
    // Save to localStorage
    localStorage.setItem('preferred-locale', locale);
    
    // Load all required namespaces for the new locale
    const namespaces = Object.keys(i18n.translations[i18n.currentLocale] || {});
    const loadPromises = namespaces.map(namespace => 
      dispatch(loadTranslations({ locale, namespace }))
    );
    
    await Promise.all(loadPromises);
    
    return locale;
  }
);

const i18nSlice = createSlice({
  name: 'i18n',
  initialState: {
    currentLocale: 'en',
    fallbackLocale: 'en',
    supportedLocales: ['en', 'es', 'fr', 'de', 'ja', 'zh'],
    translations: {},
    loadingStates: {},
    errors: {},
    isRTL: false,
    dateFormat: 'MM/DD/YYYY',
    timeFormat: '12h',
    currency: 'USD',
    numberFormat: {
      decimal: '.',
      thousands: ',',
      precision: 2,
    },
    pluralRules: {},
  },
  reducers: {
    setRTL: (state, action) => {
      state.isRTL = action.payload;
    },
    setDateFormat: (state, action) => {
      state.dateFormat = action.payload;
    },
    setTimeFormat: (state, action) => {
      state.timeFormat = action.payload;
    },
    setCurrency: (state, action) => {
      state.currency = action.payload;
    },
    setNumberFormat: (state, action) => {
      state.numberFormat = { ...state.numberFormat, ...action.payload };
    },
    clearError: (state, action) => {
      const { locale, namespace } = action.payload;
      if (state.errors[locale]) {
        delete state.errors[locale][namespace];
      }
    },
    addCustomTranslation: (state, action) => {
      const { locale, namespace, key, value } = action.payload;
      if (!state.translations[locale]) {
        state.translations[locale] = {};
      }
      if (!state.translations[locale][namespace]) {
        state.translations[locale][namespace] = {};
      }
      state.translations[locale][namespace][key] = value;
    },
  },
  extraReducers: (builder) => {
    builder
      // Load translations
      .addCase(loadTranslations.pending, (state, action) => {
        const { locale, namespace } = action.meta.arg;
        if (!state.loadingStates[locale]) {
          state.loadingStates[locale] = {};
        }
        state.loadingStates[locale][namespace] = 'loading';
      })
      .addCase(loadTranslations.fulfilled, (state, action) => {
        const { locale, namespace, translations } = action.payload;
        
        if (!state.translations[locale]) {
          state.translations[locale] = {};
        }
        state.translations[locale][namespace] = translations;
        
        if (!state.loadingStates[locale]) {
          state.loadingStates[locale] = {};
        }
        state.loadingStates[locale][namespace] = 'loaded';
        
        // Clear any previous errors
        if (state.errors[locale]) {
          delete state.errors[locale][namespace];
        }
      })
      .addCase(loadTranslations.rejected, (state, action) => {
        const { locale, namespace } = action.payload;
        
        if (!state.errors[locale]) {
          state.errors[locale] = {};
        }
        state.errors[locale][namespace] = action.payload.message;
        
        if (!state.loadingStates[locale]) {
          state.loadingStates[locale] = {};
        }
        state.loadingStates[locale][namespace] = 'error';
      })
      // Detect user locale
      .addCase(detectUserLocale.fulfilled, (state, action) => {
        state.currentLocale = action.payload;
        
        // Set RTL based on locale
        const rtlLocales = ['ar', 'he', 'fa', 'ur'];
        state.isRTL = rtlLocales.includes(action.payload);
        
        // Set locale-specific formats
        const localeFormats = {
          'en': { dateFormat: 'MM/DD/YYYY', timeFormat: '12h', currency: 'USD' },
          'de': { dateFormat: 'DD.MM.YYYY', timeFormat: '24h', currency: 'EUR' },
          'fr': { dateFormat: 'DD/MM/YYYY', timeFormat: '24h', currency: 'EUR' },
          'ja': { dateFormat: 'YYYY/MM/DD', timeFormat: '24h', currency: 'JPY' },
          'zh': { dateFormat: 'YYYY-MM-DD', timeFormat: '24h', currency: 'CNY' },
        };
        
        const formats = localeFormats[action.payload] || localeFormats['en'];
        state.dateFormat = formats.dateFormat;
        state.timeFormat = formats.timeFormat;
        state.currency = formats.currency;
      })
      // Change locale
      .addCase(changeLocale.fulfilled, (state, action) => {
        state.currentLocale = action.payload;
        
        // Update RTL and formats
        const rtlLocales = ['ar', 'he', 'fa', 'ur'];
        state.isRTL = rtlLocales.includes(action.payload);
      });
  },
});

export const {
  setRTL,
  setDateFormat,
  setTimeFormat,
  setCurrency,
  setNumberFormat,
  clearError,
  addCustomTranslation,
} = i18nSlice.actions;

export default i18nSlice.reducer;
```

```javascript
// hooks/useReduxI18n.js
import { useSelector, useDispatch } from 'react-redux';
import { useCallback, useMemo } from 'react';
import { loadTranslations, changeLocale } from '../store/i18nSlice';

export const useReduxI18n = () => {
  const dispatch = useDispatch();
  const {
    currentLocale,
    fallbackLocale,
    translations,
    loadingStates,
    errors,
    isRTL,
    dateFormat,
    timeFormat,
    currency,
    numberFormat,
  } = useSelector(state => state.i18n);
  
  // Translation function
  const t = useCallback((key, options = {}) => {
    const { namespace = 'common', interpolation = {}, count } = options;
    
    // Get translation from current locale
    let translation = getNestedValue(
      translations[currentLocale]?.[namespace],
      key
    );
    
    // Fallback to fallback locale
    if (!translation && currentLocale !== fallbackLocale) {
      translation = getNestedValue(
        translations[fallbackLocale]?.[namespace],
        key
      );
    }
    
    // Fallback to key if no translation found
    if (!translation) {
      console.warn(`Translation missing for key: ${key}`);
      return key;
    }
    
    // Handle pluralization
    if (typeof count === 'number' && typeof translation === 'object') {
      const pluralKey = getPluralKey(count, currentLocale);
      translation = translation[pluralKey] || translation.other || translation.one;
    }
    
    // Handle interpolation
    if (typeof translation === 'string' && Object.keys(interpolation).length > 0) {
      translation = interpolateString(translation, interpolation);
    }
    
    return translation;
  }, [currentLocale, fallbackLocale, translations]);
  
  // Load namespace
  const loadNamespace = useCallback((namespace) => {
    dispatch(loadTranslations({ locale: currentLocale, namespace }));
  }, [dispatch, currentLocale]);
  
  // Change language
  const changeLanguage = useCallback((locale) => {
    dispatch(changeLocale(locale));
  }, [dispatch]);
  
  // Format date
  const formatDate = useCallback((date, format = dateFormat) => {
    return new Intl.DateTimeFormat(currentLocale, {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      ...(format === '24h' ? { hour12: false } : {}),
    }).format(new Date(date));
  }, [currentLocale, dateFormat]);
  
  // Format number
  const formatNumber = useCallback((number, options = {}) => {
    return new Intl.NumberFormat(currentLocale, {
      minimumFractionDigits: numberFormat.precision,
      maximumFractionDigits: numberFormat.precision,
      ...options,
    }).format(number);
  }, [currentLocale, numberFormat]);
  
  // Format currency
  const formatCurrency = useCallback((amount, currencyCode = currency) => {
    return new Intl.NumberFormat(currentLocale, {
      style: 'currency',
      currency: currencyCode,
    }).format(amount);
  }, [currentLocale, currency]);
  
  // Get loading state for namespace
  const isLoading = useCallback((namespace = 'common') => {
    return loadingStates[currentLocale]?.[namespace] === 'loading';
  }, [loadingStates, currentLocale]);
  
  // Get error for namespace
  const getError = useCallback((namespace = 'common') => {
    return errors[currentLocale]?.[namespace];
  }, [errors, currentLocale]);
  
  return {
    currentLocale,
    isRTL,
    t,
    loadNamespace,
    changeLanguage,
    formatDate,
    formatNumber,
    formatCurrency,
    isLoading,
    getError,
  };
};

// Helper functions
const getNestedValue = (obj, path) => {
  return path.split('.').reduce((current, key) => current?.[key], obj);
};

const interpolateString = (str, values) => {
  return str.replace(/{{(.*?)}}/g, (match, key) => {
    return values[key.trim()] || match;
  });
};

const getPluralKey = (count, locale) => {
  // Simplified pluralization rules
  const rules = {
    en: (n) => n === 1 ? 'one' : 'other',
    es: (n) => n === 1 ? 'one' : 'other',
    fr: (n) => n <= 1 ? 'one' : 'other',
    de: (n) => n === 1 ? 'one' : 'other',
    ja: () => 'other',
    zh: () => 'other',
  };
  
  const rule = rules[locale] || rules.en;
  return rule(count);
};
```

#### Zustand i18n Implementation

```javascript
// stores/i18nStore.js
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

const useI18nStore = create(
  subscribeWithSelector(
    persist(
      immer((set, get) => ({
        // State
        currentLocale: 'en',
        fallbackLocale: 'en',
        supportedLocales: ['en', 'es', 'fr', 'de', 'ja', 'zh'],
        translations: {},
        loadingStates: {},
        errors: {},
        isRTL: false,
        dateFormat: 'MM/DD/YYYY',
        timeFormat: '12h',
        currency: 'USD',
        numberFormat: {
          decimal: '.',
          thousands: ',',
          precision: 2,
        },
        
        // Actions
        loadTranslations: async (locale, namespace = 'common') => {
          set((state) => {
            if (!state.loadingStates[locale]) {
              state.loadingStates[locale] = {};
            }
            state.loadingStates[locale][namespace] = 'loading';
          });
          
          try {
            // Dynamic import for code splitting
            const translations = await import(`../locales/${locale}/${namespace}.json`);
            
            set((state) => {
              if (!state.translations[locale]) {
                state.translations[locale] = {};
              }
              state.translations[locale][namespace] = translations.default;
              state.loadingStates[locale][namespace] = 'loaded';
              
              // Clear any previous errors
              if (state.errors[locale]) {
                delete state.errors[locale][namespace];
              }
            });
          } catch (error) {
            set((state) => {
              if (!state.errors[locale]) {
                state.errors[locale] = {};
              }
              state.errors[locale][namespace] = `Failed to load translations for ${locale}/${namespace}`;
              state.loadingStates[locale][namespace] = 'error';
            });
          }
        },
        
        detectUserLocale: () => {
          // Check localStorage first
          const savedLocale = localStorage.getItem('preferred-locale');
          if (savedLocale) {
            get().setLocale(savedLocale);
            return;
          }
          
          // Check browser language
          const browserLocale = navigator.language.split('-')[0];
          const { supportedLocales } = get();
          
          if (supportedLocales.includes(browserLocale)) {
            get().setLocale(browserLocale);
          } else {
            get().setLocale('en');
          }
        },
        
        setLocale: (locale) => {
          set((state) => {
            state.currentLocale = locale;
            
            // Set RTL based on locale
            const rtlLocales = ['ar', 'he', 'fa', 'ur'];
            state.isRTL = rtlLocales.includes(locale);
            
            // Set locale-specific formats
            const localeFormats = {
              'en': { dateFormat: 'MM/DD/YYYY', timeFormat: '12h', currency: 'USD' },
              'de': { dateFormat: 'DD.MM.YYYY', timeFormat: '24h', currency: 'EUR' },
              'fr': { dateFormat: 'DD/MM/YYYY', timeFormat: '24h', currency: 'EUR' },
              'ja': { dateFormat: 'YYYY/MM/DD', timeFormat: '24h', currency: 'JPY' },
              'zh': { dateFormat: 'YYYY-MM-DD', timeFormat: '24h', currency: 'CNY' },
            };
            
            const formats = localeFormats[locale] || localeFormats['en'];
            state.dateFormat = formats.dateFormat;
            state.timeFormat = formats.timeFormat;
            state.currency = formats.currency;
          });
          
          // Save to localStorage
          localStorage.setItem('preferred-locale', locale);
        },
        
        changeLocale: async (locale) => {
          const { translations, currentLocale } = get();
          
          // Load all required namespaces for the new locale
          const namespaces = Object.keys(translations[currentLocale] || {});
          const loadPromises = namespaces.map(namespace => 
            get().loadTranslations(locale, namespace)
          );
          
          await Promise.all(loadPromises);
          get().setLocale(locale);
        },
        
        addCustomTranslation: (locale, namespace, key, value) => {
          set((state) => {
            if (!state.translations[locale]) {
              state.translations[locale] = {};
            }
            if (!state.translations[locale][namespace]) {
              state.translations[locale][namespace] = {};
            }
            state.translations[locale][namespace][key] = value;
          });
        },
        
        clearError: (locale, namespace) => {
          set((state) => {
            if (state.errors[locale]) {
              delete state.errors[locale][namespace];
            }
          });
        },
        
        setRTL: (isRTL) => {
          set((state) => {
            state.isRTL = isRTL;
          });
        },
        
        setDateFormat: (format) => {
          set((state) => {
            state.dateFormat = format;
          });
        },
        
        setTimeFormat: (format) => {
          set((state) => {
            state.timeFormat = format;
          });
        },
        
        setCurrency: (currency) => {
          set((state) => {
            state.currency = currency;
          });
        },
        
        setNumberFormat: (format) => {
          set((state) => {
            state.numberFormat = { ...state.numberFormat, ...format };
          });
        },
      })),
      {
        name: 'i18n-store',
        partialize: (state) => ({
          currentLocale: state.currentLocale,
          dateFormat: state.dateFormat,
          timeFormat: state.timeFormat,
          currency: state.currency,
          numberFormat: state.numberFormat,
          // Don't persist translations to avoid stale data
        }),
      }
    )
  )
);

export default useI18nStore;
```

```javascript
// hooks/useZustandI18n.js
import { useCallback } from 'react';
import useI18nStore from '../stores/i18nStore';

export const useZustandI18n = () => {
  const {
    currentLocale,
    fallbackLocale,
    translations,
    loadingStates,
    errors,
    isRTL,
    dateFormat,
    timeFormat,
    currency,
    numberFormat,
    loadTranslations,
    changeLocale,
    addCustomTranslation,
  } = useI18nStore();
  
  // Translation function
  const t = useCallback((key, options = {}) => {
    const { namespace = 'common', interpolation = {}, count } = options;
    
    // Get translation from current locale
    let translation = getNestedValue(
      translations[currentLocale]?.[namespace],
      key
    );
    
    // Fallback to fallback locale
    if (!translation && currentLocale !== fallbackLocale) {
      translation = getNestedValue(
        translations[fallbackLocale]?.[namespace],
        key
      );
    }
    
    // Fallback to key if no translation found
    if (!translation) {
      console.warn(`Translation missing for key: ${key}`);
      return key;
    }
    
    // Handle pluralization
    if (typeof count === 'number' && typeof translation === 'object') {
      const pluralKey = getPluralKey(count, currentLocale);
      translation = translation[pluralKey] || translation.other || translation.one;
    }
    
    // Handle interpolation
    if (typeof translation === 'string' && Object.keys(interpolation).length > 0) {
      translation = interpolateString(translation, interpolation);
    }
    
    return translation;
  }, [currentLocale, fallbackLocale, translations]);
  
  // Load namespace
  const loadNamespace = useCallback((namespace) => {
    loadTranslations(currentLocale, namespace);
  }, [loadTranslations, currentLocale]);
  
  // Format date
  const formatDate = useCallback((date, format = dateFormat) => {
    return new Intl.DateTimeFormat(currentLocale, {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      ...(format === '24h' ? { hour12: false } : {}),
    }).format(new Date(date));
  }, [currentLocale, dateFormat]);
  
  // Format number
  const formatNumber = useCallback((number, options = {}) => {
    return new Intl.NumberFormat(currentLocale, {
      minimumFractionDigits: numberFormat.precision,
      maximumFractionDigits: numberFormat.precision,
      ...options,
    }).format(number);
  }, [currentLocale, numberFormat]);
  
  // Format currency
  const formatCurrency = useCallback((amount, currencyCode = currency) => {
    return new Intl.NumberFormat(currentLocale, {
      style: 'currency',
      currency: currencyCode,
    }).format(amount);
  }, [currentLocale, currency]);
  
  // Get loading state for namespace
  const isLoading = useCallback((namespace = 'common') => {
    return loadingStates[currentLocale]?.[namespace] === 'loading';
  }, [loadingStates, currentLocale]);
  
  // Get error for namespace
  const getError = useCallback((namespace = 'common') => {
    return errors[currentLocale]?.[namespace];
  }, [errors, currentLocale]);
  
  return {
    currentLocale,
    isRTL,
    t,
    loadNamespace,
    changeLanguage: changeLocale,
    formatDate,
    formatNumber,
    formatCurrency,
    isLoading,
    getError,
    addCustomTranslation,
  };
};

// Helper functions (same as Redux version)
const getNestedValue = (obj, path) => {
  return path.split('.').reduce((current, key) => current?.[key], obj);
};

const interpolateString = (str, values) => {
  return str.replace(/{{(.*?)}}/g, (match, key) => {
    return values[key.trim()] || match;
  });
};

const getPluralKey = (count, locale) => {
  const rules = {
    en: (n) => n === 1 ? 'one' : 'other',
    es: (n) => n === 1 ? 'one' : 'other',
    fr: (n) => n <= 1 ? 'one' : 'other',
    de: (n) => n === 1 ? 'one' : 'other',
    ja: () => 'other',
    zh: () => 'other',
  };
  
  const rule = rules[locale] || rules.en;
  return rule(count);
};
```

#### Best Practices

1. **Translation Management**:
   - Use namespaces for organization
   - Implement lazy loading for translations
   - Support nested translation keys
   - Handle missing translations gracefully

2. **Localization Features**:
   - Support RTL languages
   - Format dates, numbers, and currencies
   - Handle pluralization rules
   - Support interpolation

3. **Performance Optimization**:
   - Code splitting for translation files
   - Caching loaded translations
   - Debounce locale changes
   - Preload critical translations

4. **User Experience**:
   - Detect user's preferred language
   - Persist language preferences
   - Provide fallback translations
   - Show loading states

**Comparison Summary:**

| Feature | Redux | Zustand |
|---------|-------|---------|
| Implementation | Slice + Async Thunks | Store Actions |
| Complexity | Higher | Lower |
| DevTools | Excellent | Manual |
| Performance | Good with Optimization | Excellent |
| Bundle Size | Larger | Smaller |
| Type Safety | Excellent | Good |
| Learning Curve | Steep | Gentle |
| Middleware Support | Rich Ecosystem | Custom Implementation |

---

### 52. How do you implement advanced WebSocket and real-time communication patterns in Redux vs Zustand?

**Answer:**

Real-time communication through WebSockets is essential for modern applications. Both Redux and Zustand can effectively manage WebSocket connections, real-time data updates, and connection states with different architectural approaches.

#### Redux WebSocket Implementation

```javascript
// store/websocketSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// Async thunk for establishing WebSocket connection
export const connectWebSocket = createAsyncThunk(
  'websocket/connect',
  async ({ url, protocols = [] }, { dispatch, rejectWithValue }) => {
    try {
      const ws = new WebSocket(url, protocols);
      
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          ws.close();
          reject(new Error('WebSocket connection timeout'));
        }, 10000);
        
        ws.onopen = () => {
          clearTimeout(timeout);
          dispatch(websocketSlice.actions.setWebSocket(ws));
          dispatch(websocketSlice.actions.setConnectionState('connected'));
          resolve({ url, protocols });
        };
        
        ws.onerror = (error) => {
          clearTimeout(timeout);
          reject(error);
        };
        
        ws.onmessage = (event) => {
          dispatch(handleWebSocketMessage(event));
        };
        
        ws.onclose = (event) => {
          dispatch(websocketSlice.actions.setConnectionState('disconnected'));
          dispatch(websocketSlice.actions.setWebSocket(null));
          
          // Auto-reconnect logic
          if (!event.wasClean && event.code !== 1000) {
            dispatch(scheduleReconnect());
          }
        };
      });
    } catch (error) {
      return rejectWithValue({
        message: error.message,
        code: error.code,
      });
    }
  }
);

// Async thunk for handling incoming messages
export const handleWebSocketMessage = createAsyncThunk(
  'websocket/handleMessage',
  async (event, { dispatch, getState }) => {
    try {
      const data = JSON.parse(event.data);
      const { type, payload, id } = data;
      
      // Handle different message types
      switch (type) {
        case 'CHAT_MESSAGE':
          dispatch(addChatMessage(payload));
          break;
        case 'USER_STATUS':
          dispatch(updateUserStatus(payload));
          break;
        case 'NOTIFICATION':
          dispatch(addNotification(payload));
          break;
        case 'TYPING_INDICATOR':
          dispatch(updateTypingStatus(payload));
          break;
        case 'PRESENCE_UPDATE':
          dispatch(updatePresence(payload));
          break;
        case 'ROOM_UPDATE':
          dispatch(updateRoom(payload));
          break;
        default:
          console.warn('Unknown message type:', type);
      }
      
      // Send acknowledgment if required
      if (id) {
        dispatch(sendWebSocketMessage({
          type: 'ACK',
          id,
          timestamp: Date.now(),
        }));
      }
      
      return data;
    } catch (error) {
      console.error('Failed to parse WebSocket message:', error);
      return { error: error.message, rawData: event.data };
    }
  }
);

// Async thunk for sending messages
export const sendWebSocketMessage = createAsyncThunk(
  'websocket/sendMessage',
  async (message, { getState, rejectWithValue }) => {
    const { websocket } = getState();
    
    if (!websocket.connection || websocket.connectionState !== 'connected') {
      return rejectWithValue({
        message: 'WebSocket not connected',
        code: 'NOT_CONNECTED',
      });
    }
    
    try {
      const messageWithId = {
        ...message,
        id: generateMessageId(),
        timestamp: Date.now(),
      };
      
      websocket.connection.send(JSON.stringify(messageWithId));
      
      return messageWithId;
    } catch (error) {
      return rejectWithValue({
        message: error.message,
        code: 'SEND_FAILED',
      });
    }
  }
);

// Async thunk for reconnection logic
export const scheduleReconnect = createAsyncThunk(
  'websocket/scheduleReconnect',
  async (_, { dispatch, getState }) => {
    const { websocket } = getState();
    
    if (websocket.reconnectAttempts >= websocket.maxReconnectAttempts) {
      return { maxAttemptsReached: true };
    }
    
    const delay = Math.min(
      websocket.reconnectDelay * Math.pow(2, websocket.reconnectAttempts),
      30000 // Max 30 seconds
    );
    
    await new Promise(resolve => setTimeout(resolve, delay));
    
    dispatch(connectWebSocket({
      url: websocket.url,
      protocols: websocket.protocols,
    }));
    
    return { delay, attempt: websocket.reconnectAttempts + 1 };
  }
);

const websocketSlice = createSlice({
  name: 'websocket',
  initialState: {
    connection: null,
    connectionState: 'disconnected', // 'disconnected', 'connecting', 'connected', 'error'
    url: null,
    protocols: [],
    reconnectAttempts: 0,
    maxReconnectAttempts: 5,
    reconnectDelay: 1000,
    lastError: null,
    messageQueue: [],
    subscriptions: {},
    rooms: {},
    presence: {},
    typingUsers: {},
    notifications: [],
    chatMessages: [],
    connectionStats: {
      connectedAt: null,
      messagesSent: 0,
      messagesReceived: 0,
      reconnectCount: 0,
    },
  },
  reducers: {
    setWebSocket: (state, action) => {
      state.connection = action.payload;
    },
    setConnectionState: (state, action) => {
      state.connectionState = action.payload;
      if (action.payload === 'connected') {
        state.connectionStats.connectedAt = Date.now();
        state.reconnectAttempts = 0;
        // Send queued messages
        state.messageQueue.forEach(message => {
          if (state.connection) {
            state.connection.send(JSON.stringify(message));
          }
        });
        state.messageQueue = [];
      }
    },
    incrementReconnectAttempts: (state) => {
      state.reconnectAttempts += 1;
      state.connectionStats.reconnectCount += 1;
    },
    resetReconnectAttempts: (state) => {
      state.reconnectAttempts = 0;
    },
    setLastError: (state, action) => {
      state.lastError = action.payload;
    },
    queueMessage: (state, action) => {
      state.messageQueue.push(action.payload);
    },
    addSubscription: (state, action) => {
      const { channel, callback } = action.payload;
      if (!state.subscriptions[channel]) {
        state.subscriptions[channel] = [];
      }
      state.subscriptions[channel].push(callback);
    },
    removeSubscription: (state, action) => {
      const { channel, callback } = action.payload;
      if (state.subscriptions[channel]) {
        state.subscriptions[channel] = state.subscriptions[channel].filter(
          cb => cb !== callback
        );
      }
    },
    addChatMessage: (state, action) => {
      state.chatMessages.push({
        ...action.payload,
        receivedAt: Date.now(),
      });
      state.connectionStats.messagesReceived += 1;
    },
    updateUserStatus: (state, action) => {
      const { userId, status } = action.payload;
      if (!state.presence[userId]) {
        state.presence[userId] = {};
      }
      state.presence[userId].status = status;
      state.presence[userId].lastSeen = Date.now();
    },
    updatePresence: (state, action) => {
      const { userId, presence } = action.payload;
      state.presence[userId] = {
        ...state.presence[userId],
        ...presence,
        lastUpdated: Date.now(),
      };
    },
    updateTypingStatus: (state, action) => {
      const { userId, roomId, isTyping } = action.payload;
      if (!state.typingUsers[roomId]) {
        state.typingUsers[roomId] = {};
      }
      if (isTyping) {
        state.typingUsers[roomId][userId] = Date.now();
      } else {
        delete state.typingUsers[roomId][userId];
      }
    },
    updateRoom: (state, action) => {
      const { roomId, updates } = action.payload;
      state.rooms[roomId] = {
        ...state.rooms[roomId],
        ...updates,
        lastUpdated: Date.now(),
      };
    },
    addNotification: (state, action) => {
      state.notifications.push({
        ...action.payload,
        id: generateMessageId(),
        receivedAt: Date.now(),
      });
    },
    removeNotification: (state, action) => {
      state.notifications = state.notifications.filter(
        notification => notification.id !== action.payload
      );
    },
    incrementMessagesSent: (state) => {
      state.connectionStats.messagesSent += 1;
    },
    clearChatMessages: (state) => {
      state.chatMessages = [];
    },
    clearNotifications: (state) => {
      state.notifications = [];
    },
  },
  extraReducers: (builder) => {
    builder
      // Connect WebSocket
      .addCase(connectWebSocket.pending, (state) => {
        state.connectionState = 'connecting';
        state.lastError = null;
      })
      .addCase(connectWebSocket.fulfilled, (state, action) => {
        state.url = action.payload.url;
        state.protocols = action.payload.protocols;
        state.lastError = null;
      })
      .addCase(connectWebSocket.rejected, (state, action) => {
        state.connectionState = 'error';
        state.lastError = action.payload;
        state.reconnectAttempts += 1;
      })
      // Send message
      .addCase(sendWebSocketMessage.fulfilled, (state, action) => {
        state.connectionStats.messagesSent += 1;
      })
      .addCase(sendWebSocketMessage.rejected, (state, action) => {
        // Queue message for retry if connection issue
        if (action.payload?.code === 'NOT_CONNECTED') {
          state.messageQueue.push(action.meta.arg);
        }
        state.lastError = action.payload;
      })
      // Handle message
      .addCase(handleWebSocketMessage.fulfilled, (state) => {
        state.connectionStats.messagesReceived += 1;
      })
      // Schedule reconnect
      .addCase(scheduleReconnect.fulfilled, (state, action) => {
        if (action.payload.maxAttemptsReached) {
          state.connectionState = 'error';
          state.lastError = {
            message: 'Max reconnection attempts reached',
            code: 'MAX_RECONNECT_ATTEMPTS',
          };
        }
      });
  },
});

export const {
  setWebSocket,
  setConnectionState,
  incrementReconnectAttempts,
  resetReconnectAttempts,
  setLastError,
  queueMessage,
  addSubscription,
  removeSubscription,
  addChatMessage,
  updateUserStatus,
  updatePresence,
  updateTypingStatus,
  updateRoom,
  addNotification,
  removeNotification,
  incrementMessagesSent,
  clearChatMessages,
  clearNotifications,
} = websocketSlice.actions;

export default websocketSlice.reducer;

// Helper function
const generateMessageId = () => {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};
```

```javascript
// hooks/useReduxWebSocket.js
import { useSelector, useDispatch } from 'react-redux';
import { useCallback, useEffect, useRef } from 'react';
import {
  connectWebSocket,
  sendWebSocketMessage,
  addSubscription,
  removeSubscription,
} from '../store/websocketSlice';

export const useReduxWebSocket = (url, options = {}) => {
  const dispatch = useDispatch();
  const {
    connection,
    connectionState,
    lastError,
    messageQueue,
    chatMessages,
    notifications,
    presence,
    typingUsers,
    rooms,
    connectionStats,
  } = useSelector(state => state.websocket);
  
  const subscriptionsRef = useRef(new Map());
  
  // Connect to WebSocket
  const connect = useCallback((customUrl = url, protocols = []) => {
    if (customUrl) {
      dispatch(connectWebSocket({ url: customUrl, protocols }));
    }
  }, [dispatch, url]);
  
  // Disconnect WebSocket
  const disconnect = useCallback(() => {
    if (connection) {
      connection.close(1000, 'User initiated disconnect');
    }
  }, [connection]);
  
  // Send message
  const sendMessage = useCallback((message) => {
    dispatch(sendWebSocketMessage(message));
  }, [dispatch]);
  
  // Subscribe to specific message types
  const subscribe = useCallback((channel, callback) => {
    const subscriptionId = `${channel}-${Date.now()}`;
    subscriptionsRef.current.set(subscriptionId, { channel, callback });
    dispatch(addSubscription({ channel, callback }));
    
    return () => {
      subscriptionsRef.current.delete(subscriptionId);
      dispatch(removeSubscription({ channel, callback }));
    };
  }, [dispatch]);
  
  // Join room
  const joinRoom = useCallback((roomId, userData = {}) => {
    sendMessage({
      type: 'JOIN_ROOM',
      payload: { roomId, userData },
    });
  }, [sendMessage]);
  
  // Leave room
  const leaveRoom = useCallback((roomId) => {
    sendMessage({
      type: 'LEAVE_ROOM',
      payload: { roomId },
    });
  }, [sendMessage]);
  
  // Send chat message
  const sendChatMessage = useCallback((roomId, message, metadata = {}) => {
    sendMessage({
      type: 'CHAT_MESSAGE',
      payload: {
        roomId,
        message,
        metadata,
        timestamp: Date.now(),
      },
    });
  }, [sendMessage]);
  
  // Update typing status
  const setTyping = useCallback((roomId, isTyping) => {
    sendMessage({
      type: 'TYPING_INDICATOR',
      payload: { roomId, isTyping },
    });
  }, [sendMessage]);
  
  // Update presence
  const updatePresence = useCallback((presence) => {
    sendMessage({
      type: 'PRESENCE_UPDATE',
      payload: presence,
    });
  }, [sendMessage]);
  
  // Auto-connect on mount
  useEffect(() => {
    if (options.autoConnect !== false && url && connectionState === 'disconnected') {
      connect();
    }
    
    // Cleanup on unmount
    return () => {
      if (options.disconnectOnUnmount !== false) {
        disconnect();
      }
    };
  }, [connect, disconnect, url, connectionState, options.autoConnect, options.disconnectOnUnmount]);
  
  // Cleanup subscriptions on unmount
  useEffect(() => {
    return () => {
      subscriptionsRef.current.clear();
    };
  }, []);
  
  return {
    // Connection state
    isConnected: connectionState === 'connected',
    isConnecting: connectionState === 'connecting',
    connectionState,
    lastError,
    connectionStats,
    
    // Actions
    connect,
    disconnect,
    sendMessage,
    subscribe,
    joinRoom,
    leaveRoom,
    sendChatMessage,
    setTyping,
    updatePresence,
    
    // Data
    chatMessages,
    notifications,
    presence,
    typingUsers,
    rooms,
    messageQueue,
  };
};
```

#### Zustand WebSocket Implementation

```javascript
// stores/websocketStore.js
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

const useWebSocketStore = create(
  subscribeWithSelector(
    immer((set, get) => ({
      // State
      connection: null,
      connectionState: 'disconnected',
      url: null,
      protocols: [],
      reconnectAttempts: 0,
      maxReconnectAttempts: 5,
      reconnectDelay: 1000,
      lastError: null,
      messageQueue: [],
      subscriptions: {},
      rooms: {},
      presence: {},
      typingUsers: {},
      notifications: [],
      chatMessages: [],
      connectionStats: {
        connectedAt: null,
        messagesSent: 0,
        messagesReceived: 0,
        reconnectCount: 0,
      },
      
      // Actions
      connect: async (url, protocols = []) => {
        set((state) => {
          state.connectionState = 'connecting';
          state.lastError = null;
          state.url = url;
          state.protocols = protocols;
        });
        
        try {
          const ws = new WebSocket(url, protocols);
          
          return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
              ws.close();
              reject(new Error('WebSocket connection timeout'));
            }, 10000);
            
            ws.onopen = () => {
              clearTimeout(timeout);
              set((state) => {
                state.connection = ws;
                state.connectionState = 'connected';
                state.connectionStats.connectedAt = Date.now();
                state.reconnectAttempts = 0;
                
                // Send queued messages
                state.messageQueue.forEach(message => {
                  ws.send(JSON.stringify(message));
                });
                state.messageQueue = [];
              });
              resolve();
            };
            
            ws.onerror = (error) => {
              clearTimeout(timeout);
              set((state) => {
                state.connectionState = 'error';
                state.lastError = { message: error.message };
              });
              reject(error);
            };
            
            ws.onmessage = (event) => {
              get().handleMessage(event);
            };
            
            ws.onclose = (event) => {
              set((state) => {
                state.connectionState = 'disconnected';
                state.connection = null;
              });
              
              // Auto-reconnect logic
              if (!event.wasClean && event.code !== 1000) {
                get().scheduleReconnect();
              }
            };
          });
        } catch (error) {
          set((state) => {
            state.connectionState = 'error';
            state.lastError = { message: error.message };
          });
          throw error;
        }
      },
      
      disconnect: () => {
        const { connection } = get();
        if (connection) {
          connection.close(1000, 'User initiated disconnect');
        }
      },
      
      sendMessage: (message) => {
        const { connection, connectionState } = get();
        
        if (!connection || connectionState !== 'connected') {
          set((state) => {
            state.messageQueue.push(message);
          });
          return;
        }
        
        try {
          const messageWithId = {
            ...message,
            id: generateMessageId(),
            timestamp: Date.now(),
          };
          
          connection.send(JSON.stringify(messageWithId));
          
          set((state) => {
            state.connectionStats.messagesSent += 1;
          });
          
          return messageWithId;
        } catch (error) {
          set((state) => {
            state.lastError = { message: error.message };
          });
          throw error;
        }
      },
      
      handleMessage: (event) => {
        try {
          const data = JSON.parse(event.data);
          const { type, payload, id } = data;
          
          set((state) => {
            state.connectionStats.messagesReceived += 1;
          });
          
          // Handle different message types
          switch (type) {
            case 'CHAT_MESSAGE':
              set((state) => {
                state.chatMessages.push({
                  ...payload,
                  receivedAt: Date.now(),
                });
              });
              break;
            case 'USER_STATUS':
              set((state) => {
                const { userId, status } = payload;
                if (!state.presence[userId]) {
                  state.presence[userId] = {};
                }
                state.presence[userId].status = status;
                state.presence[userId].lastSeen = Date.now();
              });
              break;
            case 'NOTIFICATION':
              set((state) => {
                state.notifications.push({
                  ...payload,
                  id: generateMessageId(),
                  receivedAt: Date.now(),
                });
              });
              break;
            case 'TYPING_INDICATOR':
              set((state) => {
                const { userId, roomId, isTyping } = payload;
                if (!state.typingUsers[roomId]) {
                  state.typingUsers[roomId] = {};
                }
                if (isTyping) {
                  state.typingUsers[roomId][userId] = Date.now();
                } else {
                  delete state.typingUsers[roomId][userId];
                }
              });
              break;
            case 'PRESENCE_UPDATE':
              set((state) => {
                const { userId, presence } = payload;
                state.presence[userId] = {
                  ...state.presence[userId],
                  ...presence,
                  lastUpdated: Date.now(),
                };
              });
              break;
            case 'ROOM_UPDATE':
              set((state) => {
                const { roomId, updates } = payload;
                state.rooms[roomId] = {
                  ...state.rooms[roomId],
                  ...updates,
                  lastUpdated: Date.now(),
                };
              });
              break;
          }
          
          // Send acknowledgment if required
          if (id) {
            get().sendMessage({
              type: 'ACK',
              id,
              timestamp: Date.now(),
            });
          }
          
          // Trigger subscriptions
          const subscriptions = get().subscriptions[type] || [];
          subscriptions.forEach(callback => {
            try {
              callback(payload);
            } catch (error) {
              console.error('Subscription callback error:', error);
            }
          });
          
        } catch (error) {
          console.error('Failed to parse WebSocket message:', error);
        }
      },
      
      scheduleReconnect: async () => {
        const { reconnectAttempts, maxReconnectAttempts, reconnectDelay, url, protocols } = get();
        
        if (reconnectAttempts >= maxReconnectAttempts) {
          set((state) => {
            state.connectionState = 'error';
            state.lastError = {
              message: 'Max reconnection attempts reached',
              code: 'MAX_RECONNECT_ATTEMPTS',
            };
          });
          return;
        }
        
        const delay = Math.min(
          reconnectDelay * Math.pow(2, reconnectAttempts),
          30000
        );
        
        set((state) => {
          state.reconnectAttempts += 1;
          state.connectionStats.reconnectCount += 1;
        });
        
        await new Promise(resolve => setTimeout(resolve, delay));
        
        try {
          await get().connect(url, protocols);
        } catch (error) {
          console.error('Reconnection failed:', error);
        }
      },
      
      subscribe: (channel, callback) => {
        set((state) => {
          if (!state.subscriptions[channel]) {
            state.subscriptions[channel] = [];
          }
          state.subscriptions[channel].push(callback);
        });
        
        return () => {
          set((state) => {
            if (state.subscriptions[channel]) {
              state.subscriptions[channel] = state.subscriptions[channel].filter(
                cb => cb !== callback
              );
            }
          });
        };
      },
      
      joinRoom: (roomId, userData = {}) => {
        get().sendMessage({
          type: 'JOIN_ROOM',
          payload: { roomId, userData },
        });
      },
      
      leaveRoom: (roomId) => {
        get().sendMessage({
          type: 'LEAVE_ROOM',
          payload: { roomId },
        });
      },
      
      sendChatMessage: (roomId, message, metadata = {}) => {
        get().sendMessage({
          type: 'CHAT_MESSAGE',
          payload: {
            roomId,
            message,
            metadata,
            timestamp: Date.now(),
          },
        });
      },
      
      setTyping: (roomId, isTyping) => {
        get().sendMessage({
          type: 'TYPING_INDICATOR',
          payload: { roomId, isTyping },
        });
      },
      
      updatePresence: (presence) => {
        get().sendMessage({
          type: 'PRESENCE_UPDATE',
          payload: presence,
        });
      },
      
      clearChatMessages: () => {
        set((state) => {
          state.chatMessages = [];
        });
      },
      
      clearNotifications: () => {
        set((state) => {
          state.notifications = [];
        });
      },
      
      removeNotification: (id) => {
        set((state) => {
          state.notifications = state.notifications.filter(
            notification => notification.id !== id
          );
        });
      },
    }))
  )
);

export default useWebSocketStore;

// Helper function
const generateMessageId = () => {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};
```

```javascript
// hooks/useZustandWebSocket.js
import { useCallback, useEffect, useRef } from 'react';
import useWebSocketStore from '../stores/websocketStore';

export const useZustandWebSocket = (url, options = {}) => {
  const {
    connection,
    connectionState,
    lastError,
    messageQueue,
    chatMessages,
    notifications,
    presence,
    typingUsers,
    rooms,
    connectionStats,
    connect,
    disconnect,
    sendMessage,
    subscribe,
    joinRoom,
    leaveRoom,
    sendChatMessage,
    setTyping,
    updatePresence,
    clearChatMessages,
    clearNotifications,
    removeNotification,
  } = useWebSocketStore();
  
  const subscriptionsRef = useRef(new Map());
  
  // Enhanced subscribe with cleanup
  const enhancedSubscribe = useCallback((channel, callback) => {
    const unsubscribe = subscribe(channel, callback);
    const subscriptionId = `${channel}-${Date.now()}`;
    subscriptionsRef.current.set(subscriptionId, unsubscribe);
    
    return () => {
      unsubscribe();
      subscriptionsRef.current.delete(subscriptionId);
    };
  }, [subscribe]);
  
  // Auto-connect on mount
  useEffect(() => {
    if (options.autoConnect !== false && url && connectionState === 'disconnected') {
      connect(url, options.protocols || []);
    }
    
    // Cleanup on unmount
    return () => {
      if (options.disconnectOnUnmount !== false) {
        disconnect();
      }
    };
  }, [connect, disconnect, url, connectionState, options.autoConnect, options.disconnectOnUnmount, options.protocols]);
  
  // Cleanup subscriptions on unmount
  useEffect(() => {
    return () => {
      subscriptionsRef.current.forEach(unsubscribe => unsubscribe());
      subscriptionsRef.current.clear();
    };
  }, []);
  
  return {
    // Connection state
    isConnected: connectionState === 'connected',
    isConnecting: connectionState === 'connecting',
    connectionState,
    lastError,
    connectionStats,
    
    // Actions
    connect: useCallback((customUrl = url, protocols = []) => {
      if (customUrl) {
        connect(customUrl, protocols);
      }
    }, [connect, url]),
    disconnect,
    sendMessage,
    subscribe: enhancedSubscribe,
    joinRoom,
    leaveRoom,
    sendChatMessage,
    setTyping,
    updatePresence,
    clearChatMessages,
    clearNotifications,
    removeNotification,
    
    // Data
    chatMessages,
    notifications,
    presence,
    typingUsers,
    rooms,
    messageQueue,
  };
};
```

#### Best Practices

1. **Connection Management**:
   - Implement automatic reconnection with exponential backoff
   - Handle connection state transitions properly
   - Queue messages when disconnected
   - Provide connection status feedback

2. **Message Handling**:
   - Use structured message formats
   - Implement message acknowledgments
   - Handle different message types appropriately
   - Provide error handling for malformed messages

3. **Performance Optimization**:
   - Debounce frequent updates (typing indicators)
   - Implement message batching for high-frequency data
   - Use efficient data structures for presence tracking
   - Clean up old data periodically

4. **User Experience**:
   - Show connection status indicators
   - Handle offline/online scenarios
   - Provide retry mechanisms
   - Implement graceful degradation

**Comparison Summary:**

| Feature | Redux | Zustand |
|---------|-------|---------|
| Implementation | Slice + Async Thunks | Store Actions |
| Complexity | Higher | Lower |
| DevTools | Excellent | Manual |
| Performance | Good with Optimization | Excellent |
| Bundle Size | Larger | Smaller |
| Type Safety | Excellent | Good |
| Learning Curve | Steep | Gentle |
| Real-time Updates | Structured | Direct |

---

### 53. How do you implement advanced file upload and management with progress tracking in Redux vs Zustand?

**Answer:**

File upload management with progress tracking, error handling, and state management is crucial for modern applications. Both Redux and Zustand can effectively handle complex file upload scenarios with different architectural approaches.

#### Redux File Upload Implementation

```javascript
// store/fileUploadSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// Async thunk for single file upload
export const uploadFile = createAsyncThunk(
  'fileUpload/uploadFile',
  async ({ file, uploadUrl, options = {} }, { dispatch, rejectWithValue }) => {
    try {
      const formData = new FormData();
      formData.append('file', file);
      
      // Add additional fields if provided
      if (options.metadata) {
        Object.entries(options.metadata).forEach(([key, value]) => {
          formData.append(key, value);
        });
      }
      
      const uploadId = generateUploadId();
      
      // Initialize upload tracking
      dispatch(fileUploadSlice.actions.initializeUpload({
        uploadId,
        file: {
          name: file.name,
          size: file.size,
          type: file.type,
          lastModified: file.lastModified,
        },
        status: 'uploading',
      }));
      
      const xhr = new XMLHttpRequest();
      
      return new Promise((resolve, reject) => {
        // Track upload progress
        xhr.upload.addEventListener('progress', (event) => {
          if (event.lengthComputable) {
            const progress = Math.round((event.loaded / event.total) * 100);
            dispatch(fileUploadSlice.actions.updateProgress({
              uploadId,
              progress,
              loaded: event.loaded,
              total: event.total,
            }));
          }
        });
        
        // Handle upload completion
        xhr.addEventListener('load', () => {
          if (xhr.status >= 200 && xhr.status < 300) {
            try {
              const response = JSON.parse(xhr.responseText);
              dispatch(fileUploadSlice.actions.completeUpload({
                uploadId,
                response,
              }));
              resolve({ uploadId, response });
            } catch (error) {
              dispatch(fileUploadSlice.actions.failUpload({
                uploadId,
                error: 'Invalid response format',
              }));
              reject(new Error('Invalid response format'));
            }
          } else {
            const error = `Upload failed with status ${xhr.status}`;
            dispatch(fileUploadSlice.actions.failUpload({
              uploadId,
              error,
            }));
            reject(new Error(error));
          }
        });
        
        // Handle upload errors
        xhr.addEventListener('error', () => {
          const error = 'Network error during upload';
          dispatch(fileUploadSlice.actions.failUpload({
            uploadId,
            error,
          }));
          reject(new Error(error));
        });
        
        // Handle upload abort
        xhr.addEventListener('abort', () => {
          dispatch(fileUploadSlice.actions.cancelUpload({ uploadId }));
          reject(new Error('Upload cancelled'));
        });
        
        // Store xhr reference for potential cancellation
        dispatch(fileUploadSlice.actions.setXhrReference({
          uploadId,
          xhr,
        }));
        
        // Start upload
        xhr.open('POST', uploadUrl);
        
        // Set headers if provided
        if (options.headers) {
          Object.entries(options.headers).forEach(([key, value]) => {
            xhr.setRequestHeader(key, value);
          });
        }
        
        xhr.send(formData);
      });
    } catch (error) {
      return rejectWithValue({
        message: error.message,
        code: error.code,
      });
    }
  }
);

// Async thunk for multiple file upload
export const uploadMultipleFiles = createAsyncThunk(
  'fileUpload/uploadMultipleFiles',
  async ({ files, uploadUrl, options = {} }, { dispatch }) => {
    const uploadPromises = Array.from(files).map(file => 
      dispatch(uploadFile({ file, uploadUrl, options }))
    );
    
    try {
      const results = await Promise.allSettled(uploadPromises);
      return results.map((result, index) => ({
        file: files[index],
        status: result.status,
        value: result.status === 'fulfilled' ? result.value : null,
        error: result.status === 'rejected' ? result.reason : null,
      }));
    } catch (error) {
      throw error;
    }
  }
);

// Async thunk for chunked upload
export const uploadLargeFile = createAsyncThunk(
  'fileUpload/uploadLargeFile',
  async ({ file, uploadUrl, chunkSize = 1024 * 1024, options = {} }, { dispatch, rejectWithValue }) => {
    try {
      const uploadId = generateUploadId();
      const totalChunks = Math.ceil(file.size / chunkSize);
      
      dispatch(fileUploadSlice.actions.initializeChunkedUpload({
        uploadId,
        file: {
          name: file.name,
          size: file.size,
          type: file.type,
        },
        totalChunks,
        chunkSize,
      }));
      
      const uploadedChunks = [];
      
      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
        const start = chunkIndex * chunkSize;
        const end = Math.min(start + chunkSize, file.size);
        const chunk = file.slice(start, end);
        
        const formData = new FormData();
        formData.append('chunk', chunk);
        formData.append('chunkIndex', chunkIndex.toString());
        formData.append('totalChunks', totalChunks.toString());
        formData.append('uploadId', uploadId);
        formData.append('fileName', file.name);
        
        try {
          const response = await fetch(uploadUrl, {
            method: 'POST',
            body: formData,
            headers: options.headers || {},
          });
          
          if (!response.ok) {
            throw new Error(`Chunk ${chunkIndex} upload failed`);
          }
          
          const chunkResponse = await response.json();
          uploadedChunks.push(chunkResponse);
          
          dispatch(fileUploadSlice.actions.updateChunkProgress({
            uploadId,
            chunkIndex,
            progress: Math.round(((chunkIndex + 1) / totalChunks) * 100),
          }));
        } catch (error) {
          dispatch(fileUploadSlice.actions.failChunkedUpload({
            uploadId,
            error: error.message,
            failedChunk: chunkIndex,
          }));
          throw error;
        }
      }
      
      // Finalize upload
      const finalizeResponse = await fetch(`${uploadUrl}/finalize`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...options.headers,
        },
        body: JSON.stringify({
          uploadId,
          fileName: file.name,
          totalChunks,
        }),
      });
      
      if (!finalizeResponse.ok) {
        throw new Error('Failed to finalize upload');
      }
      
      const finalResponse = await finalizeResponse.json();
      
      dispatch(fileUploadSlice.actions.completeChunkedUpload({
        uploadId,
        response: finalResponse,
      }));
      
      return { uploadId, response: finalResponse };
    } catch (error) {
      return rejectWithValue({
        message: error.message,
        code: error.code,
      });
    }
  }
);

// Async thunk for resumable upload
export const resumeUpload = createAsyncThunk(
  'fileUpload/resumeUpload',
  async ({ uploadId }, { dispatch, getState, rejectWithValue }) => {
    try {
      const { fileUpload } = getState();
      const upload = fileUpload.uploads[uploadId];
      
      if (!upload || upload.status !== 'paused') {
        return rejectWithValue({ message: 'Upload not found or not paused' });
      }
      
      // Check server for upload status
      const statusResponse = await fetch(`/api/upload/status/${uploadId}`);
      const statusData = await statusResponse.json();
      
      dispatch(fileUploadSlice.actions.updateUploadFromServer({
        uploadId,
        serverData: statusData,
      }));
      
      // Resume from where we left off
      if (upload.type === 'chunked') {
        return dispatch(uploadLargeFile({
          file: upload.file,
          uploadUrl: upload.uploadUrl,
          chunkSize: upload.chunkSize,
          options: upload.options,
        }));
      } else {
        return dispatch(uploadFile({
          file: upload.file,
          uploadUrl: upload.uploadUrl,
          options: upload.options,
        }));
      }
    } catch (error) {
      return rejectWithValue({
        message: error.message,
        code: error.code,
      });
    }
  }
);

const fileUploadSlice = createSlice({
  name: 'fileUpload',
  initialState: {
    uploads: {},
    queue: [],
    maxConcurrentUploads: 3,
    activeUploads: 0,
    totalUploaded: 0,
    totalSize: 0,
    globalProgress: 0,
    settings: {
      autoRetry: true,
      maxRetries: 3,
      retryDelay: 1000,
      chunkSize: 1024 * 1024, // 1MB
      allowedTypes: [],
      maxFileSize: 100 * 1024 * 1024, // 100MB
    },
    history: [],
  },
  reducers: {
    initializeUpload: (state, action) => {
      const { uploadId, file, status } = action.payload;
      state.uploads[uploadId] = {
        id: uploadId,
        file,
        status,
        progress: 0,
        loaded: 0,
        total: file.size,
        startTime: Date.now(),
        endTime: null,
        error: null,
        retryCount: 0,
        type: 'single',
        xhr: null,
      };
      state.activeUploads += 1;
      state.totalSize += file.size;
    },
    
    initializeChunkedUpload: (state, action) => {
      const { uploadId, file, totalChunks, chunkSize } = action.payload;
      state.uploads[uploadId] = {
        id: uploadId,
        file,
        status: 'uploading',
        progress: 0,
        loaded: 0,
        total: file.size,
        startTime: Date.now(),
        endTime: null,
        error: null,
        retryCount: 0,
        type: 'chunked',
        totalChunks,
        chunkSize,
        uploadedChunks: [],
        failedChunks: [],
      };
      state.activeUploads += 1;
      state.totalSize += file.size;
    },
    
    updateProgress: (state, action) => {
      const { uploadId, progress, loaded, total } = action.payload;
      if (state.uploads[uploadId]) {
        state.uploads[uploadId].progress = progress;
        state.uploads[uploadId].loaded = loaded;
        state.uploads[uploadId].total = total;
        
        // Update global progress
        const totalLoaded = Object.values(state.uploads).reduce(
          (sum, upload) => sum + upload.loaded, 0
        );
        state.globalProgress = state.totalSize > 0 
          ? Math.round((totalLoaded / state.totalSize) * 100) 
          : 0;
      }
    },
    
    updateChunkProgress: (state, action) => {
      const { uploadId, chunkIndex, progress } = action.payload;
      if (state.uploads[uploadId]) {
        state.uploads[uploadId].progress = progress;
        if (!state.uploads[uploadId].uploadedChunks.includes(chunkIndex)) {
          state.uploads[uploadId].uploadedChunks.push(chunkIndex);
        }
      }
    },
    
    completeUpload: (state, action) => {
      const { uploadId, response } = action.payload;
      if (state.uploads[uploadId]) {
        state.uploads[uploadId].status = 'completed';
        state.uploads[uploadId].progress = 100;
        state.uploads[uploadId].endTime = Date.now();
        state.uploads[uploadId].response = response;
        state.activeUploads -= 1;
        state.totalUploaded += state.uploads[uploadId].total;
        
        // Add to history
        state.history.unshift({
          ...state.uploads[uploadId],
          completedAt: Date.now(),
        });
        
        // Keep only last 50 items in history
        if (state.history.length > 50) {
          state.history = state.history.slice(0, 50);
        }
      }
    },
    
    completeChunkedUpload: (state, action) => {
      const { uploadId, response } = action.payload;
      if (state.uploads[uploadId]) {
        state.uploads[uploadId].status = 'completed';
        state.uploads[uploadId].progress = 100;
        state.uploads[uploadId].endTime = Date.now();
        state.uploads[uploadId].response = response;
        state.activeUploads -= 1;
        state.totalUploaded += state.uploads[uploadId].total;
      }
    },
    
    failUpload: (state, action) => {
      const { uploadId, error } = action.payload;
      if (state.uploads[uploadId]) {
        state.uploads[uploadId].status = 'failed';
        state.uploads[uploadId].error = error;
        state.uploads[uploadId].endTime = Date.now();
        state.activeUploads -= 1;
      }
    },
    
    failChunkedUpload: (state, action) => {
      const { uploadId, error, failedChunk } = action.payload;
      if (state.uploads[uploadId]) {
        state.uploads[uploadId].status = 'failed';
        state.uploads[uploadId].error = error;
        state.uploads[uploadId].failedChunks.push(failedChunk);
        state.activeUploads -= 1;
      }
    },
    
    cancelUpload: (state, action) => {
      const { uploadId } = action.payload;
      if (state.uploads[uploadId]) {
        state.uploads[uploadId].status = 'cancelled';
        state.uploads[uploadId].endTime = Date.now();
        state.activeUploads -= 1;
      }
    },
    
    pauseUpload: (state, action) => {
      const { uploadId } = action.payload;
      if (state.uploads[uploadId]) {
        state.uploads[uploadId].status = 'paused';
      }
    },
    
    retryUpload: (state, action) => {
      const { uploadId } = action.payload;
      if (state.uploads[uploadId]) {
        state.uploads[uploadId].status = 'uploading';
        state.uploads[uploadId].retryCount += 1;
        state.uploads[uploadId].error = null;
      }
    },
    
    setXhrReference: (state, action) => {
      const { uploadId, xhr } = action.payload;
      if (state.uploads[uploadId]) {
        state.uploads[uploadId].xhr = xhr;
      }
    },
    
    updateUploadFromServer: (state, action) => {
      const { uploadId, serverData } = action.payload;
      if (state.uploads[uploadId]) {
        Object.assign(state.uploads[uploadId], serverData);
      }
    },
    
    addToQueue: (state, action) => {
      state.queue.push(action.payload);
    },
    
    removeFromQueue: (state, action) => {
      const { uploadId } = action.payload;
      state.queue = state.queue.filter(item => item.uploadId !== uploadId);
    },
    
    clearCompleted: (state) => {
      Object.keys(state.uploads).forEach(uploadId => {
        if (state.uploads[uploadId].status === 'completed') {
          delete state.uploads[uploadId];
        }
      });
    },
    
    clearAll: (state) => {
      state.uploads = {};
      state.queue = [];
      state.activeUploads = 0;
      state.totalUploaded = 0;
      state.totalSize = 0;
      state.globalProgress = 0;
    },
    
    updateSettings: (state, action) => {
      state.settings = { ...state.settings, ...action.payload };
    },
  },
  extraReducers: (builder) => {
    builder
      // Upload file
      .addCase(uploadFile.pending, (state, action) => {
        // Handle in initializeUpload reducer
      })
      .addCase(uploadFile.fulfilled, (state, action) => {
        // Handle in completeUpload reducer
      })
      .addCase(uploadFile.rejected, (state, action) => {
        // Handle in failUpload reducer
      })
      // Upload multiple files
      .addCase(uploadMultipleFiles.fulfilled, (state, action) => {
        // Results are handled individually by uploadFile thunks
      })
      // Upload large file
      .addCase(uploadLargeFile.pending, (state, action) => {
        // Handle in initializeChunkedUpload reducer
      })
      .addCase(uploadLargeFile.fulfilled, (state, action) => {
        // Handle in completeChunkedUpload reducer
      })
      .addCase(uploadLargeFile.rejected, (state, action) => {
        // Handle in failChunkedUpload reducer
      });
  },
});

export const {
  initializeUpload,
  initializeChunkedUpload,
  updateProgress,
  updateChunkProgress,
  completeUpload,
  completeChunkedUpload,
  failUpload,
  failChunkedUpload,
  cancelUpload,
  pauseUpload,
  retryUpload,
  setXhrReference,
  updateUploadFromServer,
  addToQueue,
  removeFromQueue,
  clearCompleted,
  clearAll,
  updateSettings,
} = fileUploadSlice.actions;

export default fileUploadSlice.reducer;

// Helper function
const generateUploadId = () => {
  return `upload_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
};
```

```javascript
// hooks/useReduxFileUpload.js
import { useSelector, useDispatch } from 'react-redux';
import { useCallback, useRef } from 'react';
import {
  uploadFile,
  uploadMultipleFiles,
  uploadLargeFile,
  resumeUpload,
  cancelUpload,
  pauseUpload,
  retryUpload,
  clearCompleted,
  clearAll,
  updateSettings,
} from '../store/fileUploadSlice';

export const useReduxFileUpload = (defaultOptions = {}) => {
  const dispatch = useDispatch();
  const {
    uploads,
    queue,
    activeUploads,
    maxConcurrentUploads,
    totalUploaded,
    totalSize,
    globalProgress,
    settings,
    history,
  } = useSelector(state => state.fileUpload);
  
  const fileInputRef = useRef(null);
  
  // Upload single file
  const uploadSingleFile = useCallback((file, uploadUrl, options = {}) => {
    const mergedOptions = { ...defaultOptions, ...options };
    
    // Validate file
    if (settings.allowedTypes.length > 0 && !settings.allowedTypes.includes(file.type)) {
      throw new Error(`File type ${file.type} not allowed`);
    }
    
    if (file.size > settings.maxFileSize) {
      throw new Error(`File size exceeds maximum allowed size`);
    }
    
    // Choose upload method based on file size
    if (file.size > settings.chunkSize * 10) {
      return dispatch(uploadLargeFile({
        file,
        uploadUrl,
        chunkSize: settings.chunkSize,
        options: mergedOptions,
      }));
    } else {
      return dispatch(uploadFile({
        file,
        uploadUrl,
        options: mergedOptions,
      }));
    }
  }, [dispatch, defaultOptions, settings]);
  
  // Upload multiple files
  const uploadFiles = useCallback((files, uploadUrl, options = {}) => {
    const mergedOptions = { ...defaultOptions, ...options };
    return dispatch(uploadMultipleFiles({
      files,
      uploadUrl,
      options: mergedOptions,
    }));
  }, [dispatch, defaultOptions]);
  
  // Cancel upload
  const cancel = useCallback((uploadId) => {
    const upload = uploads[uploadId];
    if (upload && upload.xhr) {
      upload.xhr.abort();
    }
    dispatch(cancelUpload({ uploadId }));
  }, [dispatch, uploads]);
  
  // Pause upload
  const pause = useCallback((uploadId) => {
    const upload = uploads[uploadId];
    if (upload && upload.xhr) {
      upload.xhr.abort();
    }
    dispatch(pauseUpload({ uploadId }));
  }, [dispatch, uploads]);
  
  // Resume upload
  const resume = useCallback((uploadId) => {
    return dispatch(resumeUpload({ uploadId }));
  }, [dispatch]);
  
  // Retry upload
  const retry = useCallback((uploadId) => {
    const upload = uploads[uploadId];
    if (upload && upload.retryCount < settings.maxRetries) {
      dispatch(retryUpload({ uploadId }));
      
      // Retry with delay
      setTimeout(() => {
        if (upload.type === 'chunked') {
          dispatch(uploadLargeFile({
            file: upload.file,
            uploadUrl: upload.uploadUrl,
            chunkSize: upload.chunkSize,
            options: upload.options,
          }));
        } else {
          dispatch(uploadFile({
            file: upload.file,
            uploadUrl: upload.uploadUrl,
            options: upload.options,
          }));
        }
      }, settings.retryDelay * upload.retryCount);
    }
  }, [dispatch, uploads, settings]);
  
  // Open file picker
  const openFilePicker = useCallback((options = {}) => {
    if (fileInputRef.current) {
      fileInputRef.current.accept = options.accept || '';
      fileInputRef.current.multiple = options.multiple || false;
      fileInputRef.current.click();
    }
  }, []);
  
  // Handle file selection
  const handleFileSelect = useCallback((event, uploadUrl, options = {}) => {
    const files = Array.from(event.target.files);
    if (files.length === 1) {
      return uploadSingleFile(files[0], uploadUrl, options);
    } else if (files.length > 1) {
      return uploadFiles(files, uploadUrl, options);
    }
  }, [uploadSingleFile, uploadFiles]);
  
  // Handle drag and drop
  const handleDrop = useCallback((event, uploadUrl, options = {}) => {
    event.preventDefault();
    const files = Array.from(event.dataTransfer.files);
    if (files.length === 1) {
      return uploadSingleFile(files[0], uploadUrl, options);
    } else if (files.length > 1) {
      return uploadFiles(files, uploadUrl, options);
    }
  }, [uploadSingleFile, uploadFiles]);
  
  // Clear completed uploads
  const clearCompletedUploads = useCallback(() => {
    dispatch(clearCompleted());
  }, [dispatch]);
  
  // Clear all uploads
  const clearAllUploads = useCallback(() => {
    dispatch(clearAll());
  }, [dispatch]);
  
  // Update settings
  const updateUploadSettings = useCallback((newSettings) => {
    dispatch(updateSettings(newSettings));
  }, [dispatch]);
  
  // Get upload statistics
  const getStatistics = useCallback(() => {
    const completed = Object.values(uploads).filter(u => u.status === 'completed').length;
    const failed = Object.values(uploads).filter(u => u.status === 'failed').length;
    const uploading = Object.values(uploads).filter(u => u.status === 'uploading').length;
    const paused = Object.values(uploads).filter(u => u.status === 'paused').length;
    
    return {
      total: Object.keys(uploads).length,
      completed,
      failed,
      uploading,
      paused,
      totalUploaded,
      totalSize,
      globalProgress,
      activeUploads,
    };
  }, [uploads, totalUploaded, totalSize, globalProgress, activeUploads]);
  
  return {
    // State
    uploads,
    queue,
    settings,
    history,
    statistics: getStatistics(),
    
    // Actions
    uploadSingleFile,
    uploadFiles,
    cancel,
    pause,
    resume,
    retry,
    openFilePicker,
    handleFileSelect,
    handleDrop,
    clearCompletedUploads,
    clearAllUploads,
    updateUploadSettings,
    
    // Utilities
    fileInputRef,
  };
};
```

#### Zustand File Upload Implementation

```javascript
// stores/fileUploadStore.js
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import { persist } from 'zustand/middleware';

const useFileUploadStore = create(
  subscribeWithSelector(
    persist(
      immer((set, get) => ({
        // State
        uploads: {},
        queue: [],
        maxConcurrentUploads: 3,
        activeUploads: 0,
        totalUploaded: 0,
        totalSize: 0,
        globalProgress: 0,
        settings: {
          autoRetry: true,
          maxRetries: 3,
          retryDelay: 1000,
          chunkSize: 1024 * 1024,
          allowedTypes: [],
          maxFileSize: 100 * 1024 * 1024,
        },
        history: [],
        
        // Actions
        uploadFile: async (file, uploadUrl, options = {}) => {
          const uploadId = generateUploadId();
          
          // Validate file
          const { settings } = get();
          if (settings.allowedTypes.length > 0 && !settings.allowedTypes.includes(file.type)) {
            throw new Error(`File type ${file.type} not allowed`);
          }
          
          if (file.size > settings.maxFileSize) {
            throw new Error(`File size exceeds maximum allowed size`);
          }
          
          // Initialize upload
          set((state) => {
            state.uploads[uploadId] = {
              id: uploadId,
              file: {
                name: file.name,
                size: file.size,
                type: file.type,
                lastModified: file.lastModified,
              },
              status: 'uploading',
              progress: 0,
              loaded: 0,
              total: file.size,
              startTime: Date.now(),
              endTime: null,
              error: null,
              retryCount: 0,
              type: 'single',
              xhr: null,
            };
            state.activeUploads += 1;
            state.totalSize += file.size;
          });
          
          try {
            const formData = new FormData();
            formData.append('file', file);
            
            if (options.metadata) {
              Object.entries(options.metadata).forEach(([key, value]) => {
                formData.append(key, value);
              });
            }
            
            const xhr = new XMLHttpRequest();
            
            return new Promise((resolve, reject) => {
              xhr.upload.addEventListener('progress', (event) => {
                if (event.lengthComputable) {
                  const progress = Math.round((event.loaded / event.total) * 100);
                  get().updateProgress(uploadId, progress, event.loaded, event.total);
                }
              });
              
              xhr.addEventListener('load', () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                  try {
                    const response = JSON.parse(xhr.responseText);
                    get().completeUpload(uploadId, response);
                    resolve({ uploadId, response });
                  } catch (error) {
                    get().failUpload(uploadId, 'Invalid response format');
                    reject(new Error('Invalid response format'));
                  }
                } else {
                  const error = `Upload failed with status ${xhr.status}`;
                  get().failUpload(uploadId, error);
                  reject(new Error(error));
                }
              });
              
              xhr.addEventListener('error', () => {
                const error = 'Network error during upload';
                get().failUpload(uploadId, error);
                reject(new Error(error));
              });
              
              xhr.addEventListener('abort', () => {
                get().cancelUpload(uploadId);
                reject(new Error('Upload cancelled'));
              });
              
              // Store xhr reference
              set((state) => {
                if (state.uploads[uploadId]) {
                  state.uploads[uploadId].xhr = xhr;
                }
              });
              
              xhr.open('POST', uploadUrl);
              
              if (options.headers) {
                Object.entries(options.headers).forEach(([key, value]) => {
                  xhr.setRequestHeader(key, value);
                });
              }
              
              xhr.send(formData);
            });
          } catch (error) {
            get().failUpload(uploadId, error.message);
            throw error;
          }
        },
        
        uploadMultipleFiles: async (files, uploadUrl, options = {}) => {
          const uploadPromises = Array.from(files).map(file => 
            get().uploadFile(file, uploadUrl, options)
          );
          
          try {
            const results = await Promise.allSettled(uploadPromises);
            return results.map((result, index) => ({
              file: files[index],
              status: result.status,
              value: result.status === 'fulfilled' ? result.value : null,
              error: result.status === 'rejected' ? result.reason : null,
            }));
          } catch (error) {
            throw error;
          }
        },
        
        uploadLargeFile: async (file, uploadUrl, chunkSize = null, options = {}) => {
          const { settings } = get();
          const actualChunkSize = chunkSize || settings.chunkSize;
          const uploadId = generateUploadId();
          const totalChunks = Math.ceil(file.size / actualChunkSize);
          
          // Initialize chunked upload
          set((state) => {
            state.uploads[uploadId] = {
              id: uploadId,
              file: {
                name: file.name,
                size: file.size,
                type: file.type,
              },
              status: 'uploading',
              progress: 0,
              loaded: 0,
              total: file.size,
              startTime: Date.now(),
              endTime: null,
              error: null,
              retryCount: 0,
              type: 'chunked',
              totalChunks,
              chunkSize: actualChunkSize,
              uploadedChunks: [],
              failedChunks: [],
            };
            state.activeUploads += 1;
            state.totalSize += file.size;
          });
          
          try {
            const uploadedChunks = [];
            
            for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
              const start = chunkIndex * actualChunkSize;
              const end = Math.min(start + actualChunkSize, file.size);
              const chunk = file.slice(start, end);
              
              const formData = new FormData();
              formData.append('chunk', chunk);
              formData.append('chunkIndex', chunkIndex.toString());
              formData.append('totalChunks', totalChunks.toString());
              formData.append('uploadId', uploadId);
              formData.append('fileName', file.name);
              
              const response = await fetch(uploadUrl, {
                method: 'POST',
                body: formData,
                headers: options.headers || {},
              });
              
              if (!response.ok) {
                throw new Error(`Chunk ${chunkIndex} upload failed`);
              }
              
              const chunkResponse = await response.json();
              uploadedChunks.push(chunkResponse);
              
              get().updateChunkProgress(uploadId, chunkIndex, 
                Math.round(((chunkIndex + 1) / totalChunks) * 100)
              );
            }
            
            // Finalize upload
            const finalizeResponse = await fetch(`${uploadUrl}/finalize`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                ...options.headers,
              },
              body: JSON.stringify({
                uploadId,
                fileName: file.name,
                totalChunks,
              }),
            });
            
            if (!finalizeResponse.ok) {
              throw new Error('Failed to finalize upload');
            }
            
            const finalResponse = await finalizeResponse.json();
            get().completeChunkedUpload(uploadId, finalResponse);
            
            return { uploadId, response: finalResponse };
          } catch (error) {
            get().failChunkedUpload(uploadId, error.message);
            throw error;
          }
        },
        
        updateProgress: (uploadId, progress, loaded, total) => {
          set((state) => {
            if (state.uploads[uploadId]) {
              state.uploads[uploadId].progress = progress;
              state.uploads[uploadId].loaded = loaded;
              state.uploads[uploadId].total = total;
              
              // Update global progress
              const totalLoaded = Object.values(state.uploads).reduce(
                (sum, upload) => sum + upload.loaded, 0
              );
              state.globalProgress = state.totalSize > 0 
                ? Math.round((totalLoaded / state.totalSize) * 100) 
                : 0;
            }
          });
        },
        
        updateChunkProgress: (uploadId, chunkIndex, progress) => {
          set((state) => {
            if (state.uploads[uploadId]) {
              state.uploads[uploadId].progress = progress;
              if (!state.uploads[uploadId].uploadedChunks.includes(chunkIndex)) {
                state.uploads[uploadId].uploadedChunks.push(chunkIndex);
              }
            }
          });
        },
        
        completeUpload: (uploadId, response) => {
          set((state) => {
            if (state.uploads[uploadId]) {
              state.uploads[uploadId].status = 'completed';
              state.uploads[uploadId].progress = 100;
              state.uploads[uploadId].endTime = Date.now();
              state.uploads[uploadId].response = response;
              state.activeUploads -= 1;
              state.totalUploaded += state.uploads[uploadId].total;
              
              // Add to history
              state.history.unshift({
                ...state.uploads[uploadId],
                completedAt: Date.now(),
              });
              
              if (state.history.length > 50) {
                state.history = state.history.slice(0, 50);
              }
            }
          });
        },
        
        completeChunkedUpload: (uploadId, response) => {
          set((state) => {
            if (state.uploads[uploadId]) {
              state.uploads[uploadId].status = 'completed';
              state.uploads[uploadId].progress = 100;
              state.uploads[uploadId].endTime = Date.now();
              state.uploads[uploadId].response = response;
              state.activeUploads -= 1;
              state.totalUploaded += state.uploads[uploadId].total;
            }
          });
        },
        
        failUpload: (uploadId, error) => {
          set((state) => {
            if (state.uploads[uploadId]) {
              state.uploads[uploadId].status = 'failed';
              state.uploads[uploadId].error = error;
              state.uploads[uploadId].endTime = Date.now();
              state.activeUploads -= 1;
            }
          });
        },
        
        failChunkedUpload: (uploadId, error, failedChunk = null) => {
          set((state) => {
            if (state.uploads[uploadId]) {
              state.uploads[uploadId].status = 'failed';
              state.uploads[uploadId].error = error;
              if (failedChunk !== null) {
                state.uploads[uploadId].failedChunks.push(failedChunk);
              }
              state.activeUploads -= 1;
            }
          });
        },
        
        cancelUpload: (uploadId) => {
          set((state) => {
            if (state.uploads[uploadId]) {
              if (state.uploads[uploadId].xhr) {
                state.uploads[uploadId].xhr.abort();
              }
              state.uploads[uploadId].status = 'cancelled';
              state.uploads[uploadId].endTime = Date.now();
              state.activeUploads -= 1;
            }
          });
        },
        
        pauseUpload: (uploadId) => {
          set((state) => {
            if (state.uploads[uploadId]) {
              if (state.uploads[uploadId].xhr) {
                state.uploads[uploadId].xhr.abort();
              }
              state.uploads[uploadId].status = 'paused';
            }
          });
        },
        
        retryUpload: async (uploadId) => {
          const { uploads, settings } = get();
          const upload = uploads[uploadId];
          
          if (!upload || upload.retryCount >= settings.maxRetries) {
            return;
          }
          
          set((state) => {
            if (state.uploads[uploadId]) {
              state.uploads[uploadId].status = 'uploading';
              state.uploads[uploadId].retryCount += 1;
              state.uploads[uploadId].error = null;
            }
          });
          
          // Retry with delay
          await new Promise(resolve => 
            setTimeout(resolve, settings.retryDelay * upload.retryCount)
          );
          
          try {
            if (upload.type === 'chunked') {
              return get().uploadLargeFile(
                upload.file, 
                upload.uploadUrl, 
                upload.chunkSize, 
                upload.options
              );
            } else {
              return get().uploadFile(
                upload.file, 
                upload.uploadUrl, 
                upload.options
              );
            }
          } catch (error) {
            get().failUpload(uploadId, error.message);
          }
        },
        
        clearCompleted: () => {
          set((state) => {
            Object.keys(state.uploads).forEach(uploadId => {
              if (state.uploads[uploadId].status === 'completed') {
                delete state.uploads[uploadId];
              }
            });
          });
        },
        
        clearAll: () => {
          set((state) => {
            state.uploads = {};
            state.queue = [];
            state.activeUploads = 0;
            state.totalUploaded = 0;
            state.totalSize = 0;
            state.globalProgress = 0;
          });
        },
        
        updateSettings: (newSettings) => {
          set((state) => {
            state.settings = { ...state.settings, ...newSettings };
          });
        },
        
        getStatistics: () => {
          const { uploads, totalUploaded, totalSize, globalProgress, activeUploads } = get();
          const completed = Object.values(uploads).filter(u => u.status === 'completed').length;
          const failed = Object.values(uploads).filter(u => u.status === 'failed').length;
          const uploading = Object.values(uploads).filter(u => u.status === 'uploading').length;
          const paused = Object.values(uploads).filter(u => u.status === 'paused').length;
          
          return {
            total: Object.keys(uploads).length,
            completed,
            failed,
            uploading,
            paused,
            totalUploaded,
            totalSize,
            globalProgress,
            activeUploads,
          };
        },
      })),
      {
        name: 'file-upload-storage',
        partialize: (state) => ({
          settings: state.settings,
          history: state.history.slice(0, 10), // Only persist recent history
        }),
      }
    )
  )
);

export default useFileUploadStore;

// Helper function
const generateUploadId = () => {
  return `upload_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
};
```

#### Best Practices

1. **Progress Tracking**:
   - Use XMLHttpRequest for detailed progress events
   - Implement chunked uploads for large files
   - Provide visual feedback with progress bars
   - Track global progress across multiple uploads

2. **Error Handling**:
   - Implement automatic retry with exponential backoff
   - Validate files before upload (type, size)
   - Handle network errors gracefully
   - Provide meaningful error messages

3. **Performance Optimization**:
   - Limit concurrent uploads
   - Use chunked uploads for large files
   - Implement upload queuing
   - Clean up completed uploads periodically

4. **User Experience**:
   - Support drag and drop
   - Show upload status and progress
   - Allow pause/resume functionality
   - Provide upload history

**Comparison Summary:**

| Feature | Redux | Zustand |
|---------|-------|---------|
| Implementation | Slice + Async Thunks | Store Actions |
| Complexity | Higher | Lower |
| Progress Tracking | Structured | Direct |
| Error Handling | Comprehensive | Simplified |
| Bundle Size | Larger | Smaller |
| Type Safety | Excellent | Good |
| DevTools | Excellent | Manual |
| Learning Curve | Steep | Gentle |

---

### 54. How do you implement advanced form management with validation and dynamic fields in Redux vs Zustand?

**Answer:**

Advanced form management with validation, dynamic fields, and complex state handling is a common requirement in modern applications. Both Redux and Zustand offer different approaches to handle these complex form scenarios.

#### Redux Form Management Implementation

```javascript
// store/formSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import * as yup from 'yup'; // For validation

// Async thunk for form submission
export const submitForm = createAsyncThunk(
  'form/submitForm',
  async ({ formId, values, endpoint }, { getState, rejectWithValue }) => {
    try {
      const { form } = getState();
      const formConfig = form.forms[formId];
      
      if (!formConfig) {
        return rejectWithValue({ message: 'Form configuration not found' });
      }
      
      // Validate before submission if schema exists
      if (formConfig.validationSchema) {
        try {
          await formConfig.validationSchema.validate(values, { abortEarly: false });
        } catch (validationError) {
          return rejectWithValue({
            validationErrors: validationError.inner.reduce((acc, error) => {
              acc[error.path] = error.message;
              return acc;
            }, {}),
          });
        }
      }
      
      // Submit form data
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(values),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        return rejectWithValue({
          message: errorData.message || 'Form submission failed',
          errors: errorData.errors,
          status: response.status,
        });
      }
      
      const data = await response.json();
      return { formId, data };
    } catch (error) {
      return rejectWithValue({
        message: error.message || 'An unexpected error occurred',
      });
    }
  }
);

// Async thunk for loading form data
export const loadFormData = createAsyncThunk(
  'form/loadFormData',
  async ({ formId, endpoint, params = {} }, { dispatch, rejectWithValue }) => {
    try {
      // Build query string from params
      const queryString = Object.entries(params)
        .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
        .join('&');
      
      const url = queryString ? `${endpoint}?${queryString}` : endpoint;
      
      const response = await fetch(url);
      
      if (!response.ok) {
        const errorData = await response.json();
        return rejectWithValue({
          message: errorData.message || 'Failed to load form data',
          status: response.status,
        });
      }
      
      const data = await response.json();
      
      // Initialize form with loaded data
      dispatch(initializeForm({
        formId,
        initialValues: data,
        touched: {},
        errors: {},
      }));
      
      return { formId, data };
    } catch (error) {
      return rejectWithValue({
        message: error.message || 'An unexpected error occurred',
      });
    }
  }
);

const formSlice = createSlice({
  name: 'form',
  initialState: {
    forms: {},
    submissions: {},
    loading: {},
    submitting: {},
  },
  reducers: {
    // Initialize a form with configuration
    registerForm: (state, action) => {
      const { formId, config } = action.payload;
      
      // Create validation schema if field validations are provided
      let validationSchema = null;
      if (config.fields) {
        const schemaFields = {};
        
        Object.entries(config.fields).forEach(([fieldName, fieldConfig]) => {
          if (fieldConfig.validations) {
            let fieldSchema = yup.mixed();
            
            fieldConfig.validations.forEach(validation => {
              if (validation.type === 'required') {
                fieldSchema = fieldSchema.required(validation.message || 'This field is required');
              } else if (validation.type === 'email') {
                fieldSchema = fieldSchema.email(validation.message || 'Invalid email address');
              } else if (validation.type === 'min') {
                fieldSchema = fieldSchema.min(validation.value, validation.message);
              } else if (validation.type === 'max') {
                fieldSchema = fieldSchema.max(validation.value, validation.message);
              } else if (validation.type === 'matches') {
                fieldSchema = fieldSchema.matches(validation.pattern, validation.message);
              } else if (validation.type === 'custom' && validation.test) {
                fieldSchema = fieldSchema.test(
                  validation.name || 'custom',
                  validation.message || 'Invalid value',
                  validation.test
                );
              }
            });
            
            schemaFields[fieldName] = fieldSchema;
          }
        });
        
        validationSchema = yup.object().shape(schemaFields);
      }
      
      state.forms[formId] = {
        ...config,
        validationSchema,
        values: config.initialValues || {},
        touched: {},
        errors: {},
        dirty: false,
        isValid: true,
        isSubmitted: false,
        submitCount: 0,
      };
    },
    
    // Remove form from state
    unregisterForm: (state, action) => {
      const { formId } = action.payload;
      delete state.forms[formId];
    },
    
    // Initialize form with values
    initializeForm: (state, action) => {
      const { formId, initialValues, touched, errors } = action.payload;
      
      if (state.forms[formId]) {
        state.forms[formId].values = initialValues || {};
        state.forms[formId].initialValues = initialValues || {};
        state.forms[formId].touched = touched || {};
        state.forms[formId].errors = errors || {};
        state.forms[formId].dirty = false;
        state.forms[formId].isSubmitted = false;
        state.forms[formId].submitCount = 0;
      }
    },
    
    // Reset form to initial values
    resetForm: (state, action) => {
      const { formId } = action.payload;
      
      if (state.forms[formId]) {
        state.forms[formId].values = state.forms[formId].initialValues || {};
        state.forms[formId].touched = {};
        state.forms[formId].errors = {};
        state.forms[formId].dirty = false;
        state.forms[formId].isSubmitted = false;
      }
    },
    
    // Update a single field value
    updateField: (state, action) => {
      const { formId, field, value } = action.payload;
      
      if (state.forms[formId]) {
        state.forms[formId].values = {
          ...state.forms[formId].values,
          [field]: value,
        };
        state.forms[formId].dirty = true;
        
        // Mark field as touched
        state.forms[formId].touched = {
          ...state.forms[formId].touched,
          [field]: true,
        };
      }
    },
    
    // Update multiple fields at once
    updateFields: (state, action) => {
      const { formId, values } = action.payload;
      
      if (state.forms[formId]) {
        state.forms[formId].values = {
          ...state.forms[formId].values,
          ...values,
        };
        state.forms[formId].dirty = true;
        
        // Mark fields as touched
        const touchedFields = Object.keys(values).reduce((acc, field) => {
          acc[field] = true;
          return acc;
        }, {});
        
        state.forms[formId].touched = {
          ...state.forms[formId].touched,
          ...touchedFields,
        };
      }
    },
    
    // Set field touched state
    setFieldTouched: (state, action) => {
      const { formId, field, isTouched } = action.payload;
      
      if (state.forms[formId]) {
        state.forms[formId].touched = {
          ...state.forms[formId].touched,
          [field]: isTouched,
        };
      }
    },
    
    // Set multiple fields touched state
    setFieldsTouched: (state, action) => {
      const { formId, touched } = action.payload;
      
      if (state.forms[formId]) {
        state.forms[formId].touched = {
          ...state.forms[formId].touched,
          ...touched,
        };
      }
    },
    
    // Set field error
    setFieldError: (state, action) => {
      const { formId, field, error } = action.payload;
      
      if (state.forms[formId]) {
        state.forms[formId].errors = {
          ...state.forms[formId].errors,
          [field]: error,
        };
        
        // Update form validity
        state.forms[formId].isValid = Object.keys(state.forms[formId].errors).length === 0;
      }
    },
    
    // Set multiple field errors
    setFieldErrors: (state, action) => {
      const { formId, errors } = action.payload;
      
      if (state.forms[formId]) {
        state.forms[formId].errors = {
          ...state.forms[formId].errors,
          ...errors,
        };
        
        // Update form validity
        state.forms[formId].isValid = Object.keys(state.forms[formId].errors).length === 0;
      }
    },
    
    // Clear field error
    clearFieldError: (state, action) => {
      const { formId, field } = action.payload;
      
      if (state.forms[formId] && state.forms[formId].errors[field]) {
        const newErrors = { ...state.forms[formId].errors };
        delete newErrors[field];
        state.forms[formId].errors = newErrors;
        
        // Update form validity
        state.forms[formId].isValid = Object.keys(newErrors).length === 0;
      }
    },
    
    // Clear all errors
    clearErrors: (state, action) => {
      const { formId } = action.payload;
      
      if (state.forms[formId]) {
        state.forms[formId].errors = {};
        state.forms[formId].isValid = true;
      }
    },
    
    // Validate form
    validateForm: (state, action) => {
      const { formId, errors } = action.payload;
      
      if (state.forms[formId]) {
        state.forms[formId].errors = errors || {};
        state.forms[formId].isValid = Object.keys(errors || {}).length === 0;
      }
    },
    
    // Add dynamic field
    addDynamicField: (state, action) => {
      const { formId, field, config, initialValue } = action.payload;
      
      if (state.forms[formId]) {
        // Add field to form config
        if (!state.forms[formId].fields) {
          state.forms[formId].fields = {};
        }
        
        state.forms[formId].fields[field] = config;
        
        // Set initial value
        state.forms[formId].values = {
          ...state.forms[formId].values,
          [field]: initialValue,
        };
      }
    },
    
    // Remove dynamic field
    removeDynamicField: (state, action) => {
      const { formId, field } = action.payload;
      
      if (state.forms[formId] && state.forms[formId].fields) {
        // Remove field from config
        const newFields = { ...state.forms[formId].fields };
        delete newFields[field];
        state.forms[formId].fields = newFields;
        
        // Remove value
        const newValues = { ...state.forms[formId].values };
        delete newValues[field];
        state.forms[formId].values = newValues;
        
        // Remove from touched and errors
        const newTouched = { ...state.forms[formId].touched };
        delete newTouched[field];
        state.forms[formId].touched = newTouched;
        
        const newErrors = { ...state.forms[formId].errors };
        delete newErrors[field];
        state.forms[formId].errors = newErrors;
      }
    },
    
    // Add array field item
    addArrayFieldItem: (state, action) => {
      const { formId, field, item } = action.payload;
      
      if (state.forms[formId]) {
        const currentArray = state.forms[formId].values[field] || [];
        state.forms[formId].values = {
          ...state.forms[formId].values,
          [field]: [...currentArray, item],
        };
      }
    },
    
    // Remove array field item
    removeArrayFieldItem: (state, action) => {
      const { formId, field, index } = action.payload;
      
      if (state.forms[formId] && Array.isArray(state.forms[formId].values[field])) {
        const newArray = [...state.forms[formId].values[field]];
        newArray.splice(index, 1);
        
        state.forms[formId].values = {
          ...state.forms[formId].values,
          [field]: newArray,
        };
      }
    },
    
    // Update array field item
    updateArrayFieldItem: (state, action) => {
      const { formId, field, index, item } = action.payload;
      
      if (state.forms[formId] && Array.isArray(state.forms[formId].values[field])) {
        const newArray = [...state.forms[formId].values[field]];
        newArray[index] = item;
        
        state.forms[formId].values = {
          ...state.forms[formId].values,
          [field]: newArray,
        };
      }
    },
    
    // Move array field item
    moveArrayFieldItem: (state, action) => {
      const { formId, field, fromIndex, toIndex } = action.payload;
      
      if (state.forms[formId] && Array.isArray(state.forms[formId].values[field])) {
        const newArray = [...state.forms[formId].values[field]];
        const [movedItem] = newArray.splice(fromIndex, 1);
        newArray.splice(toIndex, 0, movedItem);
        
        state.forms[formId].values = {
          ...state.forms[formId].values,
          [field]: newArray,
        };
      }
    },
    
    // Set form submission state
    setSubmitting: (state, action) => {
      const { formId, isSubmitting } = action.payload;
      
      if (state.forms[formId]) {
        state.submitting[formId] = isSubmitting;
        
        if (isSubmitting) {
          state.forms[formId].submitCount += 1;
          state.forms[formId].isSubmitted = true;
        }
      }
    },
  },
  extraReducers: (builder) => {
    builder
      // Handle form submission
      .addCase(submitForm.pending, (state, action) => {
        const { formId } = action.meta.arg;
        state.submitting[formId] = true;
        
        if (state.forms[formId]) {
          state.forms[formId].submitCount += 1;
          state.forms[formId].isSubmitted = true;
        }
      })
      .addCase(submitForm.fulfilled, (state, action) => {
        const { formId, data } = action.payload;
        state.submitting[formId] = false;
        state.submissions[formId] = {
          status: 'success',
          data,
          timestamp: Date.now(),
        };
      })
      .addCase(submitForm.rejected, (state, action) => {
        const { formId } = action.meta.arg;
        state.submitting[formId] = false;
        
        const payload = action.payload || {};
        
        state.submissions[formId] = {
          status: 'error',
          error: payload.message || 'Form submission failed',
          timestamp: Date.now(),
        };
        
        // Set validation errors if any
        if (payload.validationErrors && state.forms[formId]) {
          state.forms[formId].errors = payload.validationErrors;
          state.forms[formId].isValid = false;
        }
      })
      // Handle form data loading
      .addCase(loadFormData.pending, (state, action) => {
        const { formId } = action.meta.arg;
        state.loading[formId] = true;
      })
      .addCase(loadFormData.fulfilled, (state, action) => {
        const { formId } = action.payload;
        state.loading[formId] = false;
      })
      .addCase(loadFormData.rejected, (state, action) => {
        const { formId } = action.meta.arg;
        state.loading[formId] = false;
      });
  },
});

export const {
  registerForm,
  unregisterForm,
  initializeForm,
  resetForm,
  updateField,
  updateFields,
  setFieldTouched,
  setFieldsTouched,
  setFieldError,
  setFieldErrors,
  clearFieldError,
  clearErrors,
  validateForm,
  addDynamicField,
  removeDynamicField,
  addArrayFieldItem,
  removeArrayFieldItem,
  updateArrayFieldItem,
  moveArrayFieldItem,
  setSubmitting,
} = formSlice.actions;

export default formSlice.reducer;
```

```javascript
// hooks/useReduxForm.js
import { useCallback, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import {
  registerForm,
  unregisterForm,
  initializeForm,
  resetForm,
  updateField,
  updateFields,
  setFieldTouched,
  setFieldsTouched,
  setFieldError,
  setFieldErrors,
  clearFieldError,
  clearErrors,
  validateForm,
  addDynamicField,
  removeDynamicField,
  addArrayFieldItem,
  removeArrayFieldItem,
  updateArrayFieldItem,
  moveArrayFieldItem,
  submitForm,
  loadFormData,
} from '../store/formSlice';

export const useReduxForm = (formId, config = {}) => {
  const dispatch = useDispatch();
  
  const form = useSelector(state => state.form.forms[formId]);
  const isSubmitting = useSelector(state => state.form.submitting[formId] || false);
  const isLoading = useSelector(state => state.form.loading[formId] || false);
  const submission = useSelector(state => state.form.submissions[formId]);
  
  // Register form on mount
  useEffect(() => {
    dispatch(registerForm({ formId, config }));
    
    return () => {
      dispatch(unregisterForm({ formId }));
    };
  }, [dispatch, formId, config]);
  
  // Initialize form
  const initialize = useCallback((initialValues, touched = {}, errors = {}) => {
    dispatch(initializeForm({ formId, initialValues, touched, errors }));
  }, [dispatch, formId]);
  
  // Reset form
  const reset = useCallback(() => {
    dispatch(resetForm({ formId }));
  }, [dispatch, formId]);
  
  // Handle field change
  const handleChange = useCallback((field, value) => {
    dispatch(updateField({ formId, field, value }));
  }, [dispatch, formId]);
  
  // Handle multiple fields change
  const handleChanges = useCallback((values) => {
    dispatch(updateFields({ formId, values }));
  }, [dispatch, formId]);
  
  // Handle field blur
  const handleBlur = useCallback((field) => {
    dispatch(setFieldTouched({ formId, field, isTouched: true }));
    
    // Validate field if form has validation schema
    if (form && form.validationSchema) {
      try {
        form.validationSchema.validateAt(field, form.values)
          .then(() => {
            dispatch(clearFieldError({ formId, field }));
          })
          .catch(error => {
            dispatch(setFieldError({ formId, field, error: error.message }));
          });
      } catch (error) {
        // Handle synchronous validation errors
        dispatch(setFieldError({ formId, field, error: error.message }));
      }
    }
  }, [dispatch, formId, form]);
  
  // Validate entire form
  const validate = useCallback(async () => {
    if (!form || !form.validationSchema) return true;
    
    try {
      await form.validationSchema.validate(form.values, { abortEarly: false });
      dispatch(clearErrors({ formId }));
      return true;
    } catch (error) {
      const validationErrors = error.inner.reduce((acc, err) => {
        acc[err.path] = err.message;
        return acc;
      }, {});
      
      dispatch(validateForm({ formId, errors: validationErrors }));
      return false;
    }
  }, [dispatch, formId, form]);
  
  // Submit form
  const submit = useCallback(async (endpoint, options = {}) => {
    if (!form) return;
    
    // Validate before submission
    const isValid = await validate();
    
    if (isValid) {
      return dispatch(submitForm({
        formId,
        values: form.values,
        endpoint,
        ...options,
      }));
    }
    
    // Mark all fields as touched on failed validation
    const touchedFields = Object.keys(form.values).reduce((acc, field) => {
      acc[field] = true;
      return acc;
    }, {});
    
    dispatch(setFieldsTouched({ formId, touched: touchedFields }));
    return Promise.reject({ validationFailed: true });
  }, [dispatch, formId, form, validate]);
  
  // Load form data
  const load = useCallback((endpoint, params = {}) => {
    return dispatch(loadFormData({ formId, endpoint, params }));
  }, [dispatch, formId]);
  
  // Add dynamic field
  const addField = useCallback((field, config, initialValue) => {
    dispatch(addDynamicField({ formId, field, config, initialValue }));
  }, [dispatch, formId]);
  
  // Remove dynamic field
  const removeField = useCallback((field) => {
    dispatch(removeDynamicField({ formId, field }));
  }, [dispatch, formId]);
  
  // Array field operations
  const arrayHelpers = useCallback((field) => ({
    add: (item) => dispatch(addArrayFieldItem({ formId, field, item })),
    remove: (index) => dispatch(removeArrayFieldItem({ formId, field, index })),
    update: (index, item) => dispatch(updateArrayFieldItem({ formId, field, index, item })),
    move: (fromIndex, toIndex) => dispatch(moveArrayFieldItem({ formId, field, fromIndex, toIndex })),
    get: () => form?.values[field] || [],
  }), [dispatch, formId, form]);
  
  return {
    // Form state
    values: form?.values || {},
    touched: form?.touched || {},
    errors: form?.errors || {},
    dirty: form?.dirty || false,
    isValid: form?.isValid !== false,
    isSubmitting,
    isLoading,
    submitCount: form?.submitCount || 0,
    isSubmitted: form?.isSubmitted || false,
    submission,
    
    // Form actions
    initialize,
    reset,
    handleChange,
    handleChanges,
    handleBlur,
    validate,
    submit,
    load,
    
    // Field management
    addField,
    removeField,
    arrayHelpers,
    
    // Field helpers
    getFieldProps: (field) => ({
      name: field,
      value: form?.values[field] || '',
      onChange: (e) => handleChange(field, e.target.value),
      onBlur: () => handleBlur(field),
    }),
    
    getInputProps: (field) => ({
      name: field,
      id: field,
      value: form?.values[field] || '',
      onChange: (e) => handleChange(field, e.target.value),
      onBlur: () => handleBlur(field),
      'aria-invalid': !!(form?.touched[field] && form?.errors[field]),
      'aria-describedby': form?.errors[field] ? `${field}-error` : undefined,
    }),
  };
};
```

#### Zustand Form Management Implementation

```javascript
// stores/formStore.js
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import * as yup from 'yup'; // For validation

const useFormStore = create(
  subscribeWithSelector(
    immer((set, get) => ({
      // State
      forms: {},
      submissions: {},
      loading: {},
      submitting: {},
      
      // Actions
      registerForm: (formId, config) => {
        // Create validation schema if field validations are provided
        let validationSchema = null;
        if (config.fields) {
          const schemaFields = {};
          
          Object.entries(config.fields).forEach(([fieldName, fieldConfig]) => {
            if (fieldConfig.validations) {
              let fieldSchema = yup.mixed();
              
              fieldConfig.validations.forEach(validation => {
                if (validation.type === 'required') {
                  fieldSchema = fieldSchema.required(validation.message || 'This field is required');
                } else if (validation.type === 'email') {
                  fieldSchema = fieldSchema.email(validation.message || 'Invalid email address');
                } else if (validation.type === 'min') {
                  fieldSchema = fieldSchema.min(validation.value, validation.message);
                } else if (validation.type === 'max') {
                  fieldSchema = fieldSchema.max(validation.value, validation.message);
                } else if (validation.type === 'matches') {
                  fieldSchema = fieldSchema.matches(validation.pattern, validation.message);
                } else if (validation.type === 'custom' && validation.test) {
                  fieldSchema = fieldSchema.test(
                    validation.name || 'custom',
                    validation.message || 'Invalid value',
                    validation.test
                  );
                }
              });
              
              schemaFields[fieldName] = fieldSchema;
            }
          });
          
          validationSchema = yup.object().shape(schemaFields);
        }
        
        set((state) => {
          state.forms[formId] = {
            ...config,
            validationSchema,
            values: config.initialValues || {},
            initialValues: config.initialValues || {},
            touched: {},
            errors: {},
            dirty: false,
            isValid: true,
            isSubmitted: false,
            submitCount: 0,
          };
        });
      },
      
      unregisterForm: (formId) => {
        set((state) => {
          delete state.forms[formId];
        });
      },
      
      initializeForm: (formId, initialValues, touched = {}, errors = {}) => {
        set((state) => {
          if (state.forms[formId]) {
            state.forms[formId].values = initialValues || {};
            state.forms[formId].initialValues = initialValues || {};
            state.forms[formId].touched = touched || {};
            state.forms[formId].errors = errors || {};
            state.forms[formId].dirty = false;
            state.forms[formId].isSubmitted = false;
            state.forms[formId].submitCount = 0;
          }
        });
      },
      
      resetForm: (formId) => {
        set((state) => {
          if (state.forms[formId]) {
            state.forms[formId].values = state.forms[formId].initialValues || {};
            state.forms[formId].touched = {};
            state.forms[formId].errors = {};
            state.forms[formId].dirty = false;
            state.forms[formId].isSubmitted = false;
          }
        });
      },
      
      updateField: (formId, field, value) => {
        set((state) => {
          if (state.forms[formId]) {
            state.forms[formId].values[field] = value;
            state.forms[formId].dirty = true;
            state.forms[formId].touched[field] = true;
          }
        });
      },
      
      updateFields: (formId, values) => {
        set((state) => {
          if (state.forms[formId]) {
            Object.entries(values).forEach(([field, value]) => {
              state.forms[formId].values[field] = value;
              state.forms[formId].touched[field] = true;
            });
            state.forms[formId].dirty = true;
          }
        });
      },
      
      setFieldTouched: (formId, field, isTouched) => {
        set((state) => {
          if (state.forms[formId]) {
            state.forms[formId].touched[field] = isTouched;
          }
        });
      },
      
      setFieldsTouched: (formId, touched) => {
        set((state) => {
          if (state.forms[formId]) {
            Object.entries(touched).forEach(([field, value]) => {
              state.forms[formId].touched[field] = value;
            });
          }
        });
      },
      
      setFieldError: (formId, field, error) => {
        set((state) => {
          if (state.forms[formId]) {
            state.forms[formId].errors[field] = error;
            state.forms[formId].isValid = Object.keys(state.forms[formId].errors).length === 0;
          }
        });
      },
      
      setFieldErrors: (formId, errors) => {
        set((state) => {
          if (state.forms[formId]) {
            state.forms[formId].errors = { ...state.forms[formId].errors, ...errors };
            state.forms[formId].isValid = Object.keys(state.forms[formId].errors).length === 0;
          }
        });
      },
      
      clearFieldError: (formId, field) => {
        set((state) => {
          if (state.forms[formId] && state.forms[formId].errors[field]) {
            delete state.forms[formId].errors[field];
            state.forms[formId].isValid = Object.keys(state.forms[formId].errors).length === 0;
          }
        });
      },
      
      clearErrors: (formId) => {
        set((state) => {
          if (state.forms[formId]) {
            state.forms[formId].errors = {};
            state.forms[formId].isValid = true;
          }
        });
      },
      
      validateForm: async (formId) => {
        const { forms } = get();
        const form = forms[formId];
        
        if (!form || !form.validationSchema) return true;
        
        try {
          await form.validationSchema.validate(form.values, { abortEarly: false });
          get().clearErrors(formId);
          return true;
        } catch (error) {
          const validationErrors = error.inner.reduce((acc, err) => {
            acc[err.path] = err.message;
            return acc;
          }, {});
          
          set((state) => {
            if (state.forms[formId]) {
              state.forms[formId].errors = validationErrors;
              state.forms[formId].isValid = false;
            }
          });
          
          return false;
        }
      },
      
      validateField: async (formId, field) => {
        const { forms } = get();
        const form = forms[formId];
        
        if (!form || !form.validationSchema) return true;
        
        try {
          await form.validationSchema.validateAt(field, form.values);
          get().clearFieldError(formId, field);
          return true;
        } catch (error) {
          get().setFieldError(formId, field, error.message);
          return false;
        }
      },
      
      addDynamicField: (formId, field, config, initialValue) => {
        set((state) => {
          if (state.forms[formId]) {
            if (!state.forms[formId].fields) {
              state.forms[formId].fields = {};
            }
            
            state.forms[formId].fields[field] = config;
            state.forms[formId].values[field] = initialValue;
          }
        });
      },
      
      removeDynamicField: (formId, field) => {
        set((state) => {
          if (state.forms[formId] && state.forms[formId].fields) {
            delete state.forms[formId].fields[field];
            delete state.forms[formId].values[field];
            delete state.forms[formId].touched[field];
            delete state.forms[formId].errors[field];
          }
        });
      },
      
      addArrayFieldItem: (formId, field, item) => {
        set((state) => {
          if (state.forms[formId]) {
            if (!state.forms[formId].values[field]) {
              state.forms[formId].values[field] = [];
            }
            state.forms[formId].values[field].push(item);
          }
        });
      },
      
      removeArrayFieldItem: (formId, field, index) => {
        set((state) => {
          if (state.forms[formId] && Array.isArray(state.forms[formId].values[field])) {
            state.forms[formId].values[field].splice(index, 1);
          }
        });
      },
      
      updateArrayFieldItem: (formId, field, index, item) => {
        set((state) => {
          if (state.forms[formId] && Array.isArray(state.forms[formId].values[field])) {
            state.forms[formId].values[field][index] = item;
          }
        });
      },
      
      moveArrayFieldItem: (formId, field, fromIndex, toIndex) => {
        set((state) => {
          if (state.forms[formId] && Array.isArray(state.forms[formId].values[field])) {
            const [movedItem] = state.forms[formId].values[field].splice(fromIndex, 1);
            state.forms[formId].values[field].splice(toIndex, 0, movedItem);
          }
        });
      },
      
      submitForm: async (formId, endpoint, options = {}) => {
        const { forms } = get();
        const form = forms[formId];
        
        if (!form) return Promise.reject(new Error('Form not found'));
        
        // Validate before submission
        const isValid = await get().validateForm(formId);
        
        if (!isValid) {
          // Mark all fields as touched on failed validation
          const touchedFields = Object.keys(form.values).reduce((acc, field) => {
            acc[field] = true;
            return acc;
          }, {});
          
          get().setFieldsTouched(formId, touchedFields);
          return Promise.reject({ validationFailed: true });
        }
        
        // Set submitting state
        set((state) => {
          state.submitting[formId] = true;
          if (state.forms[formId]) {
            state.forms[formId].submitCount += 1;
            state.forms[formId].isSubmitted = true;
          }
        });
        
        try {
          // Submit form data
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(form.values),
            ...options,
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || 'Form submission failed');
          }
          
          const data = await response.json();
          
          // Update submission state
          set((state) => {
            state.submitting[formId] = false;
            state.submissions[formId] = {
              status: 'success',
              data,
              timestamp: Date.now(),
            };
          });
          
          return data;
        } catch (error) {
          // Update submission state with error
          set((state) => {
            state.submitting[formId] = false;
            state.submissions[formId] = {
              status: 'error',
              error: error.message || 'Form submission failed',
              timestamp: Date.now(),
            };
          });
          
          throw error;
        }
      },
      
      loadFormData: async (formId, endpoint, params = {}) => {
        // Set loading state
        set((state) => {
          state.loading[formId] = true;
        });
        
        try {
          // Build query string from params
          const queryString = Object.entries(params)
            .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
            .join('&');
          
          const url = queryString ? `${endpoint}?${queryString}` : endpoint;
          
          const response = await fetch(url);
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || 'Failed to load form data');
          }
          
          const data = await response.json();
          
          // Initialize form with loaded data
          get().initializeForm(formId, data);
          
          // Update loading state
          set((state) => {
            state.loading[formId] = false;
          });
          
          return data;
        } catch (error) {
          // Update loading state with error
          set((state) => {
            state.loading[formId] = false;
          });
          
          throw error;
        }
      },
      
      getFormState: (formId) => {
        const { forms, submitting, loading, submissions } = get();
        const form = forms[formId];
        
        if (!form) return null;
        
        return {
          values: form.values,
          touched: form.touched,
          errors: form.errors,
          dirty: form.dirty,
          isValid: form.isValid,
          isSubmitting: submitting[formId] || false,
          isLoading: loading[formId] || false,
          submitCount: form.submitCount,
          isSubmitted: form.isSubmitted,
          submission: submissions[formId],
        };
      },
    }))
  )
);

export default useFormStore;
```

```javascript
// hooks/useZustandForm.js
import { useCallback, useEffect } from 'react';
import useFormStore from '../stores/formStore';

export const useZustandForm = (formId, config = {}) => {
  // Get form actions from store
  const {
    registerForm,
    unregisterForm,
    initializeForm,
    resetForm,
    updateField,
    updateFields,
    setFieldTouched,
    setFieldsTouched,
    setFieldError,
    setFieldErrors,
    clearFieldError,
    clearErrors,
    validateForm,
    validateField,
    addDynamicField,
    removeDynamicField,
    addArrayFieldItem,
    removeArrayFieldItem,
    updateArrayFieldItem,
    moveArrayFieldItem,
    submitForm,
    loadFormData,
    getFormState,
  } = useFormStore();
  
  // Register form on mount
  useEffect(() => {
    registerForm(formId, config);
    
    return () => {
      unregisterForm(formId);
    };
  }, [formId, config]);
  
  // Get current form state
  const formState = useFormStore(useCallback(
    state => state.forms[formId] || {},
    [formId]
  ));
  
  const isSubmitting = useFormStore(useCallback(
    state => state.submitting[formId] || false,
    [formId]
  ));
  
  const isLoading = useFormStore(useCallback(
    state => state.loading[formId] || false,
    [formId]
  ));
  
  const submission = useFormStore(useCallback(
    state => state.submissions[formId],
    [formId]
  ));
  
  // Handle field change
  const handleChange = useCallback((field, value) => {
    updateField(formId, field, value);
  }, [formId]);
  
  // Handle multiple fields change
  const handleChanges = useCallback((values) => {
    updateFields(formId, values);
  }, [formId]);
  
  // Handle field blur
  const handleBlur = useCallback((field) => {
    setFieldTouched(formId, field, true);
    validateField(formId, field);
  }, [formId]);
  
  // Submit form
  const submit = useCallback(async (endpoint, options = {}) => {
    return submitForm(formId, endpoint, options);
  }, [formId]);
  
  // Load form data
  const load = useCallback((endpoint, params = {}) => {
    return loadFormData(formId, endpoint, params);
  }, [formId]);
  
  // Array field operations
  const arrayHelpers = useCallback((field) => ({
    add: (item) => addArrayFieldItem(formId, field, item),
    remove: (index) => removeArrayFieldItem(formId, field, index),
    update: (index, item) => updateArrayFieldItem(formId, field, index, item),
    move: (fromIndex, toIndex) => moveArrayFieldItem(formId, field, fromIndex, toIndex),
    get: () => formState.values?.[field] || [],
  }), [formId, formState.values]);
  
  return {
    // Form state
    values: formState.values || {},
    touched: formState.touched || {},
    errors: formState.errors || {},
    dirty: formState.dirty || false,
    isValid: formState.isValid !== false,
    isSubmitting,
    isLoading,
    submitCount: formState.submitCount || 0,
    isSubmitted: formState.isSubmitted || false,
    submission,
    
    // Form actions
    initialize: (initialValues, touched = {}, errors = {}) => 
      initializeForm(formId, initialValues, touched, errors),
    reset: () => resetForm(formId),
    handleChange,
    handleChanges,
    handleBlur,
    validate: () => validateForm(formId),
    submit,
    load,
    
    // Field management
    addField: (field, config, initialValue) => 
      addDynamicField(formId, field, config, initialValue),
    removeField: (field) => removeDynamicField(formId, field),
    arrayHelpers,
    
    // Field helpers
    getFieldProps: (field) => ({
      name: field,
      value: formState.values?.[field] || '',
      onChange: (e) => handleChange(field, e.target.value),
      onBlur: () => handleBlur(field),
    }),
    
    getInputProps: (field) => ({
      name: field,
      id: field,
      value: formState.values?.[field] || '',
      onChange: (e) => handleChange(field, e.target.value),
      onBlur: () => handleBlur(field),
      'aria-invalid': !!(formState.touched?.[field] && formState.errors?.[field]),
      'aria-describedby': formState.errors?.[field] ? `${field}-error` : undefined,
    }),
  };
};
```

#### Best Practices

1. **Form Validation**:
   - Use schema-based validation (Yup, Zod, etc.)
   - Validate on blur for better UX
   - Provide clear error messages
   - Support both field-level and form-level validation

2. **Dynamic Fields**:
   - Support adding/removing fields at runtime
   - Handle array fields with add/remove/move operations
   - Maintain validation schema consistency with dynamic fields

3. **Performance Optimization**:
   - Avoid unnecessary re-renders
   - Memoize form operations
   - Implement field-level updates
   - Use debounce for real-time validation

4. **Accessibility**:
   - Provide proper ARIA attributes
   - Support keyboard navigation
   - Ensure error messages are accessible
   - Maintain focus management

5. **Form Submission**:
   - Handle loading states
   - Provide submission feedback
   - Support retry on failure
   - Prevent double submission

**Comparison Summary:**

| Feature | Redux | Zustand |
|---------|-------|---------|
| Implementation | Slice + Async Thunks | Store Actions |
| Complexity | Higher | Lower |
| Boilerplate | More | Less |
| Performance | Good with memoization | Better by default |
| DevTools | Excellent | Basic |
| Type Safety | Excellent | Good |
| Bundle Size | Larger | Smaller |
| Learning Curve | Steep | Gentle |
| Dynamic Fields | Comprehensive | Streamlined |
| Form Arrays | Full featured | Simplified |

---

### 55. How do you implement advanced data visualization and charting state management in Redux vs Zustand?

**Answer:**

Data visualization and charting applications require sophisticated state management for handling chart data, configurations, interactions, real-time updates, and user customizations. Both Redux and Zustand provide different approaches to manage complex visualization state.

#### Redux Data Visualization Implementation

```javascript
// store/chartSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { debounce } from 'lodash';

// Async thunk for loading chart data
export const loadChartData = createAsyncThunk(
  'chart/loadChartData',
  async ({ chartId, endpoint, params = {} }, { getState, rejectWithValue }) => {
    try {
      const { chart } = getState();
      const chartConfig = chart.charts[chartId];
      
      if (!chartConfig) {
        return rejectWithValue({ message: 'Chart configuration not found' });
      }
      
      // Build query string from params
      const queryString = Object.entries({
        ...params,
        startDate: chartConfig.dateRange?.start,
        endDate: chartConfig.dateRange?.end,
        granularity: chartConfig.granularity,
        filters: JSON.stringify(chartConfig.filters),
      })
        .filter(([_, value]) => value !== undefined && value !== null)
        .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
        .join('&');
      
      const url = queryString ? `${endpoint}?${queryString}` : endpoint;
      
      const response = await fetch(url, {
        headers: {
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        return rejectWithValue({
          message: errorData.message || 'Failed to load chart data',
          status: response.status,
        });
      }
      
      const data = await response.json();
      
      // Process data based on chart type
      const processedData = processChartData(data, chartConfig.type, chartConfig.options);
      
      return { chartId, data: processedData, rawData: data };
    } catch (error) {
      return rejectWithValue({
        message: error.message || 'An unexpected error occurred',
      });
    }
  }
);

// Async thunk for real-time data updates
export const subscribeToRealTimeData = createAsyncThunk(
  'chart/subscribeToRealTimeData',
  async ({ chartId, websocketUrl, options = {} }, { dispatch, getState }) => {
    const { chart } = getState();
    const chartConfig = chart.charts[chartId];
    
    if (!chartConfig) {
      throw new Error('Chart configuration not found');
    }
    
    // Create WebSocket connection
    const ws = new WebSocket(websocketUrl);
    
    ws.onopen = () => {
      dispatch(setWebSocketConnection({ chartId, connected: true }));
      
      // Send subscription message
      ws.send(JSON.stringify({
        type: 'subscribe',
        chartId,
        filters: chartConfig.filters,
        ...options,
      }));
    };
    
    ws.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        
        if (message.type === 'data_update') {
          dispatch(updateRealTimeData({
            chartId,
            data: message.data,
            timestamp: message.timestamp,
          }));
        } else if (message.type === 'error') {
          dispatch(setChartError({ chartId, error: message.error }));
        }
      } catch (error) {
        console.error('Failed to parse WebSocket message:', error);
      }
    };
    
    ws.onerror = (error) => {
      dispatch(setWebSocketConnection({ chartId, connected: false, error: error.message }));
    };
    
    ws.onclose = () => {
      dispatch(setWebSocketConnection({ chartId, connected: false }));
    };
    
    return { chartId, websocket: ws };
  }
);

// Async thunk for exporting chart data
export const exportChartData = createAsyncThunk(
  'chart/exportChartData',
  async ({ chartId, format, options = {} }, { getState, rejectWithValue }) => {
    try {
      const { chart } = getState();
      const chartConfig = chart.charts[chartId];
      
      if (!chartConfig) {
        return rejectWithValue({ message: 'Chart configuration not found' });
      }
      
      const exportData = {
        chartId,
        type: chartConfig.type,
        data: chartConfig.data,
        config: chartConfig.options,
        format,
        ...options,
      };
      
      const response = await fetch('/api/charts/export', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(exportData),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        return rejectWithValue({
          message: errorData.message || 'Export failed',
          status: response.status,
        });
      }
      
      // Handle different response types
      if (format === 'json') {
        const data = await response.json();
        return { chartId, format, data };
      } else {
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        
        // Trigger download
        const link = document.createElement('a');
        link.href = url;
        link.download = `chart-${chartId}.${format}`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        return { chartId, format, downloaded: true };
      }
    } catch (error) {
      return rejectWithValue({
        message: error.message || 'Export failed',
      });
    }
  }
);

// Helper function to process chart data
const processChartData = (rawData, chartType, options = {}) => {
  switch (chartType) {
    case 'line':
    case 'area':
      return rawData.map(item => ({
        x: new Date(item.timestamp),
        y: parseFloat(item.value),
        ...item,
      }));
    
    case 'bar':
    case 'column':
      return rawData.map(item => ({
        category: item.category,
        value: parseFloat(item.value),
        ...item,
      }));
    
    case 'pie':
    case 'donut':
      return rawData.map(item => ({
        label: item.label,
        value: parseFloat(item.value),
        percentage: parseFloat(item.percentage),
        ...item,
      }));
    
    case 'scatter':
      return rawData.map(item => ({
        x: parseFloat(item.x),
        y: parseFloat(item.y),
        size: item.size ? parseFloat(item.size) : undefined,
        ...item,
      }));
    
    case 'heatmap':
      return {
        data: rawData.data,
        xAxis: rawData.xAxis || [],
        yAxis: rawData.yAxis || [],
        min: rawData.min,
        max: rawData.max,
      };
    
    default:
      return rawData;
  }
};

const chartSlice = createSlice({
  name: 'chart',
  initialState: {
    charts: {},
    loading: {},
    errors: {},
    websockets: {},
    exports: {},
    globalSettings: {
      theme: 'light',
      animations: true,
      responsiveBreakpoints: {
        mobile: 768,
        tablet: 1024,
      },
    },
  },
  reducers: {
    // Register a new chart
    registerChart: (state, action) => {
      const { chartId, config } = action.payload;
      
      state.charts[chartId] = {
        id: chartId,
        type: config.type || 'line',
        data: [],
        rawData: [],
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: {
            duration: state.globalSettings.animations ? 750 : 0,
          },
          ...config.options,
        },
        dateRange: config.dateRange || {
          start: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // 7 days ago
          end: new Date(),
        },
        granularity: config.granularity || 'hour',
        filters: config.filters || {},
        interactions: {
          zoom: config.interactions?.zoom !== false,
          pan: config.interactions?.pan !== false,
          select: config.interactions?.select !== false,
          hover: config.interactions?.hover !== false,
        },
        realTime: {
          enabled: config.realTime?.enabled || false,
          interval: config.realTime?.interval || 5000,
          maxDataPoints: config.realTime?.maxDataPoints || 1000,
        },
        lastUpdated: null,
        version: 1,
      };
    },
    
    // Remove chart
    unregisterChart: (state, action) => {
      const { chartId } = action.payload;
      
      // Close WebSocket connection if exists
      if (state.websockets[chartId]?.websocket) {
        state.websockets[chartId].websocket.close();
      }
      
      delete state.charts[chartId];
      delete state.loading[chartId];
      delete state.errors[chartId];
      delete state.websockets[chartId];
      delete state.exports[chartId];
    },
    
    // Update chart configuration
    updateChartConfig: (state, action) => {
      const { chartId, config } = action.payload;
      
      if (state.charts[chartId]) {
        state.charts[chartId] = {
          ...state.charts[chartId],
          ...config,
          version: state.charts[chartId].version + 1,
        };
      }
    },
    
    // Update chart data
    updateChartData: (state, action) => {
      const { chartId, data, rawData } = action.payload;
      
      if (state.charts[chartId]) {
        state.charts[chartId].data = data;
        if (rawData) {
          state.charts[chartId].rawData = rawData;
        }
        state.charts[chartId].lastUpdated = Date.now();
        state.charts[chartId].version += 1;
      }
    },
    
    // Update real-time data
    updateRealTimeData: (state, action) => {
      const { chartId, data, timestamp } = action.payload;
      
      if (state.charts[chartId] && state.charts[chartId].realTime.enabled) {
        const chart = state.charts[chartId];
        const maxDataPoints = chart.realTime.maxDataPoints;
        
        // Add new data point
        const newData = [...chart.data, ...data];
        
        // Limit data points if necessary
        if (newData.length > maxDataPoints) {
          chart.data = newData.slice(-maxDataPoints);
        } else {
          chart.data = newData;
        }
        
        chart.lastUpdated = timestamp || Date.now();
        chart.version += 1;
      }
    },
    
    // Set chart options
    setChartOptions: (state, action) => {
      const { chartId, options } = action.payload;
      
      if (state.charts[chartId]) {
        state.charts[chartId].options = {
          ...state.charts[chartId].options,
          ...options,
        };
        state.charts[chartId].version += 1;
      }
    },
    
    // Set date range
    setDateRange: (state, action) => {
      const { chartId, start, end } = action.payload;
      
      if (state.charts[chartId]) {
        state.charts[chartId].dateRange = { start, end };
        state.charts[chartId].version += 1;
      }
    },
    
    // Set granularity
    setGranularity: (state, action) => {
      const { chartId, granularity } = action.payload;
      
      if (state.charts[chartId]) {
        state.charts[chartId].granularity = granularity;
        state.charts[chartId].version += 1;
      }
    },
    
    // Update filters
    updateFilters: (state, action) => {
      const { chartId, filters } = action.payload;
      
      if (state.charts[chartId]) {
        state.charts[chartId].filters = {
          ...state.charts[chartId].filters,
          ...filters,
        };
        state.charts[chartId].version += 1;
      }
    },
    
    // Clear filters
    clearFilters: (state, action) => {
      const { chartId } = action.payload;
      
      if (state.charts[chartId]) {
        state.charts[chartId].filters = {};
        state.charts[chartId].version += 1;
      }
    },
    
    // Set chart error
    setChartError: (state, action) => {
      const { chartId, error } = action.payload;
      state.errors[chartId] = error;
    },
    
    // Clear chart error
    clearChartError: (state, action) => {
      const { chartId } = action.payload;
      delete state.errors[chartId];
    },
    
    // Set WebSocket connection
    setWebSocketConnection: (state, action) => {
      const { chartId, connected, error, websocket } = action.payload;
      
      if (!state.websockets[chartId]) {
        state.websockets[chartId] = {};
      }
      
      state.websockets[chartId].connected = connected;
      
      if (error) {
        state.websockets[chartId].error = error;
      } else {
        delete state.websockets[chartId].error;
      }
      
      if (websocket) {
        state.websockets[chartId].websocket = websocket;
      }
    },
    
    // Update global settings
    updateGlobalSettings: (state, action) => {
      const { settings } = action.payload;
      
      state.globalSettings = {
        ...state.globalSettings,
        ...settings,
      };
      
      // Update animation settings for all charts
      if (settings.animations !== undefined) {
        Object.values(state.charts).forEach(chart => {
          chart.options.animation.duration = settings.animations ? 750 : 0;
          chart.version += 1;
        });
      }
    },
    
    // Add annotation
    addAnnotation: (state, action) => {
      const { chartId, annotation } = action.payload;
      
      if (state.charts[chartId]) {
        if (!state.charts[chartId].annotations) {
          state.charts[chartId].annotations = [];
        }
        
        state.charts[chartId].annotations.push({
          id: Date.now().toString(),
          timestamp: Date.now(),
          ...annotation,
        });
        
        state.charts[chartId].version += 1;
      }
    },
    
    // Remove annotation
    removeAnnotation: (state, action) => {
      const { chartId, annotationId } = action.payload;
      
      if (state.charts[chartId] && state.charts[chartId].annotations) {
        state.charts[chartId].annotations = state.charts[chartId].annotations.filter(
          annotation => annotation.id !== annotationId
        );
        state.charts[chartId].version += 1;
      }
    },
    
    // Set chart selection
    setChartSelection: (state, action) => {
      const { chartId, selection } = action.payload;
      
      if (state.charts[chartId]) {
        state.charts[chartId].selection = selection;
      }
    },
    
    // Clear chart selection
    clearChartSelection: (state, action) => {
      const { chartId } = action.payload;
      
      if (state.charts[chartId]) {
        delete state.charts[chartId].selection;
      }
    },
  },
  extraReducers: (builder) => {
    builder
      // Handle chart data loading
      .addCase(loadChartData.pending, (state, action) => {
        const { chartId } = action.meta.arg;
        state.loading[chartId] = true;
        delete state.errors[chartId];
      })
      .addCase(loadChartData.fulfilled, (state, action) => {
        const { chartId, data, rawData } = action.payload;
        state.loading[chartId] = false;
        
        if (state.charts[chartId]) {
          state.charts[chartId].data = data;
          state.charts[chartId].rawData = rawData;
          state.charts[chartId].lastUpdated = Date.now();
          state.charts[chartId].version += 1;
        }
      })
      .addCase(loadChartData.rejected, (state, action) => {
        const { chartId } = action.meta.arg;
        state.loading[chartId] = false;
        state.errors[chartId] = action.payload?.message || 'Failed to load chart data';
      })
      // Handle real-time subscription
      .addCase(subscribeToRealTimeData.fulfilled, (state, action) => {
        const { chartId, websocket } = action.payload;
        
        if (!state.websockets[chartId]) {
          state.websockets[chartId] = {};
        }
        
        state.websockets[chartId].websocket = websocket;
      })
      // Handle export
      .addCase(exportChartData.pending, (state, action) => {
        const { chartId } = action.meta.arg;
        
        if (!state.exports[chartId]) {
          state.exports[chartId] = {};
        }
        
        state.exports[chartId].loading = true;
      })
      .addCase(exportChartData.fulfilled, (state, action) => {
        const { chartId, format, data, downloaded } = action.payload;
        
        state.exports[chartId] = {
          loading: false,
          lastExport: {
            format,
            timestamp: Date.now(),
            data: data || null,
            downloaded: downloaded || false,
          },
        };
      })
      .addCase(exportChartData.rejected, (state, action) => {
        const { chartId } = action.meta.arg;
        
        state.exports[chartId] = {
          loading: false,
          error: action.payload?.message || 'Export failed',
        };
      });
  },
});

export const {
  registerChart,
  unregisterChart,
  updateChartConfig,
  updateChartData,
  updateRealTimeData,
  setChartOptions,
  setDateRange,
  setGranularity,
  updateFilters,
  clearFilters,
  setChartError,
  clearChartError,
  setWebSocketConnection,
  updateGlobalSettings,
  addAnnotation,
  removeAnnotation,
  setChartSelection,
  clearChartSelection,
} = chartSlice.actions;

export default chartSlice.reducer;
```

```javascript
// hooks/useReduxChart.js
import { useCallback, useEffect, useRef } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import {
  registerChart,
  unregisterChart,
  updateChartConfig,
  updateChartData,
  setChartOptions,
  setDateRange,
  setGranularity,
  updateFilters,
  clearFilters,
  clearChartError,
  updateGlobalSettings,
  addAnnotation,
  removeAnnotation,
  setChartSelection,
  clearChartSelection,
  loadChartData,
  subscribeToRealTimeData,
  exportChartData,
} from '../store/chartSlice';

export const useReduxChart = (chartId, config = {}) => {
  const dispatch = useDispatch();
  const refreshIntervalRef = useRef(null);
  
  const chart = useSelector(state => state.chart.charts[chartId]);
  const isLoading = useSelector(state => state.chart.loading[chartId] || false);
  const error = useSelector(state => state.chart.errors[chartId]);
  const websocket = useSelector(state => state.chart.websockets[chartId]);
  const exportState = useSelector(state => state.chart.exports[chartId]);
  const globalSettings = useSelector(state => state.chart.globalSettings);
  
  // Register chart on mount
  useEffect(() => {
    dispatch(registerChart({ chartId, config }));
    
    return () => {
      // Clear refresh interval
      if (refreshIntervalRef.current) {
        clearInterval(refreshIntervalRef.current);
      }
      
      // Close WebSocket connection
      if (websocket?.websocket) {
        websocket.websocket.close();
      }
      
      dispatch(unregisterChart({ chartId }));
    };
  }, [dispatch, chartId, config]);
  
  // Load chart data
  const loadData = useCallback((endpoint, params = {}) => {
    return dispatch(loadChartData({ chartId, endpoint, params }));
  }, [dispatch, chartId]);
  
  // Update chart configuration
  const updateConfig = useCallback((newConfig) => {
    dispatch(updateChartConfig({ chartId, config: newConfig }));
  }, [dispatch, chartId]);
  
  // Update chart options
  const updateOptions = useCallback((options) => {
    dispatch(setChartOptions({ chartId, options }));
  }, [dispatch, chartId]);
  
  // Set date range
  const setRange = useCallback((start, end) => {
    dispatch(setDateRange({ chartId, start, end }));
  }, [dispatch, chartId]);
  
  // Set granularity
  const setGranularity = useCallback((granularity) => {
    dispatch(setGranularity({ chartId, granularity }));
  }, [dispatch, chartId]);
  
  // Update filters
  const setFilters = useCallback((filters) => {
    dispatch(updateFilters({ chartId, filters }));
  }, [dispatch, chartId]);
  
  // Clear all filters
  const resetFilters = useCallback(() => {
    dispatch(clearFilters({ chartId }));
  }, [dispatch, chartId]);
  
  // Clear error
  const clearError = useCallback(() => {
    dispatch(clearChartError({ chartId }));
  }, [dispatch, chartId]);
  
  // Subscribe to real-time data
  const subscribeRealTime = useCallback((websocketUrl, options = {}) => {
    return dispatch(subscribeToRealTimeData({ chartId, websocketUrl, options }));
  }, [dispatch, chartId]);
  
  // Export chart data
  const exportData = useCallback((format, options = {}) => {
    return dispatch(exportChartData({ chartId, format, options }));
  }, [dispatch, chartId]);
  
  // Add annotation
  const addChartAnnotation = useCallback((annotation) => {
    dispatch(addAnnotation({ chartId, annotation }));
  }, [dispatch, chartId]);
  
  // Remove annotation
  const removeChartAnnotation = useCallback((annotationId) => {
    dispatch(removeAnnotation({ chartId, annotationId }));
  }, [dispatch, chartId]);
  
  // Set selection
  const setSelection = useCallback((selection) => {
    dispatch(setChartSelection({ chartId, selection }));
  }, [dispatch, chartId]);
  
  // Clear selection
  const clearSelection = useCallback(() => {
    dispatch(clearChartSelection({ chartId }));
  }, [dispatch, chartId]);
  
  // Auto-refresh functionality
  const startAutoRefresh = useCallback((endpoint, interval = 30000, params = {}) => {
    if (refreshIntervalRef.current) {
      clearInterval(refreshIntervalRef.current);
    }
    
    refreshIntervalRef.current = setInterval(() => {
      loadData(endpoint, params);
    }, interval);
  }, [loadData]);
  
  const stopAutoRefresh = useCallback(() => {
    if (refreshIntervalRef.current) {
      clearInterval(refreshIntervalRef.current);
      refreshIntervalRef.current = null;
    }
  }, []);
  
  // Update global settings
  const updateSettings = useCallback((settings) => {
    dispatch(updateGlobalSettings({ settings }));
  }, [dispatch]);
  
  return {
    // Chart state
    chart,
    data: chart?.data || [],
    rawData: chart?.rawData || [],
    options: chart?.options || {},
    dateRange: chart?.dateRange,
    granularity: chart?.granularity,
    filters: chart?.filters || {},
    annotations: chart?.annotations || [],
    selection: chart?.selection,
    lastUpdated: chart?.lastUpdated,
    version: chart?.version || 1,
    
    // Loading states
    isLoading,
    error,
    
    // WebSocket state
    websocket,
    isConnected: websocket?.connected || false,
    
    // Export state
    exportState,
    isExporting: exportState?.loading || false,
    
    // Global settings
    globalSettings,
    
    // Actions
    loadData,
    updateConfig,
    updateOptions,
    setRange,
    setGranularity,
    setFilters,
    resetFilters,
    clearError,
    subscribeRealTime,
    exportData,
    addChartAnnotation,
    removeChartAnnotation,
    setSelection,
    clearSelection,
    startAutoRefresh,
    stopAutoRefresh,
    updateSettings,
    
    // Utility functions
    refresh: () => loadData(chart?.endpoint, chart?.params),
    hasData: () => chart?.data && chart.data.length > 0,
    getDataPoint: (index) => chart?.data[index],
    getDataRange: (start, end) => chart?.data.slice(start, end),
  };
};
```

#### Zustand Data Visualization Implementation

```javascript
// stores/chartStore.js
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import { persist } from 'zustand/middleware/persist';

// Helper function to process chart data
const processChartData = (rawData, chartType, options = {}) => {
  switch (chartType) {
    case 'line':
    case 'area':
      return rawData.map(item => ({
        x: new Date(item.timestamp),
        y: parseFloat(item.value),
        ...item,
      }));
    
    case 'bar':
    case 'column':
      return rawData.map(item => ({
        category: item.category,
        value: parseFloat(item.value),
        ...item,
      }));
    
    case 'pie':
    case 'donut':
      return rawData.map(item => ({
        label: item.label,
        value: parseFloat(item.value),
        percentage: parseFloat(item.percentage),
        ...item,
      }));
    
    case 'scatter':
      return rawData.map(item => ({
        x: parseFloat(item.x),
        y: parseFloat(item.y),
        size: item.size ? parseFloat(item.size) : undefined,
        ...item,
      }));
    
    case 'heatmap':
      return {
        data: rawData.data,
        xAxis: rawData.xAxis || [],
        yAxis: rawData.yAxis || [],
        min: rawData.min,
        max: rawData.max,
      };
    
    default:
      return rawData;
  }
};

const useChartStore = create(
  subscribeWithSelector(
    persist(
      immer((set, get) => ({
        // State
        charts: {},
        loading: {},
        errors: {},
        websockets: {},
        exports: {},
        globalSettings: {
          theme: 'light',
          animations: true,
          responsiveBreakpoints: {
            mobile: 768,
            tablet: 1024,
          },
        },
        
        // Actions
        registerChart: (chartId, config) => {
          set((state) => {
            state.charts[chartId] = {
              id: chartId,
              type: config.type || 'line',
              data: [],
              rawData: [],
              options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                  duration: state.globalSettings.animations ? 750 : 0,
                },
                ...config.options,
              },
              dateRange: config.dateRange || {
                start: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // 7 days ago
                end: new Date(),
              },
              granularity: config.granularity || 'hour',
              filters: config.filters || {},
              interactions: {
                zoom: config.interactions?.zoom !== false,
                pan: config.interactions?.pan !== false,
                select: config.interactions?.select !== false,
                hover: config.interactions?.hover !== false,
              },
              realTime: {
                enabled: config.realTime?.enabled || false,
                interval: config.realTime?.interval || 5000,
                maxDataPoints: config.realTime?.maxDataPoints || 1000,
              },
              lastUpdated: null,
              version: 1,
            };
          });
        },
        
        unregisterChart: (chartId) => {
          set((state) => {
            // Close WebSocket connection if exists
            if (state.websockets[chartId]?.websocket) {
              state.websockets[chartId].websocket.close();
            }
            
            delete state.charts[chartId];
            delete state.loading[chartId];
            delete state.errors[chartId];
            delete state.websockets[chartId];
            delete state.exports[chartId];
          });
        },
        
        updateChartConfig: (chartId, config) => {
          set((state) => {
            if (state.charts[chartId]) {
              state.charts[chartId] = {
                ...state.charts[chartId],
                ...config,
                version: state.charts[chartId].version + 1,
              };
            }
          });
        },
        
        updateChartData: (chartId, data, rawData) => {
          set((state) => {
            if (state.charts[chartId]) {
              state.charts[chartId].data = data;
              if (rawData) {
                state.charts[chartId].rawData = rawData;
              }
              state.charts[chartId].lastUpdated = Date.now();
              state.charts[chartId].version += 1;
            }
          });
        },
        
        updateRealTimeData: (chartId, data, timestamp) => {
          set((state) => {
            if (state.charts[chartId] && state.charts[chartId].realTime.enabled) {
              const chart = state.charts[chartId];
              const maxDataPoints = chart.realTime.maxDataPoints;
              
              // Add new data point
              const newData = [...chart.data, ...data];
              
              // Limit data points if necessary
              if (newData.length > maxDataPoints) {
                chart.data = newData.slice(-maxDataPoints);
              } else {
                chart.data = newData;
              }
              
              chart.lastUpdated = timestamp || Date.now();
              chart.version += 1;
            }
          });
        },
        
        setChartOptions: (chartId, options) => {
          set((state) => {
            if (state.charts[chartId]) {
              state.charts[chartId].options = {
                ...state.charts[chartId].options,
                ...options,
              };
              state.charts[chartId].version += 1;
            }
          });
        },
        
        setDateRange: (chartId, start, end) => {
          set((state) => {
            if (state.charts[chartId]) {
              state.charts[chartId].dateRange = { start, end };
              state.charts[chartId].version += 1;
            }
          });
        },
        
        setGranularity: (chartId, granularity) => {
          set((state) => {
            if (state.charts[chartId]) {
              state.charts[chartId].granularity = granularity;
              state.charts[chartId].version += 1;
            }
          });
        },
        
        updateFilters: (chartId, filters) => {
          set((state) => {
            if (state.charts[chartId]) {
              state.charts[chartId].filters = {
                ...state.charts[chartId].filters,
                ...filters,
              };
              state.charts[chartId].version += 1;
            }
          });
        },
        
        clearFilters: (chartId) => {
          set((state) => {
            if (state.charts[chartId]) {
              state.charts[chartId].filters = {};
              state.charts[chartId].version += 1;
            }
          });
        },
        
        setChartError: (chartId, error) => {
          set((state) => {
            state.errors[chartId] = error;
          });
        },
        
        clearChartError: (chartId) => {
          set((state) => {
            delete state.errors[chartId];
          });
        },
        
        setWebSocketConnection: (chartId, connected, error, websocket) => {
          set((state) => {
            if (!state.websockets[chartId]) {
              state.websockets[chartId] = {};
            }
            
            state.websockets[chartId].connected = connected;
            
            if (error) {
              state.websockets[chartId].error = error;
            } else {
              delete state.websockets[chartId].error;
            }
            
            if (websocket) {
              state.websockets[chartId].websocket = websocket;
            }
          });
        },
        
        updateGlobalSettings: (settings) => {
          set((state) => {
            state.globalSettings = {
              ...state.globalSettings,
              ...settings,
            };
            
            // Update animation settings for all charts
            if (settings.animations !== undefined) {
              Object.values(state.charts).forEach(chart => {
                chart.options.animation.duration = settings.animations ? 750 : 0;
                chart.version += 1;
              });
            }
          });
        },
        
        addAnnotation: (chartId, annotation) => {
          set((state) => {
            if (state.charts[chartId]) {
              if (!state.charts[chartId].annotations) {
                state.charts[chartId].annotations = [];
              }
              
              state.charts[chartId].annotations.push({
                id: Date.now().toString(),
                timestamp: Date.now(),
                ...annotation,
              });
              
              state.charts[chartId].version += 1;
            }
          });
        },
        
        removeAnnotation: (chartId, annotationId) => {
          set((state) => {
            if (state.charts[chartId] && state.charts[chartId].annotations) {
              state.charts[chartId].annotations = state.charts[chartId].annotations.filter(
                annotation => annotation.id !== annotationId
              );
              state.charts[chartId].version += 1;
            }
          });
        },
        
        setChartSelection: (chartId, selection) => {
          set((state) => {
            if (state.charts[chartId]) {
              state.charts[chartId].selection = selection;
            }
          });
        },
        
        clearChartSelection: (chartId) => {
          set((state) => {
            if (state.charts[chartId]) {
              delete state.charts[chartId].selection;
            }
          });
        },
        
        // Async actions
        loadChartData: async (chartId, endpoint, params = {}) => {
          const { charts } = get();
          const chartConfig = charts[chartId];
          
          if (!chartConfig) {
            throw new Error('Chart configuration not found');
          }
          
          // Set loading state
          set((state) => {
            state.loading[chartId] = true;
            delete state.errors[chartId];
          });
          
          try {
            // Build query string from params
            const queryString = Object.entries({
              ...params,
              startDate: chartConfig.dateRange?.start,
              endDate: chartConfig.dateRange?.end,
              granularity: chartConfig.granularity,
              filters: JSON.stringify(chartConfig.filters),
            })
              .filter(([_, value]) => value !== undefined && value !== null)
              .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
              .join('&');
            
            const url = queryString ? `${endpoint}?${queryString}` : endpoint;
            
            const response = await fetch(url, {
              headers: {
                'Content-Type': 'application/json',
              },
            });
            
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.message || 'Failed to load chart data');
            }
            
            const data = await response.json();
            
            // Process data based on chart type
            const processedData = processChartData(data, chartConfig.type, chartConfig.options);
            
            // Update chart data
            get().updateChartData(chartId, processedData, data);
            
            // Clear loading state
            set((state) => {
              state.loading[chartId] = false;
            });
            
            return processedData;
          } catch (error) {
            // Set error state
            set((state) => {
              state.loading[chartId] = false;
              state.errors[chartId] = error.message;
            });
            
            throw error;
          }
        },
        
        subscribeToRealTimeData: async (chartId, websocketUrl, options = {}) => {
          const { charts } = get();
          const chartConfig = charts[chartId];
          
          if (!chartConfig) {
            throw new Error('Chart configuration not found');
          }
          
          // Create WebSocket connection
          const ws = new WebSocket(websocketUrl);
          
          ws.onopen = () => {
            get().setWebSocketConnection(chartId, true, null, ws);
            
            // Send subscription message
            ws.send(JSON.stringify({
              type: 'subscribe',
              chartId,
              filters: chartConfig.filters,
              ...options,
            }));
          };
          
          ws.onmessage = (event) => {
            try {
              const message = JSON.parse(event.data);
              
              if (message.type === 'data_update') {
                get().updateRealTimeData(chartId, message.data, message.timestamp);
              } else if (message.type === 'error') {
                get().setChartError(chartId, message.error);
              }
            } catch (error) {
              console.error('Failed to parse WebSocket message:', error);
            }
          };
          
          ws.onerror = (error) => {
            get().setWebSocketConnection(chartId, false, error.message);
          };
          
          ws.onclose = () => {
            get().setWebSocketConnection(chartId, false);
          };
          
          return ws;
        },
        
        exportChartData: async (chartId, format, options = {}) => {
          const { charts } = get();
          const chartConfig = charts[chartId];
          
          if (!chartConfig) {
            throw new Error('Chart configuration not found');
          }
          
          // Set loading state
          set((state) => {
            if (!state.exports[chartId]) {
              state.exports[chartId] = {};
            }
            state.exports[chartId].loading = true;
          });
          
          try {
            const exportData = {
              chartId,
              type: chartConfig.type,
              data: chartConfig.data,
              config: chartConfig.options,
              format,
              ...options,
            };
            
            const response = await fetch('/api/charts/export', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(exportData),
            });
            
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.message || 'Export failed');
            }
            
            // Handle different response types
            let result;
            if (format === 'json') {
              const data = await response.json();
              result = { chartId, format, data };
            } else {
              const blob = await response.blob();
              const url = URL.createObjectURL(blob);
              
              // Trigger download
              const link = document.createElement('a');
              link.href = url;
              link.download = `chart-${chartId}.${format}`;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              URL.revokeObjectURL(url);
              
              result = { chartId, format, downloaded: true };
            }
            
            // Update export state
            set((state) => {
              state.exports[chartId] = {
                loading: false,
                lastExport: {
                  format,
                  timestamp: Date.now(),
                  data: result.data || null,
                  downloaded: result.downloaded || false,
                },
              };
            });
            
            return result;
          } catch (error) {
            // Set error state
            set((state) => {
              state.exports[chartId] = {
                loading: false,
                error: error.message,
              };
            });
            
            throw error;
          }
        },
        
        getChartState: (chartId) => {
          const { charts, loading, errors, websockets, exports } = get();
          const chart = charts[chartId];
          
          if (!chart) return null;
          
          return {
            chart,
            data: chart.data,
            rawData: chart.rawData,
            options: chart.options,
            dateRange: chart.dateRange,
            granularity: chart.granularity,
            filters: chart.filters,
            annotations: chart.annotations || [],
            selection: chart.selection,
            lastUpdated: chart.lastUpdated,
            version: chart.version,
            isLoading: loading[chartId] || false,
            error: errors[chartId],
            websocket: websockets[chartId],
            isConnected: websockets[chartId]?.connected || false,
            exportState: exports[chartId],
            isExporting: exports[chartId]?.loading || false,
          };
        },
      })),
      {
        name: 'chart-store',
        partialize: (state) => ({
          globalSettings: state.globalSettings,
          // Persist only chart configurations, not data
          charts: Object.fromEntries(
            Object.entries(state.charts).map(([id, chart]) => [
              id,
              {
                id: chart.id,
                type: chart.type,
                options: chart.options,
                dateRange: chart.dateRange,
                granularity: chart.granularity,
                filters: chart.filters,
                interactions: chart.interactions,
                realTime: chart.realTime,
              },
            ])
          ),
        }),
      }
    )
  )
);

export default useChartStore;
```

```javascript
// hooks/useZustandChart.js
import { useCallback, useEffect, useRef } from 'react';
import useChartStore from '../stores/chartStore';

export const useZustandChart = (chartId, config = {}) => {
  const refreshIntervalRef = useRef(null);
  
  // Get chart actions from store
  const {
    registerChart,
    unregisterChart,
    updateChartConfig,
    setChartOptions,
    setDateRange,
    setGranularity,
    updateFilters,
    clearFilters,
    clearChartError,
    updateGlobalSettings,
    addAnnotation,
    removeAnnotation,
    setChartSelection,
    clearChartSelection,
    loadChartData,
    subscribeToRealTimeData,
    exportChartData,
    getChartState,
  } = useChartStore();
  
  // Register chart on mount
  useEffect(() => {
    registerChart(chartId, config);
    
    return () => {
      // Clear refresh interval
      if (refreshIntervalRef.current) {
        clearInterval(refreshIntervalRef.current);
      }
      
      unregisterChart(chartId);
    };
  }, [chartId, config]);
  
  // Get current chart state
  const chartState = useChartStore(useCallback(
    state => state.getChartState?.(chartId) || {
      chart: state.charts[chartId],
      data: state.charts[chartId]?.data || [],
      rawData: state.charts[chartId]?.rawData || [],
      options: state.charts[chartId]?.options || {},
      dateRange: state.charts[chartId]?.dateRange,
      granularity: state.charts[chartId]?.granularity,
      filters: state.charts[chartId]?.filters || {},
      annotations: state.charts[chartId]?.annotations || [],
      selection: state.charts[chartId]?.selection,
      lastUpdated: state.charts[chartId]?.lastUpdated,
      version: state.charts[chartId]?.version || 1,
      isLoading: state.loading[chartId] || false,
      error: state.errors[chartId],
      websocket: state.websockets[chartId],
      isConnected: state.websockets[chartId]?.connected || false,
      exportState: state.exports[chartId],
      isExporting: state.exports[chartId]?.loading || false,
    },
    [chartId]
  ));
  
  const globalSettings = useChartStore(state => state.globalSettings);
  
  // Load chart data
  const loadData = useCallback((endpoint, params = {}) => {
    return loadChartData(chartId, endpoint, params);
  }, [chartId]);
  
  // Update chart configuration
  const updateConfig = useCallback((newConfig) => {
    updateChartConfig(chartId, newConfig);
  }, [chartId]);
  
  // Update chart options
  const updateOptions = useCallback((options) => {
    setChartOptions(chartId, options);
  }, [chartId]);
  
  // Set date range
  const setRange = useCallback((start, end) => {
    setDateRange(chartId, start, end);
  }, [chartId]);
  
  // Set granularity
  const setGranularityValue = useCallback((granularity) => {
    setGranularity(chartId, granularity);
  }, [chartId]);
  
  // Update filters
  const setFilters = useCallback((filters) => {
    updateFilters(chartId, filters);
  }, [chartId]);
  
  // Clear all filters
  const resetFilters = useCallback(() => {
    clearFilters(chartId);
  }, [chartId]);
  
  // Clear error
  const clearError = useCallback(() => {
    clearChartError(chartId);
  }, [chartId]);
  
  // Subscribe to real-time data
  const subscribeRealTime = useCallback((websocketUrl, options = {}) => {
    return subscribeToRealTimeData(chartId, websocketUrl, options);
  }, [chartId]);
  
  // Export chart data
  const exportData = useCallback((format, options = {}) => {
    return exportChartData(chartId, format, options);
  }, [chartId]);
  
  // Add annotation
  const addChartAnnotation = useCallback((annotation) => {
    addAnnotation(chartId, annotation);
  }, [chartId]);
  
  // Remove annotation
  const removeChartAnnotation = useCallback((annotationId) => {
    removeAnnotation(chartId, annotationId);
  }, [chartId]);
  
  // Set selection
  const setSelection = useCallback((selection) => {
    setChartSelection(chartId, selection);
  }, [chartId]);
  
  // Clear selection
  const clearSelection = useCallback(() => {
    clearChartSelection(chartId);
  }, [chartId]);
  
  // Auto-refresh functionality
  const startAutoRefresh = useCallback((endpoint, interval = 30000, params = {}) => {
    if (refreshIntervalRef.current) {
      clearInterval(refreshIntervalRef.current);
    }
    
    refreshIntervalRef.current = setInterval(() => {
      loadData(endpoint, params);
    }, interval);
  }, [loadData]);
  
  const stopAutoRefresh = useCallback(() => {
    if (refreshIntervalRef.current) {
      clearInterval(refreshIntervalRef.current);
      refreshIntervalRef.current = null;
    }
  }, []);
  
  // Update global settings
  const updateSettings = useCallback((settings) => {
    updateGlobalSettings(settings);
  }, []);
  
  return {
    // Chart state
    ...chartState,
    globalSettings,
    
    // Actions
    loadData,
    updateConfig,
    updateOptions,
    setRange,
    setGranularity: setGranularityValue,
    setFilters,
    resetFilters,
    clearError,
    subscribeRealTime,
    exportData,
    addChartAnnotation,
    removeChartAnnotation,
    setSelection,
    clearSelection,
    startAutoRefresh,
    stopAutoRefresh,
    updateSettings,
    
    // Utility functions
    refresh: () => loadData(chartState.chart?.endpoint, chartState.chart?.params),
    hasData: () => chartState.data && chartState.data.length > 0,
    getDataPoint: (index) => chartState.data[index],
    getDataRange: (start, end) => chartState.data.slice(start, end),
  };
};
```

#### Best Practices

1. **Data Processing**:
   - Transform raw data into chart-specific formats
   - Handle different chart types appropriately
   - Implement data aggregation and filtering
   - Support real-time data updates

2. **Performance Optimization**:
   - Implement data virtualization for large datasets
   - Use memoization for expensive calculations
   - Debounce user interactions
   - Limit real-time data points

3. **User Experience**:
   - Provide loading states and error handling
   - Support chart interactions (zoom, pan, select)
   - Implement responsive design
   - Add accessibility features

4. **Real-time Updates**:
   - Use WebSocket connections efficiently
   - Handle connection failures gracefully
   - Implement data buffering
   - Provide connection status indicators

5. **Export and Sharing**:
   - Support multiple export formats
   - Handle large data exports
   - Provide download progress
   - Include chart configurations in exports

**Comparison Summary:**

| Feature | Redux | Zustand |
|---------|-------|---------|
| Implementation | Slice + Async Thunks | Store Actions |
| Complexity | Higher | Lower |
| Boilerplate | More | Less |
| Performance | Good with optimization | Better by default |
| DevTools | Excellent | Basic |
| Type Safety | Excellent | Good |
| Bundle Size | Larger | Smaller |
| Learning Curve | Steep | Gentle |
| Real-time Data | Comprehensive | Streamlined |
| Chart Interactions | Full featured | Simplified |

---

## Redux Fundamentals

### 1. What is Redux and what are its core principles?

**Answer:**
Redux is a predictable state container for JavaScript applications, following three core principles:

**Core Principles:**

1. **Single Source of Truth**: The entire application state is stored in a single store
2. **State is Read-Only**: State can only be changed by dispatching actions
3. **Changes are Made with Pure Functions**: Reducers are pure functions that specify how state changes

```javascript
// Basic Redux setup
import { createStore } from "redux";

// Action Types
const INCREMENT = "INCREMENT";
const DECREMENT = "DECREMENT";
const SET_COUNT = "SET_COUNT";

// Action Creators
export const increment = () => ({ type: INCREMENT });
export const decrement = () => ({ type: DECREMENT });
export const setCount = (count) => ({ type: SET_COUNT, payload: count });

// Initial State
const initialState = {
  count: 0,
  history: [],
  lastUpdated: null,
};

// Reducer (Pure Function)
function counterReducer(state = initialState, action) {
  switch (action.type) {
    case INCREMENT:
      return {
        ...state,
        count: state.count + 1,
        history: [...state.history, "increment"],
        lastUpdated: new Date().toISOString(),
      };
    case DECREMENT:
      return {
        ...state,
        count: state.count - 1,
        history: [...state.history, "decrement"],
        lastUpdated: new Date().toISOString(),
      };
    case SET_COUNT:
      return {
        ...state,
        count: action.payload,
        history: [...state.history, `set to ${action.payload}`],
        lastUpdated: new Date().toISOString(),
      };
    default:
      return state;
  }
}

// Store
const store = createStore(counterReducer);

// Usage
store.dispatch(increment()); // { count: 1, history: ['increment'], lastUpdated: '...' }
store.dispatch(setCount(10)); // { count: 10, history: ['increment', 'set to 10'], lastUpdated: '...' }
console.log(store.getState());
```

### 2. How do you handle complex state with multiple reducers?

**Answer:**
Use `combineReducers` to split state management into smaller, focused reducers.

```javascript
import { combineReducers, createStore } from "redux";

// User Reducer
const userInitialState = {
  currentUser: null,
  isAuthenticated: false,
  profile: null,
  preferences: {
    theme: "light",
    language: "en",
  },
};

function userReducer(state = userInitialState, action) {
  switch (action.type) {
    case "USER_LOGIN_SUCCESS":
      return {
        ...state,
        currentUser: action.payload.user,
        isAuthenticated: true,
        profile: action.payload.profile,
      };
    case "USER_LOGOUT":
      return {
        ...userInitialState,
      };
    case "UPDATE_PREFERENCES":
      return {
        ...state,
        preferences: {
          ...state.preferences,
          ...action.payload,
        },
      };
    default:
      return state;
  }
}

// Posts Reducer
const postsInitialState = {
  items: [],
  loading: false,
  error: null,
  pagination: {
    page: 1,
    limit: 10,
    total: 0,
  },
};

function postsReducer(state = postsInitialState, action) {
  switch (action.type) {
    case "FETCH_POSTS_START":
      return {
        ...state,
        loading: true,
        error: null,
      };
    case "FETCH_POSTS_SUCCESS":
      return {
        ...state,
        loading: false,
        items: action.payload.posts,
        pagination: {
          ...state.pagination,
          ...action.payload.pagination,
        },
      };
    case "FETCH_POSTS_ERROR":
      return {
        ...state,
        loading: false,
        error: action.payload.error,
      };
    case "ADD_POST":
      return {
        ...state,
        items: [action.payload, ...state.items],
      };
    case "UPDATE_POST":
      return {
        ...state,
        items: state.items.map((post) =>
          post.id === action.payload.id
            ? { ...post, ...action.payload.updates }
            : post
        ),
      };
    case "DELETE_POST":
      return {
        ...state,
        items: state.items.filter((post) => post.id !== action.payload.id),
      };
    default:
      return state;
  }
}

// UI Reducer
const uiInitialState = {
  sidebarOpen: false,
  modals: {
    createPost: false,
    editProfile: false,
    confirmDelete: false,
  },
  notifications: [],
  theme: "light",
};

function uiReducer(state = uiInitialState, action) {
  switch (action.type) {
    case "TOGGLE_SIDEBAR":
      return {
        ...state,
        sidebarOpen: !state.sidebarOpen,
      };
    case "OPEN_MODAL":
      return {
        ...state,
        modals: {
          ...state.modals,
          [action.payload.modalName]: true,
        },
      };
    case "CLOSE_MODAL":
      return {
        ...state,
        modals: {
          ...state.modals,
          [action.payload.modalName]: false,
        },
      };
    case "ADD_NOTIFICATION":
      return {
        ...state,
        notifications: [
          ...state.notifications,
          {
            id: Date.now(),
            ...action.payload,
          },
        ],
      };
    case "REMOVE_NOTIFICATION":
      return {
        ...state,
        notifications: state.notifications.filter(
          (notification) => notification.id !== action.payload.id
        ),
      };
    default:
      return state;
  }
}

// Combine Reducers
const rootReducer = combineReducers({
  user: userReducer,
  posts: postsReducer,
  ui: uiReducer,
});

// Store
const store = createStore(rootReducer);

// Selectors
export const selectUser = (state) => state.user.currentUser;
export const selectIsAuthenticated = (state) => state.user.isAuthenticated;
export const selectPosts = (state) => state.posts.items;
export const selectPostsLoading = (state) => state.posts.loading;
export const selectSidebarOpen = (state) => state.ui.sidebarOpen;
export const selectNotifications = (state) => state.ui.notifications;

// Action Creators
export const loginSuccess = (user, profile) => ({
  type: "USER_LOGIN_SUCCESS",
  payload: { user, profile },
});

export const logout = () => ({ type: "USER_LOGOUT" });

export const fetchPostsStart = () => ({ type: "FETCH_POSTS_START" });
export const fetchPostsSuccess = (posts, pagination) => ({
  type: "FETCH_POSTS_SUCCESS",
  payload: { posts, pagination },
});

export const addNotification = (message, type = "info") => ({
  type: "ADD_NOTIFICATION",
  payload: { message, type, timestamp: new Date().toISOString() },
});
```

---

## Redux Toolkit (RTK)

### 3. How does Redux Toolkit simplify Redux development?

**Answer:**
Redux Toolkit (RTK) provides utilities to simplify common Redux patterns and reduce boilerplate code.

```javascript
import {
  createSlice,
  configureStore,
  createAsyncThunk,
} from "@reduxjs/toolkit";

// Async Thunk for API calls
export const fetchPosts = createAsyncThunk(
  "posts/fetchPosts",
  async ({ page = 1, limit = 10 }, { rejectWithValue }) => {
    try {
      const response = await fetch(`/api/posts?page=${page}&limit=${limit}`);
      if (!response.ok) {
        throw new Error("Failed to fetch posts");
      }
      const data = await response.json();
      return data;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const createPost = createAsyncThunk(
  "posts/createPost",
  async (postData, { rejectWithValue }) => {
    try {
      const response = await fetch("/api/posts", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(postData),
      });
      if (!response.ok) {
        throw new Error("Failed to create post");
      }
      return await response.json();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Posts Slice
const postsSlice = createSlice({
  name: "posts",
  initialState: {
    items: [],
    loading: false,
    error: null,
    pagination: {
      page: 1,
      limit: 10,
      total: 0,
      totalPages: 0,
    },
    filters: {
      category: "all",
      search: "",
      sortBy: "createdAt",
      sortOrder: "desc",
    },
  },
  reducers: {
    // Synchronous actions
    updatePost: (state, action) => {
      const { id, updates } = action.payload;
      const existingPost = state.items.find((post) => post.id === id);
      if (existingPost) {
        Object.assign(existingPost, updates);
      }
    },
    deletePost: (state, action) => {
      state.items = state.items.filter((post) => post.id !== action.payload);
    },
    setFilters: (state, action) => {
      state.filters = { ...state.filters, ...action.payload };
    },
    clearError: (state) => {
      state.error = null;
    },
    resetPosts: (state) => {
      state.items = [];
      state.pagination = {
        page: 1,
        limit: 10,
        total: 0,
        totalPages: 0,
      };
    },
  },
  extraReducers: (builder) => {
    builder
      // Fetch Posts
      .addCase(fetchPosts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload.posts;
        state.pagination = action.payload.pagination;
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      // Create Post
      .addCase(createPost.pending, (state) => {
        state.loading = true;
      })
      .addCase(createPost.fulfilled, (state, action) => {
        state.loading = false;
        state.items.unshift(action.payload);
        state.pagination.total += 1;
      })
      .addCase(createPost.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

// User Slice with authentication
const userSlice = createSlice({
  name: "user",
  initialState: {
    currentUser: null,
    isAuthenticated: false,
    profile: null,
    preferences: {
      theme: "light",
      language: "en",
      notifications: true,
    },
    loading: false,
    error: null,
  },
  reducers: {
    loginStart: (state) => {
      state.loading = true;
      state.error = null;
    },
    loginSuccess: (state, action) => {
      state.loading = false;
      state.currentUser = action.payload.user;
      state.profile = action.payload.profile;
      state.isAuthenticated = true;
    },
    loginFailure: (state, action) => {
      state.loading = false;
      state.error = action.payload;
      state.isAuthenticated = false;
    },
    logout: (state) => {
      state.currentUser = null;
      state.profile = null;
      state.isAuthenticated = false;
      state.preferences = {
        theme: "light",
        language: "en",
        notifications: true,
      };
    },
    updatePreferences: (state, action) => {
      state.preferences = { ...state.preferences, ...action.payload };
    },
    updateProfile: (state, action) => {
      if (state.profile) {
        state.profile = { ...state.profile, ...action.payload };
      }
    },
  },
});

// Configure Store
const store = configureStore({
  reducer: {
    posts: postsSlice.reducer,
    user: userSlice.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ["persist/PERSIST", "persist/REHYDRATE"],
      },
    }),
  devTools: process.env.NODE_ENV !== "production",
});

// Export actions
export const { updatePost, deletePost, setFilters, clearError, resetPosts } =
  postsSlice.actions;
export const {
  loginStart,
  loginSuccess,
  loginFailure,
  logout,
  updatePreferences,
  updateProfile,
} = userSlice.actions;

// Selectors
export const selectPosts = (state) => state.posts.items;
export const selectPostsLoading = (state) => state.posts.loading;
export const selectPostsError = (state) => state.posts.error;
export const selectPostsPagination = (state) => state.posts.pagination;
export const selectPostsFilters = (state) => state.posts.filters;

export const selectCurrentUser = (state) => state.user.currentUser;
export const selectIsAuthenticated = (state) => state.user.isAuthenticated;
export const selectUserPreferences = (state) => state.user.preferences;

// Memoized selectors
import { createSelector } from "@reduxjs/toolkit";

export const selectFilteredPosts = createSelector(
  [selectPosts, selectPostsFilters],
  (posts, filters) => {
    let filtered = posts;

    if (filters.category !== "all") {
      filtered = filtered.filter((post) => post.category === filters.category);
    }

    if (filters.search) {
      const searchLower = filters.search.toLowerCase();
      filtered = filtered.filter(
        (post) =>
          post.title.toLowerCase().includes(searchLower) ||
          post.content.toLowerCase().includes(searchLower)
      );
    }

    // Sort posts
    filtered.sort((a, b) => {
      const aValue = a[filters.sortBy];
      const bValue = b[filters.sortBy];

      if (filters.sortOrder === "asc") {
        return aValue > bValue ? 1 : -1;
      } else {
        return aValue < bValue ? 1 : -1;
      }
    });

    return filtered;
  }
);

export default store;
```

### 4. How do you handle async operations with RTK Query?

**Answer:**
RTK Query provides powerful data fetching and caching capabilities built on top of Redux Toolkit.

```javascript
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

// Define API slice
export const apiSlice = createApi({
  reducerPath: "api",
  baseQuery: fetchBaseQuery({
    baseUrl: "/api",
    prepareHeaders: (headers, { getState }) => {
      const token = getState().user.token;
      if (token) {
        headers.set("authorization", `Bearer ${token}`);
      }
      return headers;
    },
  }),
  tagTypes: ["Post", "User", "Comment"],
  endpoints: (builder) => ({
    // Posts endpoints
    getPosts: builder.query({
      query: ({ page = 1, limit = 10, category, search } = {}) => {
        const params = new URLSearchParams({
          page: page.toString(),
          limit: limit.toString(),
          ...(category && { category }),
          ...(search && { search }),
        });
        return `posts?${params}`;
      },
      providesTags: (result) =>
        result
          ? [
              ...result.posts.map(({ id }) => ({ type: "Post", id })),
              { type: "Post", id: "LIST" },
            ]
          : [{ type: "Post", id: "LIST" }],
    }),

    getPost: builder.query({
      query: (id) => `posts/${id}`,
      providesTags: (result, error, id) => [{ type: "Post", id }],
    }),

    createPost: builder.mutation({
      query: (newPost) => ({
        url: "posts",
        method: "POST",
        body: newPost,
      }),
      invalidatesTags: [{ type: "Post", id: "LIST" }],
    }),

    updatePost: builder.mutation({
      query: ({ id, ...patch }) => ({
        url: `posts/${id}`,
        method: "PATCH",
        body: patch,
      }),
      invalidatesTags: (result, error, { id }) => [{ type: "Post", id }],
    }),

    deletePost: builder.mutation({
      query: (id) => ({
        url: `posts/${id}`,
        method: "DELETE",
      }),
      invalidatesTags: (result, error, id) => [
        { type: "Post", id },
        { type: "Post", id: "LIST" },
      ],
    }),

    // Comments endpoints
    getComments: builder.query({
      query: (postId) => `posts/${postId}/comments`,
      providesTags: (result, error, postId) =>
        result
          ? [
              ...result.map(({ id }) => ({ type: "Comment", id })),
              { type: "Comment", id: `LIST-${postId}` },
            ]
          : [{ type: "Comment", id: `LIST-${postId}` }],
    }),

    addComment: builder.mutation({
      query: ({ postId, content }) => ({
        url: `posts/${postId}/comments`,
        method: "POST",
        body: { content },
      }),
      invalidatesTags: (result, error, { postId }) => [
        { type: "Comment", id: `LIST-${postId}` },
      ],
    }),

    // User endpoints
    getProfile: builder.query({
      query: () => "user/profile",
      providesTags: ["User"],
    }),

    updateProfile: builder.mutation({
      query: (updates) => ({
        url: "user/profile",
        method: "PATCH",
        body: updates,
      }),
      invalidatesTags: ["User"],
    }),
  }),
});

// Export hooks for usage in components
export const {
  useGetPostsQuery,
  useGetPostQuery,
  useCreatePostMutation,
  useUpdatePostMutation,
  useDeletePostMutation,
  useGetCommentsQuery,
  useAddCommentMutation,
  useGetProfileQuery,
  useUpdateProfileMutation,
} = apiSlice;

// Usage in components
import React, { useState } from "react";
import {
  useGetPostsQuery,
  useCreatePostMutation,
  useDeletePostMutation,
} from "./apiSlice";

function PostsList() {
  const [page, setPage] = useState(1);
  const [filters, setFilters] = useState({ category: "", search: "" });

  const {
    data: postsData,
    error,
    isLoading,
    isFetching,
    refetch,
  } = useGetPostsQuery({ page, ...filters });

  const [createPost, { isLoading: isCreating }] = useCreatePostMutation();
  const [deletePost] = useDeletePostMutation();

  const handleCreatePost = async (postData) => {
    try {
      await createPost(postData).unwrap();
      // Post created successfully
    } catch (error) {
      console.error("Failed to create post:", error);
    }
  };

  const handleDeletePost = async (id) => {
    if (window.confirm("Are you sure?")) {
      try {
        await deletePost(id).unwrap();
        // Post deleted successfully
      } catch (error) {
        console.error("Failed to delete post:", error);
      }
    }
  };

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <div className="mb-4">
        <input
          type="text"
          placeholder="Search posts..."
          value={filters.search}
          onChange={(e) => setFilters({ ...filters, search: e.target.value })}
          className="border p-2 mr-2"
        />
        <select
          value={filters.category}
          onChange={(e) => setFilters({ ...filters, category: e.target.value })}
          className="border p-2"
        >
          <option value="">All Categories</option>
          <option value="tech">Technology</option>
          <option value="lifestyle">Lifestyle</option>
        </select>
        <button
          onClick={refetch}
          className="ml-2 px-4 py-2 bg-blue-500 text-white"
        >
          Refresh
        </button>
      </div>

      {isFetching && <div>Updating...</div>}

      <div className="grid gap-4">
        {postsData?.posts.map((post) => (
          <div key={post.id} className="border p-4 rounded">
            <h3 className="text-xl font-bold">{post.title}</h3>
            <p className="text-gray-600">{post.excerpt}</p>
            <div className="mt-2">
              <button
                onClick={() => handleDeletePost(post.id)}
                className="px-3 py-1 bg-red-500 text-white rounded"
              >
                Delete
              </button>
            </div>
          </div>
        ))}
      </div>

      {/* Pagination */}
      <div className="mt-4 flex justify-center space-x-2">
        <button
          onClick={() => setPage(page - 1)}
          disabled={page === 1}
          className="px-3 py-1 border disabled:opacity-50"
        >
          Previous
        </button>
        <span className="px-3 py-1">Page {page}</span>
        <button
          onClick={() => setPage(page + 1)}
          disabled={!postsData?.pagination.hasNext}
          className="px-3 py-1 border disabled:opacity-50"
        >
          Next
        </button>
      </div>
    </div>
  );
}

export default PostsList;
```

---

## Redux Middleware & Async

### 5. How do you create custom middleware in Redux?

**Answer:**
Middleware provides a way to extend Redux with custom functionality for logging, crash reporting, async actions, etc.

```javascript
// Custom logging middleware
const loggerMiddleware = (store) => (next) => (action) => {
  console.group(`Action: ${action.type}`);
  console.log("Previous State:", store.getState());
  console.log("Action:", action);

  const result = next(action);

  console.log("Next State:", store.getState());
  console.groupEnd();

  return result;
};

// Performance monitoring middleware
const performanceMiddleware = (store) => (next) => (action) => {
  const start = performance.now();

  const result = next(action);

  const end = performance.now();
  const duration = end - start;

  if (duration > 10) {
    // Log slow actions
    console.warn(
      `Slow action detected: ${action.type} took ${duration.toFixed(2)}ms`
    );
  }

  return result;
};

// Error handling middleware
const errorMiddleware = (store) => (next) => (action) => {
  try {
    return next(action);
  } catch (error) {
    console.error("Redux Error:", error);

    // Send error to monitoring service
    if (typeof window !== "undefined" && window.Sentry) {
      window.Sentry.captureException(error, {
        extra: {
          action,
          state: store.getState(),
        },
      });
    }

    // Dispatch error action
    store.dispatch({
      type: "GLOBAL_ERROR",
      payload: {
        message: error.message,
        stack: error.stack,
        action,
      },
    });

    throw error;
  }
};

// API middleware for handling async actions
const apiMiddleware = (store) => (next) => (action) => {
  // Pass through non-API actions
  if (!action.meta || !action.meta.api) {
    return next(action);
  }

  const { endpoint, method = "GET", body, headers = {} } = action.meta.api;
  const { type } = action;

  // Dispatch loading action
  store.dispatch({ type: `${type}_PENDING` });

  // Make API call
  return fetch(endpoint, {
    method,
    headers: {
      "Content-Type": "application/json",
      ...headers,
    },
    ...(body && { body: JSON.stringify(body) }),
  })
    .then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return response.json();
    })
    .then((data) => {
      // Dispatch success action
      store.dispatch({
        type: `${type}_FULFILLED`,
        payload: data,
      });
      return data;
    })
    .catch((error) => {
      // Dispatch error action
      store.dispatch({
        type: `${type}_REJECTED`,
        payload: error.message,
        error: true,
      });
      throw error;
    });
};

// Debounce middleware for search actions
const debounceMiddleware = (store) => {
  const debounceTimers = new Map();

  return (next) => (action) => {
    if (action.meta && action.meta.debounce) {
      const { delay = 300, key = action.type } = action.meta.debounce;

      // Clear existing timer
      if (debounceTimers.has(key)) {
        clearTimeout(debounceTimers.get(key));
      }

      // Set new timer
      const timer = setTimeout(() => {
        debounceTimers.delete(key);
        next(action);
      }, delay);

      debounceTimers.set(key, timer);

      return;
    }

    return next(action);
  };
};

// Local storage persistence middleware
const persistenceMiddleware = (store) => (next) => (action) => {
  const result = next(action);

  // Persist specific state slices
  const stateToPersist = {
    user: store.getState().user,
    preferences: store.getState().preferences,
  };

  try {
    localStorage.setItem("reduxState", JSON.stringify(stateToPersist));
  } catch (error) {
    console.warn("Failed to persist state:", error);
  }

  return result;
};

// Configure store with middleware
import { configureStore } from "@reduxjs/toolkit";

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ["persist/PERSIST"],
      },
    }).concat(
      loggerMiddleware,
      performanceMiddleware,
      errorMiddleware,
      apiMiddleware,
      debounceMiddleware,
      persistenceMiddleware
    ),
});

// Usage examples

// API action
const fetchUsers = () => ({
  type: "FETCH_USERS",
  meta: {
    api: {
      endpoint: "/api/users",
      method: "GET",
    },
  },
});

// Debounced search action
const searchPosts = (query) => ({
  type: "SEARCH_POSTS",
  payload: query,
  meta: {
    debounce: {
      delay: 500,
      key: "search",
    },
  },
});

// Usage in component
function SearchComponent() {
  const dispatch = useDispatch();

  const handleSearch = (query) => {
    dispatch(searchPosts(query));
  };

  const handleFetchUsers = () => {
    dispatch(fetchUsers());
  };

  return (
    <div>
      <input
        type="text"
        onChange={(e) => handleSearch(e.target.value)}
        placeholder="Search posts..."
      />
      <button onClick={handleFetchUsers}>Fetch Users</button>
    </div>
  );
}
```

---

## Zustand Fundamentals

### 6. What is Zustand and how does it differ from Redux?

**Answer:**
Zustand is a lightweight state management library that provides a simpler alternative to Redux with less boilerplate and better TypeScript support.

**Key Differences:**

- **Less Boilerplate**: No actions, reducers, or providers needed
- **Simpler API**: Direct state mutations allowed
- **Better TypeScript**: Built-in TypeScript support
- **Smaller Bundle**: Much smaller than Redux
- **No Context**: Doesn't use React Context, avoiding re-render issues

```javascript
import { create } from "zustand";
import { devtools, persist, subscribeWithSelector } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

// Basic Zustand store
const useCounterStore = create((set, get) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 }),
  incrementBy: (value) => set((state) => ({ count: state.count + value })),
  // Computed values
  get doubled() {
    return get().count * 2;
  },
  get isEven() {
    return get().count % 2 === 0;
  },
}));

// Complex store with multiple slices
const useAppStore = create(
  devtools(
    persist(
      subscribeWithSelector(
        immer((set, get) => ({
          // User slice
          user: {
            currentUser: null,
            isAuthenticated: false,
            preferences: {
              theme: "light",
              language: "en",
            },
          },

          // Posts slice
          posts: {
            items: [],
            loading: false,
            error: null,
            filters: {
              category: "all",
              search: "",
            },
          },

          // UI slice
          ui: {
            sidebarOpen: false,
            modals: {
              createPost: false,
              editProfile: false,
            },
            notifications: [],
          },

          // User actions
          login: (user) =>
            set((state) => {
              state.user.currentUser = user;
              state.user.isAuthenticated = true;
            }),

          logout: () =>
            set((state) => {
              state.user.currentUser = null;
              state.user.isAuthenticated = false;
              state.user.preferences = {
                theme: "light",
                language: "en",
              };
            }),

          updatePreferences: (preferences) =>
            set((state) => {
              Object.assign(state.user.preferences, preferences);
            }),

          // Posts actions
          setPosts: (posts) =>
            set((state) => {
              state.posts.items = posts;
              state.posts.loading = false;
              state.posts.error = null;
            }),

          addPost: (post) =>
            set((state) => {
              state.posts.items.unshift(post);
            }),

          updatePost: (id, updates) =>
            set((state) => {
              const post = state.posts.items.find((p) => p.id === id);
              if (post) {
                Object.assign(post, updates);
              }
            }),

          deletePost: (id) =>
            set((state) => {
              state.posts.items = state.posts.items.filter((p) => p.id !== id);
            }),

          setPostsLoading: (loading) =>
            set((state) => {
              state.posts.loading = loading;
            }),

          setPostsError: (error) =>
            set((state) => {
              state.posts.error = error;
              state.posts.loading = false;
            }),

          setPostsFilters: (filters) =>
            set((state) => {
              Object.assign(state.posts.filters, filters);
            }),

          // Async actions
          fetchPosts: async () => {
            const { setPostsLoading, setPosts, setPostsError } = get();

            setPostsLoading(true);
            try {
              const response = await fetch("/api/posts");
              if (!response.ok) throw new Error("Failed to fetch posts");
              const posts = await response.json();
              setPosts(posts);
            } catch (error) {
              setPostsError(error.message);
            }
          },

          createPost: async (postData) => {
            const { addPost, setPostsError } = get();

            try {
              const response = await fetch("/api/posts", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(postData),
              });
              if (!response.ok) throw new Error("Failed to create post");
              const newPost = await response.json();
              addPost(newPost);
              return newPost;
            } catch (error) {
              setPostsError(error.message);
              throw error;
            }
          },

          // UI actions
          toggleSidebar: () =>
            set((state) => {
              state.ui.sidebarOpen = !state.ui.sidebarOpen;
            }),

          openModal: (modalName) =>
            set((state) => {
              state.ui.modals[modalName] = true;
            }),

          closeModal: (modalName) =>
            set((state) => {
              state.ui.modals[modalName] = false;
            }),

          addNotification: (notification) =>
            set((state) => {
              state.ui.notifications.push({
                id: Date.now(),
                timestamp: new Date().toISOString(),
                ...notification,
              });
            }),

          removeNotification: (id) =>
            set((state) => {
              state.ui.notifications = state.ui.notifications.filter(
                (n) => n.id !== id
              );
            }),

          // Computed selectors
          get filteredPosts() {
            const { posts } = get();
            let filtered = posts.items;

            if (posts.filters.category !== "all") {
              filtered = filtered.filter(
                (post) => post.category === posts.filters.category
              );
            }

            if (posts.filters.search) {
              const search = posts.filters.search.toLowerCase();
              filtered = filtered.filter(
                (post) =>
                  post.title.toLowerCase().includes(search) ||
                  post.content.toLowerCase().includes(search)
              );
            }

            return filtered;
          },
        }))
      ),
      {
        name: "app-storage",
        partialize: (state) => ({
          user: {
            preferences: state.user.preferences,
          },
        }),
      }
    ),
    {
      name: "app-store",
    }
  )
);

// Usage in components
function Counter() {
  const { count, increment, decrement, reset, doubled, isEven } =
    useCounterStore();

  return (
    <div>
      <p>Count: {count}</p>
      <p>Doubled: {doubled}</p>
      <p>Is Even: {isEven ? "Yes" : "No"}</p>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}

function PostsList() {
  const { posts, filteredPosts, fetchPosts, deletePost, setPostsFilters } =
    useAppStore();

  useEffect(() => {
    fetchPosts();
  }, []);

  return (
    <div>
      <input
        type="text"
        placeholder="Search posts..."
        onChange={(e) => setPostsFilters({ search: e.target.value })}
      />

      {posts.loading && <div>Loading...</div>}
      {posts.error && <div>Error: {posts.error}</div>}

      <div>
        {filteredPosts.map((post) => (
          <div key={post.id}>
            <h3>{post.title}</h3>
            <p>{post.content}</p>
            <button onClick={() => deletePost(post.id)}>Delete</button>
          </div>
        ))}
      </div>
    </div>
  );
}

// Selective subscriptions to avoid unnecessary re-renders
function UserProfile() {
  const user = useAppStore((state) => state.user.currentUser);
  const updatePreferences = useAppStore((state) => state.updatePreferences);

  // This component only re-renders when user.currentUser changes
  return (
    <div>
      <h2>{user?.name}</h2>
      <button onClick={() => updatePreferences({ theme: "dark" })}>
        Switch to Dark Theme
      </button>
    </div>
  );
}

export { useCounterStore, useAppStore };
```

### 7. How do you implement middleware and persistence in Zustand?

**Answer:**
Zustand provides several built-in middleware for common patterns like persistence, devtools, and subscriptions.

```javascript
import { create } from "zustand";
import {
  devtools,
  persist,
  subscribeWithSelector,
  createJSONStorage,
} from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

// Custom middleware for logging
const logger = (config) => (set, get, api) =>
  config(
    (...args) => {
      console.log("Previous state:", get());
      set(...args);
      console.log("New state:", get());
    },
    get,
    api
  );

// Custom middleware for error handling
const errorHandler = (config) => (set, get, api) => {
  const wrappedSet = (...args) => {
    try {
      set(...args);
    } catch (error) {
      console.error("State update error:", error);
      // You could dispatch to an error store here
      api.setState({ error: error.message });
    }
  };

  return config(wrappedSet, get, api);
};

// Store with multiple middleware
const useAdvancedStore = create(
  logger(
    errorHandler(
      devtools(
        persist(
          subscribeWithSelector(
            immer((set, get) => ({
              // State
              user: null,
              posts: [],
              settings: {
                theme: "light",
                notifications: true,
                autoSave: false,
              },
              error: null,

              // Actions
              setUser: (user) =>
                set((state) => {
                  state.user = user;
                  state.error = null;
                }),

              addPost: (post) =>
                set((state) => {
                  state.posts.push({
                    ...post,
                    id: Date.now(),
                    createdAt: new Date().toISOString(),
                  });
                }),

              updateSettings: (newSettings) =>
                set((state) => {
                  Object.assign(state.settings, newSettings);
                }),

              clearError: () =>
                set((state) => {
                  state.error = null;
                }),
            }))
          ),
          {
            name: "advanced-storage",
            storage: createJSONStorage(() => localStorage),
            partialize: (state) => ({
              settings: state.settings,
              user: state.user
                ? { id: state.user.id, name: state.user.name }
                : null,
            }),
            onRehydrateStorage: () => (state) => {
              console.log("Hydration finished", state);
            },
          }
        ),
        {
          name: "advanced-store",
        }
      )
    )
  )
);

// Custom storage implementation
const customStorage = {
  getItem: async (name) => {
    try {
      const value = localStorage.getItem(name);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      console.error("Failed to get item from storage:", error);
      return null;
    }
  },
  setItem: async (name, value) => {
    try {
      localStorage.setItem(name, JSON.stringify(value));
    } catch (error) {
      console.error("Failed to set item in storage:", error);
    }
  },
  removeItem: async (name) => {
    try {
      localStorage.removeItem(name);
    } catch (error) {
      console.error("Failed to remove item from storage:", error);
    }
  },
};

// Store with custom storage
const useCustomStorageStore = create(
  persist(
    (set, get) => ({
      data: [],
      addData: (item) => set((state) => ({ data: [...state.data, item] })),
      clearData: () => set({ data: [] }),
    }),
    {
      name: "custom-storage",
      storage: createJSONStorage(() => customStorage),
    }
  )
);

// Subscription example
const useSubscriptionStore = create(
  subscribeWithSelector((set, get) => ({
    count: 0,
    user: null,
    increment: () => set((state) => ({ count: state.count + 1 })),
    setUser: (user) => set({ user }),
  }))
);

// Subscribe to specific state changes
useSubscriptionStore.subscribe(
  (state) => state.count,
  (count, previousCount) => {
    console.log("Count changed from", previousCount, "to", count);

    // Trigger side effects
    if (count > 10) {
      console.log("Count exceeded 10!");
    }
  }
);

// Subscribe to user changes
useSubscriptionStore.subscribe(
  (state) => state.user,
  (user, previousUser) => {
    if (user && !previousUser) {
      console.log("User logged in:", user);
      // Track login event
    } else if (!user && previousUser) {
      console.log("User logged out");
      // Track logout event
    }
  }
);

// Async middleware for API calls
const asyncMiddleware = (config) => (set, get, api) => {
  const asyncActions = {
    async fetchUser(id) {
      set({ loading: true, error: null });
      try {
        const response = await fetch(`/api/users/${id}`);
        if (!response.ok) throw new Error("Failed to fetch user");
        const user = await response.json();
        set({ user, loading: false });
        return user;
      } catch (error) {
        set({ error: error.message, loading: false });
        throw error;
      }
    },

    async saveData(data) {
      set({ saving: true });
      try {
        const response = await fetch("/api/data", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(data),
        });
        if (!response.ok) throw new Error("Failed to save data");
        set({ saving: false, lastSaved: new Date().toISOString() });
      } catch (error) {
        set({ saving: false, error: error.message });
        throw error;
      }
    },
  };

  return {
    ...config(set, get, api),
    ...asyncActions,
  };
};

// Store with async middleware
const useAsyncStore = create(
  asyncMiddleware((set, get) => ({
    user: null,
    loading: false,
    saving: false,
    error: null,
    lastSaved: null,

    clearError: () => set({ error: null }),
  }))
);

// Usage in components
function AsyncComponent() {
  const { user, loading, error, fetchUser, saveData, clearError } =
    useAsyncStore();

  const handleFetchUser = async () => {
    try {
      await fetchUser(123);
    } catch (error) {
      console.error("Failed to fetch user:", error);
    }
  };

  return (
    <div>
      {loading && <div>Loading...</div>}
      {error && (
        <div>
          Error: {error}
          <button onClick={clearError}>Clear</button>
        </div>
      )}
      {user && <div>User: {user.name}</div>}
      <button onClick={handleFetchUser}>Fetch User</button>
    </div>
  );
}

export {
  useAdvancedStore,
  useCustomStorageStore,
  useSubscriptionStore,
  useAsyncStore,
};
```

---

## Advanced Zustand Patterns

### 8. How do you implement complex state patterns with Zustand?

**Answer:**
Zustand supports advanced patterns like slices, computed values, and state machines for complex applications.

```javascript
import { create } from "zustand";
import { devtools, subscribeWithSelector } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

// Slice pattern for modular state management
const createUserSlice = (set, get) => ({
  user: {
    currentUser: null,
    profile: null,
    preferences: {
      theme: "light",
      language: "en",
      notifications: true,
    },
    isAuthenticated: false,
    loading: false,
    error: null,
  },

  // User actions
  loginUser: async (credentials) => {
    set((state) => {
      state.user.loading = true;
      state.user.error = null;
    });

    try {
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(credentials),
      });

      if (!response.ok) throw new Error("Login failed");

      const { user, profile } = await response.json();

      set((state) => {
        state.user.currentUser = user;
        state.user.profile = profile;
        state.user.isAuthenticated = true;
        state.user.loading = false;
      });

      return user;
    } catch (error) {
      set((state) => {
        state.user.error = error.message;
        state.user.loading = false;
      });
      throw error;
    }
  },

  logoutUser: () =>
    set((state) => {
      state.user.currentUser = null;
      state.user.profile = null;
      state.user.isAuthenticated = false;
      state.user.preferences = {
        theme: "light",
        language: "en",
        notifications: true,
      };
    }),

  updateUserPreferences: (preferences) =>
    set((state) => {
      Object.assign(state.user.preferences, preferences);
    }),

  updateUserProfile: (updates) =>
    set((state) => {
      if (state.user.profile) {
        Object.assign(state.user.profile, updates);
      }
    }),
});

const createPostsSlice = (set, get) => ({
  posts: {
    items: [],
    categories: [],
    loading: false,
    error: null,
    pagination: {
      page: 1,
      limit: 10,
      total: 0,
      hasNext: false,
    },
    filters: {
      category: "all",
      search: "",
      sortBy: "createdAt",
      sortOrder: "desc",
    },
    cache: new Map(),
  },

  // Posts actions
  fetchPosts: async (options = {}) => {
    const { posts } = get();
    const params = { ...posts.filters, ...options };
    const cacheKey = JSON.stringify(params);

    // Check cache first
    if (posts.cache.has(cacheKey)) {
      const cachedData = posts.cache.get(cacheKey);
      set((state) => {
        state.posts.items = cachedData.items;
        state.posts.pagination = cachedData.pagination;
      });
      return;
    }

    set((state) => {
      state.posts.loading = true;
      state.posts.error = null;
    });

    try {
      const queryParams = new URLSearchParams(params);
      const response = await fetch(`/api/posts?${queryParams}`);

      if (!response.ok) throw new Error("Failed to fetch posts");

      const data = await response.json();

      set((state) => {
        state.posts.items = data.posts;
        state.posts.pagination = data.pagination;
        state.posts.loading = false;

        // Cache the result
        state.posts.cache.set(cacheKey, {
          items: data.posts,
          pagination: data.pagination,
          timestamp: Date.now(),
        });
      });
    } catch (error) {
      set((state) => {
        state.posts.error = error.message;
        state.posts.loading = false;
      });
    }
  },

  createPost: async (postData) => {
    try {
      const response = await fetch("/api/posts", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(postData),
      });

      if (!response.ok) throw new Error("Failed to create post");

      const newPost = await response.json();

      set((state) => {
        state.posts.items.unshift(newPost);
        state.posts.cache.clear(); // Invalidate cache
      });

      return newPost;
    } catch (error) {
      set((state) => {
        state.posts.error = error.message;
      });
      throw error;
    }
  },

  updatePost: async (id, updates) => {
    try {
      const response = await fetch(`/api/posts/${id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(updates),
      });

      if (!response.ok) throw new Error("Failed to update post");

      const updatedPost = await response.json();

      set((state) => {
        const index = state.posts.items.findIndex((p) => p.id === id);
        if (index !== -1) {
          state.posts.items[index] = updatedPost;
        }
        state.posts.cache.clear(); // Invalidate cache
      });

      return updatedPost;
    } catch (error) {
      set((state) => {
        state.posts.error = error.message;
      });
      throw error;
    }
  },

  deletePost: async (id) => {
    try {
      const response = await fetch(`/api/posts/${id}`, {
        method: "DELETE",
      });

      if (!response.ok) throw new Error("Failed to delete post");

      set((state) => {
        state.posts.items = state.posts.items.filter((p) => p.id !== id);
        state.posts.cache.clear(); // Invalidate cache
      });
    } catch (error) {
      set((state) => {
        state.posts.error = error.message;
      });
      throw error;
    }
  },

  setPostsFilters: (filters) =>
    set((state) => {
      Object.assign(state.posts.filters, filters);
    }),

  clearPostsCache: () =>
    set((state) => {
      state.posts.cache.clear();
    }),
});

const createUISlice = (set, get) => ({
  ui: {
    theme: "light",
    sidebarOpen: false,
    modals: {
      createPost: false,
      editProfile: false,
      confirmDelete: false,
    },
    notifications: [],
    loading: {
      global: false,
      posts: false,
      user: false,
    },
    errors: [],
  },

  // UI actions
  setTheme: (theme) =>
    set((state) => {
      state.ui.theme = theme;
    }),

  toggleSidebar: () =>
    set((state) => {
      state.ui.sidebarOpen = !state.ui.sidebarOpen;
    }),

  openModal: (modalName) =>
    set((state) => {
      state.ui.modals[modalName] = true;
    }),

  closeModal: (modalName) =>
    set((state) => {
      state.ui.modals[modalName] = false;
    }),

  addNotification: (notification) =>
    set((state) => {
      state.ui.notifications.push({
        id: Date.now(),
        timestamp: new Date().toISOString(),
        type: "info",
        autoClose: true,
        duration: 5000,
        ...notification,
      });
    }),

  removeNotification: (id) =>
    set((state) => {
      state.ui.notifications = state.ui.notifications.filter(
        (n) => n.id !== id
      );
    }),

  setLoading: (key, loading) =>
    set((state) => {
      state.ui.loading[key] = loading;
    }),

  addError: (error) =>
    set((state) => {
      state.ui.errors.push({
        id: Date.now(),
        message: error.message || error,
        timestamp: new Date().toISOString(),
      });
    }),

  removeError: (id) =>
    set((state) => {
      state.ui.errors = state.ui.errors.filter((e) => e.id !== id);
    }),
});

// Computed values slice
const createComputedSlice = (set, get) => ({
  // Computed getters
  get filteredPosts() {
    const { posts } = get();
    let filtered = posts.items;

    if (posts.filters.category !== "all") {
      filtered = filtered.filter(
        (post) => post.category === posts.filters.category
      );
    }

    if (posts.filters.search) {
      const search = posts.filters.search.toLowerCase();
      filtered = filtered.filter(
        (post) =>
          post.title.toLowerCase().includes(search) ||
          post.content.toLowerCase().includes(search)
      );
    }

    // Sort posts
    filtered.sort((a, b) => {
      const aValue = a[posts.filters.sortBy];
      const bValue = b[posts.filters.sortBy];

      if (posts.filters.sortOrder === "asc") {
        return aValue > bValue ? 1 : -1;
      } else {
        return aValue < bValue ? 1 : -1;
      }
    });

    return filtered;
  },

  get userStats() {
    const { user, posts } = get();
    if (!user.currentUser) return null;

    const userPosts = posts.items.filter(
      (post) => post.authorId === user.currentUser.id
    );

    return {
      totalPosts: userPosts.length,
      totalViews: userPosts.reduce((sum, post) => sum + (post.views || 0), 0),
      totalLikes: userPosts.reduce((sum, post) => sum + (post.likes || 0), 0),
      averageViews:
        userPosts.length > 0
          ? userPosts.reduce((sum, post) => sum + (post.views || 0), 0) /
            userPosts.length
          : 0,
    };
  },

  get isLoading() {
    const { ui, user, posts } = get();
    return ui.loading.global || user.loading || posts.loading;
  },
});

// Main store combining all slices
const useAppStore = create(
  devtools(
    subscribeWithSelector(
      immer((set, get) => ({
        ...createUserSlice(set, get),
        ...createPostsSlice(set, get),
        ...createUISlice(set, get),
        ...createComputedSlice(set, get),
      }))
    ),
    { name: "app-store" }
  )
);

// State machine pattern for complex workflows
const createStateMachine = (initialState, transitions) => {
  return create((set, get) => ({
    currentState: initialState,
    context: {},

    transition: (event, payload = {}) => {
      const { currentState } = get();
      const stateConfig = transitions[currentState];

      if (!stateConfig || !stateConfig[event]) {
        console.warn(`Invalid transition: ${event} from ${currentState}`);
        return false;
      }

      const transition = stateConfig[event];
      const nextState =
        typeof transition.target === "function"
          ? transition.target(get().context, payload)
          : transition.target;

      set((state) => {
        state.currentState = nextState;

        // Update context if action provided
        if (transition.action) {
          state.context = transition.action(state.context, payload);
        }
      });

      return true;
    },

    can: (event) => {
      const { currentState } = get();
      const stateConfig = transitions[currentState];
      return stateConfig && stateConfig[event];
    },

    is: (state) => get().currentState === state,
  }));
};

// Example: Post creation workflow state machine
const usePostCreationMachine = createStateMachine("idle", {
  idle: {
    START_CREATION: {
      target: "editing",
      action: (context, payload) => ({
        ...context,
        draft: { title: "", content: "", category: "" },
      }),
    },
  },
  editing: {
    UPDATE_DRAFT: {
      target: "editing",
      action: (context, payload) => ({
        ...context,
        draft: { ...context.draft, ...payload },
      }),
    },
    VALIDATE: {
      target: (context) => {
        const { title, content } = context.draft;
        return title && content ? "valid" : "invalid";
      },
    },
    CANCEL: {
      target: "idle",
      action: () => ({}),
    },
  },
  valid: {
    SUBMIT: {
      target: "submitting",
      action: (context) => ({
        ...context,
        submittedAt: new Date().toISOString(),
      }),
    },
    EDIT: {
      target: "editing",
    },
  },
  invalid: {
    EDIT: {
      target: "editing",
    },
  },
  submitting: {
    SUCCESS: {
      target: "success",
      action: (context, payload) => ({ ...context, result: payload }),
    },
    ERROR: {
      target: "error",
      action: (context, payload) => ({ ...context, error: payload }),
    },
  },
  success: {
    RESET: {
      target: "idle",
      action: () => ({}),
    },
  },
  error: {
    RETRY: {
      target: "submitting",
    },
    EDIT: {
      target: "editing",
    },
    CANCEL: {
      target: "idle",
      action: () => ({}),
    },
  },
});

export { useAppStore, usePostCreationMachine, createStateMachine };
```

---

## Redux vs Zustand Comparison

### 9. When should you choose Redux over Zustand and vice versa?

**Answer:**
The choice between Redux and Zustand depends on project requirements, team preferences, and application complexity.

**Choose Redux when:**

- Large, complex applications with many developers
- Need for time-travel debugging and extensive DevTools
- Strict patterns and predictability are required
- Heavy use of middleware ecosystem
- Team is already familiar with Redux patterns

**Choose Zustand when:**

- Smaller to medium-sized applications
- Want minimal boilerplate and faster development
- TypeScript-first development
- Need flexible state management without strict patterns
- Bundle size is a concern

```javascript
// Redux approach - More verbose but structured
// actions/userActions.js
export const LOGIN_REQUEST = "LOGIN_REQUEST";
export const LOGIN_SUCCESS = "LOGIN_SUCCESS";
export const LOGIN_FAILURE = "LOGIN_FAILURE";

export const loginRequest = () => ({ type: LOGIN_REQUEST });
export const loginSuccess = (user) => ({ type: LOGIN_SUCCESS, payload: user });
export const loginFailure = (error) => ({
  type: LOGIN_FAILURE,
  payload: error,
});

export const login = (credentials) => async (dispatch) => {
  dispatch(loginRequest());
  try {
    const response = await fetch("/api/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(credentials),
    });
    const user = await response.json();
    dispatch(loginSuccess(user));
  } catch (error) {
    dispatch(loginFailure(error.message));
  }
};

// reducers/userReducer.js
const initialState = {
  user: null,
  loading: false,
  error: null,
};

export default function userReducer(state = initialState, action) {
  switch (action.type) {
    case LOGIN_REQUEST:
      return { ...state, loading: true, error: null };
    case LOGIN_SUCCESS:
      return { ...state, loading: false, user: action.payload };
    case LOGIN_FAILURE:
      return { ...state, loading: false, error: action.payload };
    default:
      return state;
  }
}

// store.js
import { configureStore } from "@reduxjs/toolkit";
import userReducer from "./reducers/userReducer";

export const store = configureStore({
  reducer: {
    user: userReducer,
  },
});

// Component usage
import { useSelector, useDispatch } from "react-redux";
import { login } from "./actions/userActions";

function LoginComponent() {
  const { user, loading, error } = useSelector((state) => state.user);
  const dispatch = useDispatch();

  const handleLogin = (credentials) => {
    dispatch(login(credentials));
  };

  return (
    <div>
      {loading && <div>Loading...</div>}
      {error && <div>Error: {error}</div>}
      {user && <div>Welcome, {user.name}!</div>}
    </div>
  );
}

// Zustand approach - More concise and direct
import { create } from "zustand";

const useUserStore = create((set, get) => ({
  user: null,
  loading: false,
  error: null,

  login: async (credentials) => {
    set({ loading: true, error: null });
    try {
      const response = await fetch("/api/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(credentials),
      });
      const user = await response.json();
      set({ loading: false, user });
    } catch (error) {
      set({ loading: false, error: error.message });
    }
  },

  logout: () => set({ user: null, error: null }),
}));

// Component usage
function LoginComponent() {
  const { user, loading, error, login } = useUserStore();

  const handleLogin = (credentials) => {
    login(credentials);
  };

  return (
    <div>
      {loading && <div>Loading...</div>}
      {error && <div>Error: {error}</div>}
      {user && <div>Welcome, {user.name}!</div>}
    </div>
  );
}
```

### 10. How do you migrate from Redux to Zustand?

**Answer:**
Migrating from Redux to Zustand can be done incrementally by replacing Redux slices with Zustand stores.

```javascript
// Step 1: Create equivalent Zustand stores for Redux slices

// Original Redux slice
// userSlice.js (Redux Toolkit)
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

export const fetchUser = createAsyncThunk("user/fetchUser", async (userId) => {
  const response = await fetch(`/api/users/${userId}`);
  return response.json();
});

const userSlice = createSlice({
  name: "user",
  initialState: {
    currentUser: null,
    loading: false,
    error: null,
  },
  reducers: {
    logout: (state) => {
      state.currentUser = null;
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUser.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchUser.fulfilled, (state, action) => {
        state.loading = false;
        state.currentUser = action.payload;
      })
      .addCase(fetchUser.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  },
});

export const { logout, clearError } = userSlice.actions;
export default userSlice.reducer;

// Equivalent Zustand store
// userStore.js (Zustand)
import { create } from "zustand";
import { devtools } from "zustand/middleware";

export const useUserStore = create(
  devtools(
    (set, get) => ({
      currentUser: null,
      loading: false,
      error: null,

      fetchUser: async (userId) => {
        set({ loading: true, error: null });
        try {
          const response = await fetch(`/api/users/${userId}`);
          const user = await response.json();
          set({ loading: false, currentUser: user });
        } catch (error) {
          set({ loading: false, error: error.message });
        }
      },

      logout: () => set({ currentUser: null }),

      clearError: () => set({ error: null }),
    }),
    { name: "user-store" }
  )
);

// Step 2: Create a migration adapter for gradual transition
// migrationAdapter.js
import { useSelector, useDispatch } from "react-redux";
import { useUserStore } from "./userStore";
import { fetchUser, logout, clearError } from "./userSlice";

// Adapter hook that provides the same interface as Redux
export const useUserMigration = (useZustand = false) => {
  const reduxUser = useSelector((state) => state.user);
  const dispatch = useDispatch();

  const zustandUser = useUserStore();

  if (useZustand) {
    return {
      currentUser: zustandUser.currentUser,
      loading: zustandUser.loading,
      error: zustandUser.error,
      fetchUser: zustandUser.fetchUser,
      logout: zustandUser.logout,
      clearError: zustandUser.clearError,
    };
  }

  return {
    currentUser: reduxUser.currentUser,
    loading: reduxUser.loading,
    error: reduxUser.error,
    fetchUser: (userId) => dispatch(fetchUser(userId)),
    logout: () => dispatch(logout()),
    clearError: () => dispatch(clearError()),
  };
};

// Step 3: Update components gradually
// UserProfile.js - Before migration
import { useSelector, useDispatch } from "react-redux";
import { fetchUser, logout } from "./userSlice";

function UserProfile({ userId }) {
  const { currentUser, loading, error } = useSelector((state) => state.user);
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(fetchUser(userId));
  }, [userId, dispatch]);

  const handleLogout = () => {
    dispatch(logout());
  };

  return (
    <div>
      {loading && <div>Loading...</div>}
      {error && <div>Error: {error}</div>}
      {currentUser && (
        <div>
          <h2>{currentUser.name}</h2>
          <button onClick={handleLogout}>Logout</button>
        </div>
      )}
    </div>
  );
}

// UserProfile.js - During migration (using adapter)
import { useUserMigration } from "./migrationAdapter";

function UserProfile({ userId }) {
  // Toggle this flag to switch between Redux and Zustand
  const useZustand = process.env.REACT_APP_USE_ZUSTAND === "true";
  const { currentUser, loading, error, fetchUser, logout } =
    useUserMigration(useZustand);

  useEffect(() => {
    fetchUser(userId);
  }, [userId, fetchUser]);

  return (
    <div>
      {loading && <div>Loading...</div>}
      {error && <div>Error: {error}</div>}
      {currentUser && (
        <div>
          <h2>{currentUser.name}</h2>
          <button onClick={logout}>Logout</button>
        </div>
      )}
    </div>
  );
}

// UserProfile.js - After migration (pure Zustand)
import { useUserStore } from "./userStore";

function UserProfile({ userId }) {
  const { currentUser, loading, error, fetchUser, logout } = useUserStore();

  useEffect(() => {
    fetchUser(userId);
  }, [userId, fetchUser]);

  return (
    <div>
      {loading && <div>Loading...</div>}
      {error && <div>Error: {error}</div>}
      {currentUser && (
        <div>
          <h2>{currentUser.name}</h2>
          <button onClick={logout}>Logout</button>
        </div>
      )}
    </div>
  );
}

// Step 4: Migration utilities
// migrationUtils.js
export const createMigrationStore = (reduxSlice, zustandStore) => {
  return {
    // Sync Redux state to Zustand
    syncToZustand: (reduxState) => {
      zustandStore.setState(reduxState);
    },

    // Sync Zustand state to Redux
    syncToRedux: (dispatch) => {
      const zustandState = zustandStore.getState();
      dispatch(reduxSlice.actions.setState(zustandState));
    },

    // Compare states for debugging
    compareStates: (reduxState) => {
      const zustandState = zustandStore.getState();
      console.log("Redux state:", reduxState);
      console.log("Zustand state:", zustandState);
      console.log(
        "States match:",
        JSON.stringify(reduxState) === JSON.stringify(zustandState)
      );
    },
  };
};

// Step 5: Testing utilities
// testUtils.js
import { renderHook, act } from "@testing-library/react";
import { Provider } from "react-redux";
import { store } from "./store";
import { useUserStore } from "./userStore";

// Test both Redux and Zustand implementations
export const testBothImplementations = (testFn) => {
  describe("Redux implementation", () => {
    testFn("redux");
  });

  describe("Zustand implementation", () => {
    testFn("zustand");
  });
};

// Example test
testBothImplementations((implementation) => {
  it("should handle user login", async () => {
    if (implementation === "redux") {
      // Test Redux implementation
      const wrapper = ({ children }) => (
        <Provider store={store}>{children}</Provider>
      );

      const { result } = renderHook(() => useSelector((state) => state.user), {
        wrapper,
      });
      // ... Redux-specific test logic
    } else {
      // Test Zustand implementation
      const { result } = renderHook(() => useUserStore());
      // ... Zustand-specific test logic
    }
  });
});
```

---

## Performance & Best Practices

### 11. How do you optimize performance in Redux and Zustand?

**Answer:**
Both Redux and Zustand offer different approaches to performance optimization.

**Redux Performance Optimization:**

```javascript
import { createSelector } from "@reduxjs/toolkit";
import { shallowEqual, useSelector } from "react-redux";
import { memo, useMemo, useCallback } from "react";

// 1. Use memoized selectors
const selectPosts = (state) => state.posts.items;
const selectFilters = (state) => state.posts.filters;

const selectFilteredPosts = createSelector(
  [selectPosts, selectFilters],
  (posts, filters) => {
    console.log("Recomputing filtered posts"); // Only logs when inputs change

    let filtered = posts;

    if (filters.category !== "all") {
      filtered = filtered.filter((post) => post.category === filters.category);
    }

    if (filters.search) {
      const searchLower = filters.search.toLowerCase();
      filtered = filtered.filter((post) =>
        post.title.toLowerCase().includes(searchLower)
      );
    }

    return filtered.sort(
      (a, b) => new Date(b.createdAt) - new Date(a.createdAt)
    );
  }
);

// 2. Use shallow equality for object selections
function PostsList() {
  const { posts, loading, error } = useSelector(
    (state) => ({
      posts: selectFilteredPosts(state),
      loading: state.posts.loading,
      error: state.posts.error,
    }),
    shallowEqual // Prevents re-renders when object shape is the same
  );

  return (
    <div>
      {loading && <div>Loading...</div>}
      {error && <div>Error: {error}</div>}
      {posts.map((post) => (
        <PostItem key={post.id} post={post} />
      ))}
    </div>
  );
}

// 3. Memoize components
const PostItem = memo(({ post, onDelete, onEdit }) => {
  const handleDelete = useCallback(() => {
    onDelete(post.id);
  }, [post.id, onDelete]);

  const handleEdit = useCallback(() => {
    onEdit(post);
  }, [post, onEdit]);

  return (
    <div className="post-item">
      <h3>{post.title}</h3>
      <p>{post.excerpt}</p>
      <div>
        <button onClick={handleEdit}>Edit</button>
        <button onClick={handleDelete}>Delete</button>
      </div>
    </div>
  );
});

// 4. Normalize state structure
const postsAdapter = createEntityAdapter({
  selectId: (post) => post.id,
  sortComparer: (a, b) => b.createdAt.localeCompare(a.createdAt),
});

const postsSlice = createSlice({
  name: "posts",
  initialState: postsAdapter.getInitialState({
    loading: false,
    error: null,
  }),
  reducers: {
    addPost: postsAdapter.addOne,
    updatePost: postsAdapter.updateOne,
    removePost: postsAdapter.removeOne,
    setPosts: postsAdapter.setAll,
  },
});

// Optimized selectors
export const {
  selectAll: selectAllPosts,
  selectById: selectPostById,
  selectIds: selectPostIds,
} = postsAdapter.getSelectors((state) => state.posts);

// 5. Use RTK Query for automatic caching
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

const apiSlice = createApi({
  reducerPath: "api",
  baseQuery: fetchBaseQuery({ baseUrl: "/api" }),
  tagTypes: ["Post"],
  endpoints: (builder) => ({
    getPosts: builder.query({
      query: (params) => `posts?${new URLSearchParams(params)}`,
      providesTags: (result) =>
        result
          ? [
              ...result.map(({ id }) => ({ type: "Post", id })),
              { type: "Post", id: "LIST" },
            ]
          : [{ type: "Post", id: "LIST" }],
      // Cache for 60 seconds
      keepUnusedDataFor: 60,
    }),
  }),
});
```

**Zustand Performance Optimization:**

```javascript
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { shallow } from "zustand/shallow";
import { memo, useMemo } from "react";

// 1. Use selective subscriptions
const useAppStore = create(
  subscribeWithSelector((set, get) => ({
    posts: [],
    filters: { category: "all", search: "" },
    user: null,
    ui: { theme: "light", sidebarOpen: false },

    setPosts: (posts) => set({ posts }),
    setFilters: (filters) =>
      set((state) => ({
        filters: { ...state.filters, ...filters },
      })),
    setUser: (user) => set({ user }),
    toggleSidebar: () =>
      set((state) => ({
        ui: { ...state.ui, sidebarOpen: !state.ui.sidebarOpen },
      })),
  }))
);

// 2. Selective subscriptions to prevent unnecessary re-renders
function PostsList() {
  // Only re-render when posts or filters change
  const { posts, filters } = useAppStore(
    (state) => ({ posts: state.posts, filters: state.filters }),
    shallow
  );

  const filteredPosts = useMemo(() => {
    let filtered = posts;

    if (filters.category !== "all") {
      filtered = filtered.filter((post) => post.category === filters.category);
    }

    if (filters.search) {
      const searchLower = filters.search.toLowerCase();
      filtered = filtered.filter((post) =>
        post.title.toLowerCase().includes(searchLower)
      );
    }

    return filtered;
  }, [posts, filters]);

  return (
    <div>
      {filteredPosts.map((post) => (
        <PostItem key={post.id} post={post} />
      ))}
    </div>
  );
}

// 3. Use specific selectors for individual values
function UserProfile() {
  // Only re-render when user changes, not when other state changes
  const user = useAppStore((state) => state.user);
  const setUser = useAppStore((state) => state.setUser);

  return (
    <div>
      {user ? (
        <div>
          <h2>{user.name}</h2>
          <p>{user.email}</p>
        </div>
      ) : (
        <div>Not logged in</div>
      )}
    </div>
  );
}

// 4. Optimize with computed values
const useOptimizedStore = create((set, get) => ({
  items: [],
  filters: { search: "", category: "all" },

  // Computed getter - only recalculates when accessed
  get filteredItems() {
    const { items, filters } = get();
    console.log("Computing filtered items"); // Only logs when accessed

    return items.filter((item) => {
      if (filters.category !== "all" && item.category !== filters.category) {
        return false;
      }
      if (
        filters.search &&
        !item.name.toLowerCase().includes(filters.search.toLowerCase())
      ) {
        return false;
      }
      return true;
    });
  },

  addItem: (item) =>
    set((state) => ({
      items: [...state.items, item],
    })),

  setFilters: (newFilters) =>
    set((state) => ({
      filters: { ...state.filters, ...newFilters },
    })),
}));

// 5. Use subscriptions for side effects
const useStoreWithEffects = create(
  subscribeWithSelector((set, get) => ({
    user: null,
    posts: [],
    analytics: { pageViews: 0, userActions: 0 },

    setUser: (user) => set({ user }),
    addPost: (post) =>
      set((state) => ({
        posts: [...state.posts, post],
        analytics: {
          ...state.analytics,
          userActions: state.analytics.userActions + 1,
        },
      })),
    incrementPageViews: () =>
      set((state) => ({
        analytics: {
          ...state.analytics,
          pageViews: state.analytics.pageViews + 1,
        },
      })),
  }))
);

// Subscribe to user changes for analytics
useStoreWithEffects.subscribe(
  (state) => state.user,
  (user, previousUser) => {
    if (user && !previousUser) {
      // User logged in
      console.log("User logged in, tracking event");
      // Track login event
    }
  }
);

// 6. Memoized components with Zustand
const OptimizedPostItem = memo(({ postId }) => {
  // Only subscribe to the specific post
  const post = useAppStore((state) => state.posts.find((p) => p.id === postId));

  const updatePost = useAppStore((state) => state.updatePost);

  if (!post) return null;

  return (
    <div>
      <h3>{post.title}</h3>
      <p>{post.content}</p>
      <button onClick={() => updatePost(postId, { views: post.views + 1 })}>
        View ({post.views})
      </button>
    </div>
  );
});

// 7. Batch updates for better performance
const useBatchedStore = create((set, get) => ({
  items: [],
  loading: false,
  error: null,

  fetchItems: async () => {
    // Batch multiple state updates
    set({ loading: true, error: null });

    try {
      const response = await fetch("/api/items");
      const items = await response.json();

      // Single state update instead of multiple
      set({
        items,
        loading: false,
        error: null,
      });
    } catch (error) {
      set({
        loading: false,
        error: error.message,
      });
    }
  },

  bulkUpdateItems: (updates) => {
    set((state) => ({
      items: state.items.map((item) => {
        const update = updates.find((u) => u.id === item.id);
        return update ? { ...item, ...update } : item;
      }),
    }));
  },
}));

export { useAppStore, useOptimizedStore, useStoreWithEffects, useBatchedStore };
```

### 12. What are the best practices for testing Redux and Zustand stores?

**Answer:**
Testing state management requires different approaches for Redux and Zustand, focusing on actions, state changes, and component integration.

**Redux Testing:**

```javascript
// Redux testing with Jest and React Testing Library
import { configureStore } from "@reduxjs/toolkit";
import { renderHook, act } from "@testing-library/react";
import { Provider } from "react-redux";
import userSlice, { loginUser, logout } from "./userSlice";

// Test reducer directly
describe("userSlice reducer", () => {
  const initialState = {
    currentUser: null,
    loading: false,
    error: null,
  };

  it("should handle initial state", () => {
    expect(userSlice.reducer(undefined, { type: "unknown" })).toEqual(
      initialState
    );
  });

  it("should handle logout", () => {
    const previousState = {
      currentUser: { id: 1, name: "John" },
      loading: false,
      error: null,
    };

    expect(userSlice.reducer(previousState, logout())).toEqual(initialState);
  });
});

// Test async thunks
describe("loginUser async thunk", () => {
  let store;

  beforeEach(() => {
    store = configureStore({
      reducer: {
        user: userSlice.reducer,
      },
    });

    // Mock fetch
    global.fetch = jest.fn();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  it("should handle successful login", async () => {
    const mockUser = { id: 1, name: "John", email: "john@example.com" };

    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockUser,
    });

    await store.dispatch(
      loginUser({ email: "john@example.com", password: "password" })
    );

    const state = store.getState().user;
    expect(state.currentUser).toEqual(mockUser);
    expect(state.loading).toBe(false);
    expect(state.error).toBe(null);
  });

  it("should handle login failure", async () => {
    fetch.mockRejectedValueOnce(new Error("Login failed"));

    await store.dispatch(
      loginUser({ email: "john@example.com", password: "wrong" })
    );

    const state = store.getState().user;
    expect(state.currentUser).toBe(null);
    expect(state.loading).toBe(false);
    expect(state.error).toBe("Login failed");
  });
});

// Test component integration
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import LoginForm from "./LoginForm";

const renderWithProvider = (component, initialState = {}) => {
  const store = configureStore({
    reducer: {
      user: userSlice.reducer,
    },
    preloadedState: initialState,
  });

  return {
    ...render(<Provider store={store}>{component}</Provider>),
    store,
  };
};

describe("LoginForm component", () => {
  beforeEach(() => {
    global.fetch = jest.fn();
  });

  it("should display loading state during login", async () => {
    fetch.mockImplementation(
      () =>
        new Promise((resolve) => {
          setTimeout(
            () =>
              resolve({
                ok: true,
                json: () => Promise.resolve({ id: 1, name: "John" }),
              }),
            100
          );
        })
    );

    renderWithProvider(<LoginForm />);

    fireEvent.change(screen.getByLabelText(/email/i), {
      target: { value: "john@example.com" },
    });
    fireEvent.change(screen.getByLabelText(/password/i), {
      target: { value: "password" },
    });
    fireEvent.click(screen.getByRole("button", { name: /login/i }));

    expect(screen.getByText(/logging in/i)).toBeInTheDocument();

    await waitFor(() => {
      expect(screen.queryByText(/logging in/i)).not.toBeInTheDocument();
    });
  });
});
```

**Zustand Testing:**

```javascript
// Zustand testing
import { renderHook, act } from "@testing-library/react";
import { useUserStore } from "./userStore";

// Test store directly
describe("useUserStore", () => {
  beforeEach(() => {
    // Reset store before each test
    useUserStore.setState({
      currentUser: null,
      loading: false,
      error: null,
    });

    global.fetch = jest.fn();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  it("should have initial state", () => {
    const { result } = renderHook(() => useUserStore());

    expect(result.current.currentUser).toBe(null);
    expect(result.current.loading).toBe(false);
    expect(result.current.error).toBe(null);
  });

  it("should handle logout", () => {
    const { result } = renderHook(() => useUserStore());

    // Set initial user
    act(() => {
      useUserStore.setState({ currentUser: { id: 1, name: "John" } });
    });

    expect(result.current.currentUser).toEqual({ id: 1, name: "John" });

    // Logout
    act(() => {
      result.current.logout();
    });

    expect(result.current.currentUser).toBe(null);
  });

  it("should handle successful login", async () => {
    const mockUser = { id: 1, name: "John", email: "john@example.com" };

    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockUser,
    });

    const { result } = renderHook(() => useUserStore());

    await act(async () => {
      await result.current.login({
        email: "john@example.com",
        password: "password",
      });
    });

    expect(result.current.currentUser).toEqual(mockUser);
    expect(result.current.loading).toBe(false);
    expect(result.current.error).toBe(null);
  });

  it("should handle login failure", async () => {
    fetch.mockRejectedValueOnce(new Error("Login failed"));

    const { result } = renderHook(() => useUserStore());

    await act(async () => {
      try {
        await result.current.login({
          email: "john@example.com",
          password: "wrong",
        });
      } catch (error) {
        // Expected to throw
      }
    });

    expect(result.current.currentUser).toBe(null);
    expect(result.current.loading).toBe(false);
    expect(result.current.error).toBe("Login failed");
  });
});

// Test store subscriptions
describe("useUserStore subscriptions", () => {
  it("should notify subscribers of state changes", () => {
    const subscriber = jest.fn();

    const unsubscribe = useUserStore.subscribe(subscriber);

    act(() => {
      useUserStore.setState({ currentUser: { id: 1, name: "John" } });
    });

    expect(subscriber).toHaveBeenCalledWith(
      expect.objectContaining({
        currentUser: { id: 1, name: "John" },
      }),
      expect.objectContaining({
        currentUser: null,
      })
    );

    unsubscribe();
  });
});

// Test component integration with Zustand
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import LoginForm from "./LoginForm";

describe("LoginForm with Zustand", () => {
  beforeEach(() => {
    // Reset store
    useUserStore.setState({
      currentUser: null,
      loading: false,
      error: null,
    });

    global.fetch = jest.fn();
  });

  it("should display user after successful login", async () => {
    const mockUser = { id: 1, name: "John" };

    fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockUser,
    });

    render(<LoginForm />);

    fireEvent.change(screen.getByLabelText(/email/i), {
      target: { value: "john@example.com" },
    });
    fireEvent.change(screen.getByLabelText(/password/i), {
      target: { value: "password" },
    });
    fireEvent.click(screen.getByRole("button", { name: /login/i }));

    await waitFor(() => {
      expect(screen.getByText(/welcome, john/i)).toBeInTheDocument();
    });
  });
});

// Test utilities for Zustand
export const createTestStore = (initialState = {}) => {
  const store = useUserStore;
  store.setState(initialState);
  return store;
};

export const mockStoreActions = () => {
  const originalLogin = useUserStore.getState().login;
  const originalLogout = useUserStore.getState().logout;

  const mockLogin = jest.fn();
  const mockLogout = jest.fn();

  useUserStore.setState({
    login: mockLogin,
    logout: mockLogout,
  });

  return {
    mockLogin,
    mockLogout,
    restore: () => {
      useUserStore.setState({
        login: originalLogin,
        logout: originalLogout,
      });
    },
  };
};

// Integration test helper
export const testStoreIntegration = (Component, initialState = {}) => {
  beforeEach(() => {
    useUserStore.setState({
      currentUser: null,
      loading: false,
      error: null,
      ...initialState,
    });
  });

  return render(<Component />);
};
```

These examples demonstrate comprehensive testing strategies for both Redux and Zustand, covering unit tests, integration tests, and testing utilities.

---

### 13. What are the key differences between Redux and Zustand, and when should you use each?

**Answer:**
Redux and Zustand are both state management libraries, but they differ significantly in philosophy, complexity, and use cases.

**Key Differences:**

**1. Boilerplate and Setup:**

_Redux:_

```javascript
// Redux requires multiple files and setup
// actions/userActions.js
export const LOAD_USERS = "LOAD_USERS";
export const LOAD_USERS_SUCCESS = "LOAD_USERS_SUCCESS";
export const LOAD_USERS_FAILURE = "LOAD_USERS_FAILURE";

export const loadUsers = () => ({ type: LOAD_USERS });
export const loadUsersSuccess = (users) => ({
  type: LOAD_USERS_SUCCESS,
  payload: users,
});
export const loadUsersFailure = (error) => ({
  type: LOAD_USERS_FAILURE,
  payload: error,
});

// reducers/userReducer.js
import {
  LOAD_USERS,
  LOAD_USERS_SUCCESS,
  LOAD_USERS_FAILURE,
} from "../actions/userActions";

const initialState = {
  users: [],
  loading: false,
  error: null,
};

export const userReducer = (state = initialState, action) => {
  switch (action.type) {
    case LOAD_USERS:
      return {
        ...state,
        loading: true,
        error: null,
      };
    case LOAD_USERS_SUCCESS:
      return {
        ...state,
        loading: false,
        users: action.payload,
      };
    case LOAD_USERS_FAILURE:
      return {
        ...state,
        loading: false,
        error: action.payload,
      };
    default:
      return state;
  }
};

// store/index.js
import { createStore, combineReducers, applyMiddleware } from "redux";
import { userReducer } from "../reducers/userReducer";
import thunk from "redux-thunk";

const rootReducer = combineReducers({
  users: userReducer,
});

export const store = createStore(rootReducer, applyMiddleware(thunk));
```

_Zustand:_

```javascript
// Single file store definition
import { create } from "zustand";

export const useUserStore = create((set, get) => ({
  users: [],
  loading: false,
  error: null,

  loadUsers: async () => {
    set({ loading: true, error: null });
    try {
      const response = await fetch("/api/users");
      const users = await response.json();
      set({ users, loading: false });
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  },

  addUser: (user) =>
    set((state) => ({
      users: [...state.users, user],
    })),

  updateUser: (id, updates) =>
    set((state) => ({
      users: state.users.map((user) =>
        user.id === id ? { ...user, ...updates } : user
      ),
    })),

  deleteUser: (id) =>
    set((state) => ({
      users: state.users.filter((user) => user.id !== id),
    })),

  clearError: () => set({ error: null }),
}));
```

**2. Component Usage:**

_Redux:_

```javascript
import React, { useEffect } from "react";
import { useSelector, useDispatch } from "react-redux";
import { loadUsers, addUser } from "../actions/userActions";

const UserList = () => {
  const { users, loading, error } = useSelector((state) => state.users);
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(loadUsers());
  }, [dispatch]);

  const handleAddUser = (userData) => {
    dispatch(addUser(userData));
  };

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      {users.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}
      <button onClick={() => handleAddUser({ name: "New User" })}>
        Add User
      </button>
    </div>
  );
};
```

_Zustand:_

```javascript
import React, { useEffect } from "react";
import { useUserStore } from "../stores/userStore";

const UserList = () => {
  const { users, loading, error, loadUsers, addUser } = useUserStore();

  useEffect(() => {
    loadUsers();
  }, [loadUsers]);

  const handleAddUser = () => {
    addUser({ id: Date.now(), name: "New User" });
  };

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      {users.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}
      <button onClick={handleAddUser}>Add User</button>
    </div>
  );
};
```

**When to Use Each:**

**Use Redux when:**

- Building large, complex applications with multiple teams
- Need predictable state updates with time-travel debugging
- Require extensive middleware ecosystem (sagas, observables)
- Need strict patterns and conventions across the team
- Building applications with complex async flows
- Need hot reloading and advanced debugging capabilities
- Working with legacy codebases already using Redux

**Use Zustand when:**

- Building small to medium-sized applications
- Want minimal boilerplate and faster development
- Need simple, intuitive API with TypeScript support
- Prefer co-locating state logic with business logic
- Want built-in async support without additional middleware
- Need selective subscriptions for performance optimization
- Building modern React applications with hooks-first approach
- Want easy integration with existing codebases

**Performance Comparison:**

Redux typically has more overhead due to its architecture, while Zustand offers better performance out of the box with selective subscriptions and minimal re-renders.

---

### 14. How do you implement middleware in Redux and Zustand?

**Answer:**
Middleware in both Redux and Zustand allows you to intercept and modify actions or state changes, enabling features like logging, async handling, and persistence.

**Redux Middleware:**

**1. Custom Logging Middleware:**

```javascript
// Custom logging middleware
const loggerMiddleware = (store) => (next) => (action) => {
  console.group(`Action: ${action.type}`);
  console.log("Previous State:", store.getState());
  console.log("Action:", action);

  const result = next(action);

  console.log("Next State:", store.getState());
  console.groupEnd();

  return result;
};

// API middleware for handling async actions
const apiMiddleware = (store) => (next) => (action) => {
  if (action.type?.endsWith("_REQUEST")) {
    const {
      endpoint,
      method = "GET",
      body,
      onSuccess,
      onFailure,
    } = action.payload;

    fetch(endpoint, {
      method,
      headers: { "Content-Type": "application/json" },
      body: body ? JSON.stringify(body) : undefined,
    })
      .then((response) => response.json())
      .then((data) => {
        if (onSuccess) {
          store.dispatch(onSuccess(data));
        }
      })
      .catch((error) => {
        if (onFailure) {
          store.dispatch(onFailure(error.message));
        }
      });
  }

  return next(action);
};

// Store setup with middleware
import { createStore, applyMiddleware, compose } from "redux";
import thunk from "redux-thunk";

const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;

const store = createStore(
  rootReducer,
  composeEnhancers(applyMiddleware(thunk, loggerMiddleware, apiMiddleware))
);
```

**2. Redux Toolkit Middleware:**

```javascript
import { configureStore, createListenerMiddleware } from "@reduxjs/toolkit";
import { userSlice } from "./userSlice";

// Listener middleware for side effects
const listenerMiddleware = createListenerMiddleware();

// Listen for specific actions
listenerMiddleware.startListening({
  actionCreator: userSlice.actions.userLoggedIn,
  effect: async (action, listenerApi) => {
    // Perform side effects
    console.log("User logged in:", action.payload);

    // Dispatch other actions
    listenerApi.dispatch(userSlice.actions.loadUserPreferences());

    // Access current state
    const state = listenerApi.getState();
    console.log("Current state:", state);
  },
});

// Custom middleware for RTK
const customRTKMiddleware = (api) => (next) => (action) => {
  if (action.type.startsWith("user/")) {
    console.log("User action dispatched:", action);
  }
  return next(action);
};

const store = configureStore({
  reducer: {
    user: userSlice.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ["persist/PERSIST"],
      },
    })
      .prepend(listenerMiddleware.middleware)
      .concat(customRTKMiddleware),
});
```

**Zustand Middleware:**

**1. Built-in Middleware:**

```javascript
import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";
import { devtools } from "zustand/middleware";
import { subscribeWithSelector } from "zustand/middleware";

// Combining multiple middleware
export const useUserStore = create(
  devtools(
    persist(
      subscribeWithSelector(
        immer((set, get) => ({
          users: [],
          currentUser: null,
          loading: false,

          // Using immer for immutable updates
          addUser: (user) =>
            set((state) => {
              state.users.push(user);
            }),

          updateUser: (id, updates) =>
            set((state) => {
              const userIndex = state.users.findIndex((u) => u.id === id);
              if (userIndex !== -1) {
                Object.assign(state.users[userIndex], updates);
              }
            }),

          setCurrentUser: (user) => set({ currentUser: user }),

          loadUsers: async () => {
            set({ loading: true });
            try {
              const response = await fetch("/api/users");
              const users = await response.json();
              set({ users, loading: false });
            } catch (error) {
              set({ loading: false });
              throw error;
            }
          },
        }))
      ),
      {
        name: "user-storage",
        storage: createJSONStorage(() => localStorage),
        partialize: (state) => ({
          currentUser: state.currentUser,
          users: state.users,
        }),
      }
    ),
    {
      name: "user-store",
    }
  )
);
```

**2. Custom Zustand Middleware:**

```javascript
// Custom logging middleware for Zustand
const logger = (config) => (set, get, api) =>
  config(
    (...args) => {
      console.log("Previous state:", get());
      set(...args);
      console.log("New state:", get());
    },
    get,
    api
  );

// Custom API middleware
const apiMiddleware = (config) => (set, get, api) => {
  const store = config(set, get, api);

  return {
    ...store,
    apiCall: async (endpoint, options = {}) => {
      set({ loading: true, error: null });

      try {
        const response = await fetch(endpoint, {
          headers: { "Content-Type": "application/json" },
          ...options,
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        set({ loading: false });
        return data;
      } catch (error) {
        set({ loading: false, error: error.message });
        throw error;
      }
    },
  };
};

// Usage with custom middleware
export const useApiStore = create(
  logger(
    apiMiddleware((set, get) => ({
      data: null,
      loading: false,
      error: null,

      fetchData: async (endpoint) => {
        try {
          const data = await get().apiCall(endpoint);
          set({ data });
        } catch (error) {
          console.error("Failed to fetch data:", error);
        }
      },

      reset: () => set({ data: null, error: null }),
    }))
  )
);
```

**3. Middleware for State Synchronization:**

```javascript
// Sync middleware to keep stores in sync
const createSyncMiddleware = (stores) => (config) => (set, get, api) => {
  const store = config(set, get, api);

  // Subscribe to changes and sync with other stores
  api.subscribe((state, prevState) => {
    stores.forEach((otherStore) => {
      if (otherStore !== api) {
        // Sync specific state properties
        if (state.currentUser !== prevState.currentUser) {
          otherStore.getState().setCurrentUser?.(state.currentUser);
        }
      }
    });
  });

  return store;
};

// Usage
const stores = [];

export const useAuthStore = create(
  createSyncMiddleware(stores)((set) => ({
    currentUser: null,
    setCurrentUser: (user) => set({ currentUser: user }),
  }))
);

stores.push(useAuthStore);
```

**Key Differences:**

1. **Redux**: Middleware intercepts actions before they reach reducers
2. **Zustand**: Middleware wraps the store creation and can intercept state changes
3. **Redux**: More complex setup but powerful ecosystem
4. **Zustand**: Simpler API with built-in common middleware
5. **Redux**: Middleware runs in a specific order
6. **Zustand**: Middleware composition is more flexible

Both approaches provide powerful ways to extend functionality, with Redux offering more standardized patterns and Zustand providing more flexibility and simplicity.

---

### 15. How do you handle complex state patterns and normalization in Redux vs Zustand?

**Answer:**
Both Redux and Zustand can handle complex state patterns, but they approach normalization and complex state management differently.

**Redux State Normalization:**

**1. Normalized State Structure:**

```javascript
// Normalized Redux state
const initialState = {
  users: {
    byId: {},
    allIds: [],
  },
  posts: {
    byId: {},
    allIds: [],
  },
  comments: {
    byId: {},
    allIds: [],
  },
  ui: {
    loading: false,
    selectedUserId: null,
    filters: {
      status: "all",
      category: "all",
    },
  },
};

// Selectors for denormalized data
import { createSelector } from "@reduxjs/toolkit";

const selectUsers = (state) => state.users;
const selectPosts = (state) => state.posts;
const selectComments = (state) => state.comments;

export const selectAllUsers = createSelector([selectUsers], (users) =>
  users.allIds.map((id) => users.byId[id])
);

export const selectUserById = createSelector(
  [selectUsers, (state, userId) => userId],
  (users, userId) => users.byId[userId]
);

export const selectPostsWithAuthors = createSelector(
  [selectPosts, selectUsers],
  (posts, users) => {
    return posts.allIds.map((postId) => {
      const post = posts.byId[postId];
      return {
        ...post,
        author: users.byId[post.authorId],
      };
    });
  }
);

export const selectPostsWithCommentsAndAuthors = createSelector(
  [selectPosts, selectComments, selectUsers],
  (posts, comments, users) => {
    return posts.allIds.map((postId) => {
      const post = posts.byId[postId];
      const postComments = comments.allIds
        .filter((commentId) => comments.byId[commentId].postId === postId)
        .map((commentId) => ({
          ...comments.byId[commentId],
          author: users.byId[comments.byId[commentId].authorId],
        }));

      return {
        ...post,
        author: users.byId[post.authorId],
        comments: postComments,
      };
    });
  }
);
```

**2. Redux Toolkit Entity Adapter:**

```javascript
import { createEntityAdapter, createSlice } from "@reduxjs/toolkit";

// Users entity adapter
const usersAdapter = createEntityAdapter({
  selectId: (user) => user.id,
  sortComparer: (a, b) => a.name.localeCompare(b.name),
});

const usersSlice = createSlice({
  name: "users",
  initialState: usersAdapter.getInitialState({
    loading: false,
    error: null,
  }),
  reducers: {
    addUser: usersAdapter.addOne,
    addUsers: usersAdapter.addMany,
    updateUser: usersAdapter.updateOne,
    removeUser: usersAdapter.removeOne,
    setUsers: usersAdapter.setAll,
  },
});

// Export selectors
export const {
  selectAll: selectAllUsers,
  selectById: selectUserById,
  selectIds: selectUserIds,
} = usersAdapter.getSelectors((state) => state.users);

// Posts with relationships
const postsAdapter = createEntityAdapter({
  sortComparer: (a, b) => b.createdAt.localeCompare(a.createdAt),
});

const postsSlice = createSlice({
  name: "posts",
  initialState: postsAdapter.getInitialState(),
  reducers: {
    addPost: postsAdapter.addOne,
    updatePost: postsAdapter.updateOne,
    removePost: postsAdapter.removeOne,
    setPosts: postsAdapter.setAll,
  },
});

export const { selectAll: selectAllPosts, selectById: selectPostById } =
  postsAdapter.getSelectors((state) => state.posts);
```

**Zustand Complex State Patterns:**

**1. Nested State with Immer:**

```javascript
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import { subscribeWithSelector } from "zustand/middleware";

export const useAppStore = create(
  subscribeWithSelector(
    immer((set, get) => ({
      // Normalized-like structure in Zustand
      entities: {
        users: new Map(),
        posts: new Map(),
        comments: new Map(),
      },

      ui: {
        loading: false,
        selectedUserId: null,
        filters: {
          status: "all",
          category: "all",
        },
      },

      // Actions for users
      addUser: (user) =>
        set((state) => {
          state.entities.users.set(user.id, user);
        }),

      updateUser: (id, updates) =>
        set((state) => {
          const user = state.entities.users.get(id);
          if (user) {
            Object.assign(user, updates);
          }
        }),

      removeUser: (id) =>
        set((state) => {
          state.entities.users.delete(id);
          // Remove related posts and comments
          for (const [postId, post] of state.entities.posts) {
            if (post.authorId === id) {
              state.entities.posts.delete(postId);
            }
          }
          for (const [commentId, comment] of state.entities.comments) {
            if (comment.authorId === id) {
              state.entities.comments.delete(commentId);
            }
          }
        }),

      // Actions for posts
      addPost: (post) =>
        set((state) => {
          state.entities.posts.set(post.id, {
            ...post,
            createdAt: new Date().toISOString(),
          });
        }),

      updatePost: (id, updates) =>
        set((state) => {
          const post = state.entities.posts.get(id);
          if (post) {
            Object.assign(post, updates);
          }
        }),

      // Complex derived state getters
      getAllUsers: () => {
        return Array.from(get().entities.users.values()).sort((a, b) =>
          a.name.localeCompare(b.name)
        );
      },

      getUserById: (id) => {
        return get().entities.users.get(id);
      },

      getPostsWithAuthors: () => {
        const { entities } = get();
        return Array.from(entities.posts.values())
          .map((post) => ({
            ...post,
            author: entities.users.get(post.authorId),
          }))
          .sort((a, b) => b.createdAt.localeCompare(a.createdAt));
      },

      getPostsWithCommentsAndAuthors: () => {
        const { entities } = get();
        return Array.from(entities.posts.values()).map((post) => {
          const comments = Array.from(entities.comments.values())
            .filter((comment) => comment.postId === post.id)
            .map((comment) => ({
              ...comment,
              author: entities.users.get(comment.authorId),
            }));

          return {
            ...post,
            author: entities.users.get(post.authorId),
            comments,
          };
        });
      },

      // UI actions
      setLoading: (loading) =>
        set((state) => {
          state.ui.loading = loading;
        }),

      setSelectedUser: (userId) =>
        set((state) => {
          state.ui.selectedUserId = userId;
        }),

      updateFilters: (filters) =>
        set((state) => {
          Object.assign(state.ui.filters, filters);
        }),
    }))
  )
);
```

**2. Zustand with Slices Pattern:**

```javascript
// Separate slices for different domains
const createUserSlice = (set, get) => ({
  users: new Map(),

  addUser: (user) =>
    set((state) => {
      state.users.set(user.id, user);
    }),

  updateUser: (id, updates) =>
    set((state) => {
      const user = state.users.get(id);
      if (user) Object.assign(user, updates);
    }),

  getUserById: (id) => get().users.get(id),
  getAllUsers: () => Array.from(get().users.values()),
});

const createPostSlice = (set, get) => ({
  posts: new Map(),

  addPost: (post) =>
    set((state) => {
      state.posts.set(post.id, post);
    }),

  getPostsWithAuthors: () => {
    const posts = Array.from(get().posts.values());
    const users = get().users;
    return posts.map((post) => ({
      ...post,
      author: users.get(post.authorId),
    }));
  },
});

const createUISlice = (set, get) => ({
  ui: {
    loading: false,
    selectedUserId: null,
    filters: { status: "all" },
  },

  setLoading: (loading) =>
    set((state) => {
      state.ui.loading = loading;
    }),

  updateFilters: (filters) =>
    set((state) => {
      Object.assign(state.ui.filters, filters);
    }),
});

// Combine slices
export const useAppStore = create(
  immer((set, get) => ({
    ...createUserSlice(set, get),
    ...createPostSlice(set, get),
    ...createUISlice(set, get),
  }))
);
```

**Performance Considerations:**

**Redux:**

- Use `createSelector` for memoized derived state
- Entity adapters provide optimized CRUD operations
- Normalized state prevents deep nesting issues
- Selectors prevent unnecessary re-renders

**Zustand:**

- Use `subscribeWithSelector` for granular subscriptions
- Getter functions for computed state
- Map/Set for efficient lookups
- Selective subscriptions to prevent unnecessary updates

**Usage in Components:**

```javascript
// Redux usage
const PostList = () => {
  const posts = useSelector(selectPostsWithAuthors);
  const loading = useSelector((state) => state.ui.loading);

  return (
    <div>
      {loading
        ? "Loading..."
        : posts.map((post) => <PostItem key={post.id} post={post} />)}
    </div>
  );
};

// Zustand usage with selective subscription
const PostList = () => {
  const posts = useAppStore((state) => state.getPostsWithAuthors());
  const loading = useAppStore((state) => state.ui.loading);

  return (
    <div>
      {loading
        ? "Loading..."
        : posts.map((post) => <PostItem key={post.id} post={post} />)}
    </div>
  );
};
```

Both approaches can handle complex state effectively, with Redux providing more structured patterns and Zustand offering more flexibility in implementation.

---

### 16. How do you migrate from Redux to Zustand or vice versa?

**Answer:**
Migrating between Redux and Zustand requires careful planning and can be done incrementally to minimize disruption.

**Migrating from Redux to Zustand:**

**1. Gradual Migration Strategy:**

```javascript
// Step 1: Create Zustand stores alongside Redux
// Original Redux store
const reduxUserSlice = createSlice({
  name: "users",
  initialState: { users: [], loading: false },
  reducers: {
    setUsers: (state, action) => {
      state.users = action.payload;
    },
    setLoading: (state, action) => {
      state.loading = action.payload;
    },
  },
});

// New Zustand store (parallel implementation)
import { create } from "zustand";

export const useUserStore = create((set, get) => ({
  users: [],
  loading: false,

  setUsers: (users) => set({ users }),
  setLoading: (loading) => set({ loading }),

  // Enhanced functionality in Zustand
  addUser: (user) =>
    set((state) => ({
      users: [...state.users, user],
    })),

  updateUser: (id, updates) =>
    set((state) => ({
      users: state.users.map((user) =>
        user.id === id ? { ...user, ...updates } : user
      ),
    })),

  // Async actions (simpler than Redux thunks)
  fetchUsers: async () => {
    set({ loading: true });
    try {
      const response = await fetch("/api/users");
      const users = await response.json();
      set({ users, loading: false });
    } catch (error) {
      set({ loading: false });
      throw error;
    }
  },
}));
```

**2. Component Migration:**

```javascript
// Original Redux component
import { useSelector, useDispatch } from "react-redux";
import { setUsers, setLoading } from "./userSlice";

const UserListRedux = () => {
  const { users, loading } = useSelector((state) => state.users);
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(setLoading(true));
    fetchUsersAPI().then((users) => {
      dispatch(setUsers(users));
      dispatch(setLoading(false));
    });
  }, [dispatch]);

  return (
    <div>
      {loading
        ? "Loading..."
        : users.map((user) => <div key={user.id}>{user.name}</div>)}
    </div>
  );
};

// Migrated Zustand component
import { useUserStore } from "./userStore";

const UserListZustand = () => {
  const { users, loading, fetchUsers } = useUserStore();

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  return (
    <div>
      {loading
        ? "Loading..."
        : users.map((user) => <div key={user.id}>{user.name}</div>)}
    </div>
  );
};
```

**3. State Synchronization During Migration:**

```javascript
// Bridge component to sync Redux and Zustand during migration
import { useEffect } from "react";
import { useSelector } from "react-redux";
import { useUserStore } from "./userStore";

export const ReduxZustandBridge = () => {
  const reduxUsers = useSelector((state) => state.users.users);
  const reduxLoading = useSelector((state) => state.users.loading);
  const { setUsers, setLoading } = useUserStore();

  // Sync Redux state to Zustand
  useEffect(() => {
    setUsers(reduxUsers);
  }, [reduxUsers, setUsers]);

  useEffect(() => {
    setLoading(reduxLoading);
  }, [reduxLoading, setLoading]);

  return null; // This component only handles synchronization
};

// Usage in App component during migration
const App = () => {
  return (
    <Provider store={reduxStore}>
      <ReduxZustandBridge />
      <UserListZustand /> {/* Using Zustand */}
      <OtherReduxComponent /> {/* Still using Redux */}
    </Provider>
  );
};
```

**Migrating from Zustand to Redux:**

**1. Converting Zustand Store to Redux:**

```javascript
// Original Zustand store
const useUserStore = create((set, get) => ({
  users: [],
  loading: false,

  addUser: (user) =>
    set((state) => ({
      users: [...state.users, user],
    })),

  updateUser: (id, updates) =>
    set((state) => ({
      users: state.users.map((user) =>
        user.id === id ? { ...user, ...updates } : user
      ),
    })),

  fetchUsers: async () => {
    set({ loading: true });
    try {
      const response = await fetch("/api/users");
      const users = await response.json();
      set({ users, loading: false });
    } catch (error) {
      set({ loading: false });
      throw error;
    }
  },
}));

// Converted to Redux Toolkit
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

// Async thunk for fetching users
export const fetchUsers = createAsyncThunk("users/fetchUsers", async () => {
  const response = await fetch("/api/users");
  return response.json();
});

const userSlice = createSlice({
  name: "users",
  initialState: {
    users: [],
    loading: false,
    error: null,
  },
  reducers: {
    addUser: (state, action) => {
      state.users.push(action.payload);
    },
    updateUser: (state, action) => {
      const { id, updates } = action.payload;
      const userIndex = state.users.findIndex((user) => user.id === id);
      if (userIndex !== -1) {
        Object.assign(state.users[userIndex], updates);
      }
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.users = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  },
});

export const { addUser, updateUser } = userSlice.actions;
export default userSlice.reducer;
```

**2. Component Migration from Zustand to Redux:**

```javascript
// Original Zustand component
const UserListZustand = () => {
  const { users, loading, addUser, updateUser, fetchUsers } = useUserStore();

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  const handleAddUser = () => {
    addUser({ id: Date.now(), name: "New User" });
  };

  return (
    <div>
      {loading
        ? "Loading..."
        : users.map((user) => (
            <div key={user.id}>
              {user.name}
              <button onClick={() => updateUser(user.id, { name: "Updated" })}>
                Update
              </button>
            </div>
          ))}
      <button onClick={handleAddUser}>Add User</button>
    </div>
  );
};

// Migrated Redux component
import { useSelector, useDispatch } from "react-redux";
import { addUser, updateUser, fetchUsers } from "./userSlice";

const UserListRedux = () => {
  const { users, loading, error } = useSelector((state) => state.users);
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(fetchUsers());
  }, [dispatch]);

  const handleAddUser = () => {
    dispatch(addUser({ id: Date.now(), name: "New User" }));
  };

  const handleUpdateUser = (id) => {
    dispatch(updateUser({ id, updates: { name: "Updated" } }));
  };

  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      {loading
        ? "Loading..."
        : users.map((user) => (
            <div key={user.id}>
              {user.name}
              <button onClick={() => handleUpdateUser(user.id)}>Update</button>
            </div>
          ))}
      <button onClick={handleAddUser}>Add User</button>
    </div>
  );
};
```

**Migration Best Practices:**

1. **Incremental Migration**: Migrate one feature/component at a time
2. **Maintain Parallel Implementations**: Run both systems during transition
3. **State Synchronization**: Use bridge components to sync state
4. **Testing**: Ensure functionality remains consistent
5. **Team Training**: Educate team on new patterns and conventions
6. **Documentation**: Update documentation and coding standards
7. **Performance Monitoring**: Monitor performance during and after migration

**Migration Checklist:**

- [ ] Identify migration scope and priorities
- [ ] Set up new state management alongside existing
- [ ] Create bridge components for state synchronization
- [ ] Migrate components incrementally
- [ ] Update tests and documentation
- [ ] Remove old state management code
- [ ] Performance testing and optimization
- [ ] Team training and knowledge transfer

---

### 17. How do you optimize performance in Redux and Zustand applications?

**Answer:**
Performance optimization in state management involves preventing unnecessary re-renders, optimizing selectors, and managing subscriptions efficiently.

**Redux Performance Optimization:**

**1. Memoized Selectors:**

```javascript
import { createSelector } from "@reduxjs/toolkit";

// Basic selectors
const selectUsers = (state) => state.users.items;
const selectFilters = (state) => state.users.filters;
const selectSearchTerm = (state) => state.users.searchTerm;

// Memoized selector to prevent unnecessary recalculations
export const selectFilteredUsers = createSelector(
  [selectUsers, selectFilters, selectSearchTerm],
  (users, filters, searchTerm) => {
    console.log("Filtering users..."); // This will only log when inputs change

    return users.filter((user) => {
      const matchesSearch = user.name
        .toLowerCase()
        .includes(searchTerm.toLowerCase());
      const matchesStatus =
        filters.status === "all" || user.status === filters.status;
      const matchesRole = filters.role === "all" || user.role === filters.role;

      return matchesSearch && matchesStatus && matchesRole;
    });
  }
);

// Parameterized selectors
export const selectUserById = createSelector(
  [selectUsers, (state, userId) => userId],
  (users, userId) => users.find((user) => user.id === userId)
);

// Complex derived state
export const selectUserStats = createSelector([selectUsers], (users) => ({
  total: users.length,
  active: users.filter((u) => u.status === "active").length,
  inactive: users.filter((u) => u.status === "inactive").length,
  byRole: users.reduce((acc, user) => {
    acc[user.role] = (acc[user.role] || 0) + 1;
    return acc;
  }, {}),
}));
```

**2. Component Optimization:**

```javascript
import React, { memo, useMemo } from "react";
import { useSelector, shallowEqual } from "react-redux";

// Optimized component with shallow equality check
const UserList = memo(() => {
  // Use shallowEqual to prevent unnecessary re-renders
  const { users, loading } = useSelector(
    (state) => ({
      users: selectFilteredUsers(state),
      loading: state.users.loading,
    }),
    shallowEqual
  );

  // Memoize expensive calculations
  const userStats = useMemo(() => {
    return users.reduce((stats, user) => {
      stats[user.role] = (stats[user.role] || 0) + 1;
      return stats;
    }, {});
  }, [users]);

  if (loading) return <div>Loading...</div>;

  return (
    <div>
      <div>Stats: {JSON.stringify(userStats)}</div>
      {users.map((user) => (
        <UserItem key={user.id} user={user} />
      ))}
    </div>
  );
});

// Optimized individual item component
const UserItem = memo(({ user }) => {
  const handleClick = useCallback(() => {
    // Handle user click
  }, [user.id]);

  return (
    <div onClick={handleClick}>
      {user.name} - {user.role}
    </div>
  );
});
```

**3. Redux Toolkit Query Optimization:**

```javascript
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

export const usersApi = createApi({
  reducerPath: "usersApi",
  baseQuery: fetchBaseQuery({ baseUrl: "/api/" }),
  tagTypes: ["User"],
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: (filters) => ({
        url: "users",
        params: filters,
      }),
      providesTags: ["User"],
      // Cache for 60 seconds
      keepUnusedDataFor: 60,
      // Transform response to normalize data
      transformResponse: (response) => {
        return response.users.map((user) => ({
          ...user,
          fullName: `${user.firstName} ${user.lastName}`,
        }));
      },
    }),

    getUserById: builder.query({
      query: (id) => `users/${id}`,
      providesTags: (result, error, id) => [{ type: "User", id }],
    }),
  }),
});

export const { useGetUsersQuery, useGetUserByIdQuery } = usersApi;
```

**Zustand Performance Optimization:**

**1. Selective Subscriptions:**

```javascript
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";

export const useAppStore = create(
  subscribeWithSelector((set, get) => ({
    users: [],
    filters: { status: "all", role: "all" },
    searchTerm: "",
    loading: false,

    setUsers: (users) => set({ users }),
    setFilters: (filters) => set({ filters }),
    setSearchTerm: (searchTerm) => set({ searchTerm }),
    setLoading: (loading) => set({ loading }),

    // Computed getters (not reactive)
    getFilteredUsers: () => {
      const { users, filters, searchTerm } = get();
      return users.filter((user) => {
        const matchesSearch = user.name
          .toLowerCase()
          .includes(searchTerm.toLowerCase());
        const matchesStatus =
          filters.status === "all" || user.status === filters.status;
        const matchesRole =
          filters.role === "all" || user.role === filters.role;
        return matchesSearch && matchesStatus && matchesRole;
      });
    },

    getUserById: (id) => {
      return get().users.find((user) => user.id === id);
    },
  }))
);

// Optimized component with selective subscriptions
const UserList = () => {
  // Only subscribe to specific parts of the state
  const users = useAppStore((state) => state.getFilteredUsers());
  const loading = useAppStore((state) => state.loading);

  // Memoize the filtered users to prevent recalculation
  const memoizedUsers = useMemo(() => users, [users]);

  if (loading) return <div>Loading...</div>;

  return (
    <div>
      {memoizedUsers.map((user) => (
        <UserItem key={user.id} userId={user.id} />
      ))}
    </div>
  );
};

// Component that only subscribes to specific user
const UserItem = memo(({ userId }) => {
  const user = useAppStore((state) => state.getUserById(userId));

  return (
    <div>
      {user?.name} - {user?.role}
    </div>
  );
});
```

**2. Computed State with Subscriptions:**

```javascript
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";

export const useOptimizedStore = create(
  subscribeWithSelector((set, get) => ({
    users: [],
    filters: { status: "all" },

    // Cached computed state
    _filteredUsers: [],
    _userStats: { total: 0, active: 0 },

    setUsers: (users) => {
      set({ users });
      // Trigger recomputation
      get()._recomputeFilteredUsers();
      get()._recomputeStats();
    },

    setFilters: (filters) => {
      set({ filters });
      get()._recomputeFilteredUsers();
    },

    _recomputeFilteredUsers: () => {
      const { users, filters } = get();
      const filtered = users.filter(
        (user) => filters.status === "all" || user.status === filters.status
      );
      set({ _filteredUsers: filtered });
    },

    _recomputeStats: () => {
      const { users } = get();
      const stats = {
        total: users.length,
        active: users.filter((u) => u.status === "active").length,
      };
      set({ _userStats: stats });
    },

    // Getters for cached computed state
    getFilteredUsers: () => get()._filteredUsers,
    getUserStats: () => get()._userStats,
  }))
);

// Usage with cached computed state
const OptimizedUserList = () => {
  const filteredUsers = useOptimizedStore((state) => state._filteredUsers);
  const stats = useOptimizedStore((state) => state._userStats);

  return (
    <div>
      <div>
        Total: {stats.total}, Active: {stats.active}
      </div>
      {filteredUsers.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
};
```

**3. External Store Pattern for Heavy Computations:**

```javascript
import { useSyncExternalStore } from "react";

class UserStoreManager {
  constructor() {
    this.users = [];
    this.filters = { status: "all" };
    this.listeners = new Set();
    this._filteredUsers = [];
  }

  subscribe = (listener) => {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  };

  getSnapshot = () => {
    return {
      users: this.users,
      filteredUsers: this._filteredUsers,
      filters: this.filters,
    };
  };

  setUsers = (users) => {
    this.users = users;
    this._recomputeFilteredUsers();
    this._notify();
  };

  setFilters = (filters) => {
    this.filters = filters;
    this._recomputeFilteredUsers();
    this._notify();
  };

  _recomputeFilteredUsers = () => {
    this._filteredUsers = this.users.filter(
      (user) =>
        this.filters.status === "all" || user.status === this.filters.status
    );
  };

  _notify = () => {
    this.listeners.forEach((listener) => listener());
  };
}

const userStoreManager = new UserStoreManager();

// Hook to use the external store
const useUserStoreManager = () => {
  return useSyncExternalStore(
    userStoreManager.subscribe,
    userStoreManager.getSnapshot
  );
};

// Component using external store
const ExternalStoreUserList = () => {
  const { filteredUsers } = useUserStoreManager();

  return (
    <div>
      {filteredUsers.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
};
```

**Performance Best Practices:**

**Redux:**

1. Use `createSelector` for memoized derived state
2. Implement `shallowEqual` for object comparisons
3. Normalize state structure to avoid deep nesting
4. Use RTK Query for efficient data fetching and caching
5. Split large reducers into smaller, focused ones

**Zustand:**

1. Use selective subscriptions to minimize re-renders
2. Implement computed getters for derived state
3. Use `subscribeWithSelector` for granular updates
4. Cache expensive computations in the store
5. Consider external stores for heavy computational logic

**Common Optimizations:**

1. Memoize components with `React.memo`
2. Use `useMemo` and `useCallback` appropriately
3. Implement virtualization for large lists
4. Debounce frequent state updates
5. Profile and measure performance regularly

---

### 18. How do you implement TypeScript with Redux and Zustand?

**Answer:**
Both Redux and Zustand provide excellent TypeScript support, but with different approaches to type safety and inference.

**Redux with TypeScript:**

**1. Redux Toolkit with TypeScript:**

```typescript
import { createSlice, PayloadAction, configureStore } from "@reduxjs/toolkit";

// Define types for state
interface User {
  id: string;
  name: string;
  email: string;
  role: "admin" | "user" | "moderator";
  status: "active" | "inactive";
}

interface UserState {
  users: User[];
  loading: boolean;
  error: string | null;
  selectedUserId: string | null;
}

// Initial state with proper typing
const initialState: UserState = {
  users: [],
  loading: false,
  error: null,
  selectedUserId: null,
};

// Create slice with typed actions
const userSlice = createSlice({
  name: "users",
  initialState,
  reducers: {
    setLoading: (state, action: PayloadAction<boolean>) => {
      state.loading = action.payload;
    },
    setError: (state, action: PayloadAction<string | null>) => {
      state.error = action.payload;
    },
    setUsers: (state, action: PayloadAction<User[]>) => {
      state.users = action.payload;
    },
    addUser: (state, action: PayloadAction<User>) => {
      state.users.push(action.payload);
    },
    updateUser: (
      state,
      action: PayloadAction<{ id: string; updates: Partial<User> }>
    ) => {
      const { id, updates } = action.payload;
      const userIndex = state.users.findIndex((user) => user.id === id);
      if (userIndex !== -1) {
        Object.assign(state.users[userIndex], updates);
      }
    },
    removeUser: (state, action: PayloadAction<string>) => {
      state.users = state.users.filter((user) => user.id !== action.payload);
    },
    setSelectedUser: (state, action: PayloadAction<string | null>) => {
      state.selectedUserId = action.payload;
    },
  },
});

export const {
  setLoading,
  setError,
  setUsers,
  addUser,
  updateUser,
  removeUser,
  setSelectedUser,
} = userSlice.actions;

export default userSlice.reducer;

// Store configuration with proper typing
export const store = configureStore({
  reducer: {
    users: userSlice.reducer,
  },
});

// Infer types from store
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

**2. Typed Hooks:**

```typescript
import { TypedUseSelectorHook, useDispatch, useSelector } from "react-redux";
import type { RootState, AppDispatch } from "./store";

// Typed hooks for better developer experience
export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

// Typed selectors
import { createSelector } from "@reduxjs/toolkit";

const selectUserState = (state: RootState) => state.users;

export const selectAllUsers = createSelector(
  [selectUserState],
  (userState) => userState.users
);

export const selectUserById = createSelector(
  [selectAllUsers, (state: RootState, userId: string) => userId],
  (users, userId) => users.find((user) => user.id === userId)
);

export const selectUsersByRole = createSelector(
  [selectAllUsers, (state: RootState, role: User["role"]) => role],
  (users, role) => users.filter((user) => user.role === role)
);

export const selectActiveUsers = createSelector([selectAllUsers], (users) =>
  users.filter((user) => user.status === "active")
);
```

**3. Async Thunks with TypeScript:**

```typescript
import { createAsyncThunk } from "@reduxjs/toolkit";

// API response types
interface ApiResponse<T> {
  data: T;
  message: string;
  success: boolean;
}

interface CreateUserRequest {
  name: string;
  email: string;
  role: User["role"];
}

// Typed async thunks
export const fetchUsers = createAsyncThunk<
  User[], // Return type
  void, // Argument type
  { rejectValue: string } // ThunkAPI config
>("users/fetchUsers", async (_, { rejectWithValue }) => {
  try {
    const response = await fetch("/api/users");
    if (!response.ok) {
      throw new Error("Failed to fetch users");
    }
    const result: ApiResponse<User[]> = await response.json();
    return result.data;
  } catch (error) {
    return rejectWithValue(
      error instanceof Error ? error.message : "Unknown error"
    );
  }
});

export const createUser = createAsyncThunk<
  User,
  CreateUserRequest,
  { rejectValue: string }
>("users/createUser", async (userData, { rejectWithValue }) => {
  try {
    const response = await fetch("/api/users", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(userData),
    });

    if (!response.ok) {
      throw new Error("Failed to create user");
    }

    const result: ApiResponse<User> = await response.json();
    return result.data;
  } catch (error) {
    return rejectWithValue(
      error instanceof Error ? error.message : "Unknown error"
    );
  }
});

// Add extra reducers to handle async actions
const userSliceWithAsync = createSlice({
  name: "users",
  initialState,
  reducers: {
    // ... existing reducers
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.users = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || "Failed to fetch users";
      })
      .addCase(createUser.fulfilled, (state, action) => {
        state.users.push(action.payload);
      });
  },
});
```

**Zustand with TypeScript:**

**1. Basic Zustand Store with TypeScript:**

```typescript
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

// Define the store state interface
interface UserState {
  users: User[];
  loading: boolean;
  error: string | null;
  selectedUserId: string | null;
}

// Define the store actions interface
interface UserActions {
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  setUsers: (users: User[]) => void;
  addUser: (user: User) => void;
  updateUser: (id: string, updates: Partial<User>) => void;
  removeUser: (id: string) => void;
  setSelectedUser: (userId: string | null) => void;
  fetchUsers: () => Promise<void>;
  createUser: (userData: CreateUserRequest) => Promise<User>;
  getUserById: (id: string) => User | undefined;
  getUsersByRole: (role: User['role']) => User[];
  getActiveUsers: () => User[];
  reset: () => void;
}

// Combine state and actions
type UserStore = UserState & UserActions;

// Create the store with full type safety
export const useUserStore = create<UserStore>()()
  devtools(
    persist(
      immer((set, get) => ({
        // Initial state
        users: [],
        loading: false,
        error: null,
        selectedUserId: null,

        // Actions
        setLoading: (loading) => set((state) => {
          state.loading = loading;
        }),

        setError: (error) => set((state) => {
          state.error = error;
        }),

        setUsers: (users) => set((state) => {
          state.users = users;
        }),

        addUser: (user) => set((state) => {
          state.users.push(user);
        }),

        updateUser: (id, updates) => set((state) => {
          const userIndex = state.users.findIndex(user => user.id === id);
          if (userIndex !== -1) {
            Object.assign(state.users[userIndex], updates);
          }
        }),

        removeUser: (id) => set((state) => {
          state.users = state.users.filter(user => user.id !== id);
        }),

        setSelectedUser: (userId) => set((state) => {
          state.selectedUserId = userId;
        }),

        // Async actions
        fetchUsers: async () => {
          set((state) => {
            state.loading = true;
            state.error = null;
          });

          try {
            const response = await fetch('/api/users');
            if (!response.ok) {
              throw new Error('Failed to fetch users');
            }
            const result: ApiResponse<User[]> = await response.json();

            set((state) => {
              state.users = result.data;
              state.loading = false;
            });
          } catch (error) {
            set((state) => {
              state.loading = false;
              state.error = error instanceof Error ? error.message : 'Unknown error';
            });
          }
        },

        createUser: async (userData) => {
          const response = await fetch('/api/users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(userData)
          });

          if (!response.ok) {
            throw new Error('Failed to create user');
          }

          const result: ApiResponse<User> = await response.json();

          set((state) => {
            state.users.push(result.data);
          });

          return result.data;
        },

        // Computed getters
        getUserById: (id) => {
          return get().users.find(user => user.id === id);
        },

        getUsersByRole: (role) => {
          return get().users.filter(user => user.role === role);
        },

        getActiveUsers: () => {
          return get().users.filter(user => user.status === 'active');
        },

        reset: () => set((state) => {
          state.users = [];
          state.loading = false;
          state.error = null;
          state.selectedUserId = null;
        })
      })),
      {
        name: 'user-store',
        partialize: (state) => ({
          users: state.users,
          selectedUserId: state.selectedUserId
        })
      }
    ),
    { name: 'user-store' }
  )
);
```

**2. Zustand with Slices Pattern:**

```typescript
// Define slice interfaces
interface UserSlice {
  users: User[];
  addUser: (user: User) => void;
  updateUser: (id: string, updates: Partial<User>) => void;
  removeUser: (id: string) => void;
  getUserById: (id: string) => User | undefined;
}

interface UISlice {
  loading: boolean;
  error: string | null;
  selectedUserId: string | null;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  setSelectedUser: (userId: string | null) => void;
}

// Create slice creators
const createUserSlice = (set: any, get: any): UserSlice => ({
  users: [],

  addUser: (user) => set((state: any) => {
    state.users.push(user);
  }),

  updateUser: (id, updates) => set((state: any) => {
    const userIndex = state.users.findIndex((user: User) => user.id === id);
    if (userIndex !== -1) {
      Object.assign(state.users[userIndex], updates);
    }
  }),

  removeUser: (id) => set((state: any) => {
    state.users = state.users.filter((user: User) => user.id !== id);
  }),

  getUserById: (id) => {
    return get().users.find((user: User) => user.id === id);
  }
});

const createUISlice = (set: any, get: any): UISlice => ({
  loading: false,
  error: null,
  selectedUserId: null,

  setLoading: (loading) => set((state: any) => {
    state.loading = loading;
  }),

  setError: (error) => set((state: any) => {
    state.error = error;
  }),

  setSelectedUser: (userId) => set((state: any) => {
    state.selectedUserId = userId;
  })
});

// Combine slices
type StoreState = UserSlice & UISlice;

export const useAppStore = create<StoreState>()()
  immer((set, get) => ({
    ...createUserSlice(set, get),
    ...createUISlice(set, get)
  }))
);
```

**3. Component Usage with TypeScript:**

```typescript
import React, { useEffect } from "react";
import { useUserStore } from "./store";

// Redux component
const ReduxUserList: React.FC = () => {
  const users = useAppSelector(selectAllUsers);
  const loading = useAppSelector((state) => state.users.loading);
  const error = useAppSelector((state) => state.users.error);
  const dispatch = useAppDispatch();

  useEffect(() => {
    dispatch(fetchUsers());
  }, [dispatch]);

  const handleCreateUser = async () => {
    try {
      await dispatch(
        createUser({
          name: "New User",
          email: "user@example.com",
          role: "user",
        })
      ).unwrap();
    } catch (error) {
      console.error("Failed to create user:", error);
    }
  };

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      {users.map((user) => (
        <div key={user.id}>
          {user.name} - {user.role}
        </div>
      ))}
      <button onClick={handleCreateUser}>Add User</button>
    </div>
  );
};

// Zustand component
const ZustandUserList: React.FC = () => {
  const { users, loading, error, fetchUsers, createUser } = useUserStore();

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  const handleCreateUser = async () => {
    try {
      await createUser({
        name: "New User",
        email: "user@example.com",
        role: "user",
      });
    } catch (error) {
      console.error("Failed to create user:", error);
    }
  };

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      {users.map((user) => (
        <div key={user.id}>
          {user.name} - {user.role}
        </div>
      ))}
      <button onClick={handleCreateUser}>Add User</button>
    </div>
  );
};
```

**TypeScript Benefits:**

**Redux:**

- Strong typing for actions and state
- Excellent IDE support with autocompletion
- Type-safe selectors and thunks
- Compile-time error detection

**Zustand:**

- Simpler type definitions
- Better inference for store methods
- Less boilerplate for TypeScript setup
- Flexible typing for complex state patterns

Both approaches provide excellent TypeScript support, with Redux offering more structured typing patterns and Zustand providing more flexibility with less boilerplate.

---

### 19. How do you handle error boundaries and error handling in Redux vs Zustand?

**Answer:**
Error handling strategies differ between Redux and Zustand, with each offering different approaches to manage and recover from errors.

**Redux Error Handling:**

**1. Error Handling in Async Thunks:**

```typescript
import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";

// Custom error types
interface ApiError {
  message: string;
  code: string;
  details?: any;
}

interface ErrorState {
  global: ApiError | null;
  user: ApiError | null;
  network: boolean;
}

interface AppState {
  users: User[];
  loading: boolean;
  errors: ErrorState;
}

const initialState: AppState = {
  users: [],
  loading: false,
  errors: {
    global: null,
    user: null,
    network: false,
  },
};

// Enhanced async thunk with comprehensive error handling
export const fetchUsersWithErrorHandling = createAsyncThunk<
  User[],
  void,
  { rejectValue: ApiError }
>(
  "users/fetchUsersWithErrorHandling",
  async (_, { rejectWithValue, dispatch }) => {
    try {
      const response = await fetch("/api/users", {
        timeout: 10000, // 10 second timeout
      });

      if (!response.ok) {
        // Handle different HTTP status codes
        switch (response.status) {
          case 401:
            dispatch(clearAuthToken());
            throw new Error("Authentication required");
          case 403:
            throw new Error("Access forbidden");
          case 404:
            throw new Error("Users not found");
          case 500:
            throw new Error("Server error");
          default:
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
      }

      const data = await response.json();

      // Validate response data
      if (!Array.isArray(data.users)) {
        throw new Error("Invalid response format");
      }

      return data.users;
    } catch (error) {
      // Categorize errors
      if (error instanceof TypeError && error.message.includes("fetch")) {
        return rejectWithValue({
          message: "Network connection failed",
          code: "NETWORK_ERROR",
          details: error.message,
        });
      }

      if (error.name === "AbortError") {
        return rejectWithValue({
          message: "Request timeout",
          code: "TIMEOUT_ERROR",
        });
      }

      return rejectWithValue({
        message: error instanceof Error ? error.message : "Unknown error",
        code: "API_ERROR",
        details: error,
      });
    }
  }
);

// Error handling slice
const appSlice = createSlice({
  name: "app",
  initialState,
  reducers: {
    clearError: (state, action) => {
      const errorType = action.payload;
      if (errorType && state.errors[errorType]) {
        state.errors[errorType] = null;
      } else {
        // Clear all errors
        state.errors = {
          global: null,
          user: null,
          network: false,
        };
      }
    },
    setGlobalError: (state, action) => {
      state.errors.global = action.payload;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsersWithErrorHandling.pending, (state) => {
        state.loading = true;
        state.errors.user = null;
        state.errors.network = false;
      })
      .addCase(fetchUsersWithErrorHandling.fulfilled, (state, action) => {
        state.loading = false;
        state.users = action.payload;
        state.errors.user = null;
      })
      .addCase(fetchUsersWithErrorHandling.rejected, (state, action) => {
        state.loading = false;

        if (action.payload) {
          if (action.payload.code === "NETWORK_ERROR") {
            state.errors.network = true;
          } else {
            state.errors.user = action.payload;
          }
        } else {
          state.errors.global = {
            message: "An unexpected error occurred",
            code: "UNKNOWN_ERROR",
          };
        }
      });
  },
});

export const { clearError, setGlobalError } = appSlice.actions;
```

**2. Redux Error Boundary Integration:**

```typescript
import React, { Component, ErrorInfo, ReactNode } from "react";
import { connect } from "react-redux";
import { setGlobalError } from "./store/appSlice";

interface Props {
  children: ReactNode;
  setGlobalError: (error: ApiError) => void;
}

interface State {
  hasError: boolean;
}

class ReduxErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(_: Error): State {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Redux Error Boundary caught an error:", error, errorInfo);

    // Dispatch error to Redux store
    this.props.setGlobalError({
      message: error.message,
      code: "COMPONENT_ERROR",
      details: {
        stack: error.stack,
        componentStack: errorInfo.componentStack,
      },
    });
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-fallback">
          <h2>Something went wrong</h2>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

export default connect(null, { setGlobalError })(ReduxErrorBoundary);
```

**3. Redux Error Display Component:**

```typescript
import React from "react";
import { useSelector, useDispatch } from "react-redux";
import { clearError } from "./store/appSlice";

const ErrorDisplay: React.FC = () => {
  const errors = useSelector((state: RootState) => state.app.errors);
  const dispatch = useDispatch();

  const handleDismiss = (errorType: string) => {
    dispatch(clearError(errorType));
  };

  const handleRetry = () => {
    dispatch(clearError());
    // Retry failed operations
    dispatch(fetchUsersWithErrorHandling());
  };

  if (errors.network) {
    return (
      <div className="error-banner network-error">
        <span>Network connection lost</span>
        <button onClick={handleRetry}>Retry</button>
      </div>
    );
  }

  if (errors.global) {
    return (
      <div className="error-banner global-error">
        <span>{errors.global.message}</span>
        <button onClick={() => handleDismiss("global")}>Dismiss</button>
      </div>
    );
  }

  if (errors.user) {
    return (
      <div className="error-banner user-error">
        <span>{errors.user.message}</span>
        <button onClick={() => handleDismiss("user")}>Dismiss</button>
      </div>
    );
  }

  return null;
};

export default ErrorDisplay;
```

**Zustand Error Handling:**

**1. Zustand Store with Error Handling:**

```typescript
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

interface ErrorState {
  global: ApiError | null;
  user: ApiError | null;
  network: boolean;
}

interface AppState {
  users: User[];
  loading: boolean;
  errors: ErrorState;
}

interface AppActions {
  fetchUsers: () => Promise<void>;
  clearError: (errorType?: keyof ErrorState) => void;
  setGlobalError: (error: ApiError) => void;
  handleError: (error: unknown, context: string) => void;
  retryFailedOperations: () => Promise<void>;
}

type AppStore = AppState & AppActions;

export const useAppStore = create<AppStore>()()
  devtools(
    immer((set, get) => ({
      // Initial state
      users: [],
      loading: false,
      errors: {
        global: null,
        user: null,
        network: false
      },

      // Error handling utilities
      handleError: (error: unknown, context: string) => {
        console.error(`Error in ${context}:`, error);

        set((state) => {
          if (error instanceof TypeError && error.message.includes('fetch')) {
            state.errors.network = true;
          } else if (error instanceof Error) {
            if (context === 'user') {
              state.errors.user = {
                message: error.message,
                code: 'USER_ERROR',
                details: { context }
              };
            } else {
              state.errors.global = {
                message: error.message,
                code: 'GLOBAL_ERROR',
                details: { context }
              };
            }
          } else {
            state.errors.global = {
              message: 'An unexpected error occurred',
              code: 'UNKNOWN_ERROR',
              details: { context, error }
            };
          }
        });
      },

      clearError: (errorType) => set((state) => {
        if (errorType) {
          state.errors[errorType] = errorType === 'network' ? false : null;
        } else {
          state.errors = {
            global: null,
            user: null,
            network: false
          };
        }
      }),

      setGlobalError: (error) => set((state) => {
        state.errors.global = error;
      }),

      // Async operations with error handling
      fetchUsers: async () => {
        const { handleError } = get();

        set((state) => {
          state.loading = true;
          state.errors.user = null;
          state.errors.network = false;
        });

        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 10000);

          const response = await fetch('/api/users', {
            signal: controller.signal
          });

          clearTimeout(timeoutId);

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const data = await response.json();

          if (!Array.isArray(data.users)) {
            throw new Error('Invalid response format');
          }

          set((state) => {
            state.users = data.users;
            state.loading = false;
          });
        } catch (error) {
          set((state) => {
            state.loading = false;
          });
          handleError(error, 'user');
        }
      },

      retryFailedOperations: async () => {
        const { fetchUsers, clearError } = get();
        clearError();
        await fetchUsers();
      }
    })),
    { name: 'app-store' }
  )
);
```

**2. Zustand Error Boundary:**

```typescript
import React, { Component, ErrorInfo, ReactNode } from "react";
import { useAppStore } from "./store";

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
}

class ZustandErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(_: Error): State {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Zustand Error Boundary caught an error:", error, errorInfo);

    // Access Zustand store directly
    const { setGlobalError } = useAppStore.getState();
    setGlobalError({
      message: error.message,
      code: "COMPONENT_ERROR",
      details: {
        stack: error.stack,
        componentStack: errorInfo.componentStack,
      },
    });
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-fallback">
          <h2>Something went wrong</h2>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ZustandErrorBoundary;
```

**3. Zustand Error Display Hook:**

```typescript
import { useEffect } from "react";
import { useAppStore } from "./store";

export const useErrorHandler = () => {
  const { errors, clearError, retryFailedOperations } = useAppStore();

  // Auto-clear network errors after connection is restored
  useEffect(() => {
    if (errors.network) {
      const checkConnection = async () => {
        try {
          await fetch("/api/health", { method: "HEAD" });
          clearError("network");
        } catch {
          // Still offline, check again in 5 seconds
          setTimeout(checkConnection, 5000);
        }
      };

      const timeoutId = setTimeout(checkConnection, 2000);
      return () => clearTimeout(timeoutId);
    }
  }, [errors.network, clearError]);

  return {
    errors,
    clearError,
    retryFailedOperations,
    hasErrors: errors.global || errors.user || errors.network,
  };
};

// Error display component
const ZustandErrorDisplay: React.FC = () => {
  const { errors, clearError, retryFailedOperations } = useErrorHandler();

  if (errors.network) {
    return (
      <div className="error-banner network-error">
        <span>Network connection lost</span>
        <button onClick={retryFailedOperations}>Retry</button>
      </div>
    );
  }

  if (errors.global) {
    return (
      <div className="error-banner global-error">
        <span>{errors.global.message}</span>
        <button onClick={() => clearError("global")}>Dismiss</button>
      </div>
    );
  }

  if (errors.user) {
    return (
      <div className="error-banner user-error">
        <span>{errors.user.message}</span>
        <button onClick={() => clearError("user")}>Dismiss</button>
      </div>
    );
  }

  return null;
};

export default ZustandErrorDisplay;
```

**Error Handling Comparison:**

**Redux:**

- Structured error handling through reducers
- Centralized error state management
- Built-in support for async error handling
- Integration with Redux DevTools for debugging

**Zustand:**

- More flexible error handling patterns
- Direct store access from error boundaries
- Simpler error state updates
- Custom hooks for error management

**Best Practices:**

1. Categorize errors by type and severity
2. Provide user-friendly error messages
3. Implement retry mechanisms for transient errors
4. Log errors for debugging and monitoring
5. Use error boundaries to catch component errors
6. Handle network errors gracefully
7. Provide fallback UI for critical errors

---

### 20. What are the advanced patterns and real-world use cases for Redux vs Zustand?

**Answer:**
Both Redux and Zustand support advanced patterns for complex applications, but they approach them differently.

**Redux Advanced Patterns:**

**1. Entity Normalization with RTK Query:**

```typescript
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";
import { createEntityAdapter, createSlice } from "@reduxjs/toolkit";

// Entity adapter for normalized state
const usersAdapter = createEntityAdapter<User>({
  selectId: (user) => user.id,
  sortComparer: (a, b) => a.name.localeCompare(b.name),
});

// RTK Query API
export const apiSlice = createApi({
  reducerPath: "api",
  baseQuery: fetchBaseQuery({
    baseUrl: "/api",
    prepareHeaders: (headers, { getState }) => {
      const token = (getState() as RootState).auth.token;
      if (token) {
        headers.set("authorization", `Bearer ${token}`);
      }
      return headers;
    },
  }),
  tagTypes: ["User", "Post", "Comment"],
  endpoints: (builder) => ({
    getUsers: builder.query<User[], void>({
      query: () => "/users",
      providesTags: ["User"],
      transformResponse: (response: { users: User[] }) => response.users,
    }),
    getUserById: builder.query<User, string>({
      query: (id) => `/users/${id}`,
      providesTags: (result, error, id) => [{ type: "User", id }],
    }),
    updateUser: builder.mutation<User, { id: string; updates: Partial<User> }>({
      query: ({ id, updates }) => ({
        url: `/users/${id}`,
        method: "PATCH",
        body: updates,
      }),
      invalidatesTags: (result, error, { id }) => [{ type: "User", id }],
    }),
    getUserPosts: builder.query<Post[], string>({
      query: (userId) => `/users/${userId}/posts`,
      providesTags: (result, error, userId) =>
        result
          ? [...result.map(({ id }) => ({ type: "Post" as const, id })), "Post"]
          : ["Post"],
    }),
  }),
});

export const {
  useGetUsersQuery,
  useGetUserByIdQuery,
  useUpdateUserMutation,
  useGetUserPostsQuery,
} = apiSlice;
```

**2. Advanced Middleware Chain:**

```typescript
import { configureStore, createListenerMiddleware } from "@reduxjs/toolkit";
import { persistStore, persistReducer } from "redux-persist";
import storage from "redux-persist/lib/storage";

// Custom middleware for analytics
const analyticsMiddleware: Middleware = (store) => (next) => (action) => {
  // Track user actions
  if (action.type.startsWith("user/")) {
    analytics.track("User Action", {
      action: action.type,
      payload: action.payload,
      timestamp: Date.now(),
    });
  }
  return next(action);
};

// Listener middleware for side effects
const listenerMiddleware = createListenerMiddleware();

// Listen for user updates and sync with external services
listenerMiddleware.startListening({
  actionCreator: updateUser,
  effect: async (action, listenerApi) => {
    const { id, updates } = action.payload;

    // Sync with external CRM
    try {
      await syncWithCRM(id, updates);
    } catch (error) {
      console.error("Failed to sync with CRM:", error);
      // Optionally dispatch a compensation action
      listenerApi.dispatch(
        setCrmSyncError({ userId: id, error: error.message })
      );
    }

    // Update search index
    await updateSearchIndex(id, updates);
  },
});

// Persist configuration
const persistConfig = {
  key: "root",
  storage,
  whitelist: ["user", "preferences"],
  transforms: [
    // Custom transform to encrypt sensitive data
    createTransform(
      (inboundState: any) => {
        return {
          ...inboundState,
          sensitiveData: encrypt(inboundState.sensitiveData),
        };
      },
      (outboundState: any) => {
        return {
          ...outboundState,
          sensitiveData: decrypt(outboundState.sensitiveData),
        };
      },
      { whitelist: ["user"] }
    ),
  ],
};

const persistedReducer = persistReducer(persistConfig, rootReducer);

export const store = configureStore({
  reducer: persistedReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],
      },
    })
      .concat(apiSlice.middleware)
      .concat(analyticsMiddleware)
      .concat(listenerMiddleware.middleware),
  devTools: process.env.NODE_ENV !== "production",
});

export const persistor = persistStore(store);
```

**3. Feature-Based Architecture:**

```typescript
// features/user/userSlice.ts
export const userSlice = createSlice({
  name: "user",
  initialState: usersAdapter.getInitialState({
    loading: false,
    error: null,
    filters: {
      role: null,
      status: null,
      search: "",
    },
    pagination: {
      page: 1,
      limit: 10,
      total: 0,
    },
  }),
  reducers: {
    setFilters: (state, action) => {
      state.filters = { ...state.filters, ...action.payload };
      state.pagination.page = 1; // Reset to first page
    },
    setPagination: (state, action) => {
      state.pagination = { ...state.pagination, ...action.payload };
    },
  },
  extraReducers: (builder) => {
    builder
      .addMatcher(
        apiSlice.endpoints.getUsers.matchFulfilled,
        (state, action) => {
          usersAdapter.setAll(state, action.payload);
          state.loading = false;
        }
      )
      .addMatcher(
        apiSlice.endpoints.updateUser.matchFulfilled,
        (state, action) => {
          usersAdapter.updateOne(state, {
            id: action.payload.id,
            changes: action.payload,
          });
        }
      );
  },
});

// Selectors with memoization
export const {
  selectAll: selectAllUsers,
  selectById: selectUserById,
  selectIds: selectUserIds,
} = usersAdapter.getSelectors((state: RootState) => state.user);

export const selectFilteredUsers = createSelector(
  [selectAllUsers, (state: RootState) => state.user.filters],
  (users, filters) => {
    return users.filter((user) => {
      if (filters.role && user.role !== filters.role) return false;
      if (filters.status && user.status !== filters.status) return false;
      if (
        filters.search &&
        !user.name.toLowerCase().includes(filters.search.toLowerCase())
      )
        return false;
      return true;
    });
  }
);

export const selectPaginatedUsers = createSelector(
  [selectFilteredUsers, (state: RootState) => state.user.pagination],
  (users, pagination) => {
    const start = (pagination.page - 1) * pagination.limit;
    const end = start + pagination.limit;
    return users.slice(start, end);
  }
);
```

**Zustand Advanced Patterns:**

**1. Modular Store with Subscriptions:**

```typescript
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

// Modular store slices
interface UserSlice {
  users: Map<string, User>;
  userActions: {
    addUser: (user: User) => void;
    updateUser: (id: string, updates: Partial<User>) => void;
    removeUser: (id: string) => void;
    getUserById: (id: string) => User | undefined;
    getUsersByRole: (role: string) => User[];
  };
}

interface NotificationSlice {
  notifications: Notification[];
  notificationActions: {
    addNotification: (notification: Omit<Notification, 'id'>) => void;
    removeNotification: (id: string) => void;
    markAsRead: (id: string) => void;
    clearAll: () => void;
  };
}

interface AnalyticsSlice {
  events: AnalyticsEvent[];
  analyticsActions: {
    trackEvent: (event: Omit<AnalyticsEvent, 'id' | 'timestamp'>) => void;
    getEventsByType: (type: string) => AnalyticsEvent[];
    clearEvents: () => void;
  };
}

type AppStore = UserSlice & NotificationSlice & AnalyticsSlice;

// Create modular store with subscriptions
export const useAppStore = create<AppStore>()()
  subscribeWithSelector(
    immer((set, get) => ({
      // User slice
      users: new Map(),
      userActions: {
        addUser: (user) => set((state) => {
          state.users.set(user.id, user);
          // Trigger analytics
          state.analyticsActions.trackEvent({
            type: 'user_added',
            data: { userId: user.id, role: user.role }
          });
        }),

        updateUser: (id, updates) => set((state) => {
          const user = state.users.get(id);
          if (user) {
            state.users.set(id, { ...user, ...updates });
            // Trigger notification
            state.notificationActions.addNotification({
              type: 'success',
              message: `User ${user.name} updated successfully`,
              duration: 3000
            });
          }
        }),

        removeUser: (id) => set((state) => {
          const user = state.users.get(id);
          if (user) {
            state.users.delete(id);
            state.analyticsActions.trackEvent({
              type: 'user_removed',
              data: { userId: id, role: user.role }
            });
          }
        }),

        getUserById: (id) => get().users.get(id),

        getUsersByRole: (role) => {
          return Array.from(get().users.values()).filter(user => user.role === role);
        }
      },

      // Notification slice
      notifications: [],
      notificationActions: {
        addNotification: (notification) => set((state) => {
          const newNotification = {
            ...notification,
            id: crypto.randomUUID(),
            timestamp: Date.now(),
            read: false
          };
          state.notifications.push(newNotification);

          // Auto-remove after duration
          if (notification.duration) {
            setTimeout(() => {
              get().notificationActions.removeNotification(newNotification.id);
            }, notification.duration);
          }
        }),

        removeNotification: (id) => set((state) => {
          state.notifications = state.notifications.filter(n => n.id !== id);
        }),

        markAsRead: (id) => set((state) => {
          const notification = state.notifications.find(n => n.id === id);
          if (notification) {
            notification.read = true;
          }
        }),

        clearAll: () => set((state) => {
          state.notifications = [];
        })
      },

      // Analytics slice
      events: [],
      analyticsActions: {
        trackEvent: (event) => set((state) => {
          state.events.push({
            ...event,
            id: crypto.randomUUID(),
            timestamp: Date.now()
          });

          // Keep only last 1000 events
          if (state.events.length > 1000) {
            state.events = state.events.slice(-1000);
          }
        }),

        getEventsByType: (type) => {
          return get().events.filter(event => event.type === type);
        },

        clearEvents: () => set((state) => {
          state.events = [];
        })
      }
    }))
  )
);

// Subscribe to user changes for external sync
useAppStore.subscribe(
  (state) => state.users,
  (users, prevUsers) => {
    // Sync with external services when users change
    const changedUsers = Array.from(users.entries()).filter(
      ([id, user]) => {
        const prevUser = prevUsers.get(id);
        return !prevUser || JSON.stringify(user) !== JSON.stringify(prevUser);
      }
    );

    changedUsers.forEach(([id, user]) => {
      syncUserWithExternalService(user);
    });
  },
  { equalityFn: (a, b) => a.size === b.size }
);

// Subscribe to analytics events for batching
let eventBatch: AnalyticsEvent[] = [];
useAppStore.subscribe(
  (state) => state.events,
  (events) => {
    const newEvents = events.slice(eventBatch.length);
    eventBatch.push(...newEvents);

    // Batch send every 10 events or 30 seconds
    if (eventBatch.length >= 10) {
      sendAnalyticsBatch(eventBatch);
      eventBatch = [];
    }
  }
);

// Periodic batch send
setInterval(() => {
  if (eventBatch.length > 0) {
    sendAnalyticsBatch(eventBatch);
    eventBatch = [];
  }
}, 30000);
```

**2. Advanced Persistence and Hydration:**

```typescript
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

// Custom storage with encryption
const encryptedStorage = {
  getItem: async (name: string) => {
    const encrypted = localStorage.getItem(name);
    if (!encrypted) return null;
    try {
      return decrypt(encrypted);
    } catch {
      return null;
    }
  },
  setItem: async (name: string, value: string) => {
    const encrypted = encrypt(value);
    localStorage.setItem(name, encrypted);
  },
  removeItem: async (name: string) => {
    localStorage.removeItem(name);
  }
};

// Store with advanced persistence
export const usePersistedStore = create<AppState>()()
  persist(
    (set, get) => ({
      // Store implementation
      user: null,
      preferences: defaultPreferences,
      cache: new Map(),

      setUser: (user) => set({ user }),
      updatePreferences: (updates) => set((state) => ({
        preferences: { ...state.preferences, ...updates }
      })),

      // Cache management
      setCache: (key, value, ttl = 300000) => set((state) => {
        const newCache = new Map(state.cache);
        newCache.set(key, {
          value,
          expires: Date.now() + ttl
        });
        return { cache: newCache };
      }),

      getCache: (key) => {
        const cached = get().cache.get(key);
        if (!cached || cached.expires < Date.now()) {
          return null;
        }
        return cached.value;
      },

      clearExpiredCache: () => set((state) => {
        const newCache = new Map();
        const now = Date.now();

        for (const [key, value] of state.cache) {
          if (value.expires > now) {
            newCache.set(key, value);
          }
        }

        return { cache: newCache };
      })
    }),
    {
      name: 'app-storage',
      storage: createJSONStorage(() => encryptedStorage),
      partialize: (state) => ({
        user: state.user,
        preferences: state.preferences
        // Exclude cache from persistence
      }),
      onRehydrateStorage: () => (state) => {
        if (state) {
          // Initialize cache as Map after rehydration
          state.cache = new Map();
          // Clear expired cache on startup
          state.clearExpiredCache();
        }
      },
      migrate: (persistedState: any, version: number) => {
        // Handle migration between versions
        if (version === 0) {
          // Migrate from version 0 to 1
          return {
            ...persistedState,
            preferences: {
              ...defaultPreferences,
              ...persistedState.preferences
            }
          };
        }
        return persistedState;
      },
      version: 1
    }
  )
);
```

**Real-World Use Cases:**

**Redux Best For:**

- Large enterprise applications with complex state
- Applications requiring strict state management patterns
- Teams needing predictable state updates
- Applications with extensive debugging requirements
- Complex async operations with caching
- Applications requiring time-travel debugging

**Zustand Best For:**

- Medium-sized applications with moderate complexity
- Rapid prototyping and development
- Applications requiring flexible state patterns
- Teams preferring minimal boilerplate
- Applications with simple to moderate async needs
- Projects requiring quick setup and iteration

**Performance Considerations:**

- Redux: Better for large datasets with normalization
- Zustand: Better for smaller, frequently updated state
- Both: Support selective subscriptions and memoization

**Team and Maintenance:**

- Redux: Steeper learning curve, more structured
- Zustand: Easier onboarding, more flexible
- Both: Strong TypeScript support and community

Choose based on your specific requirements, team expertise, and application complexity.

---

### 23. What are Redux actions and action creators? How do you structure them?

**Answer:**
Actions are plain JavaScript objects that describe what happened in your application. Action creators are functions that return action objects.

**Basic Action Structure:**

```javascript
// Action Types
const ADD_TODO = "ADD_TODO";
const TOGGLE_TODO = "TOGGLE_TODO";
const SET_FILTER = "SET_FILTER";

// Action Creators
const addTodo = (text) => ({
  type: ADD_TODO,
  payload: {
    id: Date.now(),
    text,
    completed: false,
  },
});

const toggleTodo = (id) => ({
  type: TOGGLE_TODO,
  payload: { id },
});

const setFilter = (filter) => ({
  type: SET_FILTER,
  payload: { filter },
});
```

**Advanced Action Creators with Redux Toolkit:**

```javascript
import { createAction, createAsyncThunk } from "@reduxjs/toolkit";

// Simple action creators
export const addTodo = createAction("todos/add", (text) => ({
  payload: {
    id: Date.now(),
    text,
    completed: false,
  },
}));

export const toggleTodo = createAction("todos/toggle");

// Async action creators
export const fetchTodos = createAsyncThunk(
  "todos/fetchTodos",
  async (userId, { rejectWithValue }) => {
    try {
      const response = await fetch(`/api/todos/${userId}`);
      if (!response.ok) {
        throw new Error("Failed to fetch todos");
      }
      return await response.json();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Action creator with prepare callback
export const addTodoWithTimestamp = createAction(
  "todos/addWithTimestamp",
  (text) => {
    return {
      payload: {
        id: Date.now(),
        text,
        completed: false,
        createdAt: new Date().toISOString(),
      },
    };
  }
);
```

**Structured Action Organization:**

```javascript
// actions/todoActions.js
export const todoActions = {
  // Synchronous actions
  add: createAction("todos/add"),
  toggle: createAction("todos/toggle"),
  remove: createAction("todos/remove"),
  edit: createAction("todos/edit"),

  // Async actions
  fetch: createAsyncThunk("todos/fetch", async () => {
    const response = await api.getTodos();
    return response.data;
  }),

  create: createAsyncThunk("todos/create", async (todoData) => {
    const response = await api.createTodo(todoData);
    return response.data;
  }),

  update: createAsyncThunk("todos/update", async ({ id, updates }) => {
    const response = await api.updateTodo(id, updates);
    return response.data;
  }),

  delete: createAsyncThunk("todos/delete", async (id) => {
    await api.deleteTodo(id);
    return id;
  }),
};
```

**Action Creator Patterns:**

```javascript
// 1. FSA (Flux Standard Action) Pattern
const createFSAAction = (type) => (payload, meta) => ({
  type,
  payload,
  meta,
  error: payload instanceof Error,
});

// 2. Action Creator Factory
const createCRUDActions = (entityName) => {
  const upperName = entityName.toUpperCase();

  return {
    create: createAction(`${upperName}/CREATE`),
    read: createAction(`${upperName}/READ`),
    update: createAction(`${upperName}/UPDATE`),
    delete: createAction(`${upperName}/DELETE`),

    // Async versions
    fetchAll: createAsyncThunk(`${upperName}/FETCH_ALL`, async () => {
      const response = await api.getAll(entityName);
      return response.data;
    }),

    createAsync: createAsyncThunk(`${upperName}/CREATE_ASYNC`, async (data) => {
      const response = await api.create(entityName, data);
      return response.data;
    }),
  };
};

// Usage
const userActions = createCRUDActions("user");
const productActions = createCRUDActions("product");
```

**Best Practices:**

1. **Use Action Constants:**

```javascript
// constants/actionTypes.js
export const TODO_ACTIONS = {
  ADD: "todos/add",
  TOGGLE: "todos/toggle",
  REMOVE: "todos/remove",
  FETCH: "todos/fetch",
};
```

2. **Normalize Action Payloads:**

```javascript
const addUser = (userData) => ({
  type: "users/add",
  payload: {
    user: normalizeUser(userData),
    timestamp: Date.now(),
    source: "user_input",
  },
});
```

3. **Use TypeScript for Type Safety:**

```typescript
interface AddTodoAction {
  type: "todos/add";
  payload: {
    id: string;
    text: string;
    completed: boolean;
  };
}

interface ToggleTodoAction {
  type: "todos/toggle";
  payload: {
    id: string;
  };
}

type TodoAction = AddTodoAction | ToggleTodoAction;

const addTodo = (text: string): AddTodoAction => ({
  type: "todos/add",
  payload: {
    id: Date.now().toString(),
    text,
    completed: false,
  },
});
```

**Key Points:**

- Actions describe what happened, not how state should change
- Action creators provide a consistent API for creating actions
- Use Redux Toolkit's `createAction` for better DX and TypeScript support
- Organize actions by feature/domain for better maintainability
- Consider using action creator factories for repetitive patterns

---

### 24. How do you handle form state management in Redux vs Zustand?

**Answer:**
Form state management can be handled differently in Redux and Zustand, each with their own advantages for different use cases.

**Redux Form State Management:**

```javascript
// Redux Toolkit slice for form state
import { createSlice } from "@reduxjs/toolkit";

const formSlice = createSlice({
  name: "form",
  initialState: {
    userForm: {
      values: {
        name: "",
        email: "",
        age: "",
      },
      errors: {},
      touched: {},
      isSubmitting: false,
      isValid: true,
    },
  },
  reducers: {
    updateField: (state, action) => {
      const { formName, field, value } = action.payload;
      state[formName].values[field] = value;
      state[formName].touched[field] = true;

      // Clear error when user starts typing
      if (state[formName].errors[field]) {
        delete state[formName].errors[field];
      }
    },

    setErrors: (state, action) => {
      const { formName, errors } = action.payload;
      state[formName].errors = errors;
      state[formName].isValid = Object.keys(errors).length === 0;
    },

    setSubmitting: (state, action) => {
      const { formName, isSubmitting } = action.payload;
      state[formName].isSubmitting = isSubmitting;
    },

    resetForm: (state, action) => {
      const { formName } = action.payload;
      state[formName] = {
        values: {},
        errors: {},
        touched: {},
        isSubmitting: false,
        isValid: true,
      };
    },
  },
});

export const { updateField, setErrors, setSubmitting, resetForm } =
  formSlice.actions;
export default formSlice.reducer;
```

**Redux Form Component:**

```javascript
import React from "react";
import { useSelector, useDispatch } from "react-redux";
import { updateField, setErrors, setSubmitting } from "./formSlice";

const UserForm = () => {
  const dispatch = useDispatch();
  const form = useSelector((state) => state.form.userForm);

  const handleChange = (field) => (e) => {
    dispatch(
      updateField({
        formName: "userForm",
        field,
        value: e.target.value,
      })
    );
  };

  const validateForm = () => {
    const errors = {};

    if (!form.values.name) errors.name = "Name is required";
    if (!form.values.email) errors.email = "Email is required";
    else if (!/\S+@\S+\.\S+/.test(form.values.email)) {
      errors.email = "Email is invalid";
    }

    dispatch(setErrors({ formName: "userForm", errors }));
    return Object.keys(errors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!validateForm()) return;

    dispatch(setSubmitting({ formName: "userForm", isSubmitting: true }));

    try {
      await submitUserData(form.values);
      dispatch(resetForm({ formName: "userForm" }));
    } catch (error) {
      dispatch(
        setErrors({
          formName: "userForm",
          errors: { submit: error.message },
        })
      );
    } finally {
      dispatch(setSubmitting({ formName: "userForm", isSubmitting: false }));
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={form.values.name || ""}
        onChange={handleChange("name")}
        placeholder="Name"
      />
      {form.errors.name && <span>{form.errors.name}</span>}

      <input
        type="email"
        value={form.values.email || ""}
        onChange={handleChange("email")}
        placeholder="Email"
      />
      {form.errors.email && <span>{form.errors.email}</span>}

      <button type="submit" disabled={form.isSubmitting}>
        {form.isSubmitting ? "Submitting..." : "Submit"}
      </button>
    </form>
  );
};
```

**Zustand Form State Management:**

```javascript
// Zustand form store
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";

const useFormStore = create(
  immer((set, get) => ({
    forms: {},

    // Initialize form
    initForm: (formName, initialValues = {}) =>
      set((state) => {
        state.forms[formName] = {
          values: initialValues,
          errors: {},
          touched: {},
          isSubmitting: false,
          isValid: true,
        };
      }),

    // Update field value
    updateField: (formName, field, value) =>
      set((state) => {
        if (!state.forms[formName]) return;

        state.forms[formName].values[field] = value;
        state.forms[formName].touched[field] = true;

        // Clear error when user starts typing
        if (state.forms[formName].errors[field]) {
          delete state.forms[formName].errors[field];
        }
      }),

    // Set form errors
    setErrors: (formName, errors) =>
      set((state) => {
        if (!state.forms[formName]) return;

        state.forms[formName].errors = errors;
        state.forms[formName].isValid = Object.keys(errors).length === 0;
      }),

    // Set submitting state
    setSubmitting: (formName, isSubmitting) =>
      set((state) => {
        if (!state.forms[formName]) return;
        state.forms[formName].isSubmitting = isSubmitting;
      }),

    // Reset form
    resetForm: (formName) =>
      set((state) => {
        if (!state.forms[formName]) return;

        state.forms[formName] = {
          values: {},
          errors: {},
          touched: {},
          isSubmitting: false,
          isValid: true,
        };
      }),

    // Get form data
    getForm: (formName) => {
      const state = get();
      return state.forms[formName] || null;
    },
  }))
);

export default useFormStore;
```

**Zustand Form Component:**

```javascript
import React, { useEffect } from "react";
import useFormStore from "./formStore";

const UserForm = () => {
  const { forms, initForm, updateField, setErrors, setSubmitting, resetForm } =
    useFormStore();

  const form = forms.userForm;

  useEffect(() => {
    initForm("userForm", { name: "", email: "", age: "" });
  }, []);

  if (!form) return null;

  const handleChange = (field) => (e) => {
    updateField("userForm", field, e.target.value);
  };

  const validateForm = () => {
    const errors = {};

    if (!form.values.name) errors.name = "Name is required";
    if (!form.values.email) errors.email = "Email is required";
    else if (!/\S+@\S+\.\S+/.test(form.values.email)) {
      errors.email = "Email is invalid";
    }

    setErrors("userForm", errors);
    return Object.keys(errors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!validateForm()) return;

    setSubmitting("userForm", true);

    try {
      await submitUserData(form.values);
      resetForm("userForm");
    } catch (error) {
      setErrors("userForm", { submit: error.message });
    } finally {
      setSubmitting("userForm", false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={form.values.name || ""}
        onChange={handleChange("name")}
        placeholder="Name"
      />
      {form.errors.name && <span>{form.errors.name}</span>}

      <input
        type="email"
        value={form.values.email || ""}
        onChange={handleChange("email")}
        placeholder="Email"
      />
      {form.errors.email && <span>{form.errors.email}</span>}

      <button type="submit" disabled={form.isSubmitting}>
        {form.isSubmitting ? "Submitting..." : "Submit"}
      </button>
    </form>
  );
};
```

**Advanced Form Patterns:**

**1. Form Validation Hook (Zustand):**

```javascript
const useFormValidation = (formName, validationRules) => {
  const { getForm, setErrors } = useFormStore();

  const validate = useCallback(() => {
    const form = getForm(formName);
    if (!form) return false;

    const errors = {};

    Object.entries(validationRules).forEach(([field, rules]) => {
      const value = form.values[field];

      rules.forEach((rule) => {
        if (rule.required && !value) {
          errors[field] = rule.message || `${field} is required`;
        } else if (rule.pattern && value && !rule.pattern.test(value)) {
          errors[field] = rule.message || `${field} is invalid`;
        } else if (rule.minLength && value && value.length < rule.minLength) {
          errors[field] =
            rule.message ||
            `${field} must be at least ${rule.minLength} characters`;
        }
      });
    });

    setErrors(formName, errors);
    return Object.keys(errors).length === 0;
  }, [formName, validationRules, getForm, setErrors]);

  return { validate };
};

// Usage
const validationRules = {
  name: [{ required: true, message: "Name is required" }],
  email: [
    { required: true, message: "Email is required" },
    { pattern: /\S+@\S+\.\S+/, message: "Email is invalid" },
  ],
};

const { validate } = useFormValidation("userForm", validationRules);
```

**2. Dynamic Form Fields:**

```javascript
// Redux approach
const dynamicFormSlice = createSlice({
  name: "dynamicForm",
  initialState: {
    fields: [],
    values: {},
  },
  reducers: {
    addField: (state, action) => {
      state.fields.push(action.payload);
    },
    removeField: (state, action) => {
      const fieldName = action.payload;
      state.fields = state.fields.filter((field) => field.name !== fieldName);
      delete state.values[fieldName];
    },
    updateValue: (state, action) => {
      const { field, value } = action.payload;
      state.values[field] = value;
    },
  },
});

// Zustand approach
const useDynamicFormStore = create((set) => ({
  fields: [],
  values: {},

  addField: (field) =>
    set((state) => ({
      fields: [...state.fields, field],
    })),

  removeField: (fieldName) =>
    set((state) => {
      const newValues = { ...state.values };
      delete newValues[fieldName];

      return {
        fields: state.fields.filter((field) => field.name !== fieldName),
        values: newValues,
      };
    }),

  updateValue: (field, value) =>
    set((state) => ({
      values: { ...state.values, [field]: value },
    })),
}));
```

**Comparison Summary:**

**Redux Advantages:**

- Centralized form state management
- Time-travel debugging for forms
- Predictable state updates
- Better for complex form workflows

**Zustand Advantages:**

- Less boilerplate code
- More flexible form structure
- Easier to implement dynamic forms
- Better performance for frequent updates

**When to Use Each:**

- **Redux**: Complex forms, multi-step wizards, form state needs to persist across routes
- **Zustand**: Simple forms, component-level form state, rapid prototyping

---

### 25. What are Redux selectors and how do you create reusable selectors?

**Answer:**
Selectors are functions that extract specific pieces of state from the Redux store. They provide a clean API for accessing state and enable memoization for performance optimization.

**Basic Selectors:**

```javascript
// Basic selector functions
const selectTodos = (state) => state.todos.items;
const selectTodosLoading = (state) => state.todos.loading;
const selectTodosError = (state) => state.todos.error;
const selectCurrentUser = (state) => state.auth.user;

// Using selectors in components
import { useSelector } from "react-redux";

const TodoList = () => {
  const todos = useSelector(selectTodos);
  const loading = useSelector(selectTodosLoading);
  const error = useSelector(selectTodosError);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
};
```

**Memoized Selectors with Reselect:**

```javascript
import { createSelector } from "@reduxjs/toolkit";

// Input selectors
const selectTodos = (state) => state.todos.items;
const selectFilter = (state) => state.todos.filter;
const selectSearchTerm = (state) => state.todos.searchTerm;

// Memoized selectors
const selectFilteredTodos = createSelector(
  [selectTodos, selectFilter],
  (todos, filter) => {
    console.log("Computing filtered todos"); // Only runs when inputs change

    switch (filter) {
      case "completed":
        return todos.filter((todo) => todo.completed);
      case "active":
        return todos.filter((todo) => !todo.completed);
      default:
        return todos;
    }
  }
);

const selectSearchedTodos = createSelector(
  [selectFilteredTodos, selectSearchTerm],
  (filteredTodos, searchTerm) => {
    if (!searchTerm) return filteredTodos;

    return filteredTodos.filter((todo) =>
      todo.text.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }
);

// Complex computed selectors
const selectTodoStats = createSelector([selectTodos], (todos) => ({
  total: todos.length,
  completed: todos.filter((todo) => todo.completed).length,
  active: todos.filter((todo) => !todo.completed).length,
  completionRate:
    todos.length > 0
      ? (todos.filter((todo) => todo.completed).length / todos.length) * 100
      : 0,
}));
```

**Parameterized Selectors:**

```javascript
// Selector factory for parameterized selectors
const makeSelectTodoById = () =>
  createSelector([selectTodos, (state, todoId) => todoId], (todos, todoId) =>
    todos.find((todo) => todo.id === todoId)
  );

// Usage in component
const TodoItem = ({ todoId }) => {
  const selectTodoById = useMemo(makeSelectTodoById, []);
  const todo = useSelector((state) => selectTodoById(state, todoId));

  return <div>{todo?.text}</div>;
};

// Alternative approach with createSelector
const selectTodoById = createSelector(
  [selectTodos, (state, id) => id],
  (todos, id) => todos.find((todo) => todo.id === id)
);

// Using with useSelector
const todo = useSelector((state) => selectTodoById(state, todoId));
```

**Advanced Selector Patterns:**

```javascript
// 1. Selector composition
const selectUserTodos = createSelector(
  [selectTodos, selectCurrentUser],
  (todos, user) => todos.filter((todo) => todo.userId === user?.id)
);

const selectUserCompletedTodos = createSelector(
  [selectUserTodos],
  (userTodos) => userTodos.filter((todo) => todo.completed)
);

// 2. Denormalized data selectors
const selectTodosWithCategories = createSelector(
  [selectTodos, (state) => state.categories.items],
  (todos, categories) => {
    const categoryMap = categories.reduce((acc, cat) => {
      acc[cat.id] = cat;
      return acc;
    }, {});

    return todos.map((todo) => ({
      ...todo,
      category: categoryMap[todo.categoryId],
    }));
  }
);

// 3. Aggregation selectors
const selectTodosByCategory = createSelector(
  [selectTodosWithCategories],
  (todosWithCategories) => {
    return todosWithCategories.reduce((acc, todo) => {
      const categoryName = todo.category?.name || "Uncategorized";
      if (!acc[categoryName]) {
        acc[categoryName] = [];
      }
      acc[categoryName].push(todo);
      return acc;
    }, {});
  }
);

// 4. Sorted selectors
const selectSortedTodos = createSelector(
  [
    selectTodos,
    (state) => state.todos.sortBy,
    (state) => state.todos.sortOrder,
  ],
  (todos, sortBy, sortOrder) => {
    const sorted = [...todos].sort((a, b) => {
      let aVal = a[sortBy];
      let bVal = b[sortBy];

      if (sortBy === "createdAt") {
        aVal = new Date(aVal);
        bVal = new Date(bVal);
      }

      if (aVal < bVal) return sortOrder === "asc" ? -1 : 1;
      if (aVal > bVal) return sortOrder === "asc" ? 1 : -1;
      return 0;
    });

    return sorted;
  }
);
```

**Selector Organization:**

```javascript
// selectors/todoSelectors.js
export const todoSelectors = {
  // Basic selectors
  selectTodos: (state) => state.todos.items,
  selectTodosLoading: (state) => state.todos.loading,
  selectTodosError: (state) => state.todos.error,
  selectFilter: (state) => state.todos.filter,
  selectSearchTerm: (state) => state.todos.searchTerm,

  // Computed selectors
  selectFilteredTodos: createSelector(
    [(state) => state.todos.items, (state) => state.todos.filter],
    (todos, filter) => {
      switch (filter) {
        case "completed":
          return todos.filter((todo) => todo.completed);
        case "active":
          return todos.filter((todo) => !todo.completed);
        default:
          return todos;
      }
    }
  ),

  selectTodoStats: createSelector([(state) => state.todos.items], (todos) => ({
    total: todos.length,
    completed: todos.filter((todo) => todo.completed).length,
    active: todos.filter((todo) => !todo.completed).length,
  })),
};

// Export individual selectors for convenience
export const {
  selectTodos,
  selectTodosLoading,
  selectFilteredTodos,
  selectTodoStats,
} = todoSelectors;
```

**Testing Selectors:**

```javascript
// selectors.test.js
import { selectFilteredTodos, selectTodoStats } from "./todoSelectors";

describe("Todo Selectors", () => {
  const mockState = {
    todos: {
      items: [
        { id: 1, text: "Learn Redux", completed: false },
        { id: 2, text: "Write tests", completed: true },
        { id: 3, text: "Deploy app", completed: false },
      ],
      filter: "all",
    },
  };

  describe("selectFilteredTodos", () => {
    it('should return all todos when filter is "all"', () => {
      const result = selectFilteredTodos(mockState);
      expect(result).toHaveLength(3);
    });

    it('should return only completed todos when filter is "completed"', () => {
      const stateWithFilter = {
        ...mockState,
        todos: { ...mockState.todos, filter: "completed" },
      };

      const result = selectFilteredTodos(stateWithFilter);
      expect(result).toHaveLength(1);
      expect(result[0].completed).toBe(true);
    });
  });

  describe("selectTodoStats", () => {
    it("should calculate correct statistics", () => {
      const result = selectTodoStats(mockState);

      expect(result).toEqual({
        total: 3,
        completed: 1,
        active: 2,
      });
    });
  });
});
```

**Performance Optimization with Selectors:**

```javascript
// 1. Avoid creating new objects in selectors
// BAD - creates new object every time
const badSelector = (state) => ({
  todos: state.todos,
  user: state.user,
});

// GOOD - use createSelector for object creation
const goodSelector = createSelector(
  [(state) => state.todos, (state) => state.user],
  (todos, user) => ({ todos, user })
);

// 2. Use shallow equality for arrays
const selectTodoIds = createSelector([selectTodos], (todos) =>
  todos.map((todo) => todo.id)
);

// 3. Memoize expensive computations
const selectExpensiveComputation = createSelector([selectTodos], (todos) => {
  // Expensive operation that should be memoized
  return todos.reduce((acc, todo) => {
    // Complex computation
    return acc + complexCalculation(todo);
  }, 0);
});
```

**Best Practices:**

1. **Keep selectors pure** - no side effects
2. **Use memoization** for expensive computations
3. **Organize selectors** by feature/domain
4. **Test selectors** independently
5. **Avoid deep nesting** in selector logic
6. **Use TypeScript** for better type safety
7. **Document complex selectors** with comments
8. **Prefer composition** over large monolithic selectors

**Key Benefits:**

- **Performance**: Memoization prevents unnecessary re-computations
- **Reusability**: Selectors can be shared across components
- **Testability**: Easy to unit test selector logic
- **Maintainability**: Centralized state access logic
- **Type Safety**: Better TypeScript integration

---

### 26. How do you handle authentication state management in Redux vs Zustand?

**Answer:**
Authentication state management involves handling user login/logout, token storage, session persistence, and protecting routes. Both Redux and Zustand offer different approaches.

**Redux Authentication Implementation:**

```javascript
// authSlice.js
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import { authAPI } from "../api/authAPI";

// Async thunks
export const loginUser = createAsyncThunk(
  "auth/loginUser",
  async ({ email, password }, { rejectWithValue }) => {
    try {
      const response = await authAPI.login({ email, password });

      // Store token in localStorage
      localStorage.setItem("token", response.data.token);
      localStorage.setItem("refreshToken", response.data.refreshToken);

      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data?.message || "Login failed");
    }
  }
);

export const logoutUser = createAsyncThunk(
  "auth/logoutUser",
  async (_, { getState }) => {
    const { auth } = getState();

    try {
      await authAPI.logout(auth.refreshToken);
    } catch (error) {
      console.error("Logout API call failed:", error);
    } finally {
      // Always clear local storage
      localStorage.removeItem("token");
      localStorage.removeItem("refreshToken");
    }
  }
);

export const refreshToken = createAsyncThunk(
  "auth/refreshToken",
  async (_, { getState, rejectWithValue }) => {
    const { auth } = getState();

    try {
      const response = await authAPI.refreshToken(auth.refreshToken);

      localStorage.setItem("token", response.data.token);

      return response.data;
    } catch (error) {
      localStorage.removeItem("token");
      localStorage.removeItem("refreshToken");
      return rejectWithValue("Token refresh failed");
    }
  }
);

export const loadUserFromToken = createAsyncThunk(
  "auth/loadUserFromToken",
  async (_, { rejectWithValue }) => {
    const token = localStorage.getItem("token");

    if (!token) {
      return rejectWithValue("No token found");
    }

    try {
      const response = await authAPI.getCurrentUser(token);
      return response.data;
    } catch (error) {
      localStorage.removeItem("token");
      localStorage.removeItem("refreshToken");
      return rejectWithValue("Invalid token");
    }
  }
);

// Auth slice
const authSlice = createSlice({
  name: "auth",
  initialState: {
    user: null,
    token: localStorage.getItem("token"),
    refreshToken: localStorage.getItem("refreshToken"),
    isAuthenticated: false,
    loading: false,
    error: null,
    lastActivity: Date.now(),
  },
  reducers: {
    clearError: (state) => {
      state.error = null;
    },
    updateLastActivity: (state) => {
      state.lastActivity = Date.now();
    },
    updateUser: (state, action) => {
      state.user = { ...state.user, ...action.payload };
    },
  },
  extraReducers: (builder) => {
    builder
      // Login
      .addCase(loginUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.loading = false;
        state.user = action.payload.user;
        state.token = action.payload.token;
        state.refreshToken = action.payload.refreshToken;
        state.isAuthenticated = true;
        state.lastActivity = Date.now();
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
        state.isAuthenticated = false;
      })

      // Logout
      .addCase(logoutUser.fulfilled, (state) => {
        state.user = null;
        state.token = null;
        state.refreshToken = null;
        state.isAuthenticated = false;
        state.error = null;
      })

      // Refresh token
      .addCase(refreshToken.fulfilled, (state, action) => {
        state.token = action.payload.token;
        state.lastActivity = Date.now();
      })
      .addCase(refreshToken.rejected, (state) => {
        state.user = null;
        state.token = null;
        state.refreshToken = null;
        state.isAuthenticated = false;
      })

      // Load user from token
      .addCase(loadUserFromToken.fulfilled, (state, action) => {
        state.user = action.payload.user;
        state.isAuthenticated = true;
        state.loading = false;
      })
      .addCase(loadUserFromToken.rejected, (state) => {
        state.token = null;
        state.refreshToken = null;
        state.isAuthenticated = false;
        state.loading = false;
      });
  },
});

export const { clearError, updateLastActivity, updateUser } = authSlice.actions;
export default authSlice.reducer;
```

**Redux Auth Selectors:**

```javascript
// authSelectors.js
import { createSelector } from "@reduxjs/toolkit";

export const selectAuth = (state) => state.auth;
export const selectUser = (state) => state.auth.user;
export const selectIsAuthenticated = (state) => state.auth.isAuthenticated;
export const selectAuthLoading = (state) => state.auth.loading;
export const selectAuthError = (state) => state.auth.error;
export const selectToken = (state) => state.auth.token;

export const selectUserRole = createSelector(
  [selectUser],
  (user) => user?.role || "guest"
);

export const selectUserPermissions = createSelector(
  [selectUser],
  (user) => user?.permissions || []
);

export const selectCanAccess = createSelector(
  [selectUserPermissions],
  (permissions) => (requiredPermission) =>
    permissions.includes(requiredPermission)
);

export const selectSessionExpiry = createSelector([selectAuth], (auth) => {
  if (!auth.token || !auth.lastActivity) return null;

  const sessionTimeout = 30 * 60 * 1000; // 30 minutes
  return auth.lastActivity + sessionTimeout;
});
```

**Zustand Authentication Implementation:**

```javascript
// authStore.js
import { create } from "zustand";
import { persist, subscribeWithSelector } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";
import { authAPI } from "../api/authAPI";

const useAuthStore = create(
  subscribeWithSelector(
    persist(
      immer((set, get) => ({
        // State
        user: null,
        token: null,
        refreshToken: null,
        isAuthenticated: false,
        loading: false,
        error: null,
        lastActivity: Date.now(),

        // Actions
        login: async (credentials) => {
          set((state) => {
            state.loading = true;
            state.error = null;
          });

          try {
            const response = await authAPI.login(credentials);

            set((state) => {
              state.user = response.data.user;
              state.token = response.data.token;
              state.refreshToken = response.data.refreshToken;
              state.isAuthenticated = true;
              state.loading = false;
              state.lastActivity = Date.now();
            });

            return { success: true };
          } catch (error) {
            set((state) => {
              state.loading = false;
              state.error = error.response?.data?.message || "Login failed";
              state.isAuthenticated = false;
            });

            return { success: false, error: error.message };
          }
        },

        logout: async () => {
          const { refreshToken } = get();

          try {
            await authAPI.logout(refreshToken);
          } catch (error) {
            console.error("Logout API call failed:", error);
          }

          set((state) => {
            state.user = null;
            state.token = null;
            state.refreshToken = null;
            state.isAuthenticated = false;
            state.error = null;
          });
        },

        refreshToken: async () => {
          const { refreshToken } = get();

          if (!refreshToken) {
            get().logout();
            return false;
          }

          try {
            const response = await authAPI.refreshToken(refreshToken);

            set((state) => {
              state.token = response.data.token;
              state.lastActivity = Date.now();
            });

            return true;
          } catch (error) {
            get().logout();
            return false;
          }
        },

        loadUserFromToken: async () => {
          const { token } = get();

          if (!token) return false;

          set((state) => {
            state.loading = true;
          });

          try {
            const response = await authAPI.getCurrentUser(token);

            set((state) => {
              state.user = response.data.user;
              state.isAuthenticated = true;
              state.loading = false;
            });

            return true;
          } catch (error) {
            set((state) => {
              state.token = null;
              state.refreshToken = null;
              state.isAuthenticated = false;
              state.loading = false;
            });

            return false;
          }
        },

        updateUser: (userData) => {
          set((state) => {
            state.user = { ...state.user, ...userData };
          });
        },

        updateLastActivity: () => {
          set((state) => {
            state.lastActivity = Date.now();
          });
        },

        clearError: () => {
          set((state) => {
            state.error = null;
          });
        },

        // Computed values
        getUserRole: () => get().user?.role || "guest",
        getUserPermissions: () => get().user?.permissions || [],
        canAccess: (permission) => {
          const permissions = get().getUserPermissions();
          return permissions.includes(permission);
        },
        getSessionExpiry: () => {
          const { token, lastActivity } = get();
          if (!token || !lastActivity) return null;

          const sessionTimeout = 30 * 60 * 1000; // 30 minutes
          return lastActivity + sessionTimeout;
        },
      })),
      {
        name: "auth-storage",
        partialize: (state) => ({
          token: state.token,
          refreshToken: state.refreshToken,
          user: state.user,
          isAuthenticated: state.isAuthenticated,
        }),
      }
    )
  )
);

export default useAuthStore;
```

**Authentication Components:**

```javascript
// Redux Login Component
import React, { useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import { loginUser, clearError } from "../store/authSlice";
import { selectAuthLoading, selectAuthError } from "../store/authSelectors";

const ReduxLoginForm = () => {
  const dispatch = useDispatch();
  const loading = useSelector(selectAuthLoading);
  const error = useSelector(selectAuthError);

  const [credentials, setCredentials] = useState({
    email: "",
    password: "",
  });

  const handleSubmit = async (e) => {
    e.preventDefault();
    dispatch(clearError());

    const result = await dispatch(loginUser(credentials));

    if (loginUser.fulfilled.match(result)) {
      // Handle successful login
      console.log("Login successful");
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={credentials.email}
        onChange={(e) =>
          setCredentials((prev) => ({
            ...prev,
            email: e.target.value,
          }))
        }
        placeholder="Email"
        required
      />

      <input
        type="password"
        value={credentials.password}
        onChange={(e) =>
          setCredentials((prev) => ({
            ...prev,
            password: e.target.value,
          }))
        }
        placeholder="Password"
        required
      />

      {error && <div className="error">{error}</div>}

      <button type="submit" disabled={loading}>
        {loading ? "Logging in..." : "Login"}
      </button>
    </form>
  );
};

// Zustand Login Component
const ZustandLoginForm = () => {
  const { login, loading, error, clearError } = useAuthStore();

  const [credentials, setCredentials] = useState({
    email: "",
    password: "",
  });

  const handleSubmit = async (e) => {
    e.preventDefault();
    clearError();

    const result = await login(credentials);

    if (result.success) {
      console.log("Login successful");
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={credentials.email}
        onChange={(e) =>
          setCredentials((prev) => ({
            ...prev,
            email: e.target.value,
          }))
        }
        placeholder="Email"
        required
      />

      <input
        type="password"
        value={credentials.password}
        onChange={(e) =>
          setCredentials((prev) => ({
            ...prev,
            password: e.target.value,
          }))
        }
        placeholder="Password"
        required
      />

      {error && <div className="error">{error}</div>}

      <button type="submit" disabled={loading}>
        {loading ? "Logging in..." : "Login"}
      </button>
    </form>
  );
};
```

**Protected Route Components:**

```javascript
// Redux Protected Route
import { useSelector } from "react-redux";
import {
  selectIsAuthenticated,
  selectAuthLoading,
} from "../store/authSelectors";

const ReduxProtectedRoute = ({ children, requiredPermission }) => {
  const isAuthenticated = useSelector(selectIsAuthenticated);
  const loading = useSelector(selectAuthLoading);
  const canAccess = useSelector(selectCanAccess);

  if (loading) {
    return <div>Loading...</div>;
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  if (requiredPermission && !canAccess(requiredPermission)) {
    return <div>Access Denied</div>;
  }

  return children;
};

// Zustand Protected Route
const ZustandProtectedRoute = ({ children, requiredPermission }) => {
  const { isAuthenticated, loading, canAccess } = useAuthStore();

  if (loading) {
    return <div>Loading...</div>;
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  if (requiredPermission && !canAccess(requiredPermission)) {
    return <div>Access Denied</div>;
  }

  return children;
};
```

**Session Management:**

```javascript
// Redux Session Manager
import { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import {
  refreshToken,
  logoutUser,
  updateLastActivity,
} from "../store/authSlice";
import {
  selectSessionExpiry,
  selectIsAuthenticated,
} from "../store/authSelectors";

const ReduxSessionManager = () => {
  const dispatch = useDispatch();
  const sessionExpiry = useSelector(selectSessionExpiry);
  const isAuthenticated = useSelector(selectIsAuthenticated);

  useEffect(() => {
    if (!isAuthenticated) return;

    const checkSession = () => {
      const now = Date.now();

      if (sessionExpiry && now > sessionExpiry) {
        dispatch(logoutUser());
        return;
      }

      // Refresh token if close to expiry
      if (sessionExpiry && now > sessionExpiry - 5 * 60 * 1000) {
        dispatch(refreshToken());
      }
    };

    const interval = setInterval(checkSession, 60000); // Check every minute

    // Update activity on user interaction
    const updateActivity = () => dispatch(updateLastActivity());

    window.addEventListener("click", updateActivity);
    window.addEventListener("keypress", updateActivity);

    return () => {
      clearInterval(interval);
      window.removeEventListener("click", updateActivity);
      window.removeEventListener("keypress", updateActivity);
    };
  }, [dispatch, sessionExpiry, isAuthenticated]);

  return null;
};

// Zustand Session Manager
const ZustandSessionManager = () => {
  const {
    isAuthenticated,
    getSessionExpiry,
    refreshToken,
    logout,
    updateLastActivity,
  } = useAuthStore();

  useEffect(() => {
    if (!isAuthenticated) return;

    const checkSession = () => {
      const sessionExpiry = getSessionExpiry();
      const now = Date.now();

      if (sessionExpiry && now > sessionExpiry) {
        logout();
        return;
      }

      // Refresh token if close to expiry
      if (sessionExpiry && now > sessionExpiry - 5 * 60 * 1000) {
        refreshToken();
      }
    };

    const interval = setInterval(checkSession, 60000);

    // Update activity on user interaction
    const updateActivity = () => updateLastActivity();

    window.addEventListener("click", updateActivity);
    window.addEventListener("keypress", updateActivity);

    return () => {
      clearInterval(interval);
      window.removeEventListener("click", updateActivity);
      window.removeEventListener("keypress", updateActivity);
    };
  }, [
    isAuthenticated,
    getSessionExpiry,
    refreshToken,
    logout,
    updateLastActivity,
  ]);

  return null;
};
```

**Comparison Summary:**

**Redux Advantages:**

- **Predictable state updates** with actions and reducers
- **Excellent DevTools** for debugging auth flows
- **Middleware support** for complex auth logic
- **Time-travel debugging** for auth state changes
- **Standardized patterns** for team consistency

**Zustand Advantages:**

- **Simpler setup** with less boilerplate
- **Built-in persistence** with middleware
- **Direct async actions** without thunks
- **Smaller bundle size** for auth-only needs
- **Flexible store structure** for auth data

**Best Practices:**

1. **Secure token storage** (consider httpOnly cookies for sensitive apps)
2. **Automatic token refresh** before expiration
3. **Session timeout** handling
4. **Activity tracking** for security
5. **Proper error handling** for auth failures
6. **Route protection** based on authentication state
7. **Logout on token expiry** or invalid tokens
8. **Persist auth state** across browser sessions

---

### 27. How do you use Redux DevTools for debugging and what are its key features?

**Answer:**
Redux DevTools is a powerful debugging tool that provides time-travel debugging, action inspection, state monitoring, and performance analysis for Redux applications.

**Setting Up Redux DevTools:**

```javascript
// store.js - Basic setup
import { configureStore } from "@reduxjs/toolkit";
import { composeWithDevTools } from "@reduxjs/toolkit/query";

// With Redux Toolkit (DevTools enabled by default)
const store = configureStore({
  reducer: {
    todos: todosReducer,
    auth: authReducer,
    ui: uiReducer,
  },
  // DevTools configuration
  devTools: process.env.NODE_ENV !== "production" && {
    name: "My App",
    trace: true,
    traceLimit: 25,
    actionSanitizer: (action) => ({
      ...action,
      // Hide sensitive data
      ...(action.type === "auth/loginUser/fulfilled" && {
        payload: { ...action.payload, token: "[HIDDEN]" },
      }),
    }),
    stateSanitizer: (state) => ({
      ...state,
      // Hide sensitive state
      auth: {
        ...state.auth,
        token: state.auth.token ? "[HIDDEN]" : null,
        refreshToken: state.auth.refreshToken ? "[HIDDEN]" : null,
      },
    }),
  },
});

// Legacy Redux setup
import { createStore, applyMiddleware, compose } from "redux";
import thunk from "redux-thunk";

const composeEnhancers =
  (typeof window !== "undefined" &&
    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) ||
  compose;

const store = createStore(
  rootReducer,
  composeEnhancers(applyMiddleware(thunk))
);
```

**Advanced DevTools Configuration:**

```javascript
// Enhanced DevTools setup with custom options
const store = configureStore({
  reducer: rootReducer,
  devTools: process.env.NODE_ENV !== "production" && {
    // Custom instance name
    name: "TodoApp Redux Store",

    // Enable action stack traces
    trace: true,
    traceLimit: 25,

    // Custom serialization
    serialize: {
      options: {
        undefined: true,
        function: true,
        symbol: true,
      },
    },

    // Action filtering
    predicate: (state, action) => {
      // Don't log certain actions
      return !action.type.includes("@@redux-form");
    },

    // Action sanitization for security
    actionSanitizer: (action) => {
      const sensitiveActions = [
        "auth/loginUser/fulfilled",
        "auth/refreshToken/fulfilled",
      ];

      if (sensitiveActions.includes(action.type)) {
        return {
          ...action,
          payload: {
            ...action.payload,
            token: "[REDACTED]",
            refreshToken: "[REDACTED]",
          },
        };
      }

      return action;
    },

    // State sanitization
    stateSanitizer: (state) => ({
      ...state,
      auth: {
        ...state.auth,
        token: state.auth.token ? "[REDACTED]" : null,
        refreshToken: state.auth.refreshToken ? "[REDACTED]" : null,
      },
      // Hide large data sets in DevTools
      cache:
        Object.keys(state.cache || {}).length > 100
          ? "[LARGE_DATASET_HIDDEN]"
          : state.cache,
    }),

    // Maximum number of actions to keep
    maxAge: 50,

    // Auto-pause on errors
    pauseActionType: "@@PAUSED",
  },
});
```

**Key DevTools Features:**

**1. Action Inspection:**

```javascript
// Custom action creators with better DevTools integration
const addTodoWithMetadata = (text) => ({
  type: "todos/addTodo",
  payload: { text },
  meta: {
    timestamp: Date.now(),
    source: "user_input",
    // Custom metadata for debugging
    debugInfo: {
      component: "TodoForm",
      userAgent: navigator.userAgent,
    },
  },
});

// Enhanced async thunk with better DevTools info
export const fetchTodosWithDebugInfo = createAsyncThunk(
  "todos/fetchTodos",
  async (userId, { getState, requestId, signal, rejectWithValue }) => {
    const startTime = performance.now();

    try {
      const response = await todosAPI.fetchTodos(userId, { signal });

      // Add performance metadata
      const endTime = performance.now();

      return {
        todos: response.data,
        meta: {
          requestId,
          duration: endTime - startTime,
          timestamp: Date.now(),
          cacheHit: false,
        },
      };
    } catch (error) {
      return rejectWithValue({
        message: error.message,
        requestId,
        duration: performance.now() - startTime,
      });
    }
  }
);
```

**2. Time Travel Debugging:**

```javascript
// Middleware for enhanced time travel debugging
const timeTravelMiddleware = (store) => (next) => (action) => {
  // Log state before action
  const prevState = store.getState();

  // Execute action
  const result = next(action);

  // Log state after action
  const nextState = store.getState();

  // Custom logging for specific actions
  if (action.type.includes("todos/")) {
    console.group(` ${action.type}`);
    console.log("Previous State:", prevState.todos);
    console.log("Action:", action);
    console.log("Next State:", nextState.todos);
    console.groupEnd();
  }

  return result;
};

// Add to store
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(timeTravelMiddleware),
});
```

**3. State Monitoring and Subscriptions:**

```javascript
// Custom DevTools monitoring
class ReduxDevToolsMonitor {
  constructor(store) {
    this.store = store;
    this.subscribers = new Set();
    this.previousState = store.getState();

    // Subscribe to store changes
    store.subscribe(() => {
      const currentState = store.getState();
      this.notifySubscribers(this.previousState, currentState);
      this.previousState = currentState;
    });
  }

  subscribe(callback) {
    this.subscribers.add(callback);

    return () => {
      this.subscribers.delete(callback);
    };
  }

  notifySubscribers(prevState, nextState) {
    this.subscribers.forEach((callback) => {
      callback(prevState, nextState);
    });
  }

  // Monitor specific state slices
  monitorSlice(sliceName, callback) {
    return this.subscribe((prevState, nextState) => {
      const prevSlice = prevState[sliceName];
      const nextSlice = nextState[sliceName];

      if (prevSlice !== nextSlice) {
        callback(prevSlice, nextSlice, sliceName);
      }
    });
  }
}

// Usage
const monitor = new ReduxDevToolsMonitor(store);

// Monitor todos slice
monitor.monitorSlice("todos", (prevTodos, nextTodos, sliceName) => {
  console.log(`${sliceName} changed:`, {
    previous: prevTodos,
    current: nextTodos,
    diff: {
      added: nextTodos.items.length - prevTodos.items.length,
      timestamp: Date.now(),
    },
  });
});
```

**4. Performance Analysis:**

```javascript
// Performance monitoring middleware
const performanceMiddleware = (store) => (next) => (action) => {
  const start = performance.now();

  // Mark the start of action processing
  performance.mark(`action-${action.type}-start`);

  const result = next(action);

  const end = performance.now();
  const duration = end - start;

  // Mark the end and measure
  performance.mark(`action-${action.type}-end`);
  performance.measure(
    `action-${action.type}`,
    `action-${action.type}-start`,
    `action-${action.type}-end`
  );

  // Log slow actions
  if (duration > 10) {
    console.warn(
      ` Slow action detected: ${action.type} took ${duration.toFixed(2)}ms`
    );
  }

  // Send to DevTools with performance data
  if (window.__REDUX_DEVTOOLS_EXTENSION__) {
    window.__REDUX_DEVTOOLS_EXTENSION__.send(
      {
        ...action,
        meta: {
          ...action.meta,
          performance: {
            duration,
            timestamp: Date.now(),
          },
        },
      },
      store.getState()
    );
  }

  return result;
};
```

**5. Custom DevTools Integration:**

```javascript
// Custom DevTools extension integration
class CustomDevTools {
  constructor(store) {
    this.store = store;
    this.devTools = window.__REDUX_DEVTOOLS_EXTENSION__;
    this.actionHistory = [];
    this.stateHistory = [];

    if (this.devTools) {
      this.setupDevTools();
    }
  }

  setupDevTools() {
    // Connect to DevTools
    this.connection = this.devTools.connect({
      name: "Custom Redux Monitor",
      features: {
        pause: true,
        lock: true,
        persist: true,
        export: true,
        import: "custom",
        jump: true,
        skip: true,
        reorder: true,
        dispatch: true,
        test: true,
      },
    });

    // Listen to DevTools messages
    this.connection.subscribe((message) => {
      if (message.type === "DISPATCH") {
        this.handleDevToolsMessage(message);
      }
    });

    // Send initial state
    this.connection.init(this.store.getState());

    // Subscribe to store changes
    this.store.subscribe(() => {
      const state = this.store.getState();
      this.stateHistory.push(state);

      // Keep history limited
      if (this.stateHistory.length > 50) {
        this.stateHistory.shift();
      }
    });
  }

  handleDevToolsMessage(message) {
    switch (message.payload.type) {
      case "JUMP_TO_ACTION":
      case "JUMP_TO_STATE":
        // Handle time travel
        const targetState = this.stateHistory[message.payload.actionId];
        if (targetState) {
          this.store.dispatch({
            type: "@@RESTORE_STATE",
            payload: targetState,
          });
        }
        break;

      case "TOGGLE_ACTION":
        // Handle action toggling
        this.toggleAction(message.payload.id);
        break;

      case "RESET":
        // Reset to initial state
        this.store.dispatch({ type: "@@RESET" });
        break;

      case "COMMIT":
        // Commit current state as new initial state
        this.actionHistory = [];
        this.stateHistory = [this.store.getState()];
        break;
    }
  }

  logAction(action) {
    this.actionHistory.push({
      action,
      timestamp: Date.now(),
      state: this.store.getState(),
    });

    if (this.connection) {
      this.connection.send(action, this.store.getState());
    }
  }

  toggleAction(actionId) {
    // Implementation for toggling actions
    const targetAction = this.actionHistory[actionId];
    if (targetAction) {
      // Replay all actions except the toggled one
      this.replayActions(
        this.actionHistory.filter((_, index) => index !== actionId)
      );
    }
  }

  replayActions(actions) {
    // Reset to initial state and replay actions
    this.store.dispatch({ type: "@@RESET" });
    actions.forEach(({ action }) => {
      this.store.dispatch(action);
    });
  }
}

// Usage
const customDevTools = new CustomDevTools(store);

// Enhanced action logging
const devToolsMiddleware = (store) => (next) => (action) => {
  const result = next(action);
  customDevTools.logAction(action);
  return result;
};
```

**6. Testing with DevTools:**

```javascript
// DevTools testing utilities
class DevToolsTestHelper {
  constructor(store) {
    this.store = store;
    this.actionLog = [];
    this.stateSnapshots = [];
  }

  // Record actions for testing
  startRecording() {
    this.actionLog = [];
    this.stateSnapshots = [this.store.getState()];

    this.unsubscribe = this.store.subscribe(() => {
      this.stateSnapshots.push(this.store.getState());
    });
  }

  stopRecording() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }

    return {
      actions: this.actionLog,
      states: this.stateSnapshots,
    };
  }

  // Export recorded session
  exportSession() {
    return {
      actions: this.actionLog,
      initialState: this.stateSnapshots[0],
      finalState: this.stateSnapshots[this.stateSnapshots.length - 1],
      timestamp: Date.now(),
    };
  }

  // Import and replay session
  importSession(session) {
    // Reset store to initial state
    this.store.dispatch({
      type: "@@RESTORE_STATE",
      payload: session.initialState,
    });

    // Replay actions
    session.actions.forEach((action) => {
      this.store.dispatch(action);
    });
  }

  // Generate test cases from recorded actions
  generateTests() {
    return this.actionLog.map((action, index) => ({
      description: `should handle ${action.type}`,
      action,
      expectedState: this.stateSnapshots[index + 1],
    }));
  }
}

// Usage in tests
const testHelper = new DevToolsTestHelper(store);

describe("Redux DevTools Integration", () => {
  it("should record and replay actions", () => {
    testHelper.startRecording();

    // Perform actions
    store.dispatch(addTodo("Test todo"));
    store.dispatch(toggleTodo(1));

    const session = testHelper.stopRecording();

    expect(session.actions).toHaveLength(2);
    expect(session.states).toHaveLength(3); // initial + 2 actions
  });

  it("should generate test cases from recorded session", () => {
    const tests = testHelper.generateTests();

    tests.forEach((test) => {
      const newStore = createStore(reducer, test.action.prevState);
      newStore.dispatch(test.action);

      expect(newStore.getState()).toEqual(test.expectedState);
    });
  });
});
```

**Best Practices for DevTools:**

1. **Sanitize sensitive data** in production builds
2. **Limit action history** to prevent memory issues
3. **Use meaningful action types** for better debugging
4. **Add metadata** to actions for context
5. **Configure trace limits** for performance
6. **Use action filtering** to reduce noise
7. **Implement custom monitors** for specific debugging needs
8. **Export/import state** for bug reproduction

**DevTools vs Zustand Debugging:**

```javascript
// Zustand DevTools integration
import { devtools } from "zustand/middleware";

const useStore = create(
  devtools(
    (set, get) => ({
      count: 0,
      increment: () =>
        set((state) => ({ count: state.count + 1 }), false, "increment"),
      decrement: () =>
        set((state) => ({ count: state.count - 1 }), false, "decrement"),
    }),
    {
      name: "counter-store",
      serialize: { options: true },
    }
  )
);
```

**Key Benefits:**

- **Time-travel debugging** for complex state changes
- **Action replay** for bug reproduction
- **Performance monitoring** and optimization
- **State inspection** at any point in time
- **Hot reloading** with state preservation
- **Export/import** for sharing debugging sessions
- **Custom monitoring** for specific use cases

---

### 28. How do you handle loading states and error handling patterns in Redux vs Zustand?

**Answer:**
Proper loading states and error handling are crucial for good user experience. Both Redux and Zustand offer different approaches to manage these patterns effectively.

**Redux Loading States and Error Handling:**

```javascript
// Enhanced slice with comprehensive loading and error handling
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

// Async thunk with detailed error handling
export const fetchTodos = createAsyncThunk(
  "todos/fetchTodos",
  async (params, { rejectWithValue, signal, getState }) => {
    try {
      const response = await todosAPI.fetchTodos(params, { signal });
      return response.data;
    } catch (error) {
      // Handle different error types
      if (error.name === "AbortError") {
        return rejectWithValue({
          type: "CANCELLED",
          message: "Request cancelled",
        });
      }

      if (error.response?.status === 401) {
        return rejectWithValue({
          type: "UNAUTHORIZED",
          message: "Please log in again",
          shouldRedirect: true,
        });
      }

      if (error.response?.status >= 500) {
        return rejectWithValue({
          type: "SERVER_ERROR",
          message: "Server error. Please try again later.",
          retryable: true,
        });
      }

      return rejectWithValue({
        type: "UNKNOWN_ERROR",
        message: error.message || "An unexpected error occurred",
        retryable: false,
      });
    }
  }
);

export const createTodo = createAsyncThunk(
  "todos/createTodo",
  async (todoData, { rejectWithValue, dispatch }) => {
    try {
      const response = await todosAPI.createTodo(todoData);

      // Optimistic update success
      dispatch(todosSlice.actions.addTodoOptimistic(response.data));

      return response.data;
    } catch (error) {
      // Revert optimistic update
      dispatch(todosSlice.actions.revertOptimisticAdd(todoData.tempId));

      return rejectWithValue({
        type: "CREATE_FAILED",
        message: error.response?.data?.message || "Failed to create todo",
        originalData: todoData,
      });
    }
  }
);

// Enhanced todos slice with loading patterns
const todosSlice = createSlice({
  name: "todos",
  initialState: {
    items: [],
    // Multiple loading states for different operations
    loading: {
      fetch: false,
      create: false,
      update: false,
      delete: false,
    },
    // Structured error handling
    errors: {
      fetch: null,
      create: null,
      update: null,
      delete: null,
      global: null,
    },
    // Request metadata
    lastFetch: null,
    retryCount: 0,
    // Optimistic updates tracking
    optimisticUpdates: new Set(),
  },
  reducers: {
    clearError: (state, action) => {
      const { errorType } = action.payload;
      if (errorType) {
        state.errors[errorType] = null;
      } else {
        // Clear all errors
        Object.keys(state.errors).forEach((key) => {
          state.errors[key] = null;
        });
      }
    },

    setGlobalError: (state, action) => {
      state.errors.global = action.payload;
    },

    addTodoOptimistic: (state, action) => {
      const todo = { ...action.payload, optimistic: true };
      state.items.push(todo);
      state.optimisticUpdates.add(todo.id);
    },

    revertOptimisticAdd: (state, action) => {
      const tempId = action.payload;
      state.items = state.items.filter((todo) => todo.tempId !== tempId);
      state.optimisticUpdates.delete(tempId);
    },

    incrementRetryCount: (state) => {
      state.retryCount += 1;
    },

    resetRetryCount: (state) => {
      state.retryCount = 0;
    },
  },
  extraReducers: (builder) => {
    builder
      // Fetch todos
      .addCase(fetchTodos.pending, (state) => {
        state.loading.fetch = true;
        state.errors.fetch = null;
      })
      .addCase(fetchTodos.fulfilled, (state, action) => {
        state.loading.fetch = false;
        state.items = action.payload;
        state.lastFetch = Date.now();
        state.retryCount = 0;
      })
      .addCase(fetchTodos.rejected, (state, action) => {
        state.loading.fetch = false;
        state.errors.fetch = action.payload;

        // Auto-retry for retryable errors
        if (action.payload?.retryable && state.retryCount < 3) {
          state.retryCount += 1;
        }
      })

      // Create todo
      .addCase(createTodo.pending, (state) => {
        state.loading.create = true;
        state.errors.create = null;
      })
      .addCase(createTodo.fulfilled, (state, action) => {
        state.loading.create = false;
        // Remove optimistic update and add real data
        const optimisticIndex = state.items.findIndex(
          (item) => item.tempId === action.meta.arg.tempId
        );
        if (optimisticIndex !== -1) {
          state.items[optimisticIndex] = action.payload;
          state.optimisticUpdates.delete(action.payload.id);
        }
      })
      .addCase(createTodo.rejected, (state, action) => {
        state.loading.create = false;
        state.errors.create = action.payload;
      });
  },
});

export const {
  clearError,
  setGlobalError,
  addTodoOptimistic,
  revertOptimisticAdd,
  incrementRetryCount,
  resetRetryCount,
} = todosSlice.actions;

export default todosSlice.reducer;
```

**Redux Loading and Error Selectors:**

```javascript
// Enhanced selectors for loading and error states
import { createSelector } from "@reduxjs/toolkit";

// Basic selectors
export const selectTodos = (state) => state.todos.items;
export const selectTodosLoading = (state) => state.todos.loading;
export const selectTodosErrors = (state) => state.todos.errors;
export const selectRetryCount = (state) => state.todos.retryCount;

// Computed loading states
export const selectIsAnyLoading = createSelector(
  [selectTodosLoading],
  (loading) => Object.values(loading).some(Boolean)
);

export const selectLoadingByType = createSelector(
  [selectTodosLoading],
  (loading) => (type) => loading[type] || false
);

// Error selectors
export const selectHasAnyError = createSelector([selectTodosErrors], (errors) =>
  Object.values(errors).some((error) => error !== null)
);

export const selectErrorByType = createSelector(
  [selectTodosErrors],
  (errors) => (type) => errors[type]
);

export const selectRetryableErrors = createSelector(
  [selectTodosErrors],
  (errors) =>
    Object.entries(errors)
      .filter(([_, error]) => error?.retryable)
      .map(([type, error]) => ({ type, error }))
);

// Combined loading and error states
export const selectTodosStatus = createSelector(
  [selectTodosLoading, selectTodosErrors, selectRetryCount],
  (loading, errors, retryCount) => ({
    isLoading: Object.values(loading).some(Boolean),
    hasError: Object.values(errors).some((error) => error !== null),
    canRetry: retryCount < 3,
    retryCount,
    loadingStates: loading,
    errors,
  })
);
```

**Zustand Loading States and Error Handling:**

```javascript
// Comprehensive Zustand store with loading and error handling
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import { subscribeWithSelector } from "zustand/middleware";

const useTodosStore = create(
  subscribeWithSelector(
    immer((set, get) => ({
      // State
      items: [],
      loading: {
        fetch: false,
        create: false,
        update: false,
        delete: false,
      },
      errors: {
        fetch: null,
        create: null,
        update: null,
        delete: null,
        global: null,
      },
      retryCount: 0,
      lastFetch: null,
      optimisticUpdates: new Set(),

      // Actions
      fetchTodos: async (params = {}) => {
        set((state) => {
          state.loading.fetch = true;
          state.errors.fetch = null;
        });

        try {
          const response = await todosAPI.fetchTodos(params);

          set((state) => {
            state.items = response.data;
            state.loading.fetch = false;
            state.lastFetch = Date.now();
            state.retryCount = 0;
          });

          return { success: true, data: response.data };
        } catch (error) {
          const errorInfo = get().handleError(error, "fetch");

          set((state) => {
            state.loading.fetch = false;
            state.errors.fetch = errorInfo;

            if (errorInfo.retryable && state.retryCount < 3) {
              state.retryCount += 1;
            }
          });

          return { success: false, error: errorInfo };
        }
      },

      createTodo: async (todoData) => {
        const tempId = `temp_${Date.now()}`;
        const optimisticTodo = { ...todoData, id: tempId, optimistic: true };

        // Optimistic update
        set((state) => {
          state.items.push(optimisticTodo);
          state.optimisticUpdates.add(tempId);
          state.loading.create = true;
          state.errors.create = null;
        });

        try {
          const response = await todosAPI.createTodo(todoData);

          set((state) => {
            // Replace optimistic todo with real one
            const index = state.items.findIndex((item) => item.id === tempId);
            if (index !== -1) {
              state.items[index] = response.data;
            }
            state.optimisticUpdates.delete(tempId);
            state.loading.create = false;
          });

          return { success: true, data: response.data };
        } catch (error) {
          // Revert optimistic update
          set((state) => {
            state.items = state.items.filter((item) => item.id !== tempId);
            state.optimisticUpdates.delete(tempId);
            state.loading.create = false;
            state.errors.create = get().handleError(error, "create");
          });

          return { success: false, error: error.message };
        }
      },

      updateTodo: async (id, updates) => {
        const originalTodo = get().items.find((item) => item.id === id);

        // Optimistic update
        set((state) => {
          const index = state.items.findIndex((item) => item.id === id);
          if (index !== -1) {
            state.items[index] = { ...state.items[index], ...updates };
          }
          state.loading.update = true;
          state.errors.update = null;
        });

        try {
          const response = await todosAPI.updateTodo(id, updates);

          set((state) => {
            const index = state.items.findIndex((item) => item.id === id);
            if (index !== -1) {
              state.items[index] = response.data;
            }
            state.loading.update = false;
          });

          return { success: true, data: response.data };
        } catch (error) {
          // Revert optimistic update
          set((state) => {
            const index = state.items.findIndex((item) => item.id === id);
            if (index !== -1 && originalTodo) {
              state.items[index] = originalTodo;
            }
            state.loading.update = false;
            state.errors.update = get().handleError(error, "update");
          });

          return { success: false, error: error.message };
        }
      },

      deleteTodo: async (id) => {
        const originalTodo = get().items.find((item) => item.id === id);

        // Optimistic removal
        set((state) => {
          state.items = state.items.filter((item) => item.id !== id);
          state.loading.delete = true;
          state.errors.delete = null;
        });

        try {
          await todosAPI.deleteTodo(id);

          set((state) => {
            state.loading.delete = false;
          });

          return { success: true };
        } catch (error) {
          // Revert optimistic removal
          set((state) => {
            if (originalTodo) {
              state.items.push(originalTodo);
              state.items.sort((a, b) => a.createdAt - b.createdAt);
            }
            state.loading.delete = false;
            state.errors.delete = get().handleError(error, "delete");
          });

          return { success: false, error: error.message };
        }
      },

      // Error handling utility
      handleError: (error, operation) => {
        if (error.name === "AbortError") {
          return {
            type: "CANCELLED",
            message: "Request cancelled",
            retryable: false,
          };
        }

        if (error.response?.status === 401) {
          return {
            type: "UNAUTHORIZED",
            message: "Please log in again",
            shouldRedirect: true,
            retryable: false,
          };
        }

        if (error.response?.status >= 500) {
          return {
            type: "SERVER_ERROR",
            message: "Server error. Please try again later.",
            retryable: true,
            operation,
          };
        }

        return {
          type: "UNKNOWN_ERROR",
          message: error.message || "An unexpected error occurred",
          retryable: false,
          operation,
        };
      },

      // Utility actions
      clearError: (errorType) => {
        set((state) => {
          if (errorType) {
            state.errors[errorType] = null;
          } else {
            Object.keys(state.errors).forEach((key) => {
              state.errors[key] = null;
            });
          }
        });
      },

      retry: async (operation, ...args) => {
        const { retryCount } = get();

        if (retryCount >= 3) {
          return { success: false, error: "Maximum retry attempts reached" };
        }

        // Clear previous error
        get().clearError(operation);

        // Retry the operation
        switch (operation) {
          case "fetch":
            return get().fetchTodos(...args);
          case "create":
            return get().createTodo(...args);
          case "update":
            return get().updateTodo(...args);
          case "delete":
            return get().deleteTodo(...args);
          default:
            return { success: false, error: "Unknown operation" };
        }
      },

      // Computed getters
      getLoadingState: () => {
        const { loading } = get();
        return {
          isAnyLoading: Object.values(loading).some(Boolean),
          loadingStates: loading,
        };
      },

      getErrorState: () => {
        const { errors } = get();
        return {
          hasAnyError: Object.values(errors).some((error) => error !== null),
          errors,
          retryableErrors: Object.entries(errors)
            .filter(([_, error]) => error?.retryable)
            .map(([type, error]) => ({ type, error })),
        };
      },
    }))
  )
);

export default useTodosStore;
```

**Loading and Error UI Components:**

```javascript
// Redux Loading Component
import React from "react";
import { useSelector, useDispatch } from "react-redux";
import {
  selectTodosStatus,
  selectRetryableErrors,
  clearError,
} from "../store/todosSlice";

const ReduxTodoList = () => {
  const dispatch = useDispatch();
  const todos = useSelector(selectTodos);
  const status = useSelector(selectTodosStatus);
  const retryableErrors = useSelector(selectRetryableErrors);

  const handleRetry = (errorType) => {
    dispatch(clearError({ errorType }));

    switch (errorType) {
      case "fetch":
        dispatch(fetchTodos());
        break;
      // Handle other retry cases
    }
  };

  if (status.loadingStates.fetch) {
    return (
      <div className="loading-container">
        <div className="spinner" />
        <p>Loading todos...</p>
      </div>
    );
  }

  if (status.errors.fetch) {
    return (
      <div className="error-container">
        <h3>Error Loading Todos</h3>
        <p>{status.errors.fetch.message}</p>
        {status.errors.fetch.retryable && status.canRetry && (
          <button onClick={() => handleRetry("fetch")}>
            Retry ({3 - status.retryCount} attempts left)
          </button>
        )}
      </div>
    );
  }

  return (
    <div>
      {/* Global error display */}
      {retryableErrors.length > 0 && (
        <div className="retry-banner">
          <p>Some operations failed. Would you like to retry?</p>
          {retryableErrors.map(({ type, error }) => (
            <button key={type} onClick={() => handleRetry(type)}>
              Retry {type}
            </button>
          ))}
        </div>
      )}

      {/* Todo list */}
      <ul>
        {todos.map((todo) => (
          <li key={todo.id} className={todo.optimistic ? "optimistic" : ""}>
            {todo.text}
            {status.loadingStates.update && (
              <span className="updating">Updating...</span>
            )}
          </li>
        ))}
      </ul>

      {/* Create todo loading */}
      {status.loadingStates.create && (
        <div className="creating-indicator">Creating new todo...</div>
      )}
    </div>
  );
};

// Zustand Loading Component
const ZustandTodoList = () => {
  const {
    items: todos,
    loading,
    errors,
    retry,
    clearError,
    getLoadingState,
    getErrorState,
  } = useTodosStore();

  const loadingState = getLoadingState();
  const errorState = getErrorState();

  const handleRetry = async (operation) => {
    const result = await retry(operation);
    if (!result.success) {
      console.error("Retry failed:", result.error);
    }
  };

  if (loading.fetch) {
    return (
      <div className="loading-container">
        <div className="spinner" />
        <p>Loading todos...</p>
      </div>
    );
  }

  if (errors.fetch) {
    return (
      <div className="error-container">
        <h3>Error Loading Todos</h3>
        <p>{errors.fetch.message}</p>
        {errors.fetch.retryable && (
          <button onClick={() => handleRetry("fetch")}>Retry</button>
        )}
      </div>
    );
  }

  return (
    <div>
      {/* Error notifications */}
      {errorState.retryableErrors.length > 0 && (
        <div className="error-notifications">
          {errorState.retryableErrors.map(({ type, error }) => (
            <div key={type} className="error-notification">
              <p>{error.message}</p>
              <button onClick={() => handleRetry(type)}>Retry {type}</button>
              <button onClick={() => clearError(type)}></button>
            </div>
          ))}
        </div>
      )}

      {/* Todo list */}
      <ul>
        {todos.map((todo) => (
          <li key={todo.id} className={todo.optimistic ? "optimistic" : ""}>
            {todo.text}
          </li>
        ))}
      </ul>

      {/* Loading indicators */}
      {loadingState.isAnyLoading && (
        <div className="loading-overlay">
          {loading.create && <p>Creating todo...</p>}
          {loading.update && <p>Updating todo...</p>}
          {loading.delete && <p>Deleting todo...</p>}
        </div>
      )}
    </div>
  );
};
```

**Advanced Error Boundary Integration:**

```javascript
// Error Boundary for Redux
class ReduxErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // Log error to Redux store
    this.props.dispatch(
      setGlobalError({
        type: "COMPONENT_ERROR",
        message: error.message,
        stack: error.stack,
        componentStack: errorInfo.componentStack,
      })
    );
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <p>{this.state.error?.message}</p>
          <button onClick={() => window.location.reload()}>Reload Page</button>
        </div>
      );
    }

    return this.props.children;
  }
}

// Zustand Error Boundary
class ZustandErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // Log error to Zustand store
    useTodosStore.getState().setGlobalError({
      type: "COMPONENT_ERROR",
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
    });
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <p>{this.state.error?.message}</p>
          <button
            onClick={() => this.setState({ hasError: false, error: null })}
          >
            Try Again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

**Comparison Summary:**

**Redux Advantages:**

- **Structured error handling** with action types
- **Predictable loading states** through reducers
- **Time-travel debugging** for error scenarios
- **Middleware integration** for global error handling
- **Standardized patterns** for team consistency

**Zustand Advantages:**

- **Simpler error handling** with direct state updates
- **Flexible loading patterns** without boilerplate
- **Built-in optimistic updates** with easy rollback
- **Direct async actions** without thunk complexity
- **Smaller bundle size** for error handling logic

**Best Practices:**

1. **Separate loading states** for different operations
2. **Structured error objects** with type and metadata
3. **Optimistic updates** with rollback capability
4. **Retry mechanisms** for transient failures
5. **Error boundaries** for component-level errors
6. **User-friendly error messages** with actionable steps
7. **Loading indicators** for better UX
8. **Error persistence** across component re-renders

---

### 29. What are the differences between Redux Thunk and Redux Saga? When would you use each?

**Answer:**
Redux Thunk and Redux Saga are both middleware solutions for handling side effects in Redux, but they use fundamentally different approaches and are suited for different use cases.

**Redux Thunk Overview:**

Redux Thunk is the simplest middleware that allows action creators to return functions instead of plain action objects.

```javascript
// Basic Redux Thunk setup
import { configureStore } from "@reduxjs/toolkit";
import thunk from "redux-thunk";
import rootReducer from "./reducers";

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      thunk: {
        extraArgument: { api, logger },
      },
    }),
});

// Simple thunk action creator
const fetchUser = (userId) => {
  return async (dispatch, getState, { api }) => {
    dispatch({ type: "FETCH_USER_START" });

    try {
      const user = await api.fetchUser(userId);
      dispatch({ type: "FETCH_USER_SUCCESS", payload: user });
    } catch (error) {
      dispatch({ type: "FETCH_USER_ERROR", payload: error.message });
    }
  };
};

// Complex thunk with conditional logic
const fetchUserIfNeeded = (userId) => {
  return async (dispatch, getState) => {
    const state = getState();
    const user = state.users.byId[userId];

    // Only fetch if user doesn't exist or is stale
    if (!user || Date.now() - user.lastFetch > 300000) {
      return dispatch(fetchUser(userId));
    }

    return Promise.resolve(user);
  };
};

// Thunk with error handling and retry logic
const fetchUserWithRetry = (userId, retryCount = 0) => {
  return async (dispatch, getState, { api }) => {
    const maxRetries = 3;

    try {
      dispatch({ type: "FETCH_USER_START", payload: { userId, retryCount } });

      const user = await api.fetchUser(userId);
      dispatch({ type: "FETCH_USER_SUCCESS", payload: user });

      return user;
    } catch (error) {
      if (retryCount < maxRetries && error.status >= 500) {
        // Exponential backoff
        const delay = Math.pow(2, retryCount) * 1000;

        setTimeout(() => {
          dispatch(fetchUserWithRetry(userId, retryCount + 1));
        }, delay);
      } else {
        dispatch({
          type: "FETCH_USER_ERROR",
          payload: { error: error.message, userId, retryCount },
        });
      }

      throw error;
    }
  };
};

// Thunk with cancellation support
const createCancellableThunk = (userId) => {
  return (dispatch, getState, { api }) => {
    const abortController = new AbortController();

    const promise = api
      .fetchUser(userId, {
        signal: abortController.signal,
      })
      .then(
        (user) => dispatch({ type: "FETCH_USER_SUCCESS", payload: user }),
        (error) => {
          if (error.name !== "AbortError") {
            dispatch({ type: "FETCH_USER_ERROR", payload: error.message });
          }
        }
      );

    // Return both promise and cancel function
    return {
      promise,
      cancel: () => abortController.abort(),
    };
  };
};
```

**Redux Saga Overview:**

Redux Saga uses ES6 generator functions to create more powerful and testable side effects.

```javascript
// Redux Saga setup
import { configureStore } from "@reduxjs/toolkit";
import createSagaMiddleware from "redux-saga";
import { all, fork } from "redux-saga/effects";
import rootReducer from "./reducers";
import { userSagas } from "./sagas";

const sagaMiddleware = createSagaMiddleware({
  context: {
    api: apiService,
    logger: loggerService,
  },
});

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({ thunk: false }).concat(sagaMiddleware),
});

// Root saga
function* rootSaga() {
  yield all([
    fork(userSagas),
    fork(notificationSagas),
    fork(backgroundSyncSagas),
  ]);
}

sagaMiddleware.run(rootSaga);

// Basic saga
import {
  call,
  put,
  takeEvery,
  takeLatest,
  select,
  race,
  delay,
  cancel,
  fork,
  cancelled,
} from "redux-saga/effects";

function* fetchUserSaga(action) {
  try {
    yield put({ type: "FETCH_USER_START" });

    const user = yield call(api.fetchUser, action.payload.userId);
    yield put({ type: "FETCH_USER_SUCCESS", payload: user });
  } catch (error) {
    yield put({ type: "FETCH_USER_ERROR", payload: error.message });
  }
}

// Advanced saga with race conditions and timeouts
function* fetchUserWithTimeoutSaga(action) {
  try {
    const { response, timeout } = yield race({
      response: call(api.fetchUser, action.payload.userId),
      timeout: delay(5000), // 5 second timeout
    });

    if (timeout) {
      yield put({
        type: "FETCH_USER_ERROR",
        payload: "Request timed out",
      });
    } else {
      yield put({ type: "FETCH_USER_SUCCESS", payload: response });
    }
  } catch (error) {
    yield put({ type: "FETCH_USER_ERROR", payload: error.message });
  }
}

// Saga with retry logic and exponential backoff
function* fetchUserWithRetrySaga(action) {
  const maxRetries = 3;
  let retryCount = 0;

  while (retryCount <= maxRetries) {
    try {
      yield put({
        type: "FETCH_USER_START",
        payload: { userId: action.payload.userId, retryCount },
      });

      const user = yield call(api.fetchUser, action.payload.userId);
      yield put({ type: "FETCH_USER_SUCCESS", payload: user });

      return; // Success, exit retry loop
    } catch (error) {
      retryCount++;

      if (retryCount > maxRetries || error.status < 500) {
        yield put({
          type: "FETCH_USER_ERROR",
          payload: { error: error.message, retryCount },
        });
        return;
      }

      // Exponential backoff
      const delayTime = Math.pow(2, retryCount - 1) * 1000;
      yield delay(delayTime);
    }
  }
}

// Saga with cancellation support
function* fetchUserCancellableSaga(action) {
  try {
    yield put({ type: "FETCH_USER_START" });

    const user = yield call(api.fetchUser, action.payload.userId);
    yield put({ type: "FETCH_USER_SUCCESS", payload: user });
  } catch (error) {
    if (yield cancelled()) {
      yield put({ type: "FETCH_USER_CANCELLED" });
    } else {
      yield put({ type: "FETCH_USER_ERROR", payload: error.message });
    }
  } finally {
    if (yield cancelled()) {
      // Cleanup logic
      console.log("Fetch user saga was cancelled");
    }
  }
}

// Background sync saga
function* backgroundSyncSaga() {
  while (true) {
    try {
      // Check if user is online
      const isOnline = yield select(getIsOnline);

      if (isOnline) {
        // Get pending sync items
        const pendingItems = yield select(getPendingSyncItems);

        if (pendingItems.length > 0) {
          yield put({ type: "SYNC_START" });

          // Process items in parallel with concurrency limit
          yield all(
            pendingItems.slice(0, 5).map((item) => fork(syncItemSaga, item))
          );

          yield put({ type: "SYNC_COMPLETE" });
        }
      }

      // Wait 30 seconds before next sync check
      yield delay(30000);
    } catch (error) {
      console.error("Background sync error:", error);
      yield delay(60000); // Wait longer on error
    }
  }
}

// Complex flow control saga
function* userRegistrationFlowSaga(action) {
  const { email, password, profile } = action.payload;

  try {
    // Step 1: Validate email
    yield put({ type: "VALIDATE_EMAIL_START" });
    const emailValid = yield call(api.validateEmail, email);

    if (!emailValid) {
      yield put({ type: "REGISTRATION_ERROR", payload: "Invalid email" });
      return;
    }

    // Step 2: Create user account
    yield put({ type: "CREATE_ACCOUNT_START" });
    const user = yield call(api.createUser, { email, password });

    // Step 3: Upload profile data
    yield put({ type: "UPLOAD_PROFILE_START" });
    const updatedUser = yield call(api.updateProfile, user.id, profile);

    // Step 4: Send welcome email
    yield fork(sendWelcomeEmailSaga, user.id);

    // Step 5: Initialize user preferences
    yield fork(initializeUserPreferencesSaga, user.id);

    yield put({
      type: "REGISTRATION_SUCCESS",
      payload: updatedUser,
    });

    // Navigate to dashboard
    yield put({ type: "NAVIGATE_TO_DASHBOARD" });
  } catch (error) {
    yield put({
      type: "REGISTRATION_ERROR",
      payload: error.message,
    });
  }
}

// Watcher sagas
function* userSagas() {
  yield takeEvery("FETCH_USER_REQUEST", fetchUserSaga);
  yield takeLatest("FETCH_USER_WITH_TIMEOUT", fetchUserWithTimeoutSaga);
  yield takeEvery("FETCH_USER_WITH_RETRY", fetchUserWithRetrySaga);
  yield takeLatest("REGISTER_USER", userRegistrationFlowSaga);

  // Cancellable saga pattern
  yield takeLatest("FETCH_USER_CANCELLABLE", function* (action) {
    const task = yield fork(fetchUserCancellableSaga, action);

    // Listen for cancel action
    yield take("CANCEL_FETCH_USER");
    yield cancel(task);
  });
}

export { userSagas };
```

**Testing Comparison:**

```javascript
// Testing Redux Thunk
import configureMockStore from "redux-mock-store";
import thunk from "redux-thunk";
import { fetchUser } from "./userActions";

const middlewares = [thunk];
const mockStore = configureMockStore(middlewares);

describe("fetchUser thunk", () => {
  it("should dispatch success action when API call succeeds", async () => {
    const mockApi = {
      fetchUser: jest.fn().mockResolvedValue({ id: 1, name: "John" }),
    };

    const store = mockStore({});

    await store.dispatch(fetchUser(1));

    const actions = store.getActions();
    expect(actions[0]).toEqual({ type: "FETCH_USER_START" });
    expect(actions[1]).toEqual({
      type: "FETCH_USER_SUCCESS",
      payload: { id: 1, name: "John" },
    });
  });
});

// Testing Redux Saga
import { runSaga } from "redux-saga";
import { fetchUserSaga } from "./userSagas";

describe("fetchUserSaga", () => {
  it("should dispatch success action when API call succeeds", async () => {
    const dispatched = [];
    const mockApi = {
      fetchUser: jest.fn().mockResolvedValue({ id: 1, name: "John" }),
    };

    await runSaga(
      {
        dispatch: (action) => dispatched.push(action),
        getState: () => ({}),
      },
      fetchUserSaga,
      { payload: { userId: 1 } }
    ).toPromise();

    expect(dispatched[0]).toEqual({ type: "FETCH_USER_START" });
    expect(dispatched[1]).toEqual({
      type: "FETCH_USER_SUCCESS",
      payload: { id: 1, name: "John" },
    });
  });

  // Testing generator step by step
  it("should handle API call step by step", () => {
    const generator = fetchUserSaga({ payload: { userId: 1 } });

    expect(generator.next().value).toEqual(put({ type: "FETCH_USER_START" }));

    expect(generator.next().value).toEqual(call(api.fetchUser, 1));

    expect(generator.next({ id: 1, name: "John" }).value).toEqual(
      put({ type: "FETCH_USER_SUCCESS", payload: { id: 1, name: "John" } })
    );

    expect(generator.next().done).toBe(true);
  });
});
```

**When to Use Redux Thunk:**

**Advantages:**

- **Simple learning curve** - easy to understand and implement
- **Lightweight** - minimal bundle size impact
- **Direct async/await support** - familiar JavaScript patterns
- **Good for simple side effects** - API calls, basic async logic
- **Less boilerplate** for straightforward use cases
- **Built into Redux Toolkit** by default

**Best for:**

- Simple applications with basic async needs
- Teams new to Redux
- Straightforward API calls and data fetching
- When bundle size is a primary concern
- Applications without complex flow control

**When to Use Redux Saga:**

**Advantages:**

- **Powerful flow control** - complex async workflows
- **Cancellation support** - built-in task cancellation
- **Racing and parallel execution** - advanced concurrency patterns
- **Excellent testing** - step-by-step generator testing
- **Background tasks** - long-running processes
- **Declarative effects** - more predictable side effects

**Best for:**

- Complex applications with intricate async flows
- Applications requiring background synchronization
- When you need advanced cancellation and racing
- Teams comfortable with generator functions
- Applications with complex business logic
- When testing is a high priority

**Comparison Summary:**

| Feature              | Redux Thunk              | Redux Saga           |
| -------------------- | ------------------------ | -------------------- |
| **Learning Curve**   | Easy                     | Moderate to Hard     |
| **Bundle Size**      | Small (~2KB)             | Larger (~25KB)       |
| **Async Patterns**   | Promises/async-await     | Generators           |
| **Cancellation**     | Manual (AbortController) | Built-in             |
| **Testing**          | Standard async testing   | Step-by-step testing |
| **Flow Control**     | Limited                  | Advanced             |
| **Background Tasks** | Difficult                | Excellent            |
| **Racing/Parallel**  | Manual Promise.race      | Built-in effects     |
| **Debugging**        | Standard debugging       | Redux-Saga dev tools |
| **Community**        | Large                    | Smaller but active   |

**Migration Considerations:**

You can use both Redux Thunk and Redux Saga in the same application:

```javascript
// Using both middlewares
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(sagaMiddleware),
  // Thunk is included by default in getDefaultMiddleware
});

// Gradually migrate from thunks to sagas
const fetchUserThunk = (userId) => async (dispatch) => {
  // Simple thunk for basic cases
};

function* complexUserFlowSaga() {
  // Complex saga for advanced cases
}
```

**Recommendation:**

- Start with **Redux Thunk** for most applications
- Migrate to **Redux Saga** when you encounter limitations
- Use **Redux Saga** from the beginning for complex applications
- Consider **RTK Query** as an alternative for data fetching

---

### 30. How do you implement optimistic updates in Redux vs Zustand?

**Answer:**
Optimistic updates improve user experience by immediately updating the UI before the server confirms the change, then handling success or failure accordingly.

**Redux Optimistic Updates:**

```javascript
// Enhanced Redux slice with optimistic updates
import { createSlice, createAsyncThunk, nanoid } from "@reduxjs/toolkit";

// Async thunk for optimistic todo creation
export const createTodoOptimistic = createAsyncThunk(
  "todos/createOptimistic",
  async (todoData, { dispatch, rejectWithValue }) => {
    const tempId = nanoid();
    const optimisticTodo = {
      ...todoData,
      id: tempId,
      createdAt: new Date().toISOString(),
      optimistic: true,
    };

    // Immediately add optimistic todo
    dispatch(todosSlice.actions.addOptimisticTodo(optimisticTodo));

    try {
      const response = await todosAPI.createTodo(todoData);

      // Replace optimistic todo with real one
      dispatch(
        todosSlice.actions.replaceOptimisticTodo({
          tempId,
          realTodo: response.data,
        })
      );

      return response.data;
    } catch (error) {
      // Remove optimistic todo on failure
      dispatch(todosSlice.actions.removeOptimisticTodo(tempId));

      return rejectWithValue({
        error: error.message,
        tempId,
        originalData: todoData,
      });
    }
  }
);

// Optimistic update thunk
export const updateTodoOptimistic = createAsyncThunk(
  "todos/updateOptimistic",
  async ({ id, updates }, { dispatch, getState, rejectWithValue }) => {
    const state = getState();
    const originalTodo = state.todos.items.find((todo) => todo.id === id);

    if (!originalTodo) {
      return rejectWithValue("Todo not found");
    }

    // Apply optimistic update
    dispatch(todosSlice.actions.applyOptimisticUpdate({ id, updates }));

    try {
      const response = await todosAPI.updateTodo(id, updates);

      // Confirm optimistic update with server data
      dispatch(
        todosSlice.actions.confirmOptimisticUpdate({
          id,
          serverData: response.data,
        })
      );

      return response.data;
    } catch (error) {
      // Revert optimistic update
      dispatch(
        todosSlice.actions.revertOptimisticUpdate({
          id,
          originalTodo,
        })
      );

      return rejectWithValue({
        error: error.message,
        id,
        originalTodo,
      });
    }
  }
);

// Optimistic delete thunk
export const deleteTodoOptimistic = createAsyncThunk(
  "todos/deleteOptimistic",
  async (id, { dispatch, getState, rejectWithValue }) => {
    const state = getState();
    const todoToDelete = state.todos.items.find((todo) => todo.id === id);

    if (!todoToDelete) {
      return rejectWithValue("Todo not found");
    }

    // Optimistically remove todo
    dispatch(todosSlice.actions.removeOptimisticTodo(id));

    try {
      await todosAPI.deleteTodo(id);

      // Confirm deletion
      dispatch(todosSlice.actions.confirmOptimisticDelete(id));

      return id;
    } catch (error) {
      // Restore deleted todo
      dispatch(todosSlice.actions.restoreOptimisticTodo(todoToDelete));

      return rejectWithValue({
        error: error.message,
        id,
        restoredTodo: todoToDelete,
      });
    }
  }
);

const todosSlice = createSlice({
  name: "todos",
  initialState: {
    items: [],
    optimisticOperations: new Map(), // Track optimistic operations
    loading: {
      create: false,
      update: false,
      delete: false,
    },
    errors: {
      create: null,
      update: null,
      delete: null,
    },
  },
  reducers: {
    // Optimistic todo creation
    addOptimisticTodo: (state, action) => {
      const todo = action.payload;
      state.items.push(todo);
      state.optimisticOperations.set(todo.id, {
        type: "CREATE",
        timestamp: Date.now(),
        data: todo,
      });
    },

    // Replace optimistic todo with real one
    replaceOptimisticTodo: (state, action) => {
      const { tempId, realTodo } = action.payload;
      const index = state.items.findIndex((todo) => todo.id === tempId);

      if (index !== -1) {
        state.items[index] = realTodo;
        state.optimisticOperations.delete(tempId);
      }
    },

    // Remove optimistic todo
    removeOptimisticTodo: (state, action) => {
      const id = action.payload;
      state.items = state.items.filter((todo) => todo.id !== id);
      state.optimisticOperations.delete(id);
    },

    // Apply optimistic update
    applyOptimisticUpdate: (state, action) => {
      const { id, updates } = action.payload;
      const index = state.items.findIndex((todo) => todo.id === id);

      if (index !== -1) {
        const originalTodo = state.items[index];
        state.items[index] = { ...originalTodo, ...updates };

        state.optimisticOperations.set(id, {
          type: "UPDATE",
          timestamp: Date.now(),
          originalData: originalTodo,
          updates,
        });
      }
    },

    // Confirm optimistic update
    confirmOptimisticUpdate: (state, action) => {
      const { id, serverData } = action.payload;
      const index = state.items.findIndex((todo) => todo.id === id);

      if (index !== -1) {
        state.items[index] = serverData;
        state.optimisticOperations.delete(id);
      }
    },

    // Revert optimistic update
    revertOptimisticUpdate: (state, action) => {
      const { id, originalTodo } = action.payload;
      const index = state.items.findIndex((todo) => todo.id === id);

      if (index !== -1) {
        state.items[index] = originalTodo;
        state.optimisticOperations.delete(id);
      }
    },

    // Confirm optimistic delete
    confirmOptimisticDelete: (state, action) => {
      const id = action.payload;
      state.optimisticOperations.delete(id);
    },

    // Restore optimistically deleted todo
    restoreOptimisticTodo: (state, action) => {
      const todo = action.payload;
      state.items.push(todo);
      state.items.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
      state.optimisticOperations.delete(todo.id);
    },

    // Clear all optimistic operations (for cleanup)
    clearOptimisticOperations: (state) => {
      state.optimisticOperations.clear();
      state.items = state.items.filter((todo) => !todo.optimistic);
    },
  },
  extraReducers: (builder) => {
    builder
      // Handle loading states for optimistic operations
      .addCase(createTodoOptimistic.pending, (state) => {
        state.loading.create = true;
        state.errors.create = null;
      })
      .addCase(createTodoOptimistic.fulfilled, (state) => {
        state.loading.create = false;
      })
      .addCase(createTodoOptimistic.rejected, (state, action) => {
        state.loading.create = false;
        state.errors.create = action.payload;
      })

      .addCase(updateTodoOptimistic.pending, (state) => {
        state.loading.update = true;
        state.errors.update = null;
      })
      .addCase(updateTodoOptimistic.fulfilled, (state) => {
        state.loading.update = false;
      })
      .addCase(updateTodoOptimistic.rejected, (state, action) => {
        state.loading.update = false;
        state.errors.update = action.payload;
      })

      .addCase(deleteTodoOptimistic.pending, (state) => {
        state.loading.delete = true;
        state.errors.delete = null;
      })
      .addCase(deleteTodoOptimistic.fulfilled, (state) => {
        state.loading.delete = false;
      })
      .addCase(deleteTodoOptimistic.rejected, (state, action) => {
        state.loading.delete = false;
        state.errors.delete = action.payload;
      });
  },
});

export const {
  addOptimisticTodo,
  replaceOptimisticTodo,
  removeOptimisticTodo,
  applyOptimisticUpdate,
  confirmOptimisticUpdate,
  revertOptimisticUpdate,
  confirmOptimisticDelete,
  restoreOptimisticTodo,
  clearOptimisticOperations,
} = todosSlice.actions;

export default todosSlice.reducer;
```

**Redux Optimistic Selectors:**

```javascript
// Selectors for optimistic updates
import { createSelector } from "@reduxjs/toolkit";

export const selectTodos = (state) => state.todos.items;
export const selectOptimisticOperations = (state) =>
  state.todos.optimisticOperations;

// Get todos with optimistic status
export const selectTodosWithOptimisticStatus = createSelector(
  [selectTodos, selectOptimisticOperations],
  (todos, operations) => {
    return todos.map((todo) => ({
      ...todo,
      isOptimistic: operations.has(todo.id),
      optimisticOperation: operations.get(todo.id),
    }));
  }
);

// Get only confirmed (non-optimistic) todos
export const selectConfirmedTodos = createSelector(
  [selectTodos, selectOptimisticOperations],
  (todos, operations) => {
    return todos.filter((todo) => !operations.has(todo.id));
  }
);

// Get pending optimistic operations
export const selectPendingOptimisticOperations = createSelector(
  [selectOptimisticOperations],
  (operations) => {
    return Array.from(operations.entries()).map(([id, operation]) => ({
      id,
      ...operation,
    }));
  }
);
```

**Zustand Optimistic Updates:**

```javascript
// Zustand store with optimistic updates
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import { nanoid } from "nanoid";

const useTodosStore = create(
  immer((set, get) => ({
    items: [],
    optimisticOperations: new Map(),
    loading: {
      create: false,
      update: false,
      delete: false,
    },
    errors: {
      create: null,
      update: null,
      delete: null,
    },

    // Optimistic create
    createTodoOptimistic: async (todoData) => {
      const tempId = nanoid();
      const optimisticTodo = {
        ...todoData,
        id: tempId,
        createdAt: new Date().toISOString(),
        optimistic: true,
      };

      // Immediately add optimistic todo
      set((state) => {
        state.items.push(optimisticTodo);
        state.optimisticOperations.set(tempId, {
          type: "CREATE",
          timestamp: Date.now(),
          data: optimisticTodo,
        });
        state.loading.create = true;
        state.errors.create = null;
      });

      try {
        const response = await todosAPI.createTodo(todoData);

        // Replace optimistic todo with real one
        set((state) => {
          const index = state.items.findIndex((todo) => todo.id === tempId);
          if (index !== -1) {
            state.items[index] = response.data;
          }
          state.optimisticOperations.delete(tempId);
          state.loading.create = false;
        });

        return { success: true, data: response.data };
      } catch (error) {
        // Remove optimistic todo on failure
        set((state) => {
          state.items = state.items.filter((todo) => todo.id !== tempId);
          state.optimisticOperations.delete(tempId);
          state.loading.create = false;
          state.errors.create = error.message;
        });

        return { success: false, error: error.message };
      }
    },

    // Optimistic update
    updateTodoOptimistic: async (id, updates) => {
      const originalTodo = get().items.find((todo) => todo.id === id);

      if (!originalTodo) {
        return { success: false, error: "Todo not found" };
      }

      // Apply optimistic update
      set((state) => {
        const index = state.items.findIndex((todo) => todo.id === id);
        if (index !== -1) {
          state.items[index] = { ...state.items[index], ...updates };
          state.optimisticOperations.set(id, {
            type: "UPDATE",
            timestamp: Date.now(),
            originalData: originalTodo,
            updates,
          });
        }
        state.loading.update = true;
        state.errors.update = null;
      });

      try {
        const response = await todosAPI.updateTodo(id, updates);

        // Confirm optimistic update with server data
        set((state) => {
          const index = state.items.findIndex((todo) => todo.id === id);
          if (index !== -1) {
            state.items[index] = response.data;
          }
          state.optimisticOperations.delete(id);
          state.loading.update = false;
        });

        return { success: true, data: response.data };
      } catch (error) {
        // Revert optimistic update
        set((state) => {
          const index = state.items.findIndex((todo) => todo.id === id);
          if (index !== -1) {
            state.items[index] = originalTodo;
          }
          state.optimisticOperations.delete(id);
          state.loading.update = false;
          state.errors.update = error.message;
        });

        return { success: false, error: error.message };
      }
    },

    // Optimistic delete
    deleteTodoOptimistic: async (id) => {
      const todoToDelete = get().items.find((todo) => todo.id === id);

      if (!todoToDelete) {
        return { success: false, error: "Todo not found" };
      }

      // Optimistically remove todo
      set((state) => {
        state.items = state.items.filter((todo) => todo.id !== id);
        state.optimisticOperations.set(id, {
          type: "DELETE",
          timestamp: Date.now(),
          data: todoToDelete,
        });
        state.loading.delete = true;
        state.errors.delete = null;
      });

      try {
        await todosAPI.deleteTodo(id);

        // Confirm deletion
        set((state) => {
          state.optimisticOperations.delete(id);
          state.loading.delete = false;
        });

        return { success: true };
      } catch (error) {
        // Restore deleted todo
        set((state) => {
          state.items.push(todoToDelete);
          state.items.sort(
            (a, b) => new Date(a.createdAt) - new Date(b.createdAt)
          );
          state.optimisticOperations.delete(id);
          state.loading.delete = false;
          state.errors.delete = error.message;
        });

        return { success: false, error: error.message };
      }
    },

    // Batch optimistic operations
    batchOptimisticUpdates: async (operations) => {
      const rollbackData = [];

      // Apply all optimistic updates
      operations.forEach(({ type, id, data }) => {
        const currentState = get();

        switch (type) {
          case "UPDATE":
            const originalTodo = currentState.items.find(
              (todo) => todo.id === id
            );
            if (originalTodo) {
              rollbackData.push({
                type: "UPDATE",
                id,
                originalData: originalTodo,
              });
              get().updateTodoOptimistic(id, data);
            }
            break;
          case "DELETE":
            const todoToDelete = currentState.items.find(
              (todo) => todo.id === id
            );
            if (todoToDelete) {
              rollbackData.push({
                type: "DELETE",
                id,
                originalData: todoToDelete,
              });
              get().deleteTodoOptimistic(id);
            }
            break;
        }
      });

      try {
        // Execute all operations on server
        const promises = operations.map(({ type, id, data }) => {
          switch (type) {
            case "UPDATE":
              return todosAPI.updateTodo(id, data);
            case "DELETE":
              return todosAPI.deleteTodo(id);
            default:
              return Promise.resolve();
          }
        });

        await Promise.all(promises);

        return { success: true };
      } catch (error) {
        // Rollback all optimistic updates
        rollbackData.forEach(({ type, id, originalData }) => {
          set((state) => {
            switch (type) {
              case "UPDATE":
                const updateIndex = state.items.findIndex(
                  (todo) => todo.id === id
                );
                if (updateIndex !== -1) {
                  state.items[updateIndex] = originalData;
                }
                break;
              case "DELETE":
                state.items.push(originalData);
                state.items.sort(
                  (a, b) => new Date(a.createdAt) - new Date(b.createdAt)
                );
                break;
            }
            state.optimisticOperations.delete(id);
          });
        });

        return { success: false, error: error.message };
      }
    },

    // Utility functions
    getOptimisticStatus: (id) => {
      const operations = get().optimisticOperations;
      return operations.has(id) ? operations.get(id) : null;
    },

    getTodosWithOptimisticStatus: () => {
      const { items, optimisticOperations } = get();
      return items.map((todo) => ({
        ...todo,
        isOptimistic: optimisticOperations.has(todo.id),
        optimisticOperation: optimisticOperations.get(todo.id),
      }));
    },

    getPendingOptimisticOperations: () => {
      const operations = get().optimisticOperations;
      return Array.from(operations.entries()).map(([id, operation]) => ({
        id,
        ...operation,
      }));
    },

    clearOptimisticOperations: () => {
      set((state) => {
        state.optimisticOperations.clear();
        state.items = state.items.filter((todo) => !todo.optimistic);
      });
    },
  }))
);

export default useTodosStore;
```

**Optimistic Updates UI Components:**

```javascript
// Redux Optimistic Todo Component
import React from "react";
import { useSelector, useDispatch } from "react-redux";
import {
  createTodoOptimistic,
  updateTodoOptimistic,
  deleteTodoOptimistic,
  selectTodosWithOptimisticStatus,
} from "../store/todosSlice";

const ReduxOptimisticTodoList = () => {
  const dispatch = useDispatch();
  const todosWithStatus = useSelector(selectTodosWithOptimisticStatus);

  const handleCreate = async (todoData) => {
    const result = await dispatch(createTodoOptimistic(todoData));

    if (createTodoOptimistic.rejected.match(result)) {
      // Handle creation failure
      console.error("Failed to create todo:", result.payload);
    }
  };

  const handleUpdate = async (id, updates) => {
    const result = await dispatch(updateTodoOptimistic({ id, updates }));

    if (updateTodoOptimistic.rejected.match(result)) {
      // Handle update failure
      console.error("Failed to update todo:", result.payload);
    }
  };

  const handleDelete = async (id) => {
    const result = await dispatch(deleteTodoOptimistic(id));

    if (deleteTodoOptimistic.rejected.match(result)) {
      // Handle deletion failure
      console.error("Failed to delete todo:", result.payload);
    }
  };

  return (
    <div className="todo-list">
      {todosWithStatus.map((todo) => (
        <div
          key={todo.id}
          className={`todo-item ${
            todo.isOptimistic ? "optimistic" : "confirmed"
          }`}
        >
          <span className="todo-text">{todo.text}</span>

          {todo.isOptimistic && (
            <div className="optimistic-indicator">
              <span className="spinner" />
              <span className="status">
                {todo.optimisticOperation?.type === "CREATE" && "Creating..."}
                {todo.optimisticOperation?.type === "UPDATE" && "Updating..."}
                {todo.optimisticOperation?.type === "DELETE" && "Deleting..."}
              </span>
            </div>
          )}

          <div className="todo-actions">
            <button
              onClick={() =>
                handleUpdate(todo.id, { completed: !todo.completed })
              }
              disabled={todo.isOptimistic}
            >
              {todo.completed ? "Undo" : "Complete"}
            </button>

            <button
              onClick={() => handleDelete(todo.id)}
              disabled={todo.isOptimistic}
              className="delete-btn"
            >
              Delete
            </button>
          </div>
        </div>
      ))}
    </div>
  );
};

// Zustand Optimistic Todo Component
const ZustandOptimisticTodoList = () => {
  const {
    items: todos,
    createTodoOptimistic,
    updateTodoOptimistic,
    deleteTodoOptimistic,
    getTodosWithOptimisticStatus,
  } = useTodosStore();

  const todosWithStatus = getTodosWithOptimisticStatus();

  const handleCreate = async (todoData) => {
    const result = await createTodoOptimistic(todoData);

    if (!result.success) {
      console.error("Failed to create todo:", result.error);
    }
  };

  const handleUpdate = async (id, updates) => {
    const result = await updateTodoOptimistic(id, updates);

    if (!result.success) {
      console.error("Failed to update todo:", result.error);
    }
  };

  const handleDelete = async (id) => {
    const result = await deleteTodoOptimistic(id);

    if (!result.success) {
      console.error("Failed to delete todo:", result.error);
    }
  };

  return (
    <div className="todo-list">
      {todosWithStatus.map((todo) => (
        <div
          key={todo.id}
          className={`todo-item ${
            todo.isOptimistic ? "optimistic" : "confirmed"
          }`}
        >
          <span className="todo-text">{todo.text}</span>

          {todo.isOptimistic && (
            <div className="optimistic-indicator">
              <span className="spinner" />
              <span className="status">
                {todo.optimisticOperation?.type === "CREATE" && "Creating..."}
                {todo.optimisticOperation?.type === "UPDATE" && "Updating..."}
                {todo.optimisticOperation?.type === "DELETE" && "Deleting..."}
              </span>
            </div>
          )}

          <div className="todo-actions">
            <button
              onClick={() =>
                handleUpdate(todo.id, { completed: !todo.completed })
              }
              disabled={todo.isOptimistic}
            >
              {todo.completed ? "Undo" : "Complete"}
            </button>

            <button
              onClick={() => handleDelete(todo.id)}
              disabled={todo.isOptimistic}
              className="delete-btn"
            >
              Delete
            </button>
          </div>
        </div>
      ))}
    </div>
  );
};
```

**Optimistic Updates CSS:**

```css
/* Optimistic updates styling */
.todo-item {
  display: flex;
  align-items: center;
  padding: 12px;
  border: 1px solid #e1e5e9;
  border-radius: 6px;
  margin-bottom: 8px;
  transition: all 0.2s ease;
}

.todo-item.optimistic {
  opacity: 0.7;
  border-color: #fbbf24;
  background-color: #fffbeb;
}

.todo-item.confirmed {
  opacity: 1;
  border-color: #10b981;
  background-color: #f0fdf4;
}

.optimistic-indicator {
  display: flex;
  align-items: center;
  margin-left: auto;
  margin-right: 12px;
  color: #f59e0b;
  font-size: 12px;
}

.spinner {
  width: 12px;
  height: 12px;
  border: 2px solid #f3f4f6;
  border-top: 2px solid #f59e0b;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-right: 6px;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.todo-actions button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
```

**Best Practices for Optimistic Updates:**

1. **Clear Visual Feedback:**

   - Show loading indicators for optimistic operations
   - Use different styling for optimistic vs confirmed items
   - Provide clear error messages when operations fail

2. **Proper Error Handling:**

   - Always revert optimistic changes on failure
   - Preserve original data for rollback
   - Show meaningful error messages to users

3. **Conflict Resolution:**

   - Handle concurrent modifications gracefully
   - Consider server timestamps for conflict detection
   - Implement merge strategies for conflicting updates

4. **Performance Considerations:**

   - Limit the number of concurrent optimistic operations
   - Clean up completed operations to prevent memory leaks
   - Use efficient data structures for tracking operations

5. **User Experience:**
   - Disable actions on items with pending operations
   - Provide undo functionality where appropriate
   - Show progress indicators for long-running operations

**Comparison Summary:**

**Redux Advantages:**

- **Structured approach** with clear action types
- **Time-travel debugging** for optimistic operations
- **Predictable state updates** through reducers
- **Middleware integration** for global optimistic handling

**Zustand Advantages:**

- **Simpler implementation** with direct state updates
- **Flexible rollback logic** without action complexity
- **Built-in async support** without thunk boilerplate
- **Smaller bundle size** for optimistic update logic

Both approaches provide robust optimistic update capabilities, with Redux offering more structure and debugging tools, while Zustand provides simplicity and flexibility.

---

### 31. What is Redux Observable and how does it compare to Redux Saga?

**Answer:**
Redux Observable is a middleware for Redux that uses RxJS observables to handle complex asynchronous operations and side effects. It provides a reactive programming approach to managing async flows in Redux applications.

**Redux Observable Setup:**

```javascript
// Installation: npm install redux-observable rxjs

import { createStore, applyMiddleware } from "redux";
import { createEpicMiddleware, combineEpics } from "redux-observable";
import { ajax } from "rxjs/ajax";
import {
  map,
  mergeMap,
  catchError,
  debounceTime,
  switchMap,
  takeUntil,
  retry,
  delay,
  filter,
  withLatestFrom,
} from "rxjs/operators";
import { of, timer, race, merge } from "rxjs";
import { ofType } from "redux-observable";

// Action types
const FETCH_USER = "FETCH_USER";
const FETCH_USER_SUCCESS = "FETCH_USER_SUCCESS";
const FETCH_USER_FAILURE = "FETCH_USER_FAILURE";
const SEARCH_USERS = "SEARCH_USERS";
const SEARCH_USERS_SUCCESS = "SEARCH_USERS_SUCCESS";
const SEARCH_USERS_FAILURE = "SEARCH_USERS_FAILURE";
const CANCEL_SEARCH = "CANCEL_SEARCH";
const WEBSOCKET_CONNECT = "WEBSOCKET_CONNECT";
const WEBSOCKET_MESSAGE = "WEBSOCKET_MESSAGE";
const WEBSOCKET_DISCONNECT = "WEBSOCKET_DISCONNECT";

// Action creators
const fetchUser = (userId) => ({ type: FETCH_USER, payload: userId });
const fetchUserSuccess = (user) => ({
  type: FETCH_USER_SUCCESS,
  payload: user,
});
const fetchUserFailure = (error) => ({
  type: FETCH_USER_FAILURE,
  payload: error,
});

const searchUsers = (query) => ({ type: SEARCH_USERS, payload: query });
const searchUsersSuccess = (users) => ({
  type: SEARCH_USERS_SUCCESS,
  payload: users,
});
const searchUsersFailure = (error) => ({
  type: SEARCH_USERS_FAILURE,
  payload: error,
});
const cancelSearch = () => ({ type: CANCEL_SEARCH });

const websocketConnect = () => ({ type: WEBSOCKET_CONNECT });
const websocketMessage = (message) => ({
  type: WEBSOCKET_MESSAGE,
  payload: message,
});
const websocketDisconnect = () => ({ type: WEBSOCKET_DISCONNECT });

// Basic Epic - Fetch User
const fetchUserEpic = (action$) =>
  action$.pipe(
    ofType(FETCH_USER),
    mergeMap((action) =>
      ajax.getJSON(`/api/users/${action.payload}`).pipe(
        map((response) => fetchUserSuccess(response)),
        catchError((error) => of(fetchUserFailure(error.message)))
      )
    )
  );

// Advanced Epic - Debounced Search with Cancellation
const searchUsersEpic = (action$) =>
  action$.pipe(
    ofType(SEARCH_USERS),
    debounceTime(300), // Debounce user input
    switchMap(
      (
        action // switchMap cancels previous requests
      ) =>
        ajax.getJSON(`/api/users/search?q=${action.payload}`).pipe(
          map((response) => searchUsersSuccess(response.users)),
          catchError((error) => of(searchUsersFailure(error.message))),
          takeUntil(action$.pipe(ofType(CANCEL_SEARCH))) // Manual cancellation
        )
    )
  );

// Epic with Retry Logic
const fetchUserWithRetryEpic = (action$) =>
  action$.pipe(
    ofType(FETCH_USER),
    mergeMap((action) =>
      ajax.getJSON(`/api/users/${action.payload}`).pipe(
        retry(3), // Retry up to 3 times
        map((response) => fetchUserSuccess(response)),
        catchError((error) => {
          console.error("Failed after 3 retries:", error);
          return of(fetchUserFailure(error.message));
        })
      )
    )
  );

// Epic with Exponential Backoff
const fetchUserWithBackoffEpic = (action$) =>
  action$.pipe(
    ofType(FETCH_USER),
    mergeMap((action) =>
      ajax.getJSON(`/api/users/${action.payload}`).pipe(
        retryWhen((errors) =>
          errors.pipe(
            mergeMap((error, index) => {
              const retryAttempt = index + 1;
              if (retryAttempt > 3) {
                throw error;
              }
              const delayTime = Math.pow(2, retryAttempt) * 1000; // Exponential backoff
              console.log(`Retry attempt ${retryAttempt} after ${delayTime}ms`);
              return timer(delayTime);
            })
          )
        ),
        map((response) => fetchUserSuccess(response)),
        catchError((error) => of(fetchUserFailure(error.message)))
      )
    )
  );

// WebSocket Epic
const websocketEpic = (action$, state$) =>
  action$.pipe(
    ofType(WEBSOCKET_CONNECT),
    switchMap(() => {
      const websocket$ = new Observable((observer) => {
        const ws = new WebSocket("ws://localhost:8080");

        ws.onopen = () => {
          console.log("WebSocket connected");
          observer.next(websocketMessage({ type: "CONNECTED" }));
        };

        ws.onmessage = (event) => {
          const data = JSON.parse(event.data);
          observer.next(websocketMessage(data));
        };

        ws.onerror = (error) => {
          observer.error(error);
        };

        ws.onclose = () => {
          console.log("WebSocket disconnected");
          observer.complete();
        };

        // Cleanup function
        return () => {
          if (ws.readyState === WebSocket.OPEN) {
            ws.close();
          }
        };
      });

      return websocket$.pipe(
        takeUntil(action$.pipe(ofType(WEBSOCKET_DISCONNECT)))
      );
    })
  );

// Polling Epic
const pollingEpic = (action$, state$) =>
  action$.pipe(
    ofType("START_POLLING"),
    switchMap(() =>
      timer(0, 5000).pipe(
        // Poll every 5 seconds
        mergeMap(() =>
          ajax.getJSON("/api/status").pipe(
            map((response) => ({ type: "POLLING_SUCCESS", payload: response })),
            catchError((error) =>
              of({ type: "POLLING_FAILURE", payload: error.message })
            )
          )
        ),
        takeUntil(action$.pipe(ofType("STOP_POLLING")))
      )
    )
  );

// Complex Flow Epic - Race Conditions
const raceConditionEpic = (action$) =>
  action$.pipe(
    ofType("FETCH_DATA_WITH_TIMEOUT"),
    switchMap((action) => {
      const dataRequest$ = ajax
        .getJSON(`/api/data/${action.payload}`)
        .pipe(
          map((response) => ({ type: "FETCH_DATA_SUCCESS", payload: response }))
        );

      const timeout$ = timer(5000).pipe(
        map(() => ({ type: "FETCH_DATA_TIMEOUT" }))
      );

      return race(dataRequest$, timeout$).pipe(
        catchError((error) =>
          of({ type: "FETCH_DATA_FAILURE", payload: error.message })
        )
      );
    })
  );

// Epic with State Access
const conditionalEpic = (action$, state$) =>
  action$.pipe(
    ofType("CONDITIONAL_ACTION"),
    withLatestFrom(state$),
    filter(([action, state]) => state.user.isAuthenticated), // Only proceed if authenticated
    mergeMap(([action, state]) =>
      ajax
        .getJSON("/api/protected-data", {
          Authorization: `Bearer ${state.user.token}`,
        })
        .pipe(
          map((response) => ({
            type: "PROTECTED_DATA_SUCCESS",
            payload: response,
          })),
          catchError((error) =>
            of({ type: "PROTECTED_DATA_FAILURE", payload: error.message })
          )
        )
    )
  );

// Combine all epics
const rootEpic = combineEpics(
  fetchUserEpic,
  searchUsersEpic,
  fetchUserWithRetryEpic,
  fetchUserWithBackoffEpic,
  websocketEpic,
  pollingEpic,
  raceConditionEpic,
  conditionalEpic
);

// Create epic middleware
const epicMiddleware = createEpicMiddleware();

// Create store
const store = createStore(rootReducer, applyMiddleware(epicMiddleware));

// Run the root epic
epicMiddleware.run(rootEpic);
```

**Advanced Redux Observable Patterns:**

```javascript
// Hot Observable Epic - Share expensive operations
const sharedDataEpic = (action$) => {
  const sharedRequest$ = ajax.getJSON("/api/expensive-data").pipe(
    shareReplay(1) // Cache the result for multiple subscribers
  );

  return action$.pipe(
    ofType("REQUEST_SHARED_DATA"),
    switchMap(() =>
      sharedRequest$.pipe(
        map((response) => ({ type: "SHARED_DATA_SUCCESS", payload: response })),
        catchError((error) =>
          of({ type: "SHARED_DATA_FAILURE", payload: error.message })
        )
      )
    )
  );
};

// Buffer and Batch Epic
const batchEpic = (action$) =>
  action$.pipe(
    ofType("BATCH_ACTION"),
    bufferTime(1000), // Collect actions for 1 second
    filter((actions) => actions.length > 0),
    mergeMap((actions) => {
      const batchData = actions.map((action) => action.payload);
      return ajax.post("/api/batch", batchData).pipe(
        map((response) => ({ type: "BATCH_SUCCESS", payload: response })),
        catchError((error) =>
          of({ type: "BATCH_FAILURE", payload: error.message })
        )
      );
    })
  );

// Dependency Injection Epic
const createApiEpic = (dependencies) => (action$, state$) =>
  action$.pipe(
    ofType("API_CALL"),
    mergeMap((action) =>
      dependencies.apiService.getData(action.payload).pipe(
        map((response) => ({ type: "API_SUCCESS", payload: response })),
        catchError((error) =>
          of({ type: "API_FAILURE", payload: error.message })
        )
      )
    )
  );

// Epic with dependencies
const epicMiddleware = createEpicMiddleware({
  dependencies: {
    apiService: new ApiService(),
    logger: new Logger(),
  },
});

// Testing Epic
const testEpic = (action$, state$, dependencies) => {
  const { scheduler } = dependencies;

  return action$.pipe(
    ofType("TEST_ACTION"),
    delay(1000, scheduler), // Use scheduler for testing
    map(() => ({ type: "TEST_SUCCESS" }))
  );
};
```

**Redux Observable vs Redux Saga Comparison:**

```javascript
// Redux Observable - Reactive approach
const fetchUserEpic = (action$) =>
  action$.pipe(
    ofType(FETCH_USER),
    mergeMap((action) =>
      ajax.getJSON(`/api/users/${action.payload}`).pipe(
        map((response) => fetchUserSuccess(response)),
        catchError((error) => of(fetchUserFailure(error.message)))
      )
    )
  );

// Redux Saga - Generator approach
function* fetchUserSaga() {
  try {
    const action = yield take(FETCH_USER);
    const response = yield call(api.getUser, action.payload);
    yield put(fetchUserSuccess(response));
  } catch (error) {
    yield put(fetchUserFailure(error.message));
  }
}

// Complex flow comparison

// Redux Observable - Declarative stream composition
const complexFlowEpic = (action$, state$) =>
  action$.pipe(
    ofType("START_COMPLEX_FLOW"),
    withLatestFrom(state$),
    filter(([action, state]) => state.user.isAuthenticated),
    debounceTime(300),
    switchMap(([action, state]) =>
      merge(
        ajax
          .getJSON("/api/data1")
          .pipe(
            map((response) => ({ type: "DATA1_SUCCESS", payload: response }))
          ),
        ajax
          .getJSON("/api/data2")
          .pipe(
            map((response) => ({ type: "DATA2_SUCCESS", payload: response }))
          )
      ).pipe(
        takeUntil(action$.pipe(ofType("CANCEL_FLOW"))),
        catchError((error) =>
          of({ type: "FLOW_FAILURE", payload: error.message })
        )
      )
    )
  );

// Redux Saga - Imperative step-by-step approach
function* complexFlowSaga() {
  try {
    const action = yield take("START_COMPLEX_FLOW");
    const state = yield select();

    if (!state.user.isAuthenticated) {
      return;
    }

    yield delay(300); // Debounce

    const { data1, data2 } = yield race({
      data1: call(api.getData1),
      data2: call(api.getData2),
      cancel: take("CANCEL_FLOW"),
    });

    if (data1) {
      yield put({ type: "DATA1_SUCCESS", payload: data1 });
    }

    if (data2) {
      yield put({ type: "DATA2_SUCCESS", payload: data2 });
    }
  } catch (error) {
    yield put({ type: "FLOW_FAILURE", payload: error.message });
  }
}
```

**Testing Redux Observable:**

```javascript
import { TestScheduler } from "rxjs/testing";
import { fetchUserEpic } from "./epics";

describe("fetchUserEpic", () => {
  let testScheduler;

  beforeEach(() => {
    testScheduler = new TestScheduler((actual, expected) => {
      expect(actual).toEqual(expected);
    });
  });

  it("should fetch user successfully", () => {
    testScheduler.run(({ hot, cold, expectObservable }) => {
      const action$ = hot("-a", {
        a: { type: FETCH_USER, payload: "123" },
      });

      const dependencies = {
        ajax: {
          getJSON: () =>
            cold("--a|", {
              a: { id: "123", name: "John" },
            }),
        },
      };

      const output$ = fetchUserEpic(action$, null, dependencies);

      expectObservable(output$).toBe("---a", {
        a: {
          type: FETCH_USER_SUCCESS,
          payload: { id: "123", name: "John" },
        },
      });
    });
  });

  it("should handle errors", () => {
    testScheduler.run(({ hot, cold, expectObservable }) => {
      const action$ = hot("-a", {
        a: { type: FETCH_USER, payload: "123" },
      });

      const dependencies = {
        ajax: {
          getJSON: () => cold("--#", null, new Error("Network error")),
        },
      };

      const output$ = fetchUserEpic(action$, null, dependencies);

      expectObservable(output$).toBe("---a", {
        a: {
          type: FETCH_USER_FAILURE,
          payload: "Network error",
        },
      });
    });
  });
});
```

**Comparison Summary:**

| Feature                   | Redux Observable                  | Redux Saga                       |
| ------------------------- | --------------------------------- | -------------------------------- |
| **Learning Curve**        | Steep (RxJS knowledge required)   | Moderate (Generator functions)   |
| **Async Handling**        | Reactive streams                  | Imperative generators            |
| **Cancellation**          | Built-in with operators           | Manual with `cancel()`           |
| **Testing**               | Marble testing with TestScheduler | Easy with step-by-step execution |
| **Debugging**             | Stream visualization tools        | Step-through debugging           |
| **Bundle Size**           | Larger (includes RxJS)            | Smaller                          |
| **Complex Flows**         | Declarative composition           | Imperative control flow          |
| **Error Handling**        | Stream-based with operators       | Try-catch blocks                 |
| **Concurrency**           | Built-in operators (merge, race)  | Manual coordination              |
| **Time-based Operations** | Rich set of operators             | Basic delay/timeout              |

**When to Choose Redux Observable:**

- **Complex async flows** with multiple data streams
- **Real-time applications** with WebSockets or SSE
- **Heavy data transformation** and filtering
- **Time-based operations** (debouncing, throttling, polling)
- **Team familiar with RxJS** and reactive programming
- **Applications requiring advanced cancellation** and backpressure handling

**When to Choose Redux Saga:**

- **Simpler async flows** with clear step-by-step logic
- **Teams new to reactive programming**
- **Applications requiring easy debugging** and testing
- **Background tasks** and long-running processes
- **Complex business logic** with conditional flows
- **Smaller bundle size** requirements

Both Redux Observable and Redux Saga are powerful tools for handling side effects, with Redux Observable excelling in reactive scenarios and Redux Saga providing more straightforward imperative control flow.

---

### 32. How do you implement advanced Zustand subscriptions and reactive patterns?

**Answer:**
Zustand provides powerful subscription mechanisms that allow you to react to state changes in sophisticated ways. These patterns enable reactive programming similar to observables but with a simpler API.

**Basic Zustand Subscriptions:**

```javascript
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";

// Store with subscription middleware
const useStore = create(
  subscribeWithSelector((set, get) => ({
    user: null,
    posts: [],
    notifications: [],
    settings: {
      theme: "light",
      language: "en",
      notifications: true,
    },

    // Actions
    setUser: (user) => set({ user }),
    addPost: (post) =>
      set((state) => ({
        posts: [...state.posts, post],
      })),
    updateSettings: (newSettings) =>
      set((state) => ({
        settings: { ...state.settings, ...newSettings },
      })),
    addNotification: (notification) =>
      set((state) => ({
        notifications: [...state.notifications, notification],
      })),
  }))
);

// Basic subscription to user changes
const unsubscribeUser = useStore.subscribe(
  (state) => state.user,
  (user, previousUser) => {
    console.log("User changed:", { user, previousUser });

    if (user && !previousUser) {
      console.log("User logged in");
      // Trigger side effects for login
    } else if (!user && previousUser) {
      console.log("User logged out");
      // Trigger side effects for logout
    }
  },
  {
    equalityFn: (a, b) => a?.id === b?.id, // Custom equality check
    fireImmediately: false, // Don't fire on subscription
  }
);

// Subscription to nested state changes
const unsubscribeTheme = useStore.subscribe(
  (state) => state.settings.theme,
  (theme) => {
    document.documentElement.setAttribute("data-theme", theme);
    localStorage.setItem("theme", theme);
  }
);

// Multiple state subscription
const unsubscribeMultiple = useStore.subscribe(
  (state) => [state.user, state.settings.notifications],
  ([user, notificationsEnabled]) => {
    if (user && notificationsEnabled) {
      // Setup notification listeners
      console.log("Setting up notifications for user:", user.id);
    } else {
      // Cleanup notification listeners
      console.log("Cleaning up notifications");
    }
  }
);
```

**Advanced Subscription Patterns:**

```javascript
// Debounced subscriptions
const createDebouncedSubscription = (
  store,
  selector,
  callback,
  delay = 300
) => {
  let timeoutId;

  return store.subscribe(selector, (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => callback(...args), delay);
  });
};

// Usage: Debounced search
const unsubscribeSearch = createDebouncedSubscription(
  useStore,
  (state) => state.searchQuery,
  (query) => {
    if (query.length > 2) {
      performSearch(query);
    }
  },
  500
);

// Throttled subscriptions
const createThrottledSubscription = (
  store,
  selector,
  callback,
  delay = 100
) => {
  let lastCall = 0;

  return store.subscribe(selector, (...args) => {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      callback(...args);
    }
  });
};

// Usage: Throttled scroll position tracking
const unsubscribeScroll = createThrottledSubscription(
  useStore,
  (state) => state.scrollPosition,
  (position) => {
    updateScrollIndicator(position);
  },
  16 // ~60fps
);

// Conditional subscriptions
const createConditionalSubscription = (
  store,
  selector,
  condition,
  callback
) => {
  return store.subscribe(selector, (value, previousValue) => {
    if (condition(value, previousValue)) {
      callback(value, previousValue);
    }
  });
};

// Usage: Only react to increases
const unsubscribeScore = createConditionalSubscription(
  useStore,
  (state) => state.gameScore,
  (current, previous) => current > previous,
  (score) => {
    showScoreAnimation(score);
    playSound("score-increase");
  }
);

// Batch subscriptions
const createBatchSubscription = (
  store,
  selectors,
  callback,
  batchDelay = 0
) => {
  const values = new Map();
  let timeoutId;

  const unsubscribers = selectors.map((selector, index) => {
    return store.subscribe(selector, (value) => {
      values.set(index, value);

      if (batchDelay > 0) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          callback(Array.from(values.values()));
        }, batchDelay);
      } else {
        callback(Array.from(values.values()));
      }
    });
  });

  return () => unsubscribers.forEach((unsub) => unsub());
};

// Usage: Batch multiple state changes
const unsubscribeBatch = createBatchSubscription(
  useStore,
  [
    (state) => state.user,
    (state) => state.settings,
    (state) => state.preferences,
  ],
  ([user, settings, preferences]) => {
    updateUserProfile({ user, settings, preferences });
  },
  100 // Batch changes within 100ms
);
```

**Reactive Store with Computed Values:**

```javascript
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";

const useReactiveStore = create(
  subscribeWithSelector((set, get) => {
    const store = {
      // Base state
      todos: [],
      filter: "all", // 'all', 'active', 'completed'
      searchQuery: "",

      // Computed values (will be updated reactively)
      filteredTodos: [],
      todoStats: {
        total: 0,
        active: 0,
        completed: 0,
      },

      // Actions
      addTodo: (text) => {
        const newTodo = {
          id: Date.now(),
          text,
          completed: false,
          createdAt: new Date(),
        };
        set((state) => ({ todos: [...state.todos, newTodo] }));
      },

      toggleTodo: (id) => {
        set((state) => ({
          todos: state.todos.map((todo) =>
            todo.id === id ? { ...todo, completed: !todo.completed } : todo
          ),
        }));
      },

      setFilter: (filter) => set({ filter }),
      setSearchQuery: (searchQuery) => set({ searchQuery }),

      // Reactive computations
      computeFilteredTodos: () => {
        const { todos, filter, searchQuery } = get();

        let filtered = todos;

        // Apply search filter
        if (searchQuery) {
          filtered = filtered.filter((todo) =>
            todo.text.toLowerCase().includes(searchQuery.toLowerCase())
          );
        }

        // Apply status filter
        switch (filter) {
          case "active":
            filtered = filtered.filter((todo) => !todo.completed);
            break;
          case "completed":
            filtered = filtered.filter((todo) => todo.completed);
            break;
          default:
            // 'all' - no additional filtering
            break;
        }

        set({ filteredTodos: filtered });
      },

      computeTodoStats: () => {
        const { todos } = get();

        const stats = {
          total: todos.length,
          active: todos.filter((todo) => !todo.completed).length,
          completed: todos.filter((todo) => todo.completed).length,
        };

        set({ todoStats: stats });
      },
    };

    return store;
  })
);

// Setup reactive subscriptions
const setupReactiveSubscriptions = () => {
  // Recompute filtered todos when todos, filter, or search query changes
  const unsubscribeFiltered = useReactiveStore.subscribe(
    (state) => [state.todos, state.filter, state.searchQuery],
    () => {
      useReactiveStore.getState().computeFilteredTodos();
    },
    { equalityFn: (a, b) => JSON.stringify(a) === JSON.stringify(b) }
  );

  // Recompute stats when todos change
  const unsubscribeStats = useReactiveStore.subscribe(
    (state) => state.todos,
    () => {
      useReactiveStore.getState().computeTodoStats();
    }
  );

  // Cleanup function
  return () => {
    unsubscribeFiltered();
    unsubscribeStats();
  };
};

// Initialize reactive subscriptions
const cleanupReactive = setupReactiveSubscriptions();
```

**Subscription Manager for Complex Applications:**

```javascript
class SubscriptionManager {
  constructor() {
    this.subscriptions = new Map();
    this.groups = new Map();
  }

  // Add a named subscription
  add(name, unsubscriber, group = "default") {
    // Cleanup existing subscription with same name
    if (this.subscriptions.has(name)) {
      this.subscriptions.get(name)();
    }

    this.subscriptions.set(name, unsubscriber);

    // Add to group
    if (!this.groups.has(group)) {
      this.groups.set(group, new Set());
    }
    this.groups.get(group).add(name);
  }

  // Remove a specific subscription
  remove(name) {
    if (this.subscriptions.has(name)) {
      this.subscriptions.get(name)();
      this.subscriptions.delete(name);

      // Remove from groups
      for (const [groupName, groupSubs] of this.groups) {
        groupSubs.delete(name);
        if (groupSubs.size === 0) {
          this.groups.delete(groupName);
        }
      }
    }
  }

  // Remove all subscriptions in a group
  removeGroup(groupName) {
    if (this.groups.has(groupName)) {
      const groupSubs = this.groups.get(groupName);
      for (const name of groupSubs) {
        if (this.subscriptions.has(name)) {
          this.subscriptions.get(name)();
          this.subscriptions.delete(name);
        }
      }
      this.groups.delete(groupName);
    }
  }

  // Remove all subscriptions
  removeAll() {
    for (const unsubscriber of this.subscriptions.values()) {
      unsubscriber();
    }
    this.subscriptions.clear();
    this.groups.clear();
  }

  // Get subscription info
  getInfo() {
    return {
      totalSubscriptions: this.subscriptions.size,
      groups: Array.from(this.groups.entries()).map(([name, subs]) => ({
        name,
        count: subs.size,
        subscriptions: Array.from(subs),
      })),
    };
  }
}

// Usage with subscription manager
const subscriptionManager = new SubscriptionManager();

// Add subscriptions with groups
subscriptionManager.add(
  "userAuth",
  useStore.subscribe(
    (state) => state.user,
    (user) => {
      if (user) {
        initializeUserSession(user);
      } else {
        cleanupUserSession();
      }
    }
  ),
  "authentication"
);

subscriptionManager.add(
  "themeSync",
  useStore.subscribe(
    (state) => state.settings.theme,
    (theme) => {
      document.documentElement.setAttribute("data-theme", theme);
    }
  ),
  "ui"
);

subscriptionManager.add(
  "notificationSettings",
  useStore.subscribe(
    (state) => [state.user, state.settings.notifications],
    ([user, enabled]) => {
      if (user && enabled) {
        enableNotifications(user.id);
      } else {
        disableNotifications();
      }
    }
  ),
  "notifications"
);

// React hook for managing subscriptions
const useSubscriptionManager = () => {
  const managerRef = useRef(new SubscriptionManager());

  useEffect(() => {
    return () => {
      // Cleanup all subscriptions on unmount
      managerRef.current.removeAll();
    };
  }, []);

  return managerRef.current;
};

// Component using subscription manager
const App = () => {
  const subscriptionManager = useSubscriptionManager();

  useEffect(() => {
    // Setup application-level subscriptions
    subscriptionManager.add(
      "appInit",
      useStore.subscribe(
        (state) => state.isInitialized,
        (isInitialized) => {
          if (isInitialized) {
            console.log("App initialized");
            // Setup additional subscriptions
            setupFeatureSubscriptions(subscriptionManager);
          }
        }
      ),
      "app"
    );
  }, []);

  return <div className="app">{/* App content */}</div>;
};
```

**Performance Optimization for Subscriptions:**

```javascript
// Memoized selectors for better performance
const createMemoizedSelector = (selector) => {
  let lastResult;
  let lastArgs;

  return (state) => {
    const args = selector(state);

    if (!lastArgs || !shallowEqual(args, lastArgs)) {
      lastArgs = args;
      lastResult = args;
    }

    return lastResult;
  };
};

// Shallow equality check
const shallowEqual = (a, b) => {
  if (a === b) return true;

  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    return a.every((item, index) => item === b[index]);
  }

  if (typeof a === "object" && typeof b === "object") {
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);

    if (keysA.length !== keysB.length) return false;

    return keysA.every((key) => a[key] === b[key]);
  }

  return false;
};

// Usage with memoized selector
const memoizedUserSelector = createMemoizedSelector((state) => ({
  id: state.user?.id,
  name: state.user?.name,
  email: state.user?.email,
}));

const unsubscribeUser = useStore.subscribe(
  memoizedUserSelector,
  (userData) => {
    updateUserProfile(userData);
  },
  { equalityFn: shallowEqual }
);
```

**Best Practices for Zustand Subscriptions:**

1. **Use subscribeWithSelector middleware** for advanced subscription features
2. **Implement proper cleanup** to prevent memory leaks
3. **Use custom equality functions** for complex state comparisons
4. **Debounce/throttle subscriptions** for performance-sensitive operations
5. **Group related subscriptions** for easier management
6. **Memoize selectors** to prevent unnecessary re-computations
7. **Use subscription managers** for complex applications
8. **Avoid subscribing to entire state** - be specific with selectors
9. **Consider using React hooks** for component-level subscriptions
10. **Test subscription behavior** thoroughly, especially cleanup logic

Zustand's subscription system provides a powerful foundation for reactive programming patterns while maintaining simplicity and performance.

---

### 33. How do you implement caching strategies and data synchronization in Redux vs Zustand?

**Answer:**
Effective caching and data synchronization are crucial for building performant applications. Both Redux and Zustand offer different approaches to handle data caching, invalidation, and synchronization with external sources.

**Redux Caching with RTK Query:**

```javascript
// RTK Query API slice with advanced caching
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

const api = createApi({
  reducerPath: "api",
  baseQuery: fetchBaseQuery({
    baseUrl: "/api",
    prepareHeaders: (headers, { getState }) => {
      const token = getState().auth.token;
      if (token) {
        headers.set("authorization", `Bearer ${token}`);
      }
      return headers;
    },
  }),
  tagTypes: ["User", "Post", "Comment"],
  endpoints: (builder) => ({
    // Users
    getUsers: builder.query({
      query: (params) => ({
        url: "users",
        params: {
          page: params?.page || 1,
          limit: params?.limit || 10,
          search: params?.search,
        },
      }),
      providesTags: (result) =>
        result
          ? [
              ...result.data.map(({ id }) => ({ type: "User", id })),
              { type: "User", id: "LIST" },
            ]
          : [{ type: "User", id: "LIST" }],
      // Cache for 5 minutes
      keepUnusedDataFor: 300,
      // Transform response
      transformResponse: (response) => ({
        data: response.users,
        total: response.total,
        hasMore: response.hasMore,
      }),
    }),

    getUser: builder.query({
      query: (id) => `users/${id}`,
      providesTags: (result, error, id) => [{ type: "User", id }],
      // Cache indefinitely until invalidated
      keepUnusedDataFor: Infinity,
    }),

    updateUser: builder.mutation({
      query: ({ id, ...patch }) => ({
        url: `users/${id}`,
        method: "PATCH",
        body: patch,
      }),
      invalidatesTags: (result, error, { id }) => [
        { type: "User", id },
        { type: "User", id: "LIST" },
      ],
      // Optimistic update
      async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {
        const patchResult = dispatch(
          api.util.updateQueryData("getUser", id, (draft) => {
            Object.assign(draft, patch);
          })
        );

        try {
          await queryFulfilled;
        } catch {
          patchResult.undo();
        }
      },
    }),

    // Posts with relationship caching
    getPosts: builder.query({
      query: (userId) => `users/${userId}/posts`,
      providesTags: (result, error, userId) =>
        result
          ? [
              ...result.map(({ id }) => ({ type: "Post", id })),
              { type: "Post", id: `USER_${userId}` },
            ]
          : [{ type: "Post", id: `USER_${userId}` }],
    }),

    createPost: builder.mutation({
      query: ({ userId, ...post }) => ({
        url: `users/${userId}/posts`,
        method: "POST",
        body: post,
      }),
      invalidatesTags: (result, error, { userId }) => [
        { type: "Post", id: `USER_${userId}` },
      ],
      // Optimistic update for posts list
      async onQueryStarted({ userId, ...post }, { dispatch, queryFulfilled }) {
        const optimisticPost = {
          id: `temp-${Date.now()}`,
          ...post,
          userId,
          createdAt: new Date().toISOString(),
          isOptimistic: true,
        };

        const patchResult = dispatch(
          api.util.updateQueryData("getPosts", userId, (draft) => {
            draft.unshift(optimisticPost);
          })
        );

        try {
          const { data: newPost } = await queryFulfilled;

          // Replace optimistic post with real post
          dispatch(
            api.util.updateQueryData("getPosts", userId, (draft) => {
              const index = draft.findIndex((p) => p.id === optimisticPost.id);
              if (index !== -1) {
                draft[index] = newPost;
              }
            })
          );
        } catch {
          patchResult.undo();
        }
      },
    }),
  }),
});

export const {
  useGetUsersQuery,
  useGetUserQuery,
  useUpdateUserMutation,
  useGetPostsQuery,
  useCreatePostMutation,
} = api;

// Manual cache management
export const cacheUtils = {
  // Prefetch data
  prefetchUser: (id) => (dispatch) => {
    dispatch(api.util.prefetch("getUser", id, { force: false }));
  },

  // Invalidate specific cache
  invalidateUser: (id) => (dispatch) => {
    dispatch(api.util.invalidateTags([{ type: "User", id }]));
  },

  // Update cache manually
  updateUserCache: (id, updates) => (dispatch) => {
    dispatch(
      api.util.updateQueryData("getUser", id, (draft) => {
        Object.assign(draft, updates);
      })
    );
  },

  // Reset all cache
  resetCache: () => (dispatch) => {
    dispatch(api.util.resetApiState());
  },
};
```

**Custom Redux Caching Layer:**

```javascript
// Custom caching slice
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

const createCacheSlice = (name, fetchFn) => {
  const fetchData = createAsyncThunk(
    `${name}/fetchData`,
    async (key, { getState, rejectWithValue }) => {
      const state = getState()[name];
      const cached = state.cache[key];

      // Check if cache is still valid
      if (cached && Date.now() - cached.timestamp < cached.ttl) {
        return { key, data: cached.data, fromCache: true };
      }

      try {
        const data = await fetchFn(key);
        return { key, data, fromCache: false };
      } catch (error) {
        return rejectWithValue(error.message);
      }
    }
  );

  const slice = createSlice({
    name,
    initialState: {
      cache: {},
      loading: {},
      errors: {},
      lastFetch: {},
    },
    reducers: {
      setCacheData: (state, action) => {
        const { key, data, ttl = 300000 } = action.payload; // 5 min default TTL
        state.cache[key] = {
          data,
          timestamp: Date.now(),
          ttl,
        };
        delete state.errors[key];
      },

      invalidateCache: (state, action) => {
        const { keys } = action.payload;
        if (keys) {
          keys.forEach((key) => {
            delete state.cache[key];
            delete state.lastFetch[key];
          });
        } else {
          // Clear all cache
          state.cache = {};
          state.lastFetch = {};
        }
      },

      updateCacheData: (state, action) => {
        const { key, updates } = action.payload;
        if (state.cache[key]) {
          state.cache[key].data = {
            ...state.cache[key].data,
            ...updates,
          };
        }
      },

      removeCacheEntry: (state, action) => {
        const { key } = action.payload;
        delete state.cache[key];
        delete state.loading[key];
        delete state.errors[key];
        delete state.lastFetch[key];
      },
    },
    extraReducers: (builder) => {
      builder
        .addCase(fetchData.pending, (state, action) => {
          const key = action.meta.arg;
          state.loading[key] = true;
          delete state.errors[key];
        })
        .addCase(fetchData.fulfilled, (state, action) => {
          const { key, data, fromCache } = action.payload;
          state.loading[key] = false;

          if (!fromCache) {
            state.cache[key] = {
              data,
              timestamp: Date.now(),
              ttl: 300000, // 5 minutes
            };
            state.lastFetch[key] = Date.now();
          }
        })
        .addCase(fetchData.rejected, (state, action) => {
          const key = action.meta.arg;
          state.loading[key] = false;
          state.errors[key] = action.payload;
        });
    },
  });

  return {
    slice,
    actions: { ...slice.actions, fetchData },
    selectors: {
      selectCacheData: (key) => (state) => state[name].cache[key]?.data,
      selectIsLoading: (key) => (state) => state[name].loading[key] || false,
      selectError: (key) => (state) => state[name].errors[key],
      selectCacheInfo: (key) => (state) => {
        const cached = state[name].cache[key];
        return cached
          ? {
              hasData: true,
              isStale: Date.now() - cached.timestamp > cached.ttl,
              age: Date.now() - cached.timestamp,
            }
          : { hasData: false };
      },
    },
  };
};

// Usage
const userCache = createCacheSlice("userCache", async (userId) => {
  const response = await fetch(`/api/users/${userId}`);
  return response.json();
});

const postCache = createCacheSlice("postCache", async (postId) => {
  const response = await fetch(`/api/posts/${postId}`);
  return response.json();
});
```

**Zustand Caching Implementation:**

```javascript
import { create } from "zustand";
import { persist, subscribeWithSelector } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

// Cache store with advanced features
const useCacheStore = create(
  persist(
    subscribeWithSelector(
      immer((set, get) => ({
        // Cache data structure
        cache: new Map(),
        loading: new Set(),
        errors: new Map(),
        subscriptions: new Map(),

        // Cache configuration
        config: {
          defaultTTL: 5 * 60 * 1000, // 5 minutes
          maxCacheSize: 1000,
          staleWhileRevalidate: true,
        },

        // Core cache operations
        get: async (key, fetchFn, options = {}) => {
          const state = get();
          const cached = state.cache.get(key);
          const now = Date.now();

          // Return cached data if valid
          if (
            cached &&
            now - cached.timestamp < (options.ttl || state.config.defaultTTL)
          ) {
            return cached.data;
          }

          // Return stale data while revalidating
          if (
            cached &&
            state.config.staleWhileRevalidate &&
            !state.loading.has(key)
          ) {
            // Start background revalidation
            state.revalidate(key, fetchFn, options);
            return cached.data;
          }

          // Fetch fresh data
          return state.fetch(key, fetchFn, options);
        },

        fetch: async (key, fetchFn, options = {}) => {
          const state = get();

          // Prevent duplicate requests
          if (state.loading.has(key)) {
            return new Promise((resolve, reject) => {
              const unsubscribe = useCacheStore.subscribe(
                (state) => state.loading.has(key),
                (isLoading) => {
                  if (!isLoading) {
                    unsubscribe();
                    const cached = state.cache.get(key);
                    if (cached) {
                      resolve(cached.data);
                    } else {
                      const error = state.errors.get(key);
                      reject(error || new Error("Fetch failed"));
                    }
                  }
                }
              );
            });
          }

          set((draft) => {
            draft.loading.add(key);
            draft.errors.delete(key);
          });

          try {
            const data = await fetchFn(key);

            set((draft) => {
              // Implement LRU eviction if cache is full
              if (draft.cache.size >= draft.config.maxCacheSize) {
                const oldestKey = draft.cache.keys().next().value;
                draft.cache.delete(oldestKey);
              }

              draft.cache.set(key, {
                data,
                timestamp: Date.now(),
                ttl: options.ttl || draft.config.defaultTTL,
              });
              draft.loading.delete(key);
            });

            return data;
          } catch (error) {
            set((draft) => {
              draft.loading.delete(key);
              draft.errors.set(key, error);
            });
            throw error;
          }
        },

        revalidate: async (key, fetchFn, options = {}) => {
          try {
            const data = await fetchFn(key);
            set((draft) => {
              draft.cache.set(key, {
                data,
                timestamp: Date.now(),
                ttl: options.ttl || draft.config.defaultTTL,
              });
            });
            return data;
          } catch (error) {
            console.warn(`Revalidation failed for ${key}:`, error);
            return null;
          }
        },

        set: (key, data, options = {}) => {
          set((draft) => {
            draft.cache.set(key, {
              data,
              timestamp: Date.now(),
              ttl: options.ttl || draft.config.defaultTTL,
            });
            draft.errors.delete(key);
          });
        },

        update: (key, updater) => {
          set((draft) => {
            const cached = draft.cache.get(key);
            if (cached) {
              const updatedData =
                typeof updater === "function"
                  ? updater(cached.data)
                  : { ...cached.data, ...updater };

              draft.cache.set(key, {
                ...cached,
                data: updatedData,
              });
            }
          });
        },

        invalidate: (keys) => {
          set((draft) => {
            if (Array.isArray(keys)) {
              keys.forEach((key) => {
                draft.cache.delete(key);
                draft.errors.delete(key);
              });
            } else if (keys) {
              draft.cache.delete(keys);
              draft.errors.delete(keys);
            } else {
              // Clear all cache
              draft.cache.clear();
              draft.errors.clear();
            }
          });
        },

        // Subscription management
        subscribe: (key, callback) => {
          const state = get();
          const subscribers = state.subscriptions.get(key) || new Set();
          subscribers.add(callback);

          set((draft) => {
            draft.subscriptions.set(key, subscribers);
          });

          // Return unsubscribe function
          return () => {
            const currentSubscribers = get().subscriptions.get(key);
            if (currentSubscribers) {
              currentSubscribers.delete(callback);
              if (currentSubscribers.size === 0) {
                set((draft) => {
                  draft.subscriptions.delete(key);
                });
              }
            }
          };
        },

        // Utility methods
        getCacheInfo: (key) => {
          const state = get();
          const cached = state.cache.get(key);
          const now = Date.now();

          if (!cached) {
            return { exists: false };
          }

          return {
            exists: true,
            age: now - cached.timestamp,
            isStale: now - cached.timestamp > cached.ttl,
            size: JSON.stringify(cached.data).length,
          };
        },

        getStats: () => {
          const state = get();
          return {
            cacheSize: state.cache.size,
            loadingCount: state.loading.size,
            errorCount: state.errors.size,
            subscriptionCount: state.subscriptions.size,
            totalMemory: Array.from(state.cache.values()).reduce(
              (total, item) => total + JSON.stringify(item.data).length,
              0
            ),
          };
        },

        cleanup: () => {
          const state = get();
          const now = Date.now();

          set((draft) => {
            // Remove expired entries
            for (const [key, cached] of draft.cache) {
              if (now - cached.timestamp > cached.ttl) {
                draft.cache.delete(key);
                draft.errors.delete(key);
              }
            }
          });
        },
      }))
    ),
    {
      name: "cache-store",
      // Only persist cache data, not loading/error states
      partialize: (state) => ({ cache: state.cache }),
      // Custom serialization for Map
      serialize: (state) =>
        JSON.stringify({
          ...state,
          cache: Array.from(state.cache.entries()),
        }),
      deserialize: (str) => {
        const parsed = JSON.parse(str);
        return {
          ...parsed,
          cache: new Map(parsed.cache || []),
        };
      },
    }
  )
);

// Higher-order hook for cached data fetching
const useCachedData = (key, fetchFn, options = {}) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const cacheStore = useCacheStore();

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const result = await cacheStore.get(key, fetchFn, options);
      setData(result);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }, [key, fetchFn, options, cacheStore]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Subscribe to cache changes
  useEffect(() => {
    const unsubscribe = cacheStore.subscribe(key, (newData) => {
      setData(newData);
    });

    return unsubscribe;
  }, [key, cacheStore]);

  const refetch = useCallback(() => {
    cacheStore.invalidate(key);
    fetchData();
  }, [key, cacheStore, fetchData]);

  const updateData = useCallback(
    (updater) => {
      cacheStore.update(key, updater);
    },
    [key, cacheStore]
  );

  return {
    data,
    loading,
    error,
    refetch,
    updateData,
    cacheInfo: cacheStore.getCacheInfo(key),
  };
};

// Usage examples
const UserProfile = ({ userId }) => {
  const {
    data: user,
    loading,
    error,
    refetch,
    updateData,
  } = useCachedData(
    `user-${userId}`,
    async () => {
      const response = await fetch(`/api/users/${userId}`);
      return response.json();
    },
    { ttl: 10 * 60 * 1000 } // 10 minutes
  );

  const handleUpdateName = (newName) => {
    updateData((currentUser) => ({
      ...currentUser,
      name: newName,
    }));
  };

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  if (!user) return <div>No user found</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <button onClick={refetch}>Refresh</button>
      <button onClick={() => handleUpdateName("New Name")}>Update Name</button>
    </div>
  );
};
```

**Data Synchronization Patterns:**

```javascript
// Real-time synchronization with WebSocket
const useRealtimeSync = () => {
  const cacheStore = useCacheStore();

  useEffect(() => {
    const ws = new WebSocket("ws://localhost:8080");

    ws.onmessage = (event) => {
      const { type, key, data } = JSON.parse(event.data);

      switch (type) {
        case "UPDATE":
          cacheStore.set(key, data);
          break;
        case "DELETE":
          cacheStore.invalidate(key);
          break;
        case "INVALIDATE":
          cacheStore.invalidate(key);
          break;
      }
    };

    return () => ws.close();
  }, [cacheStore]);
};

// Periodic background sync
const useBackgroundSync = (keys, fetchFunctions, interval = 60000) => {
  const cacheStore = useCacheStore();

  useEffect(() => {
    const syncData = async () => {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const fetchFn = fetchFunctions[i];

        try {
          await cacheStore.revalidate(key, fetchFn);
        } catch (error) {
          console.warn(`Background sync failed for ${key}:`, error);
        }
      }
    };

    const intervalId = setInterval(syncData, interval);

    return () => clearInterval(intervalId);
  }, [keys, fetchFunctions, interval, cacheStore]);
};

// Optimistic updates with rollback
const useOptimisticUpdate = () => {
  const cacheStore = useCacheStore();

  const performOptimisticUpdate = async (key, optimisticData, updateFn) => {
    // Store original data for rollback
    const originalData = cacheStore.cache.get(key)?.data;

    // Apply optimistic update
    cacheStore.set(key, optimisticData);

    try {
      // Perform actual update
      const result = await updateFn();

      // Update with real data
      cacheStore.set(key, result);

      return result;
    } catch (error) {
      // Rollback on error
      if (originalData) {
        cacheStore.set(key, originalData);
      } else {
        cacheStore.invalidate(key);
      }

      throw error;
    }
  };

  return { performOptimisticUpdate };
};
```

**Comparison Summary:**

| Feature                | Redux (RTK Query)                                      | Zustand Custom Cache               |
| ---------------------- | ------------------------------------------------------ | ---------------------------------- |
| **Setup Complexity**   | Medium (requires RTK setup)                            | Low (simple store creation)        |
| **Built-in Features**  | Comprehensive (tags, invalidation, optimistic updates) | Custom implementation needed       |
| **Bundle Size**        | Larger (RTK Query + Redux)                             | Smaller (minimal dependencies)     |
| **TypeScript Support** | Excellent (auto-generated types)                       | Good (manual typing)               |
| **DevTools**           | Excellent Redux DevTools integration                   | Basic Zustand DevTools             |
| **Caching Strategy**   | Tag-based invalidation                                 | TTL-based with manual invalidation |
| **Real-time Updates**  | Manual implementation                                  | Easy WebSocket integration         |
| **Persistence**        | Requires additional setup                              | Built-in with persist middleware   |
| **Learning Curve**     | Steeper (RTK Query concepts)                           | Gentler (straightforward API)      |
| **Flexibility**        | Structured approach                                    | Highly customizable                |

**Best Practices:**

1. **Choose the right strategy** based on your application's complexity and requirements
2. **Implement proper cache invalidation** to prevent stale data issues
3. **Use optimistic updates** for better user experience
4. **Monitor cache performance** and implement cleanup strategies
5. **Handle offline scenarios** with appropriate fallback mechanisms
6. **Implement proper error handling** and retry logic
7. **Use background synchronization** for critical data
8. **Consider memory usage** and implement cache size limits
9. **Test caching behavior** thoroughly, especially edge cases
10. **Document your caching strategy** for team understanding

Both approaches offer powerful caching capabilities, with Redux providing more structure and Zustand offering more flexibility for custom implementations.

---

### 34. How do you handle concurrent updates and race conditions in Redux vs Zustand?

**Answer:**
Concurrent updates and race conditions are common challenges in modern applications, especially when dealing with asynchronous operations, real-time updates, and multiple user interactions. Both Redux and Zustand provide different approaches to handle these scenarios.

**Redux Race Condition Handling:**

```javascript
// Redux Toolkit with race condition handling
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

// Async thunk with race condition protection
const fetchUserWithRaceProtection = createAsyncThunk(
  "user/fetchUser",
  async (userId, { getState, signal, rejectWithValue }) => {
    // Check if request is already in progress
    const state = getState();
    if (state.user.loading[userId]) {
      return rejectWithValue("Request already in progress");
    }

    try {
      const response = await fetch(`/api/users/${userId}`, {
        signal, // AbortController signal for cancellation
      });

      if (!response.ok) {
        throw new Error("Failed to fetch user");
      }

      return await response.json();
    } catch (error) {
      if (error.name === "AbortError") {
        return rejectWithValue("Request was cancelled");
      }
      throw error;
    }
  },
  {
    condition: (userId, { getState }) => {
      // Prevent duplicate requests
      const state = getState();
      return !state.user.loading[userId];
    },
  }
);

// Advanced async thunk with request deduplication
const createDedupedAsyncThunk = (typePrefix, payloadCreator) => {
  const pendingRequests = new Map();

  return createAsyncThunk(typePrefix, async (arg, thunkAPI) => {
    const key = JSON.stringify(arg);

    // Return existing promise if request is already pending
    if (pendingRequests.has(key)) {
      return pendingRequests.get(key);
    }

    const promise = payloadCreator(arg, thunkAPI);
    pendingRequests.set(key, promise);

    try {
      const result = await promise;
      pendingRequests.delete(key);
      return result;
    } catch (error) {
      pendingRequests.delete(key);
      throw error;
    }
  });
};

// Usage of deduped async thunk
const fetchUserDeduped = createDedupedAsyncThunk(
  "user/fetchUserDeduped",
  async (userId, { signal }) => {
    const response = await fetch(`/api/users/${userId}`, { signal });
    return response.json();
  }
);

// User slice with concurrent update handling
const userSlice = createSlice({
  name: "user",
  initialState: {
    entities: {},
    loading: {},
    errors: {},
    lastUpdated: {},
    optimisticUpdates: {},
    requestIds: {}, // Track request IDs for cancellation
  },
  reducers: {
    // Optimistic update with conflict resolution
    updateUserOptimistic: (state, action) => {
      const { userId, updates, requestId } = action.payload;
      const timestamp = Date.now();

      // Store optimistic update
      state.optimisticUpdates[userId] = {
        updates,
        timestamp,
        requestId,
      };

      // Apply optimistic update
      if (state.entities[userId]) {
        state.entities[userId] = {
          ...state.entities[userId],
          ...updates,
          _optimistic: true,
          _optimisticTimestamp: timestamp,
        };
      }
    },

    // Resolve optimistic update
    resolveOptimisticUpdate: (state, action) => {
      const { userId, serverData, requestId } = action.payload;
      const optimistic = state.optimisticUpdates[userId];

      if (optimistic && optimistic.requestId === requestId) {
        // Remove optimistic flag and apply server data
        state.entities[userId] = {
          ...serverData,
          _optimistic: false,
        };
        delete state.optimisticUpdates[userId];
        state.lastUpdated[userId] = Date.now();
      }
    },

    // Handle conflicting updates
    handleUpdateConflict: (state, action) => {
      const {
        userId,
        localUpdates,
        serverData,
        strategy = "server-wins",
      } = action.payload;

      switch (strategy) {
        case "server-wins":
          state.entities[userId] = serverData;
          break;

        case "client-wins":
          state.entities[userId] = {
            ...serverData,
            ...localUpdates,
          };
          break;

        case "merge":
          // Custom merge logic
          state.entities[userId] = mergeUpdates(serverData, localUpdates);
          break;

        case "manual":
          // Store conflict for manual resolution
          state.entities[userId] = {
            ...serverData,
            _conflict: {
              local: localUpdates,
              server: serverData,
              timestamp: Date.now(),
            },
          };
          break;
      }

      delete state.optimisticUpdates[userId];
    },

    // Cancel pending request
    cancelRequest: (state, action) => {
      const { userId } = action.payload;
      delete state.loading[userId];
      delete state.requestIds[userId];
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUserWithRaceProtection.pending, (state, action) => {
        const userId = action.meta.arg;
        state.loading[userId] = true;
        state.requestIds[userId] = action.meta.requestId;
        delete state.errors[userId];
      })
      .addCase(fetchUserWithRaceProtection.fulfilled, (state, action) => {
        const userId = action.meta.arg;
        const requestId = action.meta.requestId;

        // Only update if this is the latest request
        if (state.requestIds[userId] === requestId) {
          state.entities[userId] = action.payload;
          state.loading[userId] = false;
          state.lastUpdated[userId] = Date.now();
          delete state.requestIds[userId];
        }
      })
      .addCase(fetchUserWithRaceProtection.rejected, (state, action) => {
        const userId = action.meta.arg;
        const requestId = action.meta.requestId;

        // Only update error if this is the latest request
        if (state.requestIds[userId] === requestId) {
          state.loading[userId] = false;
          state.errors[userId] = action.payload;
          delete state.requestIds[userId];
        }
      });
  },
});

// Custom merge function for conflict resolution
const mergeUpdates = (serverData, localUpdates) => {
  const merged = { ...serverData };

  // Custom merge logic based on field types
  Object.keys(localUpdates).forEach((key) => {
    if (key === "name" || key === "email") {
      // Client wins for user-editable fields
      merged[key] = localUpdates[key];
    } else if (key === "lastLogin" || key === "createdAt") {
      // Server wins for system fields
      merged[key] = serverData[key];
    } else if (
      typeof localUpdates[key] === "number" &&
      typeof serverData[key] === "number"
    ) {
      // Take the maximum for numeric fields
      merged[key] = Math.max(localUpdates[key], serverData[key]);
    } else {
      // Default to local updates
      merged[key] = localUpdates[key];
    }
  });

  return merged;
};

// Middleware for handling concurrent updates
const concurrentUpdateMiddleware = (store) => (next) => (action) => {
  if (action.type.endsWith("/pending")) {
    const state = store.getState();
    const userId = action.meta?.arg;

    // Cancel previous request if exists
    if (userId && state.user.requestIds[userId]) {
      // Dispatch cancel action for previous request
      store.dispatch(userSlice.actions.cancelRequest({ userId }));
    }
  }

  return next(action);
};

export const {
  updateUserOptimistic,
  resolveOptimisticUpdate,
  handleUpdateConflict,
} = userSlice.actions;
```

**Zustand Concurrent Update Handling:**

```javascript
import { create } from "zustand";
import { subscribeWithSelector } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

// Zustand store with race condition protection
const useUserStore = create(
  subscribeWithSelector(
    immer((set, get) => ({
      users: new Map(),
      loading: new Set(),
      errors: new Map(),
      pendingRequests: new Map(),
      optimisticUpdates: new Map(),
      lastUpdated: new Map(),

      // Fetch user with race protection
      fetchUser: async (userId) => {
        const state = get();

        // Check if request is already pending
        if (state.loading.has(userId)) {
          return state.pendingRequests.get(userId);
        }

        // Create abort controller for cancellation
        const abortController = new AbortController();

        const fetchPromise = (async () => {
          set((draft) => {
            draft.loading.add(userId);
            draft.errors.delete(userId);
          });

          try {
            const response = await fetch(`/api/users/${userId}`, {
              signal: abortController.signal,
            });

            if (!response.ok) {
              throw new Error("Failed to fetch user");
            }

            const userData = await response.json();

            set((draft) => {
              // Only update if request wasn't cancelled
              if (draft.loading.has(userId)) {
                draft.users.set(userId, userData);
                draft.loading.delete(userId);
                draft.lastUpdated.set(userId, Date.now());
                draft.pendingRequests.delete(userId);
              }
            });

            return userData;
          } catch (error) {
            if (error.name !== "AbortError") {
              set((draft) => {
                draft.loading.delete(userId);
                draft.errors.set(userId, error.message);
                draft.pendingRequests.delete(userId);
              });
            }
            throw error;
          }
        })();

        // Store promise and abort controller
        set((draft) => {
          draft.pendingRequests.set(userId, {
            promise: fetchPromise,
            abortController,
          });
        });

        return fetchPromise;
      },

      // Cancel pending request
      cancelRequest: (userId) => {
        const state = get();
        const pending = state.pendingRequests.get(userId);

        if (pending) {
          pending.abortController.abort();

          set((draft) => {
            draft.loading.delete(userId);
            draft.pendingRequests.delete(userId);
          });
        }
      },

      // Optimistic update with conflict resolution
      updateUserOptimistic: async (userId, updates, updateFn) => {
        const state = get();
        const originalUser = state.users.get(userId);
        const requestId = `${userId}-${Date.now()}`;

        // Apply optimistic update
        set((draft) => {
          const currentUser = draft.users.get(userId);
          if (currentUser) {
            const optimisticUser = { ...currentUser, ...updates };
            draft.users.set(userId, optimisticUser);
            draft.optimisticUpdates.set(userId, {
              original: originalUser,
              updates,
              requestId,
              timestamp: Date.now(),
            });
          }
        });

        try {
          // Perform actual update
          const serverData = await updateFn(userId, updates);

          set((draft) => {
            const optimistic = draft.optimisticUpdates.get(userId);

            // Only apply if this is the latest optimistic update
            if (optimistic && optimistic.requestId === requestId) {
              draft.users.set(userId, serverData);
              draft.optimisticUpdates.delete(userId);
              draft.lastUpdated.set(userId, Date.now());
            }
          });

          return serverData;
        } catch (error) {
          // Rollback optimistic update
          set((draft) => {
            const optimistic = draft.optimisticUpdates.get(userId);

            if (optimistic && optimistic.requestId === requestId) {
              if (optimistic.original) {
                draft.users.set(userId, optimistic.original);
              } else {
                draft.users.delete(userId);
              }
              draft.optimisticUpdates.delete(userId);
            }
          });

          throw error;
        }
      },

      // Handle concurrent updates with different strategies
      handleConcurrentUpdate: (
        userId,
        localUpdates,
        serverData,
        strategy = "server-wins"
      ) => {
        set((draft) => {
          switch (strategy) {
            case "server-wins":
              draft.users.set(userId, serverData);
              break;

            case "client-wins":
              draft.users.set(userId, { ...serverData, ...localUpdates });
              break;

            case "merge":
              const merged = mergeUserData(serverData, localUpdates);
              draft.users.set(userId, merged);
              break;

            case "timestamp":
              // Use timestamps to determine winner
              const localTimestamp = localUpdates._timestamp || 0;
              const serverTimestamp = serverData._timestamp || 0;

              if (localTimestamp > serverTimestamp) {
                draft.users.set(userId, { ...serverData, ...localUpdates });
              } else {
                draft.users.set(userId, serverData);
              }
              break;

            case "field-level":
              // Merge at field level based on timestamps
              const fieldMerged = mergeByFieldTimestamps(
                serverData,
                localUpdates
              );
              draft.users.set(userId, fieldMerged);
              break;
          }

          draft.optimisticUpdates.delete(userId);
          draft.lastUpdated.set(userId, Date.now());
        });
      },

      // Batch updates to prevent race conditions
      batchUpdate: (updates) => {
        set((draft) => {
          updates.forEach(({ userId, data }) => {
            draft.users.set(userId, data);
            draft.lastUpdated.set(userId, Date.now());
          });
        });
      },

      // Debounced update to prevent excessive API calls
      debouncedUpdate: (() => {
        const debounceMap = new Map();

        return (userId, updates, delay = 500) => {
          // Clear existing timeout
          if (debounceMap.has(userId)) {
            clearTimeout(debounceMap.get(userId));
          }

          // Apply immediate optimistic update
          set((draft) => {
            const currentUser = draft.users.get(userId);
            if (currentUser) {
              draft.users.set(userId, { ...currentUser, ...updates });
            }
          });

          // Set new timeout for actual update
          const timeoutId = setTimeout(async () => {
            try {
              const response = await fetch(`/api/users/${userId}`, {
                method: "PATCH",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(updates),
              });

              const serverData = await response.json();

              set((draft) => {
                draft.users.set(userId, serverData);
                draft.lastUpdated.set(userId, Date.now());
              });
            } catch (error) {
              console.error("Debounced update failed:", error);
              // Could implement retry logic here
            } finally {
              debounceMap.delete(userId);
            }
          }, delay);

          debounceMap.set(userId, timeoutId);
        };
      })(),
    }))
  )
);

// Helper functions for merging data
const mergeUserData = (serverData, localUpdates) => {
  const merged = { ...serverData };

  // Custom merge logic
  Object.keys(localUpdates).forEach((key) => {
    if (key.startsWith("_")) {
      // Skip internal fields
      return;
    }

    if (key === "preferences" && typeof localUpdates[key] === "object") {
      // Deep merge for preferences
      merged[key] = { ...serverData[key], ...localUpdates[key] };
    } else {
      merged[key] = localUpdates[key];
    }
  });

  return merged;
};

const mergeByFieldTimestamps = (serverData, localUpdates) => {
  const merged = { ...serverData };

  Object.keys(localUpdates).forEach((key) => {
    const localTimestamp = localUpdates[`${key}_timestamp`] || 0;
    const serverTimestamp = serverData[`${key}_timestamp`] || 0;

    if (localTimestamp >= serverTimestamp) {
      merged[key] = localUpdates[key];
      merged[`${key}_timestamp`] = localTimestamp;
    }
  });

  return merged;
};

// React hook for handling concurrent updates
const useUserWithConcurrency = (userId) => {
  const store = useUserStore();
  const [localUpdates, setLocalUpdates] = useState({});
  const [isConflicted, setIsConflicted] = useState(false);

  const user = store.users.get(userId);
  const loading = store.loading.has(userId);
  const error = store.errors.get(userId);

  // Fetch user on mount
  useEffect(() => {
    if (userId && !user && !loading) {
      store.fetchUser(userId);
    }
  }, [userId, user, loading, store]);

  // Handle optimistic updates
  const updateUser = useCallback(
    async (updates) => {
      setLocalUpdates((prev) => ({ ...prev, ...updates }));

      try {
        await store.updateUserOptimistic(userId, updates, async (id, data) => {
          const response = await fetch(`/api/users/${id}`, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(data),
          });
          return response.json();
        });

        setLocalUpdates({});
        setIsConflicted(false);
      } catch (error) {
        console.error("Update failed:", error);
        setIsConflicted(true);
      }
    },
    [userId, store]
  );

  // Resolve conflicts
  const resolveConflict = useCallback(
    (strategy) => {
      if (isConflicted && user) {
        store.handleConcurrentUpdate(userId, localUpdates, user, strategy);
        setLocalUpdates({});
        setIsConflicted(false);
      }
    },
    [userId, localUpdates, user, isConflicted, store]
  );

  return {
    user,
    loading,
    error,
    updateUser,
    localUpdates,
    isConflicted,
    resolveConflict,
  };
};
```

**Advanced Race Condition Patterns:**

```javascript
// Request deduplication utility
class RequestDeduplicator {
  constructor() {
    this.pendingRequests = new Map();
  }

  async dedupe(key, requestFn) {
    if (this.pendingRequests.has(key)) {
      return this.pendingRequests.get(key);
    }

    const promise = requestFn().finally(() => {
      this.pendingRequests.delete(key);
    });

    this.pendingRequests.set(key, promise);
    return promise;
  }

  cancel(key) {
    this.pendingRequests.delete(key);
  }

  cancelAll() {
    this.pendingRequests.clear();
  }
}

// Optimistic update manager
class OptimisticUpdateManager {
  constructor() {
    this.updates = new Map();
    this.conflicts = new Map();
  }

  apply(key, optimisticData, originalData) {
    this.updates.set(key, {
      optimistic: optimisticData,
      original: originalData,
      timestamp: Date.now(),
    });
  }

  resolve(key, serverData) {
    const update = this.updates.get(key);
    if (!update) return serverData;

    // Check for conflicts
    const hasConflict = this.detectConflict(update.optimistic, serverData);

    if (hasConflict) {
      this.conflicts.set(key, {
        local: update.optimistic,
        server: serverData,
        original: update.original,
        timestamp: Date.now(),
      });
      return update.optimistic; // Keep optimistic data for manual resolution
    }

    this.updates.delete(key);
    return serverData;
  }

  rollback(key) {
    const update = this.updates.get(key);
    if (update) {
      this.updates.delete(key);
      return update.original;
    }
    return null;
  }

  detectConflict(optimisticData, serverData) {
    // Simple conflict detection - can be customized
    return JSON.stringify(optimisticData) !== JSON.stringify(serverData);
  }

  getConflicts() {
    return Array.from(this.conflicts.entries());
  }

  resolveConflict(key, strategy = "server-wins") {
    const conflict = this.conflicts.get(key);
    if (!conflict) return null;

    let resolved;
    switch (strategy) {
      case "server-wins":
        resolved = conflict.server;
        break;
      case "client-wins":
        resolved = conflict.local;
        break;
      case "merge":
        resolved = { ...conflict.server, ...conflict.local };
        break;
      default:
        resolved = conflict.server;
    }

    this.conflicts.delete(key);
    return resolved;
  }
}

// Usage in components
const UserEditor = ({ userId }) => {
  const { user, updateUser, isConflicted, resolveConflict } =
    useUserWithConcurrency(userId);
  const [formData, setFormData] = useState({});

  useEffect(() => {
    if (user) {
      setFormData(user);
    }
  }, [user]);

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      await updateUser(formData);
    } catch (error) {
      console.error("Update failed:", error);
    }
  };

  if (isConflicted) {
    return (
      <div className="conflict-resolution">
        <h3>Conflict Detected</h3>
        <p>
          The data has been modified by another user. How would you like to
          resolve this?
        </p>

        <button onClick={() => resolveConflict("server-wins")}>
          Use Server Version
        </button>
        <button onClick={() => resolveConflict("client-wins")}>
          Keep My Changes
        </button>
        <button onClick={() => resolveConflict("merge")}>Merge Changes</button>
      </div>
    );
  }

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={formData.name || ""}
        onChange={(e) =>
          setFormData((prev) => ({ ...prev, name: e.target.value }))
        }
        placeholder="Name"
      />
      <input
        value={formData.email || ""}
        onChange={(e) =>
          setFormData((prev) => ({ ...prev, email: e.target.value }))
        }
        placeholder="Email"
      />
      <button type="submit">Update User</button>
    </form>
  );
};
```

**Comparison Summary:**

| Feature                      | Redux                                     | Zustand                               |
| ---------------------------- | ----------------------------------------- | ------------------------------------- |
| **Built-in Race Protection** | Limited (requires custom implementation)  | Flexible (easy to implement)          |
| **Request Deduplication**    | Manual with middleware                    | Simple with Map-based tracking        |
| **Optimistic Updates**       | RTK Query provides built-in support       | Custom implementation needed          |
| **Conflict Resolution**      | Requires custom logic                     | Highly customizable strategies        |
| **Cancellation Support**     | AbortController with thunks               | Easy integration with AbortController |
| **Debugging**                | Excellent with Redux DevTools             | Basic debugging capabilities          |
| **Performance**              | Can be heavy with many concurrent updates | Lightweight and efficient             |
| **Learning Curve**           | Steeper (RTK patterns)                    | Gentler (straightforward API)         |

**Best Practices:**

1. **Always handle request cancellation** to prevent memory leaks
2. **Implement request deduplication** for expensive operations
3. **Use optimistic updates** for better user experience
4. **Provide conflict resolution strategies** for concurrent modifications
5. **Debounce rapid updates** to reduce server load
6. **Use timestamps** for conflict detection and resolution
7. **Implement proper error handling** and rollback mechanisms
8. **Test concurrent scenarios** thoroughly
9. **Monitor and log** race conditions for debugging
10. **Document your concurrency strategy** for team understanding

Both Redux and Zustand can effectively handle concurrent updates, with Redux providing more structured patterns through RTK Query and Zustand offering more flexibility for custom implementations.

---

### 35. How do you implement internationalization (i18n) and localization patterns in Redux vs Zustand?

**Answer:**
Internationalization (i18n) and localization (l10n) are crucial for building applications that serve global audiences. Both Redux and Zustand can effectively manage language preferences, translations, and locale-specific data.

**Redux i18n Implementation:**

```javascript
// Redux Toolkit i18n slice
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

// Async thunk for loading translations
const loadTranslations = createAsyncThunk(
  "i18n/loadTranslations",
  async ({ locale, namespace = "common" }, { rejectWithValue }) => {
    try {
      const response = await fetch(
        `/api/translations/${locale}/${namespace}.json`
      );

      if (!response.ok) {
        throw new Error(
          `Failed to load translations for ${locale}/${namespace}`
        );
      }

      const translations = await response.json();
      return { locale, namespace, translations };
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// Async thunk for loading locale data
const loadLocaleData = createAsyncThunk(
  "i18n/loadLocaleData",
  async (locale, { rejectWithValue }) => {
    try {
      const [dateFormats, numberFormats, currencyData] = await Promise.all([
        fetch(`/api/locales/${locale}/date-formats.json`).then((r) => r.json()),
        fetch(`/api/locales/${locale}/number-formats.json`).then((r) =>
          r.json()
        ),
        fetch(`/api/locales/${locale}/currency.json`).then((r) => r.json()),
      ]);

      return {
        locale,
        dateFormats,
        numberFormats,
        currencyData,
      };
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// i18n slice
const i18nSlice = createSlice({
  name: "i18n",
  initialState: {
    currentLocale: "en-US",
    fallbackLocale: "en-US",
    supportedLocales: ["en-US", "es-ES", "fr-FR", "de-DE", "ja-JP", "zh-CN"],
    translations: {},
    localeData: {},
    loading: {},
    errors: {},
    direction: "ltr", // or 'rtl'
    loadedNamespaces: new Set(),
    pluralRules: {},
    interpolationOptions: {
      prefix: "{{",
      suffix: "}}",
      escapeValue: true,
    },
  },
  reducers: {
    // Set current locale
    setLocale: (state, action) => {
      const { locale, direction = "ltr" } = action.payload;

      if (state.supportedLocales.includes(locale)) {
        state.currentLocale = locale;
        state.direction = direction;

        // Update document attributes
        if (typeof document !== "undefined") {
          document.documentElement.lang = locale;
          document.documentElement.dir = direction;
        }
      }
    },

    // Add translations manually
    addTranslations: (state, action) => {
      const { locale, namespace, translations } = action.payload;

      if (!state.translations[locale]) {
        state.translations[locale] = {};
      }

      state.translations[locale][namespace] = {
        ...state.translations[locale][namespace],
        ...translations,
      };

      state.loadedNamespaces.add(`${locale}:${namespace}`);
    },

    // Set plural rules for a locale
    setPluralRules: (state, action) => {
      const { locale, rules } = action.payload;
      state.pluralRules[locale] = rules;
    },

    // Update interpolation options
    setInterpolationOptions: (state, action) => {
      state.interpolationOptions = {
        ...state.interpolationOptions,
        ...action.payload,
      };
    },

    // Clear translations for a locale
    clearTranslations: (state, action) => {
      const { locale, namespace } = action.payload;

      if (namespace) {
        delete state.translations[locale]?.[namespace];
        state.loadedNamespaces.delete(`${locale}:${namespace}`);
      } else {
        delete state.translations[locale];
        // Remove all namespaces for this locale
        state.loadedNamespaces.forEach((ns) => {
          if (ns.startsWith(`${locale}:`)) {
            state.loadedNamespaces.delete(ns);
          }
        });
      }
    },
  },
  extraReducers: (builder) => {
    builder
      // Load translations
      .addCase(loadTranslations.pending, (state, action) => {
        const { locale, namespace } = action.meta.arg;
        const key = `${locale}:${namespace}`;
        state.loading[key] = true;
        delete state.errors[key];
      })
      .addCase(loadTranslations.fulfilled, (state, action) => {
        const { locale, namespace, translations } = action.payload;
        const key = `${locale}:${namespace}`;

        if (!state.translations[locale]) {
          state.translations[locale] = {};
        }

        state.translations[locale][namespace] = translations;
        state.loading[key] = false;
        state.loadedNamespaces.add(key);
      })
      .addCase(loadTranslations.rejected, (state, action) => {
        const { locale, namespace } = action.meta.arg;
        const key = `${locale}:${namespace}`;
        state.loading[key] = false;
        state.errors[key] = action.payload;
      })

      // Load locale data
      .addCase(loadLocaleData.pending, (state, action) => {
        const locale = action.meta.arg;
        state.loading[`locale:${locale}`] = true;
        delete state.errors[`locale:${locale}`];
      })
      .addCase(loadLocaleData.fulfilled, (state, action) => {
        const { locale, dateFormats, numberFormats, currencyData } =
          action.payload;

        state.localeData[locale] = {
          dateFormats,
          numberFormats,
          currencyData,
        };

        state.loading[`locale:${locale}`] = false;
      })
      .addCase(loadLocaleData.rejected, (state, action) => {
        const locale = action.meta.arg;
        state.loading[`locale:${locale}`] = false;
        state.errors[`locale:${locale}`] = action.payload;
      });
  },
});

// Selectors
const selectCurrentLocale = (state) => state.i18n.currentLocale;
const selectDirection = (state) => state.i18n.direction;
const selectSupportedLocales = (state) => state.i18n.supportedLocales;

const selectTranslations = (state, locale, namespace = "common") => {
  return state.i18n.translations[locale]?.[namespace] || {};
};

const selectCurrentTranslations = (state, namespace = "common") => {
  const locale = selectCurrentLocale(state);
  return selectTranslations(state, locale, namespace);
};

const selectLocaleData = (state, locale) => {
  return state.i18n.localeData[locale];
};

const selectIsLoading = (state, locale, namespace) => {
  const key = namespace ? `${locale}:${namespace}` : `locale:${locale}`;
  return state.i18n.loading[key] || false;
};

// Translation function selector
const selectTranslationFunction = (state) => {
  const currentLocale = selectCurrentLocale(state);
  const fallbackLocale = state.i18n.fallbackLocale;
  const translations = state.i18n.translations;
  const interpolationOptions = state.i18n.interpolationOptions;

  return (key, options = {}) => {
    const { namespace = "common", values = {}, count, defaultValue } = options;

    // Get translation from current locale
    let translation = translations[currentLocale]?.[namespace]?.[key];

    // Fallback to fallback locale
    if (!translation && currentLocale !== fallbackLocale) {
      translation = translations[fallbackLocale]?.[namespace]?.[key];
    }

    // Use default value if no translation found
    if (!translation) {
      translation = defaultValue || key;
    }

    // Handle pluralization
    if (typeof count === "number" && typeof translation === "object") {
      const pluralRule = getPluralRule(currentLocale, count);
      translation =
        translation[pluralRule] || translation.other || translation.one;
    }

    // Interpolate values
    if (typeof translation === "string" && Object.keys(values).length > 0) {
      translation = interpolateString(
        translation,
        values,
        interpolationOptions
      );
    }

    return translation;
  };
};

// Helper functions
const getPluralRule = (locale, count) => {
  try {
    const pr = new Intl.PluralRules(locale);
    return pr.select(count);
  } catch {
    // Fallback for unsupported locales
    return count === 1 ? "one" : "other";
  }
};

const interpolateString = (str, values, options) => {
  const { prefix, suffix, escapeValue } = options;

  return str.replace(
    new RegExp(
      `${escapeRegExp(prefix)}([^${escapeRegExp(suffix)}]+)${escapeRegExp(
        suffix
      )}`,
      "g"
    ),
    (match, key) => {
      const value = values[key.trim()];
      if (value === undefined) return match;

      return escapeValue ? escapeHtml(String(value)) : String(value);
    }
  );
};

const escapeRegExp = (string) => {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};

const escapeHtml = (unsafe) => {
  return unsafe
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
};

// React hooks
const useTranslation = (namespace = "common") => {
  const dispatch = useDispatch();
  const currentLocale = useSelector(selectCurrentLocale);
  const t = useSelector(selectTranslationFunction);
  const isLoading = useSelector((state) =>
    selectIsLoading(state, currentLocale, namespace)
  );

  // Auto-load translations if not loaded
  useEffect(() => {
    const key = `${currentLocale}:${namespace}`;
    const loadedNamespaces = useSelector(
      (state) => state.i18n.loadedNamespaces
    );

    if (!loadedNamespaces.has(key) && !isLoading) {
      dispatch(loadTranslations({ locale: currentLocale, namespace }));
    }
  }, [currentLocale, namespace, dispatch, isLoading]);

  return {
    t: (key, options) => t(key, { ...options, namespace }),
    locale: currentLocale,
    isLoading,
  };
};

const useLocale = () => {
  const dispatch = useDispatch();
  const currentLocale = useSelector(selectCurrentLocale);
  const direction = useSelector(selectDirection);
  const supportedLocales = useSelector(selectSupportedLocales);

  const changeLocale = useCallback(
    (locale, dir) => {
      dispatch(i18nSlice.actions.setLocale({ locale, direction: dir }));
      dispatch(loadLocaleData(locale));
    },
    [dispatch]
  );

  return {
    locale: currentLocale,
    direction,
    supportedLocales,
    changeLocale,
  };
};

export const { setLocale, addTranslations, setPluralRules } = i18nSlice.actions;
export { loadTranslations, loadLocaleData };
export { useTranslation, useLocale };
```

**Zustand i18n Implementation:**

```javascript
import { create } from "zustand";
import { persist, subscribeWithSelector } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

// Zustand i18n store
const useI18nStore = create(
  persist(
    subscribeWithSelector(
      immer((set, get) => ({
        // State
        currentLocale: "en-US",
        fallbackLocale: "en-US",
        supportedLocales: [
          "en-US",
          "es-ES",
          "fr-FR",
          "de-DE",
          "ja-JP",
          "zh-CN",
        ],
        direction: "ltr",
        translations: new Map(),
        localeData: new Map(),
        loadingStates: new Map(),
        errors: new Map(),
        loadedNamespaces: new Set(),

        // Configuration
        interpolationOptions: {
          prefix: "{{",
          suffix: "}}",
          escapeValue: true,
        },

        // Actions
        setLocale: (locale, direction = "ltr") => {
          const state = get();

          if (state.supportedLocales.includes(locale)) {
            set((draft) => {
              draft.currentLocale = locale;
              draft.direction = direction;
            });

            // Update document attributes
            if (typeof document !== "undefined") {
              document.documentElement.lang = locale;
              document.documentElement.dir = direction;
            }

            // Auto-load locale data
            get().loadLocaleData(locale);
          }
        },

        // Load translations for a specific namespace
        loadTranslations: async (locale, namespace = "common") => {
          const state = get();
          const key = `${locale}:${namespace}`;

          // Check if already loaded or loading
          if (state.loadedNamespaces.has(key) || state.loadingStates.get(key)) {
            return;
          }

          set((draft) => {
            draft.loadingStates.set(key, true);
            draft.errors.delete(key);
          });

          try {
            const response = await fetch(
              `/api/translations/${locale}/${namespace}.json`
            );

            if (!response.ok) {
              throw new Error(
                `Failed to load translations for ${locale}/${namespace}`
              );
            }

            const translations = await response.json();

            set((draft) => {
              if (!draft.translations.has(locale)) {
                draft.translations.set(locale, new Map());
              }

              draft.translations.get(locale).set(namespace, translations);
              draft.loadedNamespaces.add(key);
              draft.loadingStates.set(key, false);
            });
          } catch (error) {
            set((draft) => {
              draft.loadingStates.set(key, false);
              draft.errors.set(key, error.message);
            });

            throw error;
          }
        },

        // Load locale-specific data (date formats, number formats, etc.)
        loadLocaleData: async (locale) => {
          const state = get();
          const key = `locale:${locale}`;

          if (state.localeData.has(locale) || state.loadingStates.get(key)) {
            return;
          }

          set((draft) => {
            draft.loadingStates.set(key, true);
            draft.errors.delete(key);
          });

          try {
            const [dateFormats, numberFormats, currencyData] =
              await Promise.all([
                fetch(`/api/locales/${locale}/date-formats.json`).then((r) =>
                  r.json()
                ),
                fetch(`/api/locales/${locale}/number-formats.json`).then((r) =>
                  r.json()
                ),
                fetch(`/api/locales/${locale}/currency.json`).then((r) =>
                  r.json()
                ),
              ]);

            set((draft) => {
              draft.localeData.set(locale, {
                dateFormats,
                numberFormats,
                currencyData,
              });
              draft.loadingStates.set(key, false);
            });
          } catch (error) {
            set((draft) => {
              draft.loadingStates.set(key, false);
              draft.errors.set(key, error.message);
            });
          }
        },

        // Add translations manually
        addTranslations: (locale, namespace, translations) => {
          set((draft) => {
            if (!draft.translations.has(locale)) {
              draft.translations.set(locale, new Map());
            }

            const existing =
              draft.translations.get(locale).get(namespace) || {};
            draft.translations.get(locale).set(namespace, {
              ...existing,
              ...translations,
            });

            draft.loadedNamespaces.add(`${locale}:${namespace}`);
          });
        },

        // Translation function
        t: (key, options = {}) => {
          const state = get();
          const {
            namespace = "common",
            values = {},
            count,
            defaultValue,
            locale = state.currentLocale,
          } = options;

          // Get translation from current locale
          let translation = state.translations.get(locale)?.get(namespace)?.[
            key
          ];

          // Fallback to fallback locale
          if (!translation && locale !== state.fallbackLocale) {
            translation = state.translations
              .get(state.fallbackLocale)
              ?.get(namespace)?.[key];
          }

          // Use default value if no translation found
          if (!translation) {
            translation = defaultValue || key;
          }

          // Handle pluralization
          if (typeof count === "number" && typeof translation === "object") {
            const pluralRule = getPluralRule(locale, count);
            translation =
              translation[pluralRule] || translation.other || translation.one;
          }

          // Interpolate values
          if (
            typeof translation === "string" &&
            Object.keys(values).length > 0
          ) {
            translation = interpolateString(
              translation,
              values,
              state.interpolationOptions
            );
          }

          return translation;
        },

        // Format date according to locale
        formatDate: (date, options = {}) => {
          const state = get();
          const locale = options.locale || state.currentLocale;
          const localeData = state.localeData.get(locale);

          try {
            const formatOptions = {
              ...localeData?.dateFormats?.default,
              ...options,
            };

            return new Intl.DateTimeFormat(locale, formatOptions).format(
              new Date(date)
            );
          } catch {
            return new Date(date).toLocaleDateString(locale);
          }
        },

        // Format number according to locale
        formatNumber: (number, options = {}) => {
          const state = get();
          const locale = options.locale || state.currentLocale;
          const localeData = state.localeData.get(locale);

          try {
            const formatOptions = {
              ...localeData?.numberFormats?.default,
              ...options,
            };

            return new Intl.NumberFormat(locale, formatOptions).format(number);
          } catch {
            return number.toLocaleString(locale);
          }
        },

        // Format currency according to locale
        formatCurrency: (amount, currency, options = {}) => {
          const state = get();
          const locale = options.locale || state.currentLocale;
          const localeData = state.localeData.get(locale);

          try {
            const formatOptions = {
              style: "currency",
              currency,
              ...localeData?.currencyData?.formats?.[currency],
              ...options,
            };

            return new Intl.NumberFormat(locale, formatOptions).format(amount);
          } catch {
            return `${currency} ${amount}`;
          }
        },

        // Get relative time formatting
        formatRelativeTime: (value, unit, options = {}) => {
          const state = get();
          const locale = options.locale || state.currentLocale;

          try {
            return new Intl.RelativeTimeFormat(locale, options).format(
              value,
              unit
            );
          } catch {
            return `${value} ${unit}${Math.abs(value) !== 1 ? "s" : ""} ago`;
          }
        },

        // Clear translations
        clearTranslations: (locale, namespace) => {
          set((draft) => {
            if (namespace) {
              draft.translations.get(locale)?.delete(namespace);
              draft.loadedNamespaces.delete(`${locale}:${namespace}`);
            } else {
              draft.translations.delete(locale);
              // Remove all namespaces for this locale
              draft.loadedNamespaces.forEach((ns) => {
                if (ns.startsWith(`${locale}:`)) {
                  draft.loadedNamespaces.delete(ns);
                }
              });
            }
          });
        },

        // Preload translations for multiple locales
        preloadTranslations: async (locales, namespaces = ["common"]) => {
          const promises = [];

          for (const locale of locales) {
            for (const namespace of namespaces) {
              promises.push(get().loadTranslations(locale, namespace));
            }
          }

          await Promise.allSettled(promises);
        },

        // Get loading state
        isLoading: (locale, namespace) => {
          const state = get();
          const key = namespace ? `${locale}:${namespace}` : `locale:${locale}`;
          return state.loadingStates.get(key) || false;
        },

        // Get error state
        getError: (locale, namespace) => {
          const state = get();
          const key = namespace ? `${locale}:${namespace}` : `locale:${locale}`;
          return state.errors.get(key);
        },
      }))
    ),
    {
      name: "i18n-store",
      partialize: (state) => ({
        currentLocale: state.currentLocale,
        direction: state.direction,
        // Don't persist translations and loading states
      }),
    }
  )
);

// React hooks for Zustand
const useTranslation = (namespace = "common") => {
  const store = useI18nStore();
  const currentLocale = store.currentLocale;
  const isLoading = store.isLoading(currentLocale, namespace);

  // Auto-load translations
  useEffect(() => {
    const key = `${currentLocale}:${namespace}`;
    if (!store.loadedNamespaces.has(key) && !isLoading) {
      store.loadTranslations(currentLocale, namespace);
    }
  }, [currentLocale, namespace, store, isLoading]);

  return {
    t: (key, options) => store.t(key, { ...options, namespace }),
    locale: currentLocale,
    isLoading,
  };
};

const useLocale = () => {
  const store = useI18nStore();

  return {
    locale: store.currentLocale,
    direction: store.direction,
    supportedLocales: store.supportedLocales,
    changeLocale: store.setLocale,
    formatDate: store.formatDate,
    formatNumber: store.formatNumber,
    formatCurrency: store.formatCurrency,
    formatRelativeTime: store.formatRelativeTime,
  };
};

// Language detector utility
const detectLanguage = () => {
  // Check URL parameter
  const urlParams = new URLSearchParams(window.location.search);
  const urlLang = urlParams.get("lang");
  if (urlLang) return urlLang;

  // Check localStorage
  const storedLang = localStorage.getItem("preferred-language");
  if (storedLang) return storedLang;

  // Check browser language
  const browserLang = navigator.language || navigator.languages[0];
  return browserLang;
};

// Initialize i18n
const initializeI18n = async () => {
  const detectedLanguage = detectLanguage();
  const store = useI18nStore.getState();

  // Set detected language if supported
  const supportedLanguage = store.supportedLocales.find((locale) =>
    locale.startsWith(detectedLanguage.split("-")[0])
  );

  if (supportedLanguage) {
    store.setLocale(supportedLanguage);
  }

  // Preload common translations
  await store.preloadTranslations(
    [store.currentLocale],
    ["common", "navigation"]
  );
};

export { useI18nStore, useTranslation, useLocale, initializeI18n };
```

**Advanced i18n Patterns:**

```javascript
// Lazy loading translation component
const LazyTranslation = ({ namespace, children }) => {
  const { t, isLoading } = useTranslation(namespace);

  if (isLoading) {
    return <div className="translation-loading">Loading translations...</div>;
  }

  return children({ t });
};

// Translation provider with context
const TranslationContext = createContext();

const TranslationProvider = ({ children, defaultNamespace = "common" }) => {
  const { t, locale, isLoading } = useTranslation(defaultNamespace);
  const { formatDate, formatNumber, formatCurrency } = useLocale();

  const contextValue = {
    t,
    locale,
    isLoading,
    formatDate,
    formatNumber,
    formatCurrency,
    // Enhanced translation function with automatic namespace detection
    translate: (key, options = {}) => {
      // Auto-detect namespace from key (e.g., 'navigation.home' -> namespace: 'navigation')
      if (key.includes(".") && !options.namespace) {
        const [detectedNamespace, ...keyParts] = key.split(".");
        return t(keyParts.join("."), {
          ...options,
          namespace: detectedNamespace,
        });
      }
      return t(key, options);
    },
  };

  return (
    <TranslationContext.Provider value={contextValue}>
      {children}
    </TranslationContext.Provider>
  );
};

// Higher-order component for translations
const withTranslation = (namespace) => (Component) => {
  return function TranslatedComponent(props) {
    const { t, locale, isLoading } = useTranslation(namespace);

    return (
      <Component
        {...props}
        t={t}
        locale={locale}
        isTranslationLoading={isLoading}
      />
    );
  };
};

// Translation component with interpolation
const Trans = ({ i18nKey, values = {}, components = {}, namespace }) => {
  const { t } = useTranslation(namespace);
  const translation = t(i18nKey, { values });

  // Handle component interpolation (e.g., "Click <link>here</link>")
  if (Object.keys(components).length > 0) {
    return (
      <span
        dangerouslySetInnerHTML={{
          __html: interpolateComponents(translation, components),
        }}
      />
    );
  }

  return <span>{translation}</span>;
};

// Utility for component interpolation
const interpolateComponents = (text, components) => {
  return text.replace(/<(\w+)>(.*?)<\/\1>/g, (match, tag, content) => {
    const Component = components[tag];
    if (Component) {
      return ReactDOMServer.renderToString(
        React.createElement(Component, {}, content)
      );
    }
    return match;
  });
};

// Locale switcher component
const LocaleSwitcher = ({ className }) => {
  const { locale, supportedLocales, changeLocale } = useLocale();
  const { t } = useTranslation("common");

  return (
    <select
      className={className}
      value={locale}
      onChange={(e) => changeLocale(e.target.value)}
      aria-label={t("language.select")}
    >
      {supportedLocales.map((loc) => (
        <option key={loc} value={loc}>
          {t(`language.${loc}`, { defaultValue: loc })}
        </option>
      ))}
    </select>
  );
};

// RTL support component
const RTLProvider = ({ children }) => {
  const { direction } = useLocale();

  useEffect(() => {
    document.documentElement.dir = direction;
    document.body.className = direction === "rtl" ? "rtl" : "ltr";
  }, [direction]);

  return <div className={`app-container ${direction}`}>{children}</div>;
};

// Usage examples
const App = () => {
  useEffect(() => {
    initializeI18n();
  }, []);

  return (
    <TranslationProvider>
      <RTLProvider>
        <Header />
        <Main />
        <Footer />
      </RTLProvider>
    </TranslationProvider>
  );
};

const Header = withTranslation("navigation")(({ t }) => (
  <header>
    <nav>
      <a href="/">{t("home")}</a>
      <a href="/about">{t("about")}</a>
      <a href="/contact">{t("contact")}</a>
    </nav>
    <LocaleSwitcher className="locale-switcher" />
  </header>
));

const WelcomeMessage = () => {
  const { t, formatDate } = useLocale();
  const currentDate = new Date();

  return (
    <div>
      <Trans
        i18nKey="welcome.message"
        values={{
          name: "John",
          date: formatDate(currentDate, { dateStyle: "long" }),
        }}
        components={{
          strong: <strong />,
          link: <a href="/profile" />,
        }}
      />
    </div>
  );
};
```

**Comparison Summary:**

| Feature                | Redux                                  | Zustand                             |
| ---------------------- | -------------------------------------- | ----------------------------------- |
| **Setup Complexity**   | More complex (slice, selectors, hooks) | Simpler (single store)              |
| **Type Safety**        | Excellent with TypeScript              | Good with TypeScript                |
| **Performance**        | Good (with proper selectors)           | Excellent (fine-grained reactivity) |
| **DevTools**           | Excellent debugging                    | Basic debugging                     |
| **Persistence**        | Requires additional setup              | Built-in persist middleware         |
| **Bundle Size**        | Larger (RTK + dependencies)            | Smaller footprint                   |
| **Learning Curve**     | Steeper                                | Gentler                             |
| **Async Loading**      | Built-in with RTK Query                | Custom implementation               |
| **Middleware Support** | Extensive ecosystem                    | Limited but sufficient              |
| **SSR Support**        | Good with proper setup                 | Good with hydration                 |

**Best Practices:**

1. **Lazy load translations** to reduce initial bundle size
2. **Use namespaces** to organize translations logically
3. **Implement fallback mechanisms** for missing translations
4. **Cache translations** to avoid repeated network requests
5. **Support pluralization** for languages with complex plural rules
6. **Handle RTL languages** properly with CSS and layout adjustments
7. **Use interpolation** for dynamic content in translations
8. **Implement proper error handling** for failed translation loads
9. **Test with different locales** to ensure proper functionality
10. **Consider SEO implications** for multi-language content

Both Redux and Zustand can effectively handle internationalization, with Redux providing more structure and tooling, while Zustand offers simplicity and flexibility for custom i18n implementations.

### 56. How do you implement advanced caching and memoization strategies in Redux vs Zustand?

**Answer:**

Both Redux and Zustand can implement sophisticated caching and memoization strategies to optimize performance and reduce unnecessary computations.

#### Redux Implementation:

```javascript
// store/slices/cacheSlice.js
import { createSlice, createAsyncThunk, createSelector } from '@reduxjs/toolkit';
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

// RTK Query API for advanced caching
export const apiSlice = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({
    baseUrl: '/api',
    prepareHeaders: (headers, { getState }) => {
      const token = getState().auth.token;
      if (token) {
        headers.set('authorization', `Bearer ${token}`);
      }
      return headers;
    },
  }),
  tagTypes: ['User', 'Post', 'Comment'],
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: (params) => ({
        url: '/users',
        params,
      }),
      providesTags: ['User'],
      // Advanced caching configuration
      keepUnusedDataFor: 60, // seconds
      transformResponse: (response) => {
        // Transform and normalize data
        return response.data.map(user => ({
          ...user,
          fullName: `${user.firstName} ${user.lastName}`,
        }));
      },
    }),
    getUserById: builder.query({
      query: (id) => `/users/${id}`,
      providesTags: (result, error, id) => [{ type: 'User', id }],
    }),
    updateUser: builder.mutation({
      query: ({ id, ...patch }) => ({
        url: `/users/${id}`,
        method: 'PATCH',
        body: patch,
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'User', id }],
      // Optimistic updates
      onQueryStarted: async ({ id, ...patch }, { dispatch, queryFulfilled }) => {
        const patchResult = dispatch(
          apiSlice.util.updateQueryData('getUserById', id, (draft) => {
            Object.assign(draft, patch);
          })
        );
        try {
          await queryFulfilled;
        } catch {
          patchResult.undo();
        }
      },
    }),
  }),
});

// Manual cache slice for custom caching logic
const cacheSlice = createSlice({
  name: 'cache',
  initialState: {
    computedValues: {},
    timestamps: {},
    dependencies: {},
    ttl: 300000, // 5 minutes
  },
  reducers: {
    setCachedValue: (state, action) => {
      const { key, value, dependencies = [] } = action.payload;
      state.computedValues[key] = value;
      state.timestamps[key] = Date.now();
      state.dependencies[key] = dependencies;
    },
    invalidateCache: (state, action) => {
      const { keys } = action.payload;
      keys.forEach(key => {
        delete state.computedValues[key];
        delete state.timestamps[key];
        delete state.dependencies[key];
      });
    },
    invalidateDependentCache: (state, action) => {
      const { dependency } = action.payload;
      Object.entries(state.dependencies).forEach(([key, deps]) => {
        if (deps.includes(dependency)) {
          delete state.computedValues[key];
          delete state.timestamps[key];
          delete state.dependencies[key];
        }
      });
    },
    clearExpiredCache: (state) => {
      const now = Date.now();
      Object.entries(state.timestamps).forEach(([key, timestamp]) => {
        if (now - timestamp > state.ttl) {
          delete state.computedValues[key];
          delete state.timestamps[key];
          delete state.dependencies[key];
        }
      });
    },
  },
});

// Memoized selectors
export const selectUserById = createSelector(
  [(state) => state.users.entities, (state, userId) => userId],
  (entities, userId) => entities[userId]
);

export const selectUsersByRole = createSelector(
  [(state) => state.users.entities, (state, role) => role],
  (entities, role) => {
    return Object.values(entities).filter(user => user.role === role);
  }
);

// Complex memoized selector with multiple dependencies
export const selectUserStatistics = createSelector(
  [
    (state) => state.users.entities,
    (state) => state.posts.entities,
    (state) => state.comments.entities,
  ],
  (users, posts, comments) => {
    // Expensive computation
    return Object.values(users).map(user => {
      const userPosts = Object.values(posts).filter(post => post.authorId === user.id);
      const userComments = Object.values(comments).filter(comment => comment.authorId === user.id);
      
      return {
        ...user,
        postsCount: userPosts.length,
        commentsCount: userComments.length,
        avgPostLength: userPosts.reduce((sum, post) => sum + post.content.length, 0) / userPosts.length || 0,
        lastActivity: Math.max(
          ...userPosts.map(p => new Date(p.createdAt).getTime()),
          ...userComments.map(c => new Date(c.createdAt).getTime())
        ),
      };
    });
  }
);

export const { setCachedValue, invalidateCache, invalidateDependentCache, clearExpiredCache } = cacheSlice.actions;
export default cacheSlice.reducer;
```

```javascript
// hooks/useReduxCache.js
import { useSelector, useDispatch } from 'react-redux';
import { useCallback, useEffect, useMemo } from 'react';
import { setCachedValue, invalidateCache, clearExpiredCache } from '../store/slices/cacheSlice';

export const useReduxCache = () => {
  const dispatch = useDispatch();
  const cache = useSelector(state => state.cache);

  // Memoized cache operations
  const getCachedValue = useCallback((key) => {
    const value = cache.computedValues[key];
    const timestamp = cache.timestamps[key];
    
    if (!value || !timestamp) return null;
    
    // Check if cache is expired
    if (Date.now() - timestamp > cache.ttl) {
      dispatch(invalidateCache({ keys: [key] }));
      return null;
    }
    
    return value;
  }, [cache, dispatch]);

  const setCachedValue = useCallback((key, value, dependencies = []) => {
    dispatch(setCachedValue({ key, value, dependencies }));
  }, [dispatch]);

  const invalidateByDependency = useCallback((dependency) => {
    dispatch(invalidateDependentCache({ dependency }));
  }, [dispatch]);

  // Auto cleanup expired cache
  useEffect(() => {
    const interval = setInterval(() => {
      dispatch(clearExpiredCache());
    }, 60000); // Check every minute

    return () => clearInterval(interval);
  }, [dispatch]);

  return {
    getCachedValue,
    setCachedValue,
    invalidateByDependency,
  };
};

// Hook for memoized computations
export const useMemoizedComputation = (computeFn, dependencies, cacheKey) => {
  const { getCachedValue, setCachedValue } = useReduxCache();
  
  return useMemo(() => {
    // Try to get from cache first
    const cached = getCachedValue(cacheKey);
    if (cached !== null) {
      return cached;
    }
    
    // Compute and cache the result
    const result = computeFn();
    setCachedValue(cacheKey, result, dependencies);
    return result;
  }, [computeFn, dependencies, cacheKey, getCachedValue, setCachedValue]);
};
```

#### Zustand Implementation:

```javascript
// stores/cacheStore.js
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import { persist } from 'zustand/middleware';

// Cache store with advanced memoization
export const useCacheStore = create(
  subscribeWithSelector(
    immer(
      persist(
        (set, get) => ({
          // Cache state
          computedValues: new Map(),
          timestamps: new Map(),
          dependencies: new Map(),
          memoizedSelectors: new Map(),
          ttl: 300000, // 5 minutes
          
          // Cache actions
          setCachedValue: (key, value, dependencies = []) => {
            set((state) => {
              state.computedValues.set(key, value);
              state.timestamps.set(key, Date.now());
              state.dependencies.set(key, dependencies);
            });
          },
          
          getCachedValue: (key) => {
            const state = get();
            const value = state.computedValues.get(key);
            const timestamp = state.timestamps.get(key);
            
            if (!value || !timestamp) return null;
            
            // Check if cache is expired
            if (Date.now() - timestamp > state.ttl) {
              get().invalidateCache([key]);
              return null;
            }
            
            return value;
          },
          
          invalidateCache: (keys) => {
            set((state) => {
              keys.forEach(key => {
                state.computedValues.delete(key);
                state.timestamps.delete(key);
                state.dependencies.delete(key);
              });
            });
          },
          
          invalidateDependentCache: (dependency) => {
            set((state) => {
              const keysToInvalidate = [];
              state.dependencies.forEach((deps, key) => {
                if (deps.includes(dependency)) {
                  keysToInvalidate.push(key);
                }
              });
              
              keysToInvalidate.forEach(key => {
                state.computedValues.delete(key);
                state.timestamps.delete(key);
                state.dependencies.delete(key);
              });
            });
          },
          
          clearExpiredCache: () => {
            set((state) => {
              const now = Date.now();
              const keysToDelete = [];
              
              state.timestamps.forEach((timestamp, key) => {
                if (now - timestamp > state.ttl) {
                  keysToDelete.push(key);
                }
              });
              
              keysToDelete.forEach(key => {
                state.computedValues.delete(key);
                state.timestamps.delete(key);
                state.dependencies.delete(key);
              });
            });
          },
          
          // Memoized selector factory
          createMemoizedSelector: (selectorFn, dependencies = []) => {
            const selectorKey = JSON.stringify({ fn: selectorFn.toString(), deps: dependencies });
            
            return (state) => {
              const cached = get().getCachedValue(selectorKey);
              if (cached !== null) {
                return cached;
              }
              
              const result = selectorFn(state);
              get().setCachedValue(selectorKey, result, dependencies);
              return result;
            };
          },
          
          // Advanced memoization with weak references
          memoize: (fn, keyFn = (...args) => JSON.stringify(args)) => {
            const cache = new Map();
            const weakCache = new WeakMap();
            
            return (...args) => {
              const key = keyFn(...args);
              
              // Try weak cache first for object references
              if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null) {
                if (weakCache.has(args[0])) {
                  return weakCache.get(args[0]);
                }
              }
              
              // Try regular cache
              if (cache.has(key)) {
                const { value, timestamp } = cache.get(key);
                if (Date.now() - timestamp < get().ttl) {
                  return value;
                }
                cache.delete(key);
              }
              
              // Compute new value
              const result = fn(...args);
              const cacheEntry = { value: result, timestamp: Date.now() };
              
              cache.set(key, cacheEntry);
              
              // Store in weak cache if applicable
              if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null) {
                weakCache.set(args[0], result);
              }
              
              return result;
            };
          },
        }),
        {
          name: 'cache-store',
          partialize: (state) => ({
            // Only persist non-function values
            computedValues: Array.from(state.computedValues.entries()),
            timestamps: Array.from(state.timestamps.entries()),
            dependencies: Array.from(state.dependencies.entries()),
            ttl: state.ttl,
          }),
          onRehydrateStorage: () => (state) => {
            if (state) {
              // Restore Maps from arrays
              state.computedValues = new Map(state.computedValues || []);
              state.timestamps = new Map(state.timestamps || []);
              state.dependencies = new Map(state.dependencies || []);
              state.memoizedSelectors = new Map();
            }
          },
        }
      )
    )
  )
);

// Data store with caching integration
export const useDataStore = create(
  subscribeWithSelector(
    immer((set, get) => ({
      users: new Map(),
      posts: new Map(),
      comments: new Map(),
      loading: false,
      error: null,
      
      // Memoized selectors
      getUserById: useCacheStore.getState().memoize(
        (id) => get().users.get(id),
        (id) => `user-${id}`
      ),
      
      getUsersByRole: useCacheStore.getState().memoize(
        (role) => {
          return Array.from(get().users.values()).filter(user => user.role === role);
        },
        (role) => `users-by-role-${role}`
      ),
      
      getUserStatistics: useCacheStore.getState().memoize(
        () => {
          const { users, posts, comments } = get();
          
          return Array.from(users.values()).map(user => {
            const userPosts = Array.from(posts.values()).filter(post => post.authorId === user.id);
            const userComments = Array.from(comments.values()).filter(comment => comment.authorId === user.id);
            
            return {
              ...user,
              postsCount: userPosts.length,
              commentsCount: userComments.length,
              avgPostLength: userPosts.reduce((sum, post) => sum + post.content.length, 0) / userPosts.length || 0,
              lastActivity: Math.max(
                ...userPosts.map(p => new Date(p.createdAt).getTime()),
                ...userComments.map(c => new Date(c.createdAt).getTime())
              ),
            };
          });
        },
        () => 'user-statistics'
      ),
      
      // Actions that invalidate cache
      addUser: (user) => {
        set((state) => {
          state.users.set(user.id, user);
        });
        useCacheStore.getState().invalidateDependentCache('users');
      },
      
      updateUser: (id, updates) => {
        set((state) => {
          const user = state.users.get(id);
          if (user) {
            state.users.set(id, { ...user, ...updates });
          }
        });
        useCacheStore.getState().invalidateDependentCache('users');
        useCacheStore.getState().invalidateCache([`user-${id}`]);
      },
      
      deleteUser: (id) => {
        set((state) => {
          state.users.delete(id);
        });
        useCacheStore.getState().invalidateDependentCache('users');
        useCacheStore.getState().invalidateCache([`user-${id}`]);
      },
    }))
  )
);
```

```javascript
// hooks/useZustandCache.js
import { useCallback, useEffect, useMemo } from 'react';
import { useCacheStore } from '../stores/cacheStore';

export const useZustandCache = () => {
  const {
    getCachedValue,
    setCachedValue,
    invalidateCache,
    invalidateDependentCache,
    clearExpiredCache,
    memoize,
  } = useCacheStore();

  // Auto cleanup expired cache
  useEffect(() => {
    const interval = setInterval(() => {
      clearExpiredCache();
    }, 60000); // Check every minute

    return () => clearInterval(interval);
  }, [clearExpiredCache]);

  return {
    getCachedValue,
    setCachedValue,
    invalidateCache,
    invalidateDependentCache,
    memoize,
  };
};

// Hook for memoized computations
export const useMemoizedComputation = (computeFn, dependencies, cacheKey) => {
  const { getCachedValue, setCachedValue } = useZustandCache();
  
  return useMemo(() => {
    // Try to get from cache first
    const cached = getCachedValue(cacheKey);
    if (cached !== null) {
      return cached;
    }
    
    // Compute and cache the result
    const result = computeFn();
    setCachedValue(cacheKey, result, dependencies);
    return result;
  }, [computeFn, dependencies, cacheKey, getCachedValue, setCachedValue]);
};

// Hook for creating memoized selectors
export const useMemoizedSelector = (selector, dependencies = []) => {
  const { memoize } = useZustandCache();
  
  return useMemo(() => {
    return memoize(selector, (...args) => {
      return JSON.stringify({ args, deps: dependencies });
    });
  }, [selector, dependencies, memoize]);
};
```

#### React Components:

```jsx
// components/UserList.jsx
import React, { useMemo } from 'react';
import { useSelector } from 'react-redux';
import { selectUsersByRole, selectUserStatistics } from '../store/slices/cacheSlice';
import { useDataStore } from '../stores/cacheStore';
import { useMemoizedComputation } from '../hooks/useZustandCache';

// Redux version
const ReduxUserList = ({ role, showStatistics }) => {
  // Memoized selectors automatically cache results
  const usersByRole = useSelector(state => selectUsersByRole(state, role));
  const userStatistics = useSelector(selectUserStatistics);
  
  // Additional memoized computation
  const processedUsers = useMemoizedComputation(
    () => {
      return usersByRole.map(user => ({
        ...user,
        displayName: `${user.firstName} ${user.lastName} (${user.role})`,
        isActive: user.lastLogin && new Date(user.lastLogin) > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
      }));
    },
    [role],
    `processed-users-${role}`
  );
  
  return (
    <div className="user-list">
      <h2>Users - {role}</h2>
      {processedUsers.map(user => (
        <div key={user.id} className="user-item">
          <h3>{user.displayName}</h3>
          <span className={`status ${user.isActive ? 'active' : 'inactive'}`}>
            {user.isActive ? 'Active' : 'Inactive'}
          </span>
          {showStatistics && (
            <div className="user-stats">
              <span>Posts: {userStatistics.find(s => s.id === user.id)?.postsCount || 0}</span>
              <span>Comments: {userStatistics.find(s => s.id === user.id)?.commentsCount || 0}</span>
            </div>
          )}
        </div>
      ))}
    </div>
  );
};

// Zustand version
const ZustandUserList = ({ role, showStatistics }) => {
  const getUsersByRole = useDataStore(state => state.getUsersByRole);
  const getUserStatistics = useDataStore(state => state.getUserStatistics);
  
  // Memoized data fetching
  const usersByRole = useMemo(() => getUsersByRole(role), [getUsersByRole, role]);
  const userStatistics = useMemo(() => getUserStatistics(), [getUserStatistics]);
  
  // Additional memoized computation
  const processedUsers = useMemoizedComputation(
    () => {
      return usersByRole.map(user => ({
        ...user,
        displayName: `${user.firstName} ${user.lastName} (${user.role})`,
        isActive: user.lastLogin && new Date(user.lastLogin) > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
      }));
    },
    [role],
    `processed-users-${role}`
  );
  
  return (
    <div className="user-list">
      <h2>Users - {role}</h2>
      {processedUsers.map(user => (
        <div key={user.id} className="user-item">
          <h3>{user.displayName}</h3>
          <span className={`status ${user.isActive ? 'active' : 'inactive'}`}>
            {user.isActive ? 'Active' : 'Inactive'}
          </span>
          {showStatistics && (
            <div className="user-stats">
              <span>Posts: {userStatistics.find(s => s.id === user.id)?.postsCount || 0}</span>
              <span>Comments: {userStatistics.find(s => s.id === user.id)?.commentsCount || 0}</span>
            </div>
          )}
        </div>
      ))}
    </div>
  );
};
```

#### Best Practices:

**Performance Optimization:**
- Use RTK Query for API caching in Redux
- Implement proper cache invalidation strategies
- Use weak references for object-based caching
- Implement cache size limits and LRU eviction

**Memory Management:**
- Clear expired cache entries regularly
- Use weak maps for temporary object references
- Implement cache size monitoring
- Avoid memory leaks in long-running applications

**Cache Strategy:**
- Choose appropriate TTL values
- Implement dependency-based invalidation
- Use optimistic updates for better UX
- Consider cache warming for critical data

**Development Experience:**
- Provide cache debugging tools
- Implement cache hit/miss metrics
- Use proper TypeScript types for cache keys
- Document cache dependencies clearly

#### Comparison Summary:

| Feature | Redux | Zustand |
|---------|-------|----------|
| **Built-in Caching** | RTK Query | Custom implementation |
| **Memoized Selectors** | createSelector | Custom memoization |
| **Cache Invalidation** | Tag-based system | Dependency tracking |
| **Persistence** | Additional middleware | Built-in persist |
| **Memory Management** | Manual cleanup | WeakMap support |
| **Performance** | Excellent with RTK Query | Good with custom logic |
| **Complexity** | Medium (RTK Query) | High (custom) |
| **Flexibility** | Structured approach | Highly customizable |

Both approaches provide powerful caching and memoization capabilities, with Redux offering more built-in solutions through RTK Query, while Zustand provides maximum flexibility for custom implementations.

---

## 57. How do you implement advanced error handling and recovery patterns in Redux vs Zustand?

### Redux Implementation

**Error Slice with RTK:**
```javascript
// store/errorSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

const errorSlice = createSlice({
  name: 'error',
  initialState: {
    errors: {},
    globalError: null,
    retryAttempts: {},
    errorHistory: [],
    isRecovering: false
  },
  reducers: {
    addError: (state, action) => {
      const { id, error, context } = action.payload;
      state.errors[id] = {
        ...error,
        context,
        timestamp: Date.now(),
        id
      };
      state.errorHistory.push({
        id,
        error,
        context,
        timestamp: Date.now()
      });
    },
    removeError: (state, action) => {
      delete state.errors[action.payload];
    },
    setGlobalError: (state, action) => {
      state.globalError = action.payload;
    },
    clearGlobalError: (state) => {
      state.globalError = null;
    },
    incrementRetry: (state, action) => {
      const { id } = action.payload;
      state.retryAttempts[id] = (state.retryAttempts[id] || 0) + 1;
    },
    resetRetry: (state, action) => {
      delete state.retryAttempts[action.payload];
    },
    setRecovering: (state, action) => {
      state.isRecovering = action.payload;
    },
    clearErrorHistory: (state) => {
      state.errorHistory = [];
    }
  }
});

export const {
  addError,
  removeError,
  setGlobalError,
  clearGlobalError,
  incrementRetry,
  resetRetry,
  setRecovering,
  clearErrorHistory
} = errorSlice.actions;

export default errorSlice.reducer;
```

**Error Recovery Thunks:**
```javascript
// store/errorThunks.js
import { createAsyncThunk } from '@reduxjs/toolkit';
import { addError, incrementRetry, resetRetry, setRecovering } from './errorSlice';

export const retryOperation = createAsyncThunk(
  'error/retryOperation',
  async ({ operation, maxRetries = 3, delay = 1000 }, { dispatch, getState }) => {
    const { error } = getState();
    const operationId = operation.id;
    const currentRetries = error.retryAttempts[operationId] || 0;

    if (currentRetries >= maxRetries) {
      throw new Error(`Max retries (${maxRetries}) exceeded for operation ${operationId}`);
    }

    dispatch(incrementRetry({ id: operationId }));
    dispatch(setRecovering(true));

    try {
      // Exponential backoff
      const backoffDelay = delay * Math.pow(2, currentRetries);
      await new Promise(resolve => setTimeout(resolve, backoffDelay));

      const result = await operation.execute();
      dispatch(resetRetry(operationId));
      dispatch(setRecovering(false));
      return result;
    } catch (error) {
      dispatch(addError({
        id: operationId,
        error: {
          message: error.message,
          code: error.code,
          type: 'RETRY_FAILED',
          retryCount: currentRetries + 1
        },
        context: operation.context
      }));
      dispatch(setRecovering(false));
      throw error;
    }
  }
);

export const recoverFromError = createAsyncThunk(
  'error/recoverFromError',
  async ({ errorId, recoveryStrategy }, { dispatch, getState }) => {
    const { error } = getState();
    const errorInfo = error.errors[errorId];

    if (!errorInfo) {
      throw new Error(`Error ${errorId} not found`);
    }

    dispatch(setRecovering(true));

    try {
      switch (recoveryStrategy.type) {
        case 'RETRY':
          await dispatch(retryOperation({
            operation: recoveryStrategy.operation,
            maxRetries: recoveryStrategy.maxRetries
          })).unwrap();
          break;

        case 'FALLBACK':
          await recoveryStrategy.fallbackAction();
          break;

        case 'RESET_STATE':
          await recoveryStrategy.resetAction();
          break;

        case 'REDIRECT':
          window.location.href = recoveryStrategy.redirectUrl;
          break;

        default:
          throw new Error(`Unknown recovery strategy: ${recoveryStrategy.type}`);
      }

      dispatch(removeError(errorId));
      dispatch(setRecovering(false));
    } catch (recoveryError) {
      dispatch(addError({
        id: `recovery_${errorId}`,
        error: {
          message: recoveryError.message,
          type: 'RECOVERY_FAILED',
          originalError: errorInfo
        },
        context: { recoveryStrategy }
      }));
      dispatch(setRecovering(false));
      throw recoveryError;
    }
  }
);
```

**Redux Error Hook:**
```javascript
// hooks/useReduxError.js
import { useSelector, useDispatch } from 'react-redux';
import { useCallback, useEffect } from 'react';
import { removeError, recoverFromError } from '../store/errorThunks';

export const useReduxError = () => {
  const dispatch = useDispatch();
  const {
    errors,
    globalError,
    retryAttempts,
    errorHistory,
    isRecovering
  } = useSelector(state => state.error);

  const handleError = useCallback((error, context = {}) => {
    const errorId = `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    dispatch(addError({
      id: errorId,
      error: {
        message: error.message,
        code: error.code,
        type: error.type || 'UNKNOWN'
      },
      context
    }));

    return errorId;
  }, [dispatch]);

  const dismissError = useCallback((errorId) => {
    dispatch(removeError(errorId));
  }, [dispatch]);

  const recoverError = useCallback((errorId, recoveryStrategy) => {
    return dispatch(recoverFromError({ errorId, recoveryStrategy }));
  }, [dispatch]);

  const getErrorsByType = useCallback((type) => {
    return Object.values(errors).filter(error => error.type === type);
  }, [errors]);

  const hasErrors = Object.keys(errors).length > 0;
  const criticalErrors = getErrorsByType('CRITICAL');
  const hasCriticalErrors = criticalErrors.length > 0;

  return {
    errors,
    globalError,
    retryAttempts,
    errorHistory,
    isRecovering,
    hasErrors,
    hasCriticalErrors,
    criticalErrors,
    handleError,
    dismissError,
    recoverError,
    getErrorsByType
  };
};
```

### Zustand Implementation

**Error Store with Advanced Recovery:**
```javascript
// stores/errorStore.js
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import { persist } from 'zustand/middleware/persist';

const useErrorStore = create(
  subscribeWithSelector(
    immer(
      persist(
        (set, get) => ({
          errors: {},
          globalError: null,
          retryAttempts: {},
          errorHistory: [],
          isRecovering: false,
          recoveryStrategies: {},
          errorListeners: new Map(),

          // Actions
          addError: (id, error, context = {}) => {
            set((state) => {
              state.errors[id] = {
                ...error,
                context,
                timestamp: Date.now(),
                id
              };
              state.errorHistory.push({
                id,
                error,
                context,
                timestamp: Date.now()
              });
            });

            // Trigger error listeners
            const listeners = get().errorListeners.get(error.type) || [];
            listeners.forEach(listener => listener(id, error, context));
          },

          removeError: (id) => {
            set((state) => {
              delete state.errors[id];
            });
          },

          setGlobalError: (error) => {
            set((state) => {
              state.globalError = error;
            });
          },

          clearGlobalError: () => {
            set((state) => {
              state.globalError = null;
            });
          },

          incrementRetry: (id) => {
            set((state) => {
              state.retryAttempts[id] = (state.retryAttempts[id] || 0) + 1;
            });
          },

          resetRetry: (id) => {
            set((state) => {
              delete state.retryAttempts[id];
            });
          },

          setRecovering: (isRecovering) => {
            set((state) => {
              state.isRecovering = isRecovering;
            });
          },

          clearErrorHistory: () => {
            set((state) => {
              state.errorHistory = [];
            });
          },

          // Advanced recovery methods
          retryOperation: async (operation, maxRetries = 3, delay = 1000) => {
            const { retryAttempts, incrementRetry, resetRetry, setRecovering, addError } = get();
            const operationId = operation.id;
            const currentRetries = retryAttempts[operationId] || 0;

            if (currentRetries >= maxRetries) {
              throw new Error(`Max retries (${maxRetries}) exceeded for operation ${operationId}`);
            }

            incrementRetry(operationId);
            setRecovering(true);

            try {
              // Exponential backoff
              const backoffDelay = delay * Math.pow(2, currentRetries);
              await new Promise(resolve => setTimeout(resolve, backoffDelay));

              const result = await operation.execute();
              resetRetry(operationId);
              setRecovering(false);
              return result;
            } catch (error) {
              addError(operationId, {
                message: error.message,
                code: error.code,
                type: 'RETRY_FAILED',
                retryCount: currentRetries + 1
              }, operation.context);
              setRecovering(false);
              throw error;
            }
          },

          recoverFromError: async (errorId, recoveryStrategy) => {
            const { errors, setRecovering, removeError, addError } = get();
            const errorInfo = errors[errorId];

            if (!errorInfo) {
              throw new Error(`Error ${errorId} not found`);
            }

            setRecovering(true);

            try {
              switch (recoveryStrategy.type) {
                case 'RETRY':
                  await get().retryOperation(
                    recoveryStrategy.operation,
                    recoveryStrategy.maxRetries
                  );
                  break;

                case 'FALLBACK':
                  await recoveryStrategy.fallbackAction();
                  break;

                case 'RESET_STATE':
                  await recoveryStrategy.resetAction();
                  break;

                case 'REDIRECT':
                  window.location.href = recoveryStrategy.redirectUrl;
                  break;

                default:
                  throw new Error(`Unknown recovery strategy: ${recoveryStrategy.type}`);
              }

              removeError(errorId);
              setRecovering(false);
            } catch (recoveryError) {
              addError(`recovery_${errorId}`, {
                message: recoveryError.message,
                type: 'RECOVERY_FAILED',
                originalError: errorInfo
              }, { recoveryStrategy });
              setRecovering(false);
              throw recoveryError;
            }
          },

          // Error listener management
          addErrorListener: (errorType, listener) => {
            set((state) => {
              const listeners = state.errorListeners.get(errorType) || [];
              listeners.push(listener);
              state.errorListeners.set(errorType, listeners);
            });
          },

          removeErrorListener: (errorType, listener) => {
            set((state) => {
              const listeners = state.errorListeners.get(errorType) || [];
              const filteredListeners = listeners.filter(l => l !== listener);
              state.errorListeners.set(errorType, filteredListeners);
            });
          },

          // Helper methods
          getErrorsByType: (type) => {
            const { errors } = get();
            return Object.values(errors).filter(error => error.type === type);
          },

          hasErrors: () => {
            const { errors } = get();
            return Object.keys(errors).length > 0;
          },

          hasCriticalErrors: () => {
            return get().getErrorsByType('CRITICAL').length > 0;
          },

          registerRecoveryStrategy: (errorType, strategy) => {
            set((state) => {
              state.recoveryStrategies[errorType] = strategy;
            });
          },

          autoRecover: async (errorId) => {
            const { errors, recoveryStrategies, recoverFromError } = get();
            const error = errors[errorId];
            
            if (!error) return;
            
            const strategy = recoveryStrategies[error.type];
            if (strategy) {
              try {
                await recoverFromError(errorId, strategy);
              } catch (recoveryError) {
                console.error('Auto-recovery failed:', recoveryError);
              }
            }
          }
        }),
        {
          name: 'error-store',
          partialize: (state) => ({
            errorHistory: state.errorHistory.slice(-50), // Keep last 50 errors
            recoveryStrategies: state.recoveryStrategies
          })
        }
      )
    )
  )
);

export default useErrorStore;
```

**Zustand Error Hook:**
```javascript
// hooks/useZustandError.js
import { useCallback, useEffect } from 'react';
import useErrorStore from '../stores/errorStore';

export const useZustandError = () => {
  const {
    errors,
    globalError,
    retryAttempts,
    errorHistory,
    isRecovering,
    addError,
    removeError,
    recoverFromError,
    getErrorsByType,
    hasErrors,
    hasCriticalErrors,
    addErrorListener,
    removeErrorListener,
    autoRecover
  } = useErrorStore();

  const handleError = useCallback((error, context = {}) => {
    const errorId = `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    addError(errorId, {
      message: error.message,
      code: error.code,
      type: error.type || 'UNKNOWN'
    }, context);

    // Auto-recover if strategy exists
    setTimeout(() => autoRecover(errorId), 100);

    return errorId;
  }, [addError, autoRecover]);

  const dismissError = useCallback((errorId) => {
    removeError(errorId);
  }, [removeError]);

  const recoverError = useCallback((errorId, recoveryStrategy) => {
    return recoverFromError(errorId, recoveryStrategy);
  }, [recoverFromError]);

  // Auto-dismiss non-critical errors after timeout
  useEffect(() => {
    const nonCriticalErrors = Object.entries(errors).filter(
      ([_, error]) => error.type !== 'CRITICAL'
    );

    nonCriticalErrors.forEach(([errorId, error]) => {
      const age = Date.now() - error.timestamp;
      if (age > 30000) { // 30 seconds
        removeError(errorId);
      }
    });
  }, [errors, removeError]);

  const criticalErrors = getErrorsByType('CRITICAL');

  return {
    errors,
    globalError,
    retryAttempts,
    errorHistory,
    isRecovering,
    hasErrors: hasErrors(),
    hasCriticalErrors: hasCriticalErrors(),
    criticalErrors,
    handleError,
    dismissError,
    recoverError,
    getErrorsByType,
    addErrorListener,
    removeErrorListener
  };
};
```

### Best Practices

**Error Classification:**
```javascript
// utils/errorClassification.js
export const ErrorTypes = {
  NETWORK: 'NETWORK',
  VALIDATION: 'VALIDATION',
  AUTHENTICATION: 'AUTHENTICATION',
  AUTHORIZATION: 'AUTHORIZATION',
  SERVER: 'SERVER',
  CLIENT: 'CLIENT',
  CRITICAL: 'CRITICAL',
  RECOVERABLE: 'RECOVERABLE'
};

export const classifyError = (error) => {
  if (error.code >= 500) return ErrorTypes.SERVER;
  if (error.code === 401) return ErrorTypes.AUTHENTICATION;
  if (error.code === 403) return ErrorTypes.AUTHORIZATION;
  if (error.code >= 400) return ErrorTypes.CLIENT;
  if (error.name === 'NetworkError') return ErrorTypes.NETWORK;
  if (error.name === 'ValidationError') return ErrorTypes.VALIDATION;
  
  return ErrorTypes.CLIENT;
};

export const isCriticalError = (error) => {
  return [
    ErrorTypes.CRITICAL,
    ErrorTypes.AUTHENTICATION,
    ErrorTypes.SERVER
  ].includes(error.type);
};
```

**Recovery Strategies:**
```javascript
// utils/recoveryStrategies.js
export const createRetryStrategy = (operation, maxRetries = 3) => ({
  type: 'RETRY',
  operation,
  maxRetries
});

export const createFallbackStrategy = (fallbackAction) => ({
  type: 'FALLBACK',
  fallbackAction
});

export const createResetStrategy = (resetAction) => ({
  type: 'RESET_STATE',
  resetAction
});

export const createRedirectStrategy = (redirectUrl) => ({
  type: 'REDIRECT',
  redirectUrl
});
```

### Comparison Summary

| Feature | Redux | Zustand |
|---------|-------|----------|
| **Error State Management** | Structured with slices and reducers | Flexible store with immer |
| **Recovery Mechanisms** | Async thunks with middleware | Direct async methods |
| **Error Listeners** | Redux middleware and selectors | Built-in listener system |
| **Persistence** | Requires additional setup | Built-in persist middleware |
| **DevTools** | Excellent debugging support | Basic debugging |
| **Type Safety** | Strong with TypeScript | Good with TypeScript |
| **Bundle Size** | Larger with dependencies | Smaller and lightweight |
| **Learning Curve** | Steeper with concepts | Gentler and intuitive |
| **Error Boundaries** | Requires integration setup | Direct store integration |
| **Auto-Recovery** | Manual implementation | Built-in support |

**Best Practices:**
- **Error Classification**: Categorize errors by type and severity for appropriate handling
- **Recovery Strategies**: Implement multiple recovery patterns (retry, fallback, reset, redirect)
- **User Experience**: Provide clear error messages and recovery options
- **Monitoring**: Track error patterns and recovery success rates
- **Performance**: Avoid memory leaks with proper error cleanup
- **Testing**: Test error scenarios and recovery mechanisms thoroughly
- **Logging**: Implement comprehensive error logging for debugging
- **Graceful Degradation**: Ensure app remains functional during errors

---

## 58. How do you implement advanced testing strategies and patterns in Redux vs Zustand?

### Redux Testing Strategies

#### 1. Redux Toolkit Testing Setup

```javascript
// store/testUtils.js
import { configureStore } from '@reduxjs/toolkit';
import { render } from '@testing-library/react';
import { Provider } from 'react-redux';
import userSlice from './slices/userSlice';
import postsSlice from './slices/postsSlice';
import { api } from './api/apiSlice';

// Test store factory
export const createTestStore = (preloadedState = {}) => {
  return configureStore({
    reducer: {
      user: userSlice,
      posts: postsSlice,
      api: api.reducer,
    },
    preloadedState,
    middleware: (getDefaultMiddleware) =>
      getDefaultMiddleware({
        serializableCheck: false,
        immutableCheck: false,
      }).concat(api.middleware),
  });
};

// Custom render with Redux provider
export const renderWithRedux = (
  ui,
  {
    preloadedState = {},
    store = createTestStore(preloadedState),
    ...renderOptions
  } = {}
) => {
  const Wrapper = ({ children }) => (
    <Provider store={store}>{children}</Provider>
  );
  
  return {
    ...render(ui, { wrapper: Wrapper, ...renderOptions }),
    store,
  };
};

// Mock API responses
export const createMockApiResponse = (data, status = 200) => ({
  data,
  status,
  headers: {},
  config: {},
  statusText: 'OK',
});
```

#### 2. Slice Testing

```javascript
// __tests__/userSlice.test.js
import userSlice, {
  setUser,
  updateProfile,
  fetchUserProfile,
  selectUser,
  selectUserStatus,
} from '../slices/userSlice';
import { createTestStore } from '../testUtils';

describe('userSlice', () => {
  let store;
  
  beforeEach(() => {
    store = createTestStore();
  });
  
  describe('reducers', () => {
    it('should handle setUser', () => {
      const user = { id: 1, name: 'John Doe', email: 'john@example.com' };
      
      store.dispatch(setUser(user));
      
      expect(selectUser(store.getState())).toEqual(user);
      expect(selectUserStatus(store.getState())).toBe('idle');
    });
    
    it('should handle updateProfile', () => {
      const initialUser = { id: 1, name: 'John', email: 'john@example.com' };
      const updates = { name: 'John Doe', bio: 'Software Developer' };
      
      store.dispatch(setUser(initialUser));
      store.dispatch(updateProfile(updates));
      
      const updatedUser = selectUser(store.getState());
      expect(updatedUser).toEqual({ ...initialUser, ...updates });
    });
  });
  
  describe('async thunks', () => {
    it('should handle fetchUserProfile success', async () => {
      const mockUser = { id: 1, name: 'John Doe' };
      
      // Mock the API call
      jest.spyOn(global, 'fetch').mockResolvedValueOnce({
        ok: true,
        json: async () => mockUser,
      });
      
      await store.dispatch(fetchUserProfile(1));
      
      expect(selectUser(store.getState())).toEqual(mockUser);
      expect(selectUserStatus(store.getState())).toBe('succeeded');
    });
    
    it('should handle fetchUserProfile failure', async () => {
      jest.spyOn(global, 'fetch').mockRejectedValueOnce(
        new Error('Network error')
      );
      
      await store.dispatch(fetchUserProfile(1));
      
      expect(selectUserStatus(store.getState())).toBe('failed');
    });
  });
});
```

#### 3. Component Integration Testing

```javascript
// __tests__/UserProfile.test.js
import React from 'react';
import { screen, fireEvent, waitFor } from '@testing-library/react';
import { renderWithRedux } from '../store/testUtils';
import UserProfile from '../components/UserProfile';
import { server } from '../mocks/server';
import { rest } from 'msw';

describe('UserProfile Component', () => {
  it('should display user information', () => {
    const preloadedState = {
      user: {
        data: { id: 1, name: 'John Doe', email: 'john@example.com' },
        status: 'idle',
        error: null,
      },
    };
    
    renderWithRedux(<UserProfile />, { preloadedState });
    
    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });
  
  it('should handle profile update', async () => {
    const preloadedState = {
      user: {
        data: { id: 1, name: 'John', email: 'john@example.com' },
        status: 'idle',
        error: null,
      },
    };
    
    const { store } = renderWithRedux(<UserProfile />, { preloadedState });
    
    // Mock successful API response
    server.use(
      rest.put('/api/users/1', (req, res, ctx) => {
        return res(ctx.json({ id: 1, name: 'John Doe', email: 'john@example.com' }));
      })
    );
    
    fireEvent.click(screen.getByText('Edit Profile'));
    fireEvent.change(screen.getByLabelText('Name'), {
      target: { value: 'John Doe' },
    });
    fireEvent.click(screen.getByText('Save'));
    
    await waitFor(() => {
      expect(store.getState().user.data.name).toBe('John Doe');
    });
  });
});
```

### Zustand Testing Strategies

#### 1. Zustand Store Testing Setup

```javascript
// stores/testUtils.js
import { act, renderHook } from '@testing-library/react';
import { createUserStore } from './userStore';
import { createPostsStore } from './postsStore';

// Store factory for testing
export const createTestUserStore = (initialState = {}) => {
  const store = createUserStore();
  
  if (Object.keys(initialState).length > 0) {
    act(() => {
      store.setState(initialState);
    });
  }
  
  return store;
};

// Custom hook for testing stores
export const renderStoreHook = (store, selector) => {
  return renderHook(() => store(selector));
};

// Mock API utilities
export const mockApiCall = (response, delay = 0) => {
  return jest.fn().mockImplementation(
    () => new Promise((resolve) => {
      setTimeout(() => resolve(response), delay);
    })
  );
};

// Store state assertions
export const expectStoreState = (store, expectedState) => {
  expect(store.getState()).toMatchObject(expectedState);
};
```

#### 2. Store Unit Testing

```javascript
// __tests__/userStore.test.js
import { act } from '@testing-library/react';
import { createTestUserStore, expectStoreState } from '../testUtils';
import * as api from '../api/userApi';

// Mock the API module
jest.mock('../api/userApi');
const mockedApi = api as jest.Mocked<typeof api>;

describe('userStore', () => {
  let store;
  
  beforeEach(() => {
    store = createTestUserStore();
    jest.clearAllMocks();
  });
  
  describe('synchronous actions', () => {
    it('should set user data', () => {
      const userData = { id: 1, name: 'John Doe', email: 'john@example.com' };
      
      act(() => {
        store.getState().setUser(userData);
      });
      
      expectStoreState(store, {
        user: userData,
        loading: false,
        error: null,
      });
    });
    
    it('should update user profile', () => {
      const initialUser = { id: 1, name: 'John', email: 'john@example.com' };
      const updates = { name: 'John Doe', bio: 'Developer' };
      
      act(() => {
        store.getState().setUser(initialUser);
        store.getState().updateProfile(updates);
      });
      
      expectStoreState(store, {
        user: { ...initialUser, ...updates },
      });
    });
    
    it('should clear user data', () => {
      const userData = { id: 1, name: 'John Doe' };
      
      act(() => {
        store.getState().setUser(userData);
        store.getState().clearUser();
      });
      
      expectStoreState(store, {
        user: null,
        loading: false,
        error: null,
      });
    });
  });
  
  describe('asynchronous actions', () => {
    it('should fetch user successfully', async () => {
      const mockUser = { id: 1, name: 'John Doe', email: 'john@example.com' };
      mockedApi.fetchUser.mockResolvedValueOnce(mockUser);
      
      await act(async () => {
        await store.getState().fetchUser(1);
      });
      
      expect(mockedApi.fetchUser).toHaveBeenCalledWith(1);
      expectStoreState(store, {
        user: mockUser,
        loading: false,
        error: null,
      });
    });
    
    it('should handle fetch user error', async () => {
      const errorMessage = 'User not found';
      mockedApi.fetchUser.mockRejectedValueOnce(new Error(errorMessage));
      
      await act(async () => {
        await store.getState().fetchUser(999);
      });
      
      expectStoreState(store, {
        user: null,
        loading: false,
        error: errorMessage,
      });
    });
    
    it('should set loading state during async operations', async () => {
      let resolvePromise;
      const promise = new Promise((resolve) => {
        resolvePromise = resolve;
      });
      
      mockedApi.fetchUser.mockReturnValueOnce(promise);
      
      // Start async operation
      act(() => {
        store.getState().fetchUser(1);
      });
      
      // Check loading state
      expectStoreState(store, {
        loading: true,
        error: null,
      });
      
      // Resolve promise
      await act(async () => {
        resolvePromise({ id: 1, name: 'John' });
        await promise;
      });
      
      expectStoreState(store, {
        loading: false,
      });
    });
  });
});
```

#### 3. Hook Integration Testing

```javascript
// __tests__/useUserProfile.test.js
import { renderHook, act } from '@testing-library/react';
import { useUserProfile } from '../hooks/useUserProfile';
import { createTestUserStore } from '../testUtils';
import * as api from '../api/userApi';

jest.mock('../api/userApi');
const mockedApi = api as jest.Mocked<typeof api>;

describe('useUserProfile hook', () => {
  let store;
  
  beforeEach(() => {
    store = createTestUserStore();
    jest.clearAllMocks();
  });
  
  it('should return user profile data', () => {
    const userData = { id: 1, name: 'John Doe', email: 'john@example.com' };
    
    act(() => {
      store.getState().setUser(userData);
    });
    
    const { result } = renderHook(() => useUserProfile(store));
    
    expect(result.current.user).toEqual(userData);
    expect(result.current.loading).toBe(false);
    expect(result.current.error).toBeNull();
  });
  
  it('should handle profile updates', async () => {
    const initialUser = { id: 1, name: 'John', email: 'john@example.com' };
    const updatedUser = { ...initialUser, name: 'John Doe' };
    
    mockedApi.updateUser.mockResolvedValueOnce(updatedUser);
    
    act(() => {
      store.getState().setUser(initialUser);
    });
    
    const { result } = renderHook(() => useUserProfile(store));
    
    await act(async () => {
      await result.current.updateProfile({ name: 'John Doe' });
    });
    
    expect(result.current.user.name).toBe('John Doe');
  });
});
```

#### 4. Component Testing with Zustand

```javascript
// __tests__/UserProfileZustand.test.js
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import UserProfile from '../components/UserProfile';
import { createTestUserStore } from '../testUtils';
import { UserStoreProvider } from '../providers/UserStoreProvider';
import * as api from '../api/userApi';

jest.mock('../api/userApi');
const mockedApi = api as jest.Mocked<typeof api>;

const renderWithStore = (component, store) => {
  return render(
    <UserStoreProvider store={store}>
      {component}
    </UserStoreProvider>
  );
};

describe('UserProfile with Zustand', () => {
  let store;
  
  beforeEach(() => {
    store = createTestUserStore();
    jest.clearAllMocks();
  });
  
  it('should display user information', () => {
    const userData = { id: 1, name: 'John Doe', email: 'john@example.com' };
    
    store.getState().setUser(userData);
    
    renderWithStore(<UserProfile />, store);
    
    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });
  
  it('should handle loading state', () => {
    store.getState().setLoading(true);
    
    renderWithStore(<UserProfile />, store);
    
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });
  
  it('should handle error state', () => {
    store.getState().setError('Failed to load user');
    
    renderWithStore(<UserProfile />, store);
    
    expect(screen.getByText('Failed to load user')).toBeInTheDocument();
  });
});
```

### Advanced Testing Patterns

#### 1. Time-Travel Testing

```javascript
// __tests__/timeTravel.test.js
import { createTestStore } from '../testUtils';
import { addTodo, toggleTodo, removeTodo } from '../slices/todosSlice';

describe('Time-travel testing', () => {
  it('should support undo/redo operations', () => {
    const store = createTestStore();
    const actions = [];
    
    // Record actions
    const originalDispatch = store.dispatch;
    store.dispatch = (action) => {
      actions.push(action);
      return originalDispatch(action);
    };
    
    // Perform actions
    store.dispatch(addTodo({ id: 1, text: 'Learn Redux', completed: false }));
    store.dispatch(addTodo({ id: 2, text: 'Learn Testing', completed: false }));
    store.dispatch(toggleTodo(1));
    
    const finalState = store.getState();
    
    // Replay actions
    const replayStore = createTestStore();
    actions.forEach(action => replayStore.dispatch(action));
    
    expect(replayStore.getState()).toEqual(finalState);
  });
});
```

#### 2. Performance Testing

```javascript
// __tests__/performance.test.js
import { renderHook } from '@testing-library/react';
import { useSelector } from 'react-redux';
import { createTestStore } from '../testUtils';
import { selectExpensiveComputation } from '../selectors';

describe('Performance testing', () => {
  it('should memoize expensive selectors', () => {
    const store = createTestStore();
    const mockComputation = jest.fn(() => 'computed value');
    
    // Mock the expensive computation
    jest.spyOn(require('../selectors'), 'expensiveComputation')
      .mockImplementation(mockComputation);
    
    const { result, rerender } = renderHook(
      () => useSelector(selectExpensiveComputation),
      {
        wrapper: ({ children }) => (
          <Provider store={store}>{children}</Provider>
        ),
      }
    );
    
    // First render
    expect(result.current).toBe('computed value');
    expect(mockComputation).toHaveBeenCalledTimes(1);
    
    // Re-render without state change
    rerender();
    expect(mockComputation).toHaveBeenCalledTimes(1); // Should not recompute
  });
});
```

### Best Practices

#### Testing Strategy
- **Unit Tests**: Test individual reducers, actions, and selectors
- **Integration Tests**: Test component-store interactions
- **E2E Tests**: Test complete user workflows
- **Performance Tests**: Verify memoization and optimization

#### Test Organization
- **Arrange-Act-Assert**: Structure tests clearly
- **Test Isolation**: Each test should be independent
- **Mock External Dependencies**: API calls, timers, etc.
- **Test Edge Cases**: Error states, loading states, empty data

#### Redux-Specific Testing
- **Pure Functions**: Reducers are easy to test
- **Action Creators**: Test both sync and async actions
- **Selectors**: Test memoization and computation
- **Middleware**: Test side effects and async flows

#### Zustand-Specific Testing
- **Store Isolation**: Create fresh stores for each test
- **State Mutations**: Test immer-based updates
- **Subscriptions**: Test reactive updates
- **Persistence**: Test hydration and serialization

### Comparison Summary

| Feature | Redux | Zustand |
|---------|-------|----------|
| **Test Setup** | More complex, requires providers | Simpler, direct store usage |
| **Mocking** | Mock actions and reducers | Mock store methods |
| **Time Travel** | Built-in with DevTools | Manual implementation |
| **Async Testing** | Thunk/Saga testing patterns | Promise-based testing |
| **Performance Testing** | Selector memoization testing | Subscription testing |
| **Integration Testing** | Provider wrapper required | Direct store injection |
| **Test Utilities** | Rich ecosystem (RTL, etc.) | Custom utilities needed |
| **Debugging** | Excellent DevTools support | Manual debugging tools |

---

## 59. How do you implement advanced state management patterns for micro-frontends architecture in Redux vs Zustand?

Micro-frontends require sophisticated state management strategies to handle isolation, communication, and shared state across independent applications.

### Redux Implementation

#### Federated Store Architecture

```javascript
// shared/store-registry.js
class StoreRegistry {
  constructor() {
    this.stores = new Map();
    this.globalStore = null;
    this.eventBus = new EventTarget();
  }

  registerStore(appName, store) {
    this.stores.set(appName, store);
    this.eventBus.dispatchEvent(new CustomEvent('store-registered', {
      detail: { appName, store }
    }));
  }

  getStore(appName) {
    return this.stores.get(appName);
  }

  setGlobalStore(store) {
    this.globalStore = store;
  }

  broadcastAction(action, excludeApp = null) {
    this.stores.forEach((store, appName) => {
      if (appName !== excludeApp) {
        store.dispatch(action);
      }
    });
  }
}

export const storeRegistry = new StoreRegistry();
```

#### Shared State Slice

```javascript
// shared/shared-slice.js
import { createSlice } from '@reduxjs/toolkit';

const sharedSlice = createSlice({
  name: 'shared',
  initialState: {
    user: null,
    theme: 'light',
    notifications: [],
    crossAppData: {},
    eventHistory: []
  },
  reducers: {
    setUser: (state, action) => {
      state.user = action.payload;
      state.eventHistory.push({
        type: 'USER_UPDATED',
        timestamp: Date.now(),
        data: action.payload
      });
    },
    setTheme: (state, action) => {
      state.theme = action.payload;
    },
    addNotification: (state, action) => {
      state.notifications.push({
        id: Date.now(),
        ...action.payload
      });
    },
    setCrossAppData: (state, action) => {
      const { appName, data } = action.payload;
      state.crossAppData[appName] = data;
    },
    syncFromExternal: (state, action) => {
      const { source, data } = action.payload;
      Object.assign(state, data);
      state.eventHistory.push({
        type: 'EXTERNAL_SYNC',
        source,
        timestamp: Date.now()
      });
    }
  }
});

export const {
  setUser,
  setTheme,
  addNotification,
  setCrossAppData,
  syncFromExternal
} = sharedSlice.actions;

export default sharedSlice.reducer;
```

#### Cross-App Communication Middleware

```javascript
// shared/cross-app-middleware.js
import { storeRegistry } from './store-registry';

const crossAppMiddleware = (store) => (next) => (action) => {
  const result = next(action);
  
  // Handle cross-app actions
  if (action.meta?.crossApp) {
    const { targetApps, excludeCurrent } = action.meta.crossApp;
    
    if (targetApps) {
      targetApps.forEach(appName => {
        const targetStore = storeRegistry.getStore(appName);
        if (targetStore) {
          targetStore.dispatch({
            ...action,
            meta: { ...action.meta, fromApp: store.appName }
          });
        }
      });
    } else if (excludeCurrent) {
      storeRegistry.broadcastAction(action, store.appName);
    }
  }
  
  // Handle shared state synchronization
  if (action.type.startsWith('shared/')) {
    window.postMessage({
      type: 'REDUX_SHARED_ACTION',
      action,
      source: store.appName
    }, '*');
  }
  
  return result;
};

export default crossAppMiddleware;
```

#### Micro-Frontend Store Setup

```javascript
// app1/store.js
import { configureStore } from '@reduxjs/toolkit';
import { storeRegistry } from '../shared/store-registry';
import crossAppMiddleware from '../shared/cross-app-middleware';
import sharedReducer from '../shared/shared-slice';
import app1Reducer from './app1-slice';

const store = configureStore({
  reducer: {
    shared: sharedReducer,
    app1: app1Reducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST']
      }
    }).concat(crossAppMiddleware)
});

store.appName = 'app1';
storeRegistry.registerStore('app1', store);

// Listen for external state changes
window.addEventListener('message', (event) => {
  if (event.data.type === 'REDUX_SHARED_ACTION' && 
      event.data.source !== 'app1') {
    store.dispatch(event.data.action);
  }
});

export default store;
```

### Zustand Implementation

#### Federated Store Manager

```javascript
// shared/store-manager.js
import { subscribeWithSelector } from 'zustand/middleware';
import { createWithEqualityFn } from 'zustand/traditional';
import { shallow } from 'zustand/shallow';

class MicroFrontendStoreManager {
  constructor() {
    this.stores = new Map();
    this.sharedStore = null;
    this.eventBus = new EventTarget();
    this.subscriptions = new Map();
  }

  createSharedStore() {
    this.sharedStore = createWithEqualityFn(
      subscribeWithSelector((set, get) => ({
        user: null,
        theme: 'light',
        notifications: [],
        crossAppData: {},
        eventHistory: [],
        
        setUser: (user) => set((state) => {
          const newState = { ...state, user };
          newState.eventHistory.push({
            type: 'USER_UPDATED',
            timestamp: Date.now(),
            data: user
          });
          return newState;
        }),
        
        setTheme: (theme) => set({ theme }),
        
        addNotification: (notification) => set((state) => ({
          notifications: [...state.notifications, {
            id: Date.now(),
            ...notification
          }]
        })),
        
        setCrossAppData: (appName, data) => set((state) => ({
          crossAppData: {
            ...state.crossAppData,
            [appName]: data
          }
        })),
        
        syncFromExternal: (source, data) => set((state) => {
          const newState = { ...state, ...data };
          newState.eventHistory.push({
            type: 'EXTERNAL_SYNC',
            source,
            timestamp: Date.now()
          });
          return newState;
        })
      })),
      shallow
    );
    
    return this.sharedStore;
  }

  registerStore(appName, store) {
    this.stores.set(appName, store);
    
    // Set up cross-app communication
    const unsubscribe = store.subscribe(
      (state) => state,
      (state, prevState) => {
        this.eventBus.dispatchEvent(new CustomEvent('state-change', {
          detail: { appName, state, prevState }
        }));
      }
    );
    
    this.subscriptions.set(appName, unsubscribe);
  }

  broadcastAction(action, excludeApp = null) {
    this.stores.forEach((store, appName) => {
      if (appName !== excludeApp && store.actions) {
        const actionMethod = store.actions[action.type];
        if (actionMethod) {
          actionMethod(action.payload);
        }
      }
    });
  }
}

export const storeManager = new MicroFrontendStoreManager();
```

#### App-Specific Store with Cross-App Features

```javascript
// app1/store.js
import { createWithEqualityFn } from 'zustand/traditional';
import { subscribeWithSelector, persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import { storeManager } from '../shared/store-manager';

const useApp1Store = createWithEqualityFn(
  persist(
    subscribeWithSelector(
      immer((set, get) => ({
        // App-specific state
        products: [],
        cart: [],
        filters: {},
        loading: false,
        
        // Actions
        actions: {
          addProduct: (product) => set((state) => {
            state.products.push(product);
          }),
          
          addToCart: (productId) => set((state) => {
            const product = state.products.find(p => p.id === productId);
            if (product) {
              state.cart.push(product);
              
              // Notify other apps
              const sharedStore = storeManager.getSharedStore();
              if (sharedStore) {
                sharedStore.getState().setCrossAppData('app1', {
                  cartCount: state.cart.length
                });
              }
            }
          }),
          
          broadcastCartUpdate: () => {
            const state = get();
            storeManager.broadcastAction({
              type: 'updateCartCount',
              payload: state.cart.length
            }, 'app1');
          }
        },
        
        // Computed values
        get cartTotal() {
          return get().cart.reduce((sum, item) => sum + item.price, 0);
        }
      }))
    ),
    { name: 'app1-store' }
  )
);

storeManager.registerStore('app1', useApp1Store);
export default useApp1Store;
```

#### Cross-App Communication Hook

```javascript
// shared/use-micro-frontend.js
import { useEffect, useCallback } from 'react';
import { storeManager } from './store-manager';

export const useMicroFrontend = (appName) => {
  const sharedStore = storeManager.getSharedStore();
  const appStore = storeManager.getStore(appName);
  
  const sharedState = sharedStore?.();
  const appState = appStore?.();
  
  const communicateWithApp = useCallback((targetApp, action) => {
    const targetStore = storeManager.getStore(targetApp);
    if (targetStore && targetStore.actions) {
      const actionMethod = targetStore.actions[action.type];
      if (actionMethod) {
        actionMethod(action.payload);
      }
    }
  }, []);
  
  const broadcastToAll = useCallback((action) => {
    storeManager.broadcastAction(action, appName);
  }, [appName]);
  
  // Set up cross-app event listeners
  useEffect(() => {
    const handleStateChange = (event) => {
      const { appName: sourceApp, state } = event.detail;
      if (sourceApp !== appName && sharedStore) {
        sharedStore.getState().setCrossAppData(sourceApp, {
          lastUpdate: Date.now(),
          summary: { hasData: Object.keys(state).length > 0 }
        });
      }
    };
    
    storeManager.eventBus.addEventListener('state-change', handleStateChange);
    
    return () => {
      storeManager.eventBus.removeEventListener('state-change', handleStateChange);
    };
  }, [appName, sharedStore]);
  
  return {
    sharedState,
    appState,
    communicateWithApp,
    broadcastToAll
  };
};
```

### Best Practices

#### Architecture
- **Isolation**: Keep app-specific state separate from shared state
- **Communication**: Use event-driven architecture for loose coupling
- **Versioning**: Version shared state schemas for backward compatibility
- **Boundaries**: Define clear boundaries between micro-frontends

#### Performance
- **Lazy Loading**: Load stores only when micro-frontends are mounted
- **Selective Sync**: Only sync necessary state between apps
- **Debouncing**: Debounce cross-app communications to avoid spam
- **Memory Management**: Clean up subscriptions when apps unmount

#### Security
- **Validation**: Validate all cross-app communications
- **Sanitization**: Sanitize data before sharing between apps
- **Access Control**: Implement proper access controls for shared state
- **Audit Trail**: Log all cross-app state changes

### Comparison Summary

| Feature | Redux | Zustand |
|---------|-------|----------|
| **Setup Complexity** | High (multiple stores, middleware) | Medium (store manager) |
| **Cross-App Communication** | Middleware-based | Event-driven |
| **State Isolation** | Provider boundaries | Store boundaries |
| **Shared State** | Federated reducers | Shared store instance |
| **DevTools** | Excellent (Redux DevTools) | Custom implementation |
| **Performance** | Good (with optimization) | Excellent (minimal overhead) |
| **Type Safety** | Good (with TypeScript) | Excellent (TypeScript-first) |
| **Learning Curve** | Steep (complex patterns) | Moderate (simpler concepts) |