# JavaScript Interview Questions - Lead Software Engineer

## Table of Contents
- [JavaScript Interview Questions - Lead Software Engineer](#javascript-interview-questions---lead-software-engineer)
  - [Table of Contents](#table-of-contents)
  - [Fundamentals](#fundamentals)
    - [Q1: What are the different data types in JavaScript? Explain with examples.](#q1-what-are-the-different-data-types-in-javascript-explain-with-examples)
    - [Q2: Explain the difference between `==` and `===` operators with examples.](#q2-explain-the-difference-between--and--operators-with-examples)
    - [Q3: What is hoisting in JavaScript? Explain with examples.](#q3-what-is-hoisting-in-javascript-explain-with-examples)
    - [Q4: Explain the concept of scope in JavaScript.](#q4-explain-the-concept-of-scope-in-javascript)
    - [Q5: What is the difference between `var`, `let`, and `const`?](#q5-what-is-the-difference-between-var-let-and-const)
  - [Functions and Scope](#functions-and-scope)
    - [Q6: Explain closures in JavaScript with practical examples.](#q6-explain-closures-in-javascript-with-practical-examples)
    - [Q7: What are arrow functions and how do they differ from regular functions?](#q7-what-are-arrow-functions-and-how-do-they-differ-from-regular-functions)
  - [Asynchronous Programming](#asynchronous-programming)
    - [Q8: Explain the event loop in JavaScript.](#q8-explain-the-event-loop-in-javascript)
    - [Q9: What are Promises? Explain with examples including error handling.](#q9-what-are-promises-explain-with-examples-including-error-handling)
    - [Q10: Explain async/await and how it relates to Promises.](#q10-explain-asyncawait-and-how-it-relates-to-promises)
  - [ES6+ Features](#es6-features)
    - [Q11: Explain destructuring assignment with examples.](#q11-explain-destructuring-assignment-with-examples)
    - [Q12: What are template literals and their advanced features?](#q12-what-are-template-literals-and-their-advanced-features)
    - [Q13: Explain the spread operator and rest parameters.](#q13-explain-the-spread-operator-and-rest-parameters)
  - [Advanced Concepts](#advanced-concepts)
    - [Q14: What is currying in JavaScript? Provide practical examples.](#q14-what-is-currying-in-javascript-provide-practical-examples)
    - [Q15: Explain generators in JavaScript with practical use cases.](#q15-explain-generators-in-javascript-with-practical-use-cases)
  - [Event Handling](#event-handling)
    - [Q16: Explain event delegation and its benefits.](#q16-explain-event-delegation-and-its-benefits)
    - [Q17: Explain the JavaScript Event Loop in detail.](#q17-explain-the-javascript-event-loop-in-detail)
    - [Q18: What are JavaScript Modules (ES6 Modules) and how do they work?](#q18-what-are-javascript-modules-es6-modules-and-how-do-they-work)
  - [Advanced JavaScript Patterns and Modern Features](#advanced-javascript-patterns-and-modern-features)
    - [Q19: What are JavaScript Generators and how do they work? Provide advanced examples.](#q19-what-are-javascript-generators-and-how-do-they-work-provide-advanced-examples)
    - [Q20: Explain Proxy and Reflect in JavaScript with practical examples.](#q20-explain-proxy-and-reflect-in-javascript-with-practical-examples)
    - [Q21: What are WeakMap and WeakSet? When should you use them?](#q21-what-are-weakmap-and-weakset-when-should-you-use-them)
    - [Q22: Explain Symbol and its use cases in JavaScript.](#q22-explain-symbol-and-its-use-cases-in-javascript)
  - [Modern JavaScript Best Practices and Patterns](#modern-javascript-best-practices-and-patterns)
    - [Q23: What are the best practices for error handling in modern JavaScript?](#q23-what-are-the-best-practices-for-error-handling-in-modern-javascript)
    - [Q24: Explain error handling in JavaScript with try-catch, custom errors, and async error handling.](#q24-explain-error-handling-in-javascript-with-try-catch-custom-errors-and-async-error-handling)
    - [Q25: What is the difference between `call`, `apply`, and `bind` methods?](#q25-what-is-the-difference-between-call-apply-and-bind-methods)
  - [Advanced JavaScript Concepts](#advanced-javascript-concepts)
    - [Q26: Explain JavaScript Design Patterns with practical examples.](#q26-explain-javascript-design-patterns-with-practical-examples)
    - [Q27: Explain JavaScript Prototypes and Prototype Chain in detail.](#q27-explain-javascript-prototypes-and-prototype-chain-in-detail)
    - [Q28: Explain Advanced Array Methods and their practical use cases.](#q28-explain-advanced-array-methods-and-their-practical-use-cases)
    - [Q29: Explain Web APIs and Browser Features with practical examples.](#q29-explain-web-apis-and-browser-features-with-practical-examples)
    - [Q30: Explain Modern JavaScript Features (ES2020+) with examples.](#q30-explain-modern-javascript-features-es2020-with-examples)
  - [Modern JavaScript Features (ES2020-2023+)](#modern-javascript-features-es2020-2023)
    - [Q31: What are the latest JavaScript features and how do you use them?](#q31-what-are-the-latest-javascript-features-and-how-do-you-use-them)
  - [Advanced JavaScript Patterns](#advanced-javascript-patterns)
    - [Q32: What are some advanced JavaScript design patterns and when should you use them?](#q32-what-are-some-advanced-javascript-design-patterns-and-when-should-you-use-them)
  - [Memory Management](#memory-management)
    - [Q33: Explain JavaScript memory management and garbage collection. How can you prevent memory leaks?](#q33-explain-javascript-memory-management-and-garbage-collection-how-can-you-prevent-memory-leaks)
  - [Performance Optimization](#performance-optimization)
    - [Q34: How do you optimize JavaScript performance and manage memory effectively?](#q34-how-do-you-optimize-javascript-performance-and-manage-memory-effectively)
  - [Browser APIs](#browser-apis)
    - [Q35: Explain the Intersection Observer API and how it can be used for performance optimization.](#q35-explain-the-intersection-observer-api-and-how-it-can-be-used-for-performance-optimization)
    - [Q36: Explain Web Workers in JavaScript and how they can improve application performance.](#q36-explain-web-workers-in-javascript-and-how-they-can-improve-application-performance)
    - [Q37: Explain the Fetch API and how it compares to XMLHttpRequest.](#q37-explain-the-fetch-api-and-how-it-compares-to-xmlhttprequest)
    - [Q38: Explain Service Workers and how they enable Progressive Web Applications (PWAs).](#q38-explain-service-workers-and-how-they-enable-progressive-web-applications-pwas)
    - [Q39: Explain the History API and how it enables client-side routing in single-page applications.](#q39-explain-the-history-api-and-how-it-enables-client-side-routing-in-single-page-applications)
    - [Q40: Explain the Geolocation API and how to implement location-based features in web applications.](#q40-explain-the-geolocation-api-and-how-to-implement-location-based-features-in-web-applications)
    - [Q41: Explain WebRTC (Web Real-Time Communication) and how to implement peer-to-peer communication in web applications.](#q41-explain-webrtc-web-real-time-communication-and-how-to-implement-peer-to-peer-communication-in-web-applications)
    - [Q42: Explain the Web Audio API and how to create advanced audio applications in the browser.](#q42-explain-the-web-audio-api-and-how-to-create-advanced-audio-applications-in-the-browser)
    - [Q43: Explain IndexedDB and how to use it for client-side storage in web applications.](#q43-explain-indexeddb-and-how-to-use-it-for-client-side-storage-in-web-applications)
  - [Security](#security)
    - [Q44: Explain common JavaScript security vulnerabilities and how to prevent them.](#q44-explain-common-javascript-security-vulnerabilities-and-how-to-prevent-them)
  - [Modern JavaScript ES2024+ Features and Advanced Patterns](#modern-javascript-es2024-features-and-advanced-patterns)
    - [Q45: How do you implement advanced functional programming patterns in modern JavaScript?](#q45-how-do-you-implement-advanced-functional-programming-patterns-in-modern-javascript)
    - [Q46: How do you implement advanced state management patterns in vanilla JavaScript?](#q46-how-do-you-implement-advanced-state-management-patterns-in-vanilla-javascript)
    - [Q47: How do you implement advanced JavaScript metaprogramming and reflection patterns?](#q47-how-do-you-implement-advanced-javascript-metaprogramming-and-reflection-patterns)
    - [Q48: How do you implement advanced JavaScript performance optimization and memory management?](#q48-how-do-you-implement-advanced-javascript-performance-optimization-and-memory-management)
    - [Q49: How do you implement advanced JavaScript ES2024+ features including Records, Tuples, and Pattern Matching?](#q49-how-do-you-implement-advanced-javascript-es2024-features-including-records-tuples-and-pattern-matching)
    - [Q50: How do you implement advanced JavaScript temporal APIs and modern asynchronous patterns with AbortController and Structured Concurrency?](#q50-how-do-you-implement-advanced-javascript-temporal-apis-and-modern-asynchronous-patterns-with-abortcontroller-and-structured-concurrency)
  - [JavaScript Fundamentals Deep Dive](#javascript-fundamentals-deep-dive)
    - [Q51: What is the difference between `null` and `undefined` in JavaScript?](#q51-what-is-the-difference-between-null-and-undefined-in-javascript)
    - [Q52: Explain closures in JavaScript with advanced examples and use cases.](#q52-explain-closures-in-javascript-with-advanced-examples-and-use-cases)
    - [Q53: Explain JavaScript Promises in depth with advanced patterns and error handling.](#q53-explain-javascript-promises-in-depth-with-advanced-patterns-and-error-handling)
    - [Q54: Explain async/await in JavaScript with advanced patterns and best practices.](#q54-explain-asyncawait-in-javascript-with-advanced-patterns-and-best-practices)
    - [Q55: Explain the JavaScript Event Loop in detail with examples.](#q55-explain-the-javascript-event-loop-in-detail-with-examples)
  - [JavaScript Advanced Concepts](#javascript-advanced-concepts-1)
    - [Q56: Explain JavaScript's prototype-based inheritance in depth with examples.](#q56-explain-javascripts-prototype-based-inheritance-in-depth-with-examples)
    - [Q57: Explain JavaScript modules in depth, including different module systems and best practices.](#q57-explain-javascript-modules-in-depth-including-different-module-systems-and-best-practices)
    - [Q58: Explain JavaScript memory management and garbage collection in depth.](#q58-explain-javascript-memory-management-and-garbage-collection-in-depth)
    - [Q59: Explain common JavaScript design patterns with examples.](#q59-explain-common-javascript-design-patterns-with-examples)
    - [Q60: Explain JavaScript error handling and debugging techniques.](#q60-explain-javascript-error-handling-and-debugging-techniques)
  - [JavaScript Performance and Security](#javascript-performance-and-security)
    - [Q61: Explain JavaScript performance optimization techniques.](#q61-explain-javascript-performance-optimization-techniques)
    - [Q62: What are JavaScript security best practices and common vulnerabilities?](#q62-what-are-javascript-security-best-practices-and-common-vulnerabilities)
    - [Q63: Explain JavaScript testing strategies and frameworks.](#q63-explain-javascript-testing-strategies-and-frameworks)
  - [Web APIs and Browser Integration](#web-apis-and-browser-integration)
    - [Q64: Explain the most important Web APIs and browser interactions in JavaScript.](#q64-explain-the-most-important-web-apis-and-browser-interactions-in-javascript)
    - [Q65: Explain functional programming concepts in JavaScript.](#q65-explain-functional-programming-concepts-in-javascript)
    - [Q66: Explain JavaScript event handling and event delegation in depth.](#q66-explain-javascript-event-handling-and-event-delegation-in-depth)
    - [Q67: Compare and contrast different browser storage mechanisms in JavaScript.](#q67-compare-and-contrast-different-browser-storage-mechanisms-in-javascript)
    - [Q68: Explain Web Workers in JavaScript and how they enable concurrent programming.](#q68-explain-web-workers-in-javascript-and-how-they-enable-concurrent-programming)
  - [Internationalization and Accessibility](#internationalization-and-accessibility)
    - [Q69: Explain JavaScript's Internationalization (i18n) features and best practices.](#q69-explain-javascripts-internationalization-i18n-features-and-best-practices)
    - [Q70: Explain JavaScript's role in web accessibility (a11y) and best practices for creating accessible web applications.](#q70-explain-javascripts-role-in-web-accessibility-a11y-and-best-practices-for-creating-accessible-web-applications)
  - [Modern Web Development](#modern-web-development)
    - [Q71: Explain JavaScript build tools and module bundlers. What are their purposes, and how do they improve modern web development?](#q71-explain-javascript-build-tools-and-module-bundlers-what-are-their-purposes-and-how-do-they-improve-modern-web-development)
    - [Q72: Explain Progressive Web Apps (PWAs). How do they work, and what JavaScript technologies enable them?](#q72-explain-progressive-web-apps-pwas-how-do-they-work-and-what-javascript-technologies-enable-them)
    - [Q73: Compare and contrast popular JavaScript frameworks and libraries. What are their strengths, weaknesses, and best use cases?](#q73-compare-and-contrast-popular-javascript-frameworks-and-libraries-what-are-their-strengths-weaknesses-and-best-use-cases)
  - [Advanced JavaScript Topics](#advanced-javascript-topics)
    - [Q74: Explain JavaScript memory management and garbage collection. How can you identify and fix memory leaks in JavaScript applications?](#q74-explain-javascript-memory-management-and-garbage-collection-how-can-you-identify-and-fix-memory-leaks-in-javascript-applications)
    - [Q75: Explain JavaScript's concurrency model and event loop. How does JavaScript handle asynchronous operations despite being single-threaded?](#q75-explain-javascripts-concurrency-model-and-event-loop-how-does-javascript-handle-asynchronous-operations-despite-being-single-threaded)
    - [Q76: Explain common JavaScript design patterns. How and when would you implement them?](#q76-explain-common-javascript-design-patterns-how-and-when-would-you-implement-them)
    - [Q77: What are the common security vulnerabilities in JavaScript applications and how can you prevent them?](#q77-what-are-the-common-security-vulnerabilities-in-javascript-applications-and-how-can-you-prevent-them)
    - [Q78: What are the most effective JavaScript performance optimization techniques?](#q78-what-are-the-most-effective-javascript-performance-optimization-techniques)
    - [Q79: What are the best practices for testing JavaScript applications?](#q79-what-are-the-best-practices-for-testing-javascript-applications)
    - [Q80: What are the most effective debugging techniques and tools for JavaScript applications?](#q80-what-are-the-most-effective-debugging-techniques-and-tools-for-javascript-applications)
  - [Functional Programming and Modern JavaScript](#functional-programming-and-modern-javascript)
    - [Q81: How does functional programming work in JavaScript, and what are its key concepts?](#q81-how-does-functional-programming-work-in-javascript-and-what-are-its-key-concepts)
    - [Q82: What is WebAssembly (WASM) and how does it integrate with JavaScript?](#q82-what-is-webassembly-wasm-and-how-does-it-integrate-with-javascript)
  - [Internationalization and Accessibility Best Practices](#internationalization-and-accessibility-best-practices)
    - [Q83: How do you implement internationalization (i18n) in JavaScript applications?](#q83-how-do-you-implement-internationalization-i18n-in-javascript-applications)
    - [Q84: What are the best practices for implementing web accessibility in JavaScript applications?](#q84-what-are-the-best-practices-for-implementing-web-accessibility-in-javascript-applications)
  - [Modern Web Development Tools and Frameworks](#modern-web-development-tools-and-frameworks)
    - [Q85: Explain JavaScript build tools and module bundlers. How do they improve development workflow?](#q85-explain-javascript-build-tools-and-module-bundlers-how-do-they-improve-development-workflow)
    - [Q86: Explain Progressive Web Apps (PWAs) and how to implement them using JavaScript.](#q86-explain-progressive-web-apps-pwas-and-how-to-implement-them-using-javascript)
    - [Q87: Compare and contrast popular JavaScript frameworks and libraries. How do you choose the right one for a project?](#q87-compare-and-contrast-popular-javascript-frameworks-and-libraries-how-do-you-choose-the-right-one-for-a-project)
  - [Advanced JavaScript Performance and Debugging](#advanced-javascript-performance-and-debugging)
    - [Q88: Explain JavaScript memory management and garbage collection. How do you identify and fix memory leaks?](#q88-explain-javascript-memory-management-and-garbage-collection-how-do-you-identify-and-fix-memory-leaks)
    - [Q89: Explain JavaScript error handling and debugging strategies. How do you implement robust error handling in production applications?](#q89-explain-javascript-error-handling-and-debugging-strategies-how-do-you-implement-robust-error-handling-in-production-applications)
  - [JavaScript Security and Best Practices](#javascript-security-and-best-practices)
    - [Q90: Explain JavaScript security best practices. How do you protect web applications from common vulnerabilities?](#q90-explain-javascript-security-best-practices-how-do-you-protect-web-applications-from-common-vulnerabilities)
    - [Q91: Explain common JavaScript design patterns. How and when would you implement them?](#q91-explain-common-javascript-design-patterns-how-and-when-would-you-implement-them)
  - [JavaScript Performance and Testing](#javascript-performance-and-testing)
    - [Q92: What are the best practices for optimizing JavaScript performance? How would you identify and fix performance bottlenecks?](#q92-what-are-the-best-practices-for-optimizing-javascript-performance-how-would-you-identify-and-fix-performance-bottlenecks)
    - [Q93: What are the different testing strategies for JavaScript applications? How would you implement a comprehensive testing approach?](#q93-what-are-the-different-testing-strategies-for-javascript-applications-how-would-you-implement-a-comprehensive-testing-approach)
  - [Functional Programming and Web APIs](#functional-programming-and-web-apis)
    - [Q94: Explain functional programming concepts in JavaScript. How can they improve code quality?](#q94-explain-functional-programming-concepts-in-javascript-how-can-they-improve-code-quality)
    - [Q95: Explain JavaScript Web APIs and browser interactions. How do they enhance web applications?](#q95-explain-javascript-web-apis-and-browser-interactions-how-do-they-enhance-web-applications)
  - [Accessibility and Internationalization](#accessibility-and-internationalization)
    - [Q96: Explain JavaScript accessibility best practices. How can developers create more inclusive web applications?](#q96-explain-javascript-accessibility-best-practices-how-can-developers-create-more-inclusive-web-applications)
    - [Q97: Explain JavaScript internationalization (i18n) and localization (l10n). How can you build applications that support multiple languages and regions?](#q97-explain-javascript-internationalization-i18n-and-localization-l10n-how-can-you-build-applications-that-support-multiple-languages-and-regions)
  - [Build Tools and Frameworks](#build-tools-and-frameworks)
    - [Q98: Explain JavaScript build tools and module bundlers. How do they improve the development workflow and application performance?](#q98-explain-javascript-build-tools-and-module-bundlers-how-do-they-improve-the-development-workflow-and-application-performance)
    - [Q99: Compare and contrast popular JavaScript frameworks and libraries. How do you choose the right one for a project?](#q99-compare-and-contrast-popular-javascript-frameworks-and-libraries-how-do-you-choose-the-right-one-for-a-project)
  - [WebAssembly and JavaScript Integration](#webassembly-and-javascript-integration)
    - [Q100: Explain WebAssembly (Wasm) and how it integrates with JavaScript. What are its use cases and limitations?](#q100-explain-webassembly-wasm-and-how-it-integrates-with-javascript-what-are-its-use-cases-and-limitations)

---

## Fundamentals

### Q1: What are the different data types in JavaScript? Explain with examples.
**Difficulty: Easy**

**Answer:**
JavaScript has 8 data types, divided into two categories:

**Primitive Types:**
1. **Number** - Represents both integers and floating-point numbers
2. **String** - Represents text data
3. **Boolean** - Represents true/false values
4. **Undefined** - Represents a variable that has been declared but not assigned
5. **Null** - Represents an intentional absence of value
6. **Symbol** - Represents a unique identifier (ES6+)
7. **BigInt** - Represents integers with arbitrary precision (ES2020)

**Non-Primitive Type:**
8. **Object** - Represents complex data structures

```javascript
// Number
let age = 25;
let price = 99.99;
let infinity = Infinity;
let notANumber = NaN;

// String
let name = "John Doe";
let template = `Hello, ${name}!`;

// Boolean
let isActive = true;
let isCompleted = false;

// Undefined
let undefinedVar;
console.log(undefinedVar); // undefined

// Null
let emptyValue = null;

// Symbol
let sym1 = Symbol('id');
let sym2 = Symbol('id');
console.log(sym1 === sym2); // false

// BigInt
let bigNumber = 1234567890123456789012345678901234567890n;

// Object
let person = {
    name: "Alice",
    age: 30
};
let numbers = [1, 2, 3, 4, 5];
let func = function() { return "Hello"; };
```

**Type Checking:**
```javascript
console.log(typeof 42);          // "number"
console.log(typeof "hello");     // "string"
console.log(typeof true);        // "boolean"
console.log(typeof undefined);   // "undefined"
console.log(typeof null);        // "object" (this is a known quirk)
console.log(typeof Symbol());    // "symbol"
console.log(typeof 123n);        // "bigint"
console.log(typeof {});          // "object"
console.log(typeof []);          // "object"
console.log(typeof function(){}); // "function"
```

---

### Q2: Explain the difference between `==` and `===` operators with examples.
**Difficulty: Easy**

**Answer:**
The main difference lies in type coercion:

**`==` (Loose Equality):**
- Performs type coercion before comparison
- Converts operands to the same type, then compares
- Can lead to unexpected results

**`===` (Strict Equality):**
- No type coercion
- Compares both value and type
- Recommended for most comparisons

```javascript
// Loose Equality (==)
console.log(5 == "5");        // true (string "5" converted to number)
console.log(true == 1);       // true (boolean converted to number)
console.log(false == 0);      // true
console.log(null == undefined); // true (special case)
console.log("" == 0);         // true (empty string converted to 0)
console.log([] == 0);         // true (array converted to primitive)

// Strict Equality (===)
console.log(5 === "5");       // false (different types)
console.log(true === 1);      // false
console.log(false === 0);     // false
console.log(null === undefined); // false
console.log("" === 0);        // false
console.log([] === 0);        // false

// Same type comparisons work the same
console.log(5 == 5);          // true
console.log(5 === 5);         // true
console.log("hello" == "hello"); // true
console.log("hello" === "hello"); // true
```

**Type Coercion Examples:**
```javascript
// Complex coercion scenarios
console.log("2" + 1);         // "21" (string concatenation)
console.log("2" - 1);         // 1 (numeric subtraction)
console.log("2" * "3");       // 6 (both converted to numbers)
console.log(true + true);     // 2 (booleans converted to numbers)
console.log([1,2] + [3,4]);   // "1,23,4" (arrays converted to strings)
```

**Best Practice:**
Always use `===` and `!==` unless you specifically need type coercion.

---

### Q3: What is hoisting in JavaScript? Explain with examples.
**Difficulty: Medium**

**Answer:**
Hoisting is JavaScript's behavior of moving variable and function declarations to the top of their containing scope during the compilation phase. However, only declarations are hoisted, not initializations.

**Variable Hoisting:**

```javascript
// What you write:
console.log(x); // undefined (not ReferenceError)
var x = 5;
console.log(x); // 5

// How JavaScript interprets it:
var x; // declaration hoisted
console.log(x); // undefined
x = 5; // initialization stays in place
console.log(x); // 5
```

**Function Hoisting:**

```javascript
// Function declarations are fully hoisted
console.log(sayHello()); // "Hello!" - works before declaration

function sayHello() {
    return "Hello!";
}

// Function expressions are not hoisted
console.log(sayGoodbye()); // TypeError: sayGoodbye is not a function

var sayGoodbye = function() {
    return "Goodbye!";
};
```

**Let and Const Hoisting:**

```javascript
// let and const are hoisted but in "temporal dead zone"
console.log(a); // ReferenceError: Cannot access 'a' before initialization
let a = 10;

console.log(b); // ReferenceError: Cannot access 'b' before initialization
const b = 20;

// Temporal Dead Zone example
function example() {
    console.log(temp); // ReferenceError
    let temp = "I'm in TDZ";
}
```

**Complex Hoisting Scenarios:**

```javascript
var name = "Global";

function outer() {
    console.log(name); // undefined (not "Global")
    
    if (false) {
        var name = "Local"; // This declaration is hoisted
    }
    
    console.log(name); // undefined
}

outer();

// Equivalent to:
function outer() {
    var name; // hoisted declaration
    console.log(name); // undefined
    
    if (false) {
        name = "Local"; // assignment (never executed)
    }
    
    console.log(name); // undefined
}
```

**Function vs Variable Hoisting Priority:**

```javascript
console.log(typeof foo); // "function"

var foo = "I'm a variable";

function foo() {
    return "I'm a function";
}

console.log(typeof foo); // "string"

// Functions are hoisted before variables
```

---

### Q4: Explain the concept of scope in JavaScript.
**Difficulty: Medium**

**Answer:**
Scope determines the accessibility of variables, functions, and objects in different parts of your code. JavaScript has several types of scope:

**1. Global Scope:**
Variables declared outside any function or block have global scope.

```javascript
var globalVar = "I'm global";
let globalLet = "I'm also global";

function testGlobal() {
    console.log(globalVar); // Accessible
    console.log(globalLet); // Accessible
}

// Accessible from anywhere
console.log(globalVar);
console.log(globalLet);
```

**2. Function Scope:**
Variables declared inside a function are only accessible within that function.

```javascript
function functionScope() {
    var functionVar = "I'm function scoped";
    let functionLet = "I'm also function scoped";
    
    console.log(functionVar); // Accessible
    console.log(functionLet); // Accessible
}

functionScope();
// console.log(functionVar); // ReferenceError
// console.log(functionLet); // ReferenceError
```

**3. Block Scope (ES6+):**
`let` and `const` have block scope, `var` does not.

```javascript
if (true) {
    var varVariable = "I'm var";
    let letVariable = "I'm let";
    const constVariable = "I'm const";
}

console.log(varVariable); // "I'm var" - accessible
// console.log(letVariable); // ReferenceError
// console.log(constVariable); // ReferenceError

// Loop example
for (var i = 0; i < 3; i++) {
    // var i is function/global scoped
}
console.log(i); // 3

for (let j = 0; j < 3; j++) {
    // let j is block scoped
}
// console.log(j); // ReferenceError
```

**4. Lexical Scope:**
Inner functions have access to variables in their outer scope.

```javascript
function outerFunction(x) {
    let outerVariable = x;
    
    function innerFunction(y) {
        let innerVariable = y;
        console.log(outerVariable); // Accessible
        console.log(innerVariable); // Accessible
    }
    
    return innerFunction;
}

const inner = outerFunction(10);
inner(20); // Can access outerVariable even after outerFunction returns
```

**5. Module Scope:**
Variables declared at the top level of a module.

```javascript
// module.js
const moduleVariable = "I'm module scoped";
let anotherModuleVar = "Me too";

export function getModuleVar() {
    return moduleVariable; // Accessible within module
}

// Not accessible from outside unless exported
```

**Scope Chain:**

```javascript
let global = "global";

function level1() {
    let level1Var = "level1";
    
    function level2() {
        let level2Var = "level2";
        
        function level3() {
            let level3Var = "level3";
            
            // Can access all outer scopes
            console.log(global);     // "global"
            console.log(level1Var);  // "level1"
            console.log(level2Var);  // "level2"
            console.log(level3Var);  // "level3"
        }
        
        return level3;
    }
    
    return level2;
}

const func = level1()();
func();
```

---

### Q5: What is the difference between `var`, `let`, and `const`?
**Difficulty: Medium**

**Answer:**
These are three ways to declare variables in JavaScript, each with different characteristics:

**Comparison Table:**

| Feature | var | let | const |
|---------|-----|-----|-------|
| Scope | Function/Global | Block | Block |
| Hoisting | Yes (undefined) | Yes (TDZ) | Yes (TDZ) |
| Re-declaration | Allowed | Not allowed | Not allowed |
| Re-assignment | Allowed | Allowed | Not allowed |
| Temporal Dead Zone | No | Yes | Yes |
| Initialization | Optional | Optional | Required |

**1. Scope Differences:**

```javascript
function scopeExample() {
    if (true) {
        var varVariable = "var";
        let letVariable = "let";
        const constVariable = "const";
    }
    
    console.log(varVariable);    // "var" - function scoped
    // console.log(letVariable);    // ReferenceError - block scoped
    // console.log(constVariable);  // ReferenceError - block scoped
}

// Loop example
for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log("var:", i), 100); // 3, 3, 3
}

for (let j = 0; j < 3; j++) {
    setTimeout(() => console.log("let:", j), 100); // 0, 1, 2
}
```

**2. Hoisting Differences:**

```javascript
console.log(varVariable);    // undefined
console.log(letVariable);    // ReferenceError
console.log(constVariable);  // ReferenceError

var varVariable = "var";
let letVariable = "let";
const constVariable = "const";
```

**3. Re-declaration:**

```javascript
// var allows re-declaration
var name = "John";
var name = "Jane"; // No error
console.log(name); // "Jane"

// let and const don't allow re-declaration
let age = 25;
// let age = 30; // SyntaxError

const city = "New York";
// const city = "Boston"; // SyntaxError
```

**4. Re-assignment:**

```javascript
// var and let allow re-assignment
var varNum = 10;
varNum = 20; // OK

let letNum = 10;
letNum = 20; // OK

// const doesn't allow re-assignment
const constNum = 10;
// constNum = 20; // TypeError

// But object properties can be modified
const obj = { name: "John" };
obj.name = "Jane"; // OK
obj.age = 25;      // OK
// obj = {};       // TypeError
```

**5. Temporal Dead Zone:**

```javascript
function temporalDeadZone() {
    console.log(varVar);   // undefined
    // console.log(letVar);   // ReferenceError
    // console.log(constVar); // ReferenceError
    
    var varVar = "var";
    let letVar = "let";
    const constVar = "const";
}
```

**6. Best Practices:**

```javascript
// Use const by default
const PI = 3.14159;
const users = [];
const config = { api: "https://api.example.com" };

// Use let when you need to reassign
let counter = 0;
let currentUser = null;

for (let i = 0; i < 10; i++) {
    counter += i;
}

// Avoid var in modern JavaScript
// Only use var if you specifically need function scoping
```

---

## Functions and Scope

### Q6: Explain closures in JavaScript with practical examples.
**Difficulty: Hard**

**Answer:**
A closure is a function that has access to variables in its outer (enclosing) scope even after the outer function has returned. Closures are created every time a function is created.

**Basic Closure Example:**

```javascript
function outerFunction(x) {
    // Outer function's variable
    let outerVariable = x;
    
    // Inner function (closure)
    function innerFunction(y) {
        console.log(outerVariable + y); // Accesses outer variable
    }
    
    return innerFunction;
}

const addFive = outerFunction(5);
addFive(10); // 15 - outerVariable (5) is still accessible
```

**Practical Example 1: Data Privacy**

```javascript
function createCounter() {
    let count = 0; // Private variable
    
    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount());  // 2
console.log(counter.decrement()); // 1

// count is not directly accessible
console.log(counter.count); // undefined
```

**Practical Example 2: Function Factory**

```javascript
function createMultiplier(multiplier) {
    return function(x) {
        return x * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

**Practical Example 3: Module Pattern**

```javascript
const userModule = (function() {
    let users = [];
    let currentId = 1;
    
    return {
        addUser: function(name, email) {
            const user = {
                id: currentId++,
                name: name,
                email: email
            };
            users.push(user);
            return user;
        },
        
        getUser: function(id) {
            return users.find(user => user.id === id);
        },
        
        getAllUsers: function() {
            return [...users]; // Return copy to prevent mutation
        },
        
        removeUser: function(id) {
            const index = users.findIndex(user => user.id === id);
            if (index !== -1) {
                return users.splice(index, 1)[0];
            }
            return null;
        }
    };
})();

// Usage
const user1 = userModule.addUser("John", "john@example.com");
const user2 = userModule.addUser("Jane", "jane@example.com");
console.log(userModule.getAllUsers());
```

**Common Closure Pitfall - Loop Problem:**

```javascript
// Problem: All functions log 3
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i); // 3, 3, 3
    }, 100);
}

// Solution 1: Use let (block scope)
for (let i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i); // 0, 1, 2
    }, 100);
}

// Solution 2: Use closure with IIFE
for (var i = 0; i < 3; i++) {
    (function(index) {
        setTimeout(function() {
            console.log(index); // 0, 1, 2
        }, 100);
    })(i);
}

// Solution 3: Use bind
for (var i = 0; i < 3; i++) {
    setTimeout(function(index) {
        console.log(index); // 0, 1, 2
    }.bind(null, i), 100);
}
```

**Memory Considerations:**

```javascript
function createHeavyClosure() {
    const heavyData = new Array(1000000).fill('data');
    
    return function(index) {
        return heavyData[index]; // heavyData is kept in memory
    };
}

// Better approach if you don't need all the data
function createLightClosure() {
    return function(size, index) {
        const data = new Array(size).fill('data');
        return data[index];
    };
}
```

**Advanced Closure Pattern - Memoization:**

```javascript
function memoize(fn) {
    const cache = new Map();
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (cache.has(key)) {
            console.log('Cache hit');
            return cache.get(key);
        }
        
        console.log('Computing...');
        const result = fn.apply(this, args);
        cache.set(key, result);
        return result;
    };
}

const expensiveFunction = memoize(function(n) {
    let result = 0;
    for (let i = 0; i < n; i++) {
        result += i;
    }
    return result;
});

console.log(expensiveFunction(1000)); // Computing... then result
console.log(expensiveFunction(1000)); // Cache hit, then result
```

---

### Q7: What are arrow functions and how do they differ from regular functions?
**Difficulty: Medium**

**Answer:**
Arrow functions are a concise way to write functions introduced in ES6. They have several key differences from regular functions:

**Syntax Comparison:**

```javascript
// Regular function
function regularFunction(a, b) {
    return a + b;
}

// Arrow function
const arrowFunction = (a, b) => a + b;

// Various arrow function syntaxes
const noParams = () => "Hello";
const oneParam = x => x * 2;           // Parentheses optional for single param
const multipleParams = (x, y) => x + y;
const multipleLines = (x, y) => {
    const sum = x + y;
    return sum * 2;
};
```

**Key Differences:**

**1. `this` Binding:**

```javascript
const obj = {
    name: "John",
    
    // Regular function - 'this' refers to obj
    regularMethod: function() {
        console.log("Regular:", this.name); // "John"
        
        setTimeout(function() {
            console.log("Regular setTimeout:", this.name); // undefined (global this)
        }, 100);
    },
    
    // Arrow function - 'this' is lexically bound
    arrowMethod: () => {
        console.log("Arrow:", this.name); // undefined (global this)
    },
    
    // Mixed approach
    mixedMethod: function() {
        console.log("Mixed outer:", this.name); // "John"
        
        setTimeout(() => {
            console.log("Mixed arrow setTimeout:", this.name); // "John"
        }, 100);
    }
};

obj.regularMethod();
obj.arrowMethod();
obj.mixedMethod();
```

**2. Arguments Object:**

```javascript
// Regular function has 'arguments' object
function regularFunc() {
    console.log(arguments); // Arguments object
    console.log(Array.from(arguments));
}

// Arrow function doesn't have 'arguments'
const arrowFunc = () => {
    // console.log(arguments); // ReferenceError
};

// Use rest parameters instead
const arrowWithRest = (...args) => {
    console.log(args); // Array
};

regularFunc(1, 2, 3);
arrowWithRest(1, 2, 3);
```

**3. Constructor Usage:**

```javascript
// Regular function can be used as constructor
function RegularConstructor(name) {
    this.name = name;
}

const instance1 = new RegularConstructor("John"); // Works

// Arrow function cannot be used as constructor
const ArrowConstructor = (name) => {
    this.name = name;
};

// const instance2 = new ArrowConstructor("Jane"); // TypeError
```

**4. Hoisting:**

```javascript
// Regular function declarations are hoisted
console.log(hoistedFunction()); // "I'm hoisted!"

function hoistedFunction() {
    return "I'm hoisted!";
}

// Arrow functions are not hoisted (they're expressions)
// console.log(notHoisted()); // ReferenceError

const notHoisted = () => "I'm not hoisted!";
```

**5. Method Definitions:**

```javascript
class MyClass {
    constructor(name) {
        this.name = name;
    }
    
    // Regular method
    regularMethod() {
        return `Hello, ${this.name}`;
    }
    
    // Arrow function as property (not recommended for methods)
    arrowMethod = () => {
        return `Hi, ${this.name}`;
    }
    
    // Event handler example
    setupEventListener() {
        const button = document.getElementById('myButton');
        
        // Regular function - need to bind 'this'
        button.addEventListener('click', function() {
            console.log(this.name); // undefined
        }.bind(this));
        
        // Arrow function - 'this' is automatically bound
        button.addEventListener('click', () => {
            console.log(this.name); // Works correctly
        });
    }
}
```

**When to Use Each:**

**Use Arrow Functions:**
- Short, simple functions
- Callbacks where you want to preserve `this`
- Functional programming patterns
- Event handlers in classes

```javascript
// Good use cases for arrow functions
const numbers = [1, 2, 3, 4, 5];

// Array methods
const doubled = numbers.map(n => n * 2);
const evens = numbers.filter(n => n % 2 === 0);
const sum = numbers.reduce((acc, n) => acc + n, 0);

// Promise chains
fetch('/api/data')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error(error));
```

**Use Regular Functions:**
- Object methods
- Constructor functions
- When you need `arguments` object
- When you need dynamic `this` binding

```javascript
// Good use cases for regular functions
const calculator = {
    value: 0,
    
    add: function(n) {
        this.value += n;
        return this;
    },
    
    multiply: function(n) {
        this.value *= n;
        return this;
    },
    
    getValue: function() {
        return this.value;
    }
};

// Method chaining works because 'this' refers to calculator
calculator.add(5).multiply(2).getValue(); // 10
```

**Performance Considerations:**

```javascript
// Arrow functions in object literals create new functions each time
const createUser = (name) => ({
    name,
    greet: () => `Hello, ${name}` // New function created each time
});

// Better approach
const createUserBetter = (name) => ({
    name,
    greet() {
        return `Hello, ${this.name}`;
    }
});
```

---

## Asynchronous Programming

### Q8: Explain the event loop in JavaScript.
**Difficulty: Hard**

**Answer:**
The event loop is the mechanism that allows JavaScript to perform non-blocking operations despite being single-threaded. It manages the execution of code, collection of events, and execution of queued sub-tasks.

**JavaScript Runtime Components:**

```javascript
// 1. Call Stack - LIFO (Last In, First Out)
// 2. Web APIs (Browser) / C++ APIs (Node.js)
// 3. Callback Queue (Task Queue)
// 4. Microtask Queue (Job Queue)
// 5. Event Loop
```

**Call Stack Example:**

```javascript
function first() {
    console.log('First');
    second();
    console.log('First again');
}

function second() {
    console.log('Second');
    third();
    console.log('Second again');
}

function third() {
    console.log('Third');
}

first();

// Call Stack execution:
// 1. first() pushed
// 2. console.log('First') executed
// 3. second() pushed
// 4. console.log('Second') executed
// 5. third() pushed
// 6. console.log('Third') executed
// 7. third() popped
// 8. console.log('Second again') executed
// 9. second() popped
// 10. console.log('First again') executed
// 11. first() popped
```

**Asynchronous Operations:**

```javascript
console.log('Start');

setTimeout(() => {
    console.log('Timeout 1');
}, 0);

setTimeout(() => {
    console.log('Timeout 2');
}, 0);

Promise.resolve().then(() => {
    console.log('Promise 1');
});

Promise.resolve().then(() => {
    console.log('Promise 2');
});

console.log('End');

// Output:
// Start
// End
// Promise 1
// Promise 2
// Timeout 1
// Timeout 2
```

**Detailed Event Loop Process:**

```javascript
// Step-by-step execution
function eventLoopExample() {
    console.log('1: Synchronous');
    
    // Macro task (goes to callback queue)
    setTimeout(() => {
        console.log('4: setTimeout');
    }, 0);
    
    // Microtask (goes to microtask queue)
    Promise.resolve().then(() => {
        console.log('3: Promise');
    });
    
    console.log('2: Synchronous');
}

eventLoopExample();

// Execution order:
// 1. Call stack: console.log('1: Synchronous')
// 2. setTimeout callback goes to Web API, then callback queue
// 3. Promise.then goes to microtask queue
// 4. Call stack: console.log('2: Synchronous')
// 5. Call stack empty, event loop checks microtask queue first
// 6. Execute Promise callback: console.log('3: Promise')
// 7. Microtask queue empty, check callback queue
// 8. Execute setTimeout callback: console.log('4: setTimeout')
```

**Microtasks vs Macrotasks:**

```javascript
// Microtasks (higher priority):
// - Promise.then/catch/finally
// - queueMicrotask()
// - MutationObserver

// Macrotasks (lower priority):
// - setTimeout/setInterval
// - setImmediate (Node.js)
// - I/O operations
// - UI events

console.log('Start');

// Macrotask
setTimeout(() => console.log('Macro 1'), 0);

// Microtask
Promise.resolve().then(() => console.log('Micro 1'));

// Macrotask
setTimeout(() => console.log('Macro 2'), 0);

// Microtask
Promise.resolve().then(() => console.log('Micro 2'));

console.log('End');

// Output:
// Start
// End
// Micro 1
// Micro 2
// Macro 1
// Macro 2
```

**Complex Example with Nested Callbacks:**

```javascript
function complexEventLoop() {
    console.log('1');
    
    setTimeout(() => {
        console.log('2');
        Promise.resolve().then(() => console.log('3'));
    }, 0);
    
    Promise.resolve().then(() => {
        console.log('4');
        setTimeout(() => console.log('5'), 0);
    });
    
    setTimeout(() => {
        console.log('6');
    }, 0);
    
    console.log('7');
}

complexEventLoop();

// Output:
// 1
// 7
// 4
// 2
// 3
// 6
// 5
```

**Event Loop Phases (Node.js):**

```javascript
// Node.js event loop has 6 phases:
// 1. Timer phase (setTimeout, setInterval)
// 2. Pending callbacks phase
// 3. Idle, prepare phase
// 4. Poll phase (I/O operations)
// 5. Check phase (setImmediate)
// 6. Close callbacks phase

// Node.js specific example
setImmediate(() => console.log('setImmediate'));
setTimeout(() => console.log('setTimeout'), 0);
process.nextTick(() => console.log('nextTick'));
Promise.resolve().then(() => console.log('Promise'));

// Output in Node.js:
// nextTick
// Promise
// setTimeout (or setImmediate, order may vary)
// setImmediate (or setTimeout, order may vary)
```

**Blocking the Event Loop:**

```javascript
// Bad: Blocking the event loop
function blockingOperation() {
    const start = Date.now();
    while (Date.now() - start < 3000) {
        // Blocking for 3 seconds
    }
    console.log('Blocking operation complete');
}

console.log('Before blocking');
blockingOperation();
console.log('After blocking');

// Better: Non-blocking approach
function nonBlockingOperation() {
    return new Promise(resolve => {
        setTimeout(() => {
            console.log('Non-blocking operation complete');
            resolve();
        }, 3000);
    });
}

console.log('Before non-blocking');
nonBlockingOperation().then(() => {
    console.log('After non-blocking');
});
console.log('This runs immediately');
```

**Practical Implications:**

```javascript
// Understanding event loop helps with:

// 1. Avoiding callback hell
function callbackHell() {
    setTimeout(() => {
        console.log('1');
        setTimeout(() => {
            console.log('2');
            setTimeout(() => {
                console.log('3');
            }, 100);
        }, 100);
    }, 100);
}

// 2. Using Promises effectively
function promiseChain() {
    return Promise.resolve()
        .then(() => {
            console.log('1');
            return new Promise(resolve => setTimeout(resolve, 100));
        })
        .then(() => {
            console.log('2');
            return new Promise(resolve => setTimeout(resolve, 100));
        })
        .then(() => {
            console.log('3');
        });
}

// 3. Optimizing performance
function optimizedBatchUpdate() {
    // Batch DOM updates using microtasks
    Promise.resolve().then(() => {
        // All DOM updates happen together
        document.getElementById('element1').textContent = 'Updated 1';
        document.getElementById('element2').textContent = 'Updated 2';
        document.getElementById('element3').textContent = 'Updated 3';
    });
}
```

---

### Q9: What are Promises? Explain with examples including error handling.
**Difficulty: Medium**

**Answer:**
Promises are objects representing the eventual completion or failure of an asynchronous operation. They provide a cleaner alternative to callbacks for handling asynchronous code.

**Promise States:**
- **Pending**: Initial state, neither fulfilled nor rejected
- **Fulfilled**: Operation completed successfully
- **Rejected**: Operation failed

**Basic Promise Creation:**

```javascript
// Creating a Promise
const myPromise = new Promise((resolve, reject) => {
    const success = Math.random() > 0.5;
    
    setTimeout(() => {
        if (success) {
            resolve('Operation successful!');
        } else {
            reject(new Error('Operation failed!'));
        }
    }, 1000);
});

// Consuming the Promise
myPromise
    .then(result => {
        console.log('Success:', result);
    })
    .catch(error => {
        console.log('Error:', error.message);
    })
    .finally(() => {
        console.log('Operation completed');
    });
```

**Promise Methods:**

```javascript
// Promise.resolve() - Creates a resolved promise
const resolvedPromise = Promise.resolve('Immediate success');
resolvedPromise.then(value => console.log(value));

// Promise.reject() - Creates a rejected promise
const rejectedPromise = Promise.reject(new Error('Immediate failure'));
rejectedPromise.catch(error => console.log(error.message));

// Promise.all() - Waits for all promises to resolve
const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = Promise.resolve(3);

Promise.all([promise1, promise2, promise3])
    .then(values => {
        console.log('All resolved:', values); // [1, 2, 3]
    })
    .catch(error => {
        console.log('One or more failed:', error);
    });

// Promise.allSettled() - Waits for all promises to settle
const mixedPromises = [
    Promise.resolve('Success'),
    Promise.reject(new Error('Failure')),
    Promise.resolve('Another success')
];

Promise.allSettled(mixedPromises)
    .then(results => {
        results.forEach((result, index) => {
            if (result.status === 'fulfilled') {
                console.log(`Promise ${index} succeeded:`, result.value);
            } else {
                console.log(`Promise ${index} failed:`, result.reason.message);
            }
        });
    });

// Promise.race() - Resolves with the first settled promise
const fastPromise = new Promise(resolve => setTimeout(() => resolve('Fast'), 100));
const slowPromise = new Promise(resolve => setTimeout(() => resolve('Slow'), 500));

Promise.race([fastPromise, slowPromise])
    .then(result => {
        console.log('First to complete:', result); // 'Fast'
    });

// Promise.any() - Resolves with the first fulfilled promise
const failingPromise = Promise.reject(new Error('Failed'));
const succeedingPromise = new Promise(resolve => 
    setTimeout(() => resolve('Success'), 200)
);

Promise.any([failingPromise, succeedingPromise])
    .then(result => {
        console.log('First success:', result); // 'Success'
    })
    .catch(error => {
        console.log('All failed:', error);
    });
```

**Chaining Promises:**

```javascript
// Sequential execution
function fetchUserData(userId) {
    return fetch(`/api/users/${userId}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(user => {
            console.log('User fetched:', user);
            return fetch(`/api/users/${userId}/posts`);
        })
        .then(response => response.json())
        .then(posts => {
            console.log('Posts fetched:', posts);
            return { user, posts };
        })
        .catch(error => {
            console.error('Error in chain:', error);
            throw error; // Re-throw to propagate
        });
}

// Usage
fetchUserData(123)
    .then(data => {
        console.log('Complete data:', data);
    })
    .catch(error => {
        console.log('Final error handler:', error.message);
    });
```

**Error Handling Patterns:**

```javascript
// 1. Basic error handling
function basicErrorHandling() {
    return fetch('/api/data')
        .then(response => response.json())
        .catch(error => {
            console.error('Network error:', error);
            return { error: 'Failed to fetch data' }; // Fallback value
        });
}

// 2. Specific error handling
function specificErrorHandling() {
    return fetch('/api/data')
        .then(response => {
            if (response.status === 404) {
                throw new Error('Data not found');
            }
            if (response.status === 401) {
                throw new Error('Unauthorized');
            }
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .catch(error => {
            if (error.message === 'Data not found') {
                return null; // Handle 404 specifically
            }
            if (error.message === 'Unauthorized') {
                // Redirect to login
                window.location.href = '/login';
                return;
            }
            throw error; // Re-throw other errors
        });
}

// 3. Error recovery
function errorRecovery() {
    let retryCount = 0;
    const maxRetries = 3;
    
    function attemptFetch() {
        return fetch('/api/unreliable-endpoint')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                return response.json();
            })
            .catch(error => {
                retryCount++;
                if (retryCount <= maxRetries) {
                    console.log(`Retry ${retryCount}/${maxRetries}`);
                    return new Promise(resolve => {
                        setTimeout(() => resolve(attemptFetch()), 1000 * retryCount);
                    });
                }
                throw new Error(`Failed after ${maxRetries} retries: ${error.message}`);
            });
    }
    
    return attemptFetch();
}
```

**Advanced Promise Patterns:**

```javascript
// 1. Promise timeout
function withTimeout(promise, timeoutMs) {
    const timeout = new Promise((_, reject) => {
        setTimeout(() => {
            reject(new Error(`Operation timed out after ${timeoutMs}ms`));
        }, timeoutMs);
    });
    
    return Promise.race([promise, timeout]);
}

// Usage
const slowOperation = new Promise(resolve => 
    setTimeout(() => resolve('Done'), 5000)
);

withTimeout(slowOperation, 3000)
    .then(result => console.log(result))
    .catch(error => console.log(error.message)); // "Operation timed out after 3000ms"

// 2. Promise queue (sequential execution)
class PromiseQueue {
    constructor() {
        this.queue = [];
        this.running = false;
    }
    
    add(promiseFunction) {
        return new Promise((resolve, reject) => {
            this.queue.push({
                promiseFunction,
                resolve,
                reject
            });
            this.process();
        });
    }
    
    async process() {
        if (this.running || this.queue.length === 0) {
            return;
        }
        
        this.running = true;
        
        while (this.queue.length > 0) {
            const { promiseFunction, resolve, reject } = this.queue.shift();
            
            try {
                const result = await promiseFunction();
                resolve(result);
            } catch (error) {
                reject(error);
            }
        }
        
        this.running = false;
    }
}

// Usage
const queue = new PromiseQueue();

queue.add(() => fetch('/api/data1').then(r => r.json()));
queue.add(() => fetch('/api/data2').then(r => r.json()));
queue.add(() => fetch('/api/data3').then(r => r.json()));

// 3. Promise memoization
function memoizePromise(fn) {
    const cache = new Map();
    
    return function(...args) {
        const key = JSON.stringify(args);
        
        if (cache.has(key)) {
            return cache.get(key);
        }
        
        const promise = fn.apply(this, args)
            .catch(error => {
                cache.delete(key); // Remove failed promises from cache
                throw error;
            });
        
        cache.set(key, promise);
        return promise;
    };
}

const memoizedFetch = memoizePromise(url => fetch(url).then(r => r.json()));

// First call makes HTTP request
memoizedFetch('/api/data').then(data => console.log('First:', data));

// Second call returns cached promise
memoizedFetch('/api/data').then(data => console.log('Second:', data));
```

**Converting Callbacks to Promises:**

```javascript
// Promisifying callback-based functions
function promisify(fn) {
    return function(...args) {
        return new Promise((resolve, reject) => {
            fn(...args, (error, result) => {
                if (error) {
                    reject(error);
                } else {
                    resolve(result);
                }
            });
        });
    };
}

// Example: Promisifying setTimeout
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Example: Promisifying Node.js fs.readFile
const fs = require('fs');
const readFileAsync = promisify(fs.readFile);

readFileAsync('file.txt', 'utf8')
    .then(content => console.log(content))
    .catch(error => console.error(error));
```

---

### Q10: Explain async/await and how it relates to Promises.
**Difficulty: Medium**

**Answer:**
Async/await is syntactic sugar built on top of Promises, introduced in ES2017. It allows you to write asynchronous code that looks and behaves more like synchronous code, making it easier to read and maintain.

**Basic Syntax:**

```javascript
// Promise-based approach
function fetchDataWithPromises() {
    return fetch('/api/user/1')
        .then(response => response.json())
        .then(user => {
            console.log('User:', user);
            return fetch(`/api/user/${user.id}/posts`);
        })
        .then(response => response.json())
        .then(posts => {
            console.log('Posts:', posts);
            return { user, posts };
        })
        .catch(error => {
            console.error('Error:', error);
            throw error;
        });
}

// Async/await approach
async function fetchDataWithAsyncAwait() {
    try {
        const userResponse = await fetch('/api/user/1');
        const user = await userResponse.json();
        console.log('User:', user);
        
        const postsResponse = await fetch(`/api/user/${user.id}/posts`);
        const posts = await postsResponse.json();
        console.log('Posts:', posts);
        
        return { user, posts };
    } catch (error) {
        console.error('Error:', error);
        throw error;
    }
}
```

**Key Concepts:**

**1. Async Functions Always Return Promises:**

```javascript
async function simpleAsync() {
    return 'Hello World';
}

// Equivalent to:
function simplePromise() {
    return Promise.resolve('Hello World');
}

// Both return a Promise
console.log(simpleAsync()); // Promise { 'Hello World' }
console.log(simplePromise()); // Promise { 'Hello World' }

// To get the value:
simpleAsync().then(value => console.log(value)); // 'Hello World'
```

**2. Await Can Only Be Used Inside Async Functions:**

```javascript
// ❌ This will cause a SyntaxError
function regularFunction() {
    const result = await fetch('/api/data'); // SyntaxError
    return result;
}

// ✅ Correct usage
async function asyncFunction() {
    const result = await fetch('/api/data');
    return result;
}

// ✅ Top-level await (ES2022 in modules)
// In a module file:
const data = await fetch('/api/data');
```

**Error Handling:**

```javascript
// 1. Try-catch for error handling
async function handleErrors() {
    try {
        const response = await fetch('/api/data');
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Fetch error:', error.message);
        
        // You can return a default value or re-throw
        return { error: 'Failed to fetch data' };
    }
}

// 2. Multiple try-catch blocks
async function multipleErrorHandling() {
    let user, posts;
    
    try {
        const userResponse = await fetch('/api/user/1');
        user = await userResponse.json();
    } catch (error) {
        console.error('Failed to fetch user:', error);
        return { error: 'User fetch failed' };
    }
    
    try {
        const postsResponse = await fetch(`/api/user/${user.id}/posts`);
        posts = await postsResponse.json();
    } catch (error) {
        console.error('Failed to fetch posts:', error);
        // Continue with just user data
        posts = [];
    }
    
    return { user, posts };
}

// 3. Catching specific errors
async function specificErrorHandling() {
    try {
        const response = await fetch('/api/data');
        const data = await response.json();
        return data;
    } catch (error) {
        if (error instanceof TypeError) {
            console.error('Network error:', error.message);
        } else if (error instanceof SyntaxError) {
            console.error('JSON parsing error:', error.message);
        } else {
            console.error('Unknown error:', error.message);
        }
        throw error;
    }
}
```

**Parallel vs Sequential Execution:**

```javascript
// ❌ Sequential execution (slower)
async function sequentialExecution() {
    const start = Date.now();
    
    const user = await fetch('/api/user/1').then(r => r.json());
    const posts = await fetch('/api/posts').then(r => r.json());
    const comments = await fetch('/api/comments').then(r => r.json());
    
    console.log(`Sequential took: ${Date.now() - start}ms`);
    return { user, posts, comments };
}

// ✅ Parallel execution (faster)
async function parallelExecution() {
    const start = Date.now();
    
    // Start all requests simultaneously
    const userPromise = fetch('/api/user/1').then(r => r.json());
    const postsPromise = fetch('/api/posts').then(r => r.json());
    const commentsPromise = fetch('/api/comments').then(r => r.json());
    
    // Wait for all to complete
    const [user, posts, comments] = await Promise.all([
        userPromise,
        postsPromise,
        commentsPromise
    ]);
    
    console.log(`Parallel took: ${Date.now() - start}ms`);
    return { user, posts, comments };
}

// ✅ Alternative parallel syntax
async function parallelExecutionAlt() {
    const start = Date.now();
    
    const [user, posts, comments] = await Promise.all([
        fetch('/api/user/1').then(r => r.json()),
        fetch('/api/posts').then(r => r.json()),
        fetch('/api/comments').then(r => r.json())
    ]);
    
    console.log(`Parallel alt took: ${Date.now() - start}ms`);
    return { user, posts, comments };
}
```

**Advanced Patterns:**

**1. Async Iteration:**

```javascript
// Processing arrays with async/await
async function processUsers(userIds) {
    const users = [];
    
    // ❌ Sequential processing
    for (const id of userIds) {
        const user = await fetch(`/api/users/${id}`).then(r => r.json());
        users.push(user);
    }
    
    return users;
}

// ✅ Parallel processing
async function processUsersParallel(userIds) {
    const userPromises = userIds.map(id => 
        fetch(`/api/users/${id}`).then(r => r.json())
    );
    
    return await Promise.all(userPromises);
}

// ✅ Controlled concurrency
async function processUsersWithLimit(userIds, limit = 3) {
    const results = [];
    
    for (let i = 0; i < userIds.length; i += limit) {
        const batch = userIds.slice(i, i + limit);
        const batchPromises = batch.map(id => 
            fetch(`/api/users/${id}`).then(r => r.json())
        );
        
        const batchResults = await Promise.all(batchPromises);
        results.push(...batchResults);
    }
    
    return results;
}
```

**2. Async Generators:**

```javascript
async function* fetchPages(baseUrl) {
    let page = 1;
    let hasMore = true;
    
    while (hasMore) {
        const response = await fetch(`${baseUrl}?page=${page}`);
        const data = await response.json();
        
        yield data.items;
        
        hasMore = data.hasMore;
        page++;
    }
}

// Usage
async function processAllPages() {
    for await (const pageItems of fetchPages('/api/items')) {
        console.log('Processing page with', pageItems.length, 'items');
        // Process each page as it arrives
    }
}
```

**3. Timeout and Cancellation:**

```javascript
// Timeout wrapper
function withTimeout(promise, timeoutMs) {
    return Promise.race([
        promise,
        new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), timeoutMs)
        )
    ]);
}

async function fetchWithTimeout(url, timeoutMs = 5000) {
    try {
        const response = await withTimeout(fetch(url), timeoutMs);
        return await response.json();
    } catch (error) {
        if (error.message === 'Timeout') {
            console.error(`Request to ${url} timed out`);
        }
        throw error;
    }
}

// AbortController for cancellation
async function fetchWithCancellation(url, signal) {
    try {
        const response = await fetch(url, { signal });
        return await response.json();
    } catch (error) {
        if (error.name === 'AbortError') {
            console.log('Request was cancelled');
        }
        throw error;
    }
}

// Usage
const controller = new AbortController();
fetchWithCancellation('/api/data', controller.signal);

// Cancel after 3 seconds
setTimeout(() => controller.abort(), 3000);
```

**4. Retry Logic:**

```javascript
async function retryAsync(fn, maxRetries = 3, delay = 1000) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return await fn();
        } catch (error) {
            lastError = error;
            
            if (attempt === maxRetries) {
                throw new Error(`Failed after ${maxRetries} attempts: ${error.message}`);
            }
            
            console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            
            // Exponential backoff
            delay *= 2;
        }
    }
}

// Usage
async function unreliableOperation() {
    if (Math.random() < 0.7) {
        throw new Error('Random failure');
    }
    return 'Success!';
}

retryAsync(unreliableOperation)
    .then(result => console.log(result))
    .catch(error => console.error(error.message));
```

**Common Pitfalls:**

```javascript
// ❌ Forgetting to await
async function forgettingAwait() {
    const promise = fetch('/api/data'); // Returns Promise, not data
    console.log(promise); // Promise object, not the actual data
    return promise;
}

// ✅ Correct usage
async function correctAwait() {
    const response = await fetch('/api/data');
    const data = await response.json();
    console.log(data); // Actual data
    return data;
}

// ❌ Mixing async/await with .then()
async function mixingPatterns() {
    const data = await fetch('/api/data')
        .then(response => response.json()) // Unnecessary .then()
        .then(data => data);
    return data;
}

// ✅ Pure async/await
async function pureAsyncAwait() {
    const response = await fetch('/api/data');
    const data = await response.json();
    return data;
}
```

---

## ES6+ Features

### Q11: Explain destructuring assignment with examples.
**Difficulty: Medium**

**Answer:**
Destructuring assignment allows you to extract values from arrays or properties from objects into distinct variables using a syntax that mirrors the construction of array and object literals.

**Array Destructuring:**

```javascript
// Basic array destructuring
const numbers = [1, 2, 3, 4, 5];
const [first, second, third] = numbers;
console.log(first);  // 1
console.log(second); // 2
console.log(third);  // 3

// Skipping elements
const [a, , c, , e] = numbers;
console.log(a, c, e); // 1, 3, 5

// Rest operator
const [head, ...tail] = numbers;
console.log(head); // 1
console.log(tail); // [2, 3, 4, 5]

// Default values
const [x = 10, y = 20, z = 30] = [1, 2];
console.log(x, y, z); // 1, 2, 30

// Swapping variables
let var1 = 'a';
let var2 = 'b';
[var1, var2] = [var2, var1];
console.log(var1, var2); // 'b', 'a'

// Nested arrays
const nested = [[1, 2], [3, 4], [5, 6]];
const [[a1, a2], [b1, b2]] = nested;
console.log(a1, a2, b1, b2); // 1, 2, 3, 4
```

**Object Destructuring:**

```javascript
// Basic object destructuring
const person = {
    name: 'John Doe',
    age: 30,
    city: 'New York',
    country: 'USA'
};

const { name, age, city } = person;
console.log(name, age, city); // 'John Doe', 30, 'New York'

// Renaming variables
const { name: fullName, age: years } = person;
console.log(fullName, years); // 'John Doe', 30

// Default values
const { name, age, salary = 50000 } = person;
console.log(salary); // 50000

// Rest operator
const { name, ...rest } = person;
console.log(name); // 'John Doe'
console.log(rest); // { age: 30, city: 'New York', country: 'USA' }

// Nested objects
const user = {
    id: 1,
    profile: {
        name: 'Jane',
        contact: {
            email: 'jane@example.com',
            phone: '123-456-7890'
        }
    }
};

const {
    id,
    profile: {
        name,
        contact: { email, phone }
    }
} = user;

console.log(id, name, email, phone);
```

**Function Parameter Destructuring:**

```javascript
// Object parameter destructuring
function createUser({ name, age, email, role = 'user' }) {
    return {
        id: Date.now(),
        name,
        age,
        email,
        role,
        createdAt: new Date()
    };
}

const newUser = createUser({
    name: 'Alice',
    age: 25,
    email: 'alice@example.com'
});

// Array parameter destructuring
function calculateDistance([x1, y1], [x2, y2]) {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}

const distance = calculateDistance([0, 0], [3, 4]); // 5

// Mixed destructuring
function processOrder({ items, customer: { name, address } }) {
    console.log(`Processing order for ${name}`);
    console.log(`Shipping to: ${address}`);
    console.log(`Items: ${items.length}`);
}

processOrder({
    items: ['item1', 'item2'],
    customer: {
        name: 'Bob',
        address: '123 Main St'
    }
});
```

**Advanced Destructuring Patterns:**

```javascript
// Dynamic property names
const key = 'dynamicKey';
const obj = { dynamicKey: 'value' };
const { [key]: dynamicValue } = obj;
console.log(dynamicValue); // 'value'

// Destructuring in loops
const users = [
    { name: 'John', age: 30 },
    { name: 'Jane', age: 25 },
    { name: 'Bob', age: 35 }
];

for (const { name, age } of users) {
    console.log(`${name} is ${age} years old`);
}

// Destructuring with Map
const userMap = new Map([
    ['john', { name: 'John', age: 30 }],
    ['jane', { name: 'Jane', age: 25 }]
]);

for (const [key, { name, age }] of userMap) {
    console.log(`${key}: ${name} (${age})`);
}
```

---

### Q12: What are template literals and their advanced features?
**Difficulty: Medium**

**Answer:**
Template literals are string literals that allow embedded expressions and multi-line strings, enclosed by backticks (`) instead of quotes.

**Basic Template Literals:**

```javascript
// Basic interpolation
const name = 'John';
const age = 30;
const message = `Hello, my name is ${name} and I am ${age} years old.`;
console.log(message);

// Multi-line strings
const multiLine = `
    This is a multi-line string.
    It preserves line breaks
    and indentation.
`;

// Expression evaluation
const a = 5;
const b = 10;
const result = `The sum of ${a} and ${b} is ${a + b}.`;
console.log(result); // "The sum of 5 and 10 is 15."

// Function calls in templates
function formatCurrency(amount) {
    return `$${amount.toFixed(2)}`;
}

const price = 19.99;
const productInfo = `Price: ${formatCurrency(price)}`;
console.log(productInfo); // "Price: $19.99"
```

**Tagged Template Literals:**

```javascript
// Basic tagged template
function highlight(strings, ...values) {
    console.log('Strings:', strings);
    console.log('Values:', values);
    
    return strings.reduce((result, string, i) => {
        const value = values[i] ? `<mark>${values[i]}</mark>` : '';
        return result + string + value;
    }, '');
}

const name = 'JavaScript';
const type = 'programming language';
const highlighted = highlight`${name} is a ${type}!`;
console.log(highlighted);
// "<mark>JavaScript</mark> is a <mark>programming language</mark>!"

// SQL query builder
function sql(strings, ...values) {
    return {
        query: strings.join('?'),
        values: values
    };
}

const userId = 123;
const status = 'active';
const query = sql`SELECT * FROM users WHERE id = ${userId} AND status = ${status}`;
console.log(query);
// { query: "SELECT * FROM users WHERE id = ? AND status = ?", values: [123, "active"] }

// HTML template with escaping
function html(strings, ...values) {
    const escape = (str) => {
        return String(str)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    };
    
    return strings.reduce((result, string, i) => {
        const value = values[i] ? escape(values[i]) : '';
        return result + string + value;
    }, '');
}

const userInput = '<script>alert("XSS")</script>';
const safeHTML = html`<div>User input: ${userInput}</div>`;
console.log(safeHTML);
// "<div>User input: &lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;</div>"
```

**Advanced Use Cases:**

```javascript
// Internationalization
function i18n(strings, ...values) {
    const translations = {
        'Hello, my name is': 'Hola, mi nombre es',
        'and I am': 'y tengo',
        'years old': 'años'
    };
    
    return strings.reduce((result, string, i) => {
        const translatedString = translations[string.trim()] || string;
        const value = values[i] || '';
        return result + translatedString + value;
    }, '');
}

const greeting = i18n`Hello, my name is ${'Juan'} and I am ${25} years old`;

// CSS-in-JS
function css(strings, ...values) {
    const className = 'css-' + Math.random().toString(36).substr(2, 9);
    const cssRule = strings.reduce((result, string, i) => {
        return result + string + (values[i] || '');
    }, '');
    
    // In a real implementation, this would inject CSS into the document
    console.log(`.${className} { ${cssRule} }`);
    return className;
}

const primaryColor = '#007bff';
const buttonClass = css`
    background-color: ${primaryColor};
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
`;

// GraphQL queries
function gql(strings, ...values) {
    return strings.reduce((result, string, i) => {
        return result + string + (values[i] || '');
    }, '');
}

const GET_USER = gql`
    query GetUser($id: ID!) {
        user(id: $id) {
            name
            email
            posts {
                title
                content
            }
        }
    }
`;
```

---

### Q13: Explain the spread operator and rest parameters.
**Difficulty: Medium**

**Answer:**
The spread operator (...) and rest parameters use the same syntax but serve different purposes. Spread "spreads" elements, while rest "collects" them.

**Spread Operator:**

**1. Array Spreading:**

```javascript
// Copying arrays
const original = [1, 2, 3];
const copy = [...original];
console.log(copy); // [1, 2, 3]
console.log(copy === original); // false (different references)

// Concatenating arrays
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2];
console.log(combined); // [1, 2, 3, 4, 5, 6]

// Adding elements
const numbers = [2, 3, 4];
const withMore = [1, ...numbers, 5, 6];
console.log(withMore); // [1, 2, 3, 4, 5, 6]

// Converting NodeList to Array
const elements = document.querySelectorAll('div');
const elementsArray = [...elements];

// Finding max/min
const scores = [85, 92, 78, 96, 88];
const maxScore = Math.max(...scores);
const minScore = Math.min(...scores);
console.log(maxScore, minScore); // 96, 78
```

**2. Object Spreading:**

```javascript
// Copying objects
const person = { name: 'John', age: 30 };
const personCopy = { ...person };
console.log(personCopy); // { name: 'John', age: 30 }

// Merging objects
const defaults = { theme: 'light', language: 'en' };
const userPrefs = { theme: 'dark', fontSize: 14 };
const settings = { ...defaults, ...userPrefs };
console.log(settings); // { theme: 'dark', language: 'en', fontSize: 14 }

// Adding/updating properties
const user = { id: 1, name: 'Alice' };
const updatedUser = { ...user, age: 25, name: 'Alice Smith' };
console.log(updatedUser); // { id: 1, name: 'Alice Smith', age: 25 }

// Conditional spreading
const includeAge = true;
const userProfile = {
    name: 'Bob',
    email: 'bob@example.com',
    ...(includeAge && { age: 30 })
};
console.log(userProfile);
```

**3. Function Call Spreading:**

```javascript
// Passing array elements as arguments
function greet(first, last, title) {
    return `Hello, ${title} ${first} ${last}!`;
}

const nameArray = ['John', 'Doe', 'Mr.'];
const greeting = greet(...nameArray);
console.log(greeting); // "Hello, Mr. John Doe!"

// Date constructor
const dateArray = [2023, 11, 25]; // Year, Month (0-indexed), Day
const date = new Date(...dateArray);
console.log(date);
```

**Rest Parameters:**

**1. Function Parameters:**

```javascript
// Collecting remaining arguments
function sum(first, second, ...rest) {
    console.log('First:', first);
    console.log('Second:', second);
    console.log('Rest:', rest);
    
    return first + second + rest.reduce((acc, num) => acc + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // First: 1, Second: 2, Rest: [3, 4, 5], Result: 15

// Variable number of arguments
function createMessage(template, ...values) {
    return template.replace(/{(\d+)}/g, (match, index) => {
        return values[index] || match;
    });
}

const message = createMessage('Hello {0}, you have {1} messages', 'John', 5);
console.log(message); // "Hello John, you have 5 messages"

// Array-like operations on rest parameters
function processNumbers(...numbers) {
    const doubled = numbers.map(n => n * 2);
    const filtered = numbers.filter(n => n > 10);
    const sum = numbers.reduce((acc, n) => acc + n, 0);
    
    return { doubled, filtered, sum };
}

const result = processNumbers(5, 15, 8, 20, 3);
console.log(result);
```

**2. Destructuring with Rest:**

```javascript
// Array destructuring with rest
const [first, second, ...remaining] = [1, 2, 3, 4, 5];
console.log(first);     // 1
console.log(second);    // 2
console.log(remaining); // [3, 4, 5]

// Object destructuring with rest
const { name, age, ...otherProps } = {
    name: 'Alice',
    age: 30,
    city: 'New York',
    country: 'USA',
    occupation: 'Developer'
};

console.log(name);       // 'Alice'
console.log(age);        // 30
console.log(otherProps); // { city: 'New York', country: 'USA', occupation: 'Developer' }
```

**Advanced Patterns:**

```javascript
// Partial application with spread
function multiply(a, b, c) {
    return a * b * c;
}

const multiplyBy2And3 = (...args) => multiply(2, 3, ...args);
console.log(multiplyBy2And3(4)); // 24

// Cloning nested objects (shallow)
const original = {
    user: { name: 'John', age: 30 },
    settings: { theme: 'dark' }
};

const clone = {
    ...original,
    user: { ...original.user },
    settings: { ...original.settings }
};

// Function composition with rest/spread
function compose(...functions) {
    return (value) => {
        return functions.reduceRight((acc, fn) => fn(acc), value);
    };
}

const addOne = x => x + 1;
const double = x => x * 2;
const square = x => x * x;

const composed = compose(square, double, addOne);
console.log(composed(3)); // ((3 + 1) * 2)^2 = 64

// Merging arrays with conditions
function mergeArrays(...arrays) {
    return arrays.reduce((merged, array) => {
        return [...merged, ...array.filter(item => !merged.includes(item))];
    }, []);
}

const unique = mergeArrays([1, 2, 3], [3, 4, 5], [5, 6, 7]);
console.log(unique); // [1, 2, 3, 4, 5, 6, 7]
```

---

## Advanced Concepts

### Q14: What is currying in JavaScript? Provide practical examples.
**Difficulty: Hard**

**Answer:**
Currying is a functional programming technique that transforms a function with multiple arguments into a sequence of functions, each taking a single argument. It's named after mathematician Haskell Curry.

**Basic Currying:**

```javascript
// Regular function
function add(a, b, c) {
    return a + b + c;
}

console.log(add(1, 2, 3)); // 6

// Curried version
function curriedAdd(a) {
    return function(b) {
        return function(c) {
            return a + b + c;
        };
    };
}

console.log(curriedAdd(1)(2)(3)); // 6

// Arrow function version
const curriedAddArrow = a => b => c => a + b + c;
console.log(curriedAddArrow(1)(2)(3)); // 6

// Partial application
const addOne = curriedAdd(1);
const addOneAndTwo = addOne(2);
console.log(addOneAndTwo(3)); // 6

// Reusable functions
const add5 = curriedAdd(5);
console.log(add5(3)(2)); // 10
console.log(add5(1)(4)); // 10
```

**Automatic Currying Function:**

```javascript
// Generic curry function
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        } else {
            return function(...nextArgs) {
                return curried.apply(this, args.concat(nextArgs));
            };
        }
    };
}

// Usage
function multiply(a, b, c) {
    return a * b * c;
}

const curriedMultiply = curry(multiply);

console.log(curriedMultiply(2)(3)(4)); // 24
console.log(curriedMultiply(2, 3)(4)); // 24
console.log(curriedMultiply(2)(3, 4)); // 24
console.log(curriedMultiply(2, 3, 4)); // 24
```

**Practical Examples:**

```javascript
// 1. Event handling
const addEventListener = curry((event, element, handler) => {
    element.addEventListener(event, handler);
});

const addClickListener = addEventListener('click');
const addMouseoverListener = addEventListener('mouseover');

// Usage
const button = document.getElementById('myButton');
addClickListener(button, () => console.log('Clicked!'));
addMouseoverListener(button, () => console.log('Hovered!'));

// 2. API requests
const makeRequest = curry((method, url, data) => {
    return fetch(url, {
        method: method,
        headers: { 'Content-Type': 'application/json' },
        body: data ? JSON.stringify(data) : undefined
    });
});

const get = makeRequest('GET');
const post = makeRequest('POST');
const put = makeRequest('PUT');

// Usage
get('/api/users').then(response => response.json());
post('/api/users', { name: 'John', email: 'john@example.com' });

// 3. Validation
const validate = curry((validator, message, value) => {
    return validator(value) ? { valid: true } : { valid: false, message };
});

const isRequired = value => value != null && value !== '';
const isEmail = value => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
const minLength = min => value => value && value.length >= min;

const validateRequired = validate(isRequired, 'This field is required');
const validateEmail = validate(isEmail, 'Please enter a valid email');
const validateMinLength8 = validate(minLength(8), 'Minimum 8 characters required');

// Usage
console.log(validateRequired('John')); // { valid: true }
console.log(validateEmail('invalid-email')); // { valid: false, message: '...' }
```

---

### Q15: Explain generators in JavaScript with practical use cases.
**Difficulty: Hard**

**Answer:**
Generators are special functions that can be paused and resumed, allowing you to produce a sequence of values over time. They're defined using `function*` syntax and use the `yield` keyword.

**Basic Generator Syntax:**

```javascript
// Generator function
function* simpleGenerator() {
    yield 1;
    yield 2;
    yield 3;
    return 'done';
}

// Creating generator object
const gen = simpleGenerator();

// Calling next() method
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: 'done', done: true }
console.log(gen.next()); // { value: undefined, done: true }
```

**Generator with Parameters:**

```javascript
function* parameterGenerator() {
    const first = yield 'First yield';
    console.log('Received:', first);
    
    const second = yield 'Second yield';
    console.log('Received:', second);
    
    return 'Final value';
}

const gen = parameterGenerator();
console.log(gen.next());           // { value: 'First yield', done: false }
console.log(gen.next('Hello'));    // Logs: 'Received: Hello', returns { value: 'Second yield', done: false }
console.log(gen.next('World'));    // Logs: 'Received: World', returns { value: 'Final value', done: true }
```

**Infinite Sequences:**

```javascript
// Infinite number sequence
function* infiniteNumbers() {
    let num = 0;
    while (true) {
        yield num++;
    }
}

const numbers = infiniteNumbers();
console.log(numbers.next().value); // 0
console.log(numbers.next().value); // 1
console.log(numbers.next().value); // 2

// Fibonacci sequence
function* fibonacci() {
    let [a, b] = [0, 1];
    while (true) {
        yield a;
        [a, b] = [b, a + b];
    }
}

const fib = fibonacci();
for (let i = 0; i < 10; i++) {
    console.log(fib.next().value);
}
// Output: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34

// Random number generator
function* randomGenerator(min = 0, max = 100) {
    while (true) {
        yield Math.floor(Math.random() * (max - min + 1)) + min;
    }
}

const random = randomGenerator(1, 10);
console.log(random.next().value); // Random number between 1-10
```

**Practical Use Cases:**

**1. Pagination:**

```javascript
function* paginate(data, pageSize) {
    for (let i = 0; i < data.length; i += pageSize) {
        yield data.slice(i, i + pageSize);
    }
}

const data = Array.from({ length: 25 }, (_, i) => `Item ${i + 1}`);
const pages = paginate(data, 5);

for (const page of pages) {
    console.log('Page:', page);
}

// Or manually
const pageGen = paginate(data, 5);
console.log(pageGen.next().value); // ['Item 1', 'Item 2', 'Item 3', 'Item 4', 'Item 5']
console.log(pageGen.next().value); // ['Item 6', 'Item 7', 'Item 8', 'Item 9', 'Item 10']
```

**2. Async Data Processing:**

```javascript
function* processDataBatches(data, batchSize) {
    for (let i = 0; i < data.length; i += batchSize) {
        const batch = data.slice(i, i + batchSize);
        yield batch.map(item => {
            // Simulate processing
            return { ...item, processed: true, timestamp: Date.now() };
        });
    }
}

async function processBatchesAsync(data, batchSize, delay = 100) {
    const generator = processDataBatches(data, batchSize);
    const results = [];
    
    for (const batch of generator) {
        console.log(`Processing batch of ${batch.length} items`);
        results.push(...batch);
        
        // Add delay between batches to prevent blocking
        await new Promise(resolve => setTimeout(resolve, delay));
    }
    
    return results;
}

// Usage
const largeDataset = Array.from({ length: 1000 }, (_, i) => ({ id: i, data: `Item ${i}` }));
processBatchesAsync(largeDataset, 50).then(results => {
    console.log(`Processed ${results.length} items`);
});
```

**3. State Machine:**

```javascript
function* stateMachine() {
    let state = 'idle';
    let action;
    
    while (true) {
        switch (state) {
            case 'idle':
                action = yield 'System is idle';
                if (action === 'start') {
                    state = 'running';
                } else if (action === 'shutdown') {
                    state = 'stopped';
                }
                break;
                
            case 'running':
                action = yield 'System is running';
                if (action === 'pause') {
                    state = 'paused';
                } else if (action === 'stop') {
                    state = 'idle';
                }
                break;
                
            case 'paused':
                action = yield 'System is paused';
                if (action === 'resume') {
                    state = 'running';
                } else if (action === 'stop') {
                    state = 'idle';
                }
                break;
                
            case 'stopped':
                yield 'System is stopped';
                return 'System shutdown complete';
        }
    }
}

const machine = stateMachine();
console.log(machine.next().value);        // 'System is idle'
console.log(machine.next('start').value); // 'System is running'
console.log(machine.next('pause').value); // 'System is paused'
console.log(machine.next('resume').value);// 'System is running'
console.log(machine.next('stop').value);  // 'System is idle'
```

**4. Iterator Protocol:**

```javascript
// Custom iterable object
class Range {
    constructor(start, end, step = 1) {
        this.start = start;
        this.end = end;
        this.step = step;
    }
    
    *[Symbol.iterator]() {
        for (let value = this.start; value <= this.end; value += this.step) {
            yield value;
        }
    }
}

const range = new Range(1, 10, 2);

// Can be used with for...of
for (const num of range) {
    console.log(num); // 1, 3, 5, 7, 9
}

// Can be spread
const numbers = [...range];
console.log(numbers); // [1, 3, 5, 7, 9]

// Can use array methods
const doubled = Array.from(range, x => x * 2);
console.log(doubled); // [2, 6, 10, 14, 18]
```

**5. Lazy Evaluation:**

```javascript
function* lazyMap(iterable, transform) {
    for (const item of iterable) {
        yield transform(item);
    }
}

function* lazyFilter(iterable, predicate) {
    for (const item of iterable) {
        if (predicate(item)) {
            yield item;
        }
    }
}

function* take(iterable, count) {
    let taken = 0;
    for (const item of iterable) {
        if (taken >= count) break;
        yield item;
        taken++;
    }
}

// Chain operations without creating intermediate arrays
const numbers = function* () {
    for (let i = 1; i <= 1000000; i++) {
        yield i;
    }
};

const result = take(
    lazyFilter(
        lazyMap(numbers(), x => x * x),
        x => x % 2 === 0
    ),
    5
);

console.log([...result]); // First 5 even squares: [4, 16, 36, 64, 100]
```

**Generator Delegation:**

```javascript
function* generator1() {
    yield 1;
    yield 2;
}

function* generator2() {
    yield 3;
    yield 4;
}

function* combinedGenerator() {
    yield* generator1(); // Delegate to generator1
    yield* generator2(); // Delegate to generator2
    yield 5;
}

const combined = combinedGenerator();
for (const value of combined) {
    console.log(value); // 1, 2, 3, 4, 5
}
```

---

## Event Handling

### Q16: Explain event delegation and its benefits.
**Difficulty: Medium**

**Answer:**
Event delegation is a technique where you attach a single event listener to a parent element to handle events for multiple child elements, taking advantage of event bubbling.

**Basic Event Delegation:**

```javascript
// Without delegation (inefficient)
const buttons = document.querySelectorAll('.button');
buttons.forEach(button => {
    button.addEventListener('click', function(e) {
        console.log('Button clicked:', e.target.textContent);
    });
});

// With delegation (efficient)
const container = document.getElementById('button-container');
container.addEventListener('click', function(e) {
    if (e.target.classList.contains('button')) {
        console.log('Button clicked:', e.target.textContent);
    }
});
```

**Advanced Event Delegation:**

```javascript
// Generic delegation function
function delegate(parent, selector, event, handler) {
    parent.addEventListener(event, function(e) {
        const target = e.target.closest(selector);
        if (target && parent.contains(target)) {
            handler.call(target, e);
        }
    });
}

// Usage
const todoList = document.getElementById('todo-list');

// Handle delete button clicks
delegate(todoList, '.delete-btn', 'click', function(e) {
    e.preventDefault();
    this.closest('.todo-item').remove();
});

// Handle edit button clicks
delegate(todoList, '.edit-btn', 'click', function(e) {
    e.preventDefault();
    const todoItem = this.closest('.todo-item');
    const textElement = todoItem.querySelector('.todo-text');
    const currentText = textElement.textContent;
    
    const input = document.createElement('input');
    input.value = currentText;
    input.className = 'edit-input';
    
    textElement.replaceWith(input);
    input.focus();
});

// Handle checkbox changes
delegate(todoList, '.todo-checkbox', 'change', function(e) {
    const todoItem = this.closest('.todo-item');
    todoItem.classList.toggle('completed', this.checked);
});
```

**Benefits of Event Delegation:**

1. **Memory Efficiency**: Only one event listener instead of many
2. **Dynamic Content**: Works with elements added after page load
3. **Performance**: Fewer event listeners to manage
4. **Cleaner Code**: Centralized event handling logic

**Real-world Example - Dynamic Table:**

```javascript
class DataTable {
    constructor(container) {
        this.container = container;
        this.data = [];
        this.setupEventDelegation();
    }
    
    setupEventDelegation() {
        // Single event listener handles all table interactions
        this.container.addEventListener('click', (e) => {
            const target = e.target;
            const row = target.closest('tr');
            
            if (!row) return;
            
            const rowIndex = parseInt(row.dataset.index);
            
            if (target.classList.contains('edit-btn')) {
                this.editRow(rowIndex);
            } else if (target.classList.contains('delete-btn')) {
                this.deleteRow(rowIndex);
            } else if (target.classList.contains('save-btn')) {
                this.saveRow(rowIndex);
            } else if (target.classList.contains('cancel-btn')) {
                this.cancelEdit(rowIndex);
            }
        });
        
        // Handle input changes in edit mode
        this.container.addEventListener('input', (e) => {
            if (e.target.classList.contains('edit-input')) {
                const row = e.target.closest('tr');
                const field = e.target.dataset.field;
                const rowIndex = parseInt(row.dataset.index);
                
                // Update temporary data
                this.updateTempData(rowIndex, field, e.target.value);
            }
        });
    }
    
    addRow(data) {
        this.data.push(data);
        this.render();
    }
    
    deleteRow(index) {
        if (confirm('Are you sure you want to delete this row?')) {
            this.data.splice(index, 1);
            this.render();
        }
    }
    
    editRow(index) {
        const row = this.container.querySelector(`tr[data-index="${index}"]`);
        row.classList.add('editing');
        
        // Replace text with inputs
        const cells = row.querySelectorAll('td:not(.actions)');
        cells.forEach(cell => {
            const field = cell.dataset.field;
            const value = cell.textContent;
            cell.innerHTML = `<input type="text" class="edit-input" data-field="${field}" value="${value}">`;
        });
        
        // Update action buttons
        const actionsCell = row.querySelector('.actions');
        actionsCell.innerHTML = `
            <button class="save-btn">Save</button>
            <button class="cancel-btn">Cancel</button>
        `;
    }
    
    render() {
        const html = this.data.map((item, index) => `
            <tr data-index="${index}">
                <td data-field="name">${item.name}</td>
                <td data-field="email">${item.email}</td>
                <td data-field="role">${item.role}</td>
                <td class="actions">
                    <button class="edit-btn">Edit</button>
                    <button class="delete-btn">Delete</button>
                </td>
            </tr>
        `).join('');
        
        this.container.innerHTML = `
            <table>
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Email</th>
                        <th>Role</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>${html}</tbody>
            </table>
        `;
    }
}

// Usage
const table = new DataTable(document.getElementById('data-table'));
table.addRow({ name: 'John Doe', email: 'john@example.com', role: 'Developer' });
table.addRow({ name: 'Jane Smith', email: 'jane@example.com', role: 'Designer' });
```

---

### Q17: Explain the JavaScript Event Loop in detail.
**Difficulty: Hard**

**Answer:**
The Event Loop is the mechanism that allows JavaScript to perform non-blocking operations despite being single-threaded. It manages the execution of code, collection of events, and execution of queued sub-tasks.

**Event Loop Components:**

1. **Call Stack**: Where function calls are stored
2. **Web APIs**: Browser-provided APIs (setTimeout, DOM events, HTTP requests)
3. **Callback Queue (Task Queue)**: Where callbacks wait to be executed
4. **Microtask Queue**: Higher priority queue for Promises, queueMicrotask
5. **Event Loop**: Monitors and manages the execution

**Visual Representation:**

```javascript
// Call Stack Example
function first() {
    console.log('First');
    second();
    console.log('First End');
}

function second() {
    console.log('Second');
    third();
    console.log('Second End');
}

function third() {
    console.log('Third');
}

first();

// Call Stack execution:
// 1. first() pushed to stack
// 2. console.log('First') executed
// 3. second() pushed to stack
// 4. console.log('Second') executed
// 5. third() pushed to stack
// 6. console.log('Third') executed
// 7. third() popped from stack
// 8. console.log('Second End') executed
// 9. second() popped from stack
// 10. console.log('First End') executed
// 11. first() popped from stack

// Output:
// First
// Second
// Third
// Second End
// First End
```

**Asynchronous Operations:**

```javascript
console.log('Start');

setTimeout(() => {
    console.log('Timeout 1');
}, 0);

setTimeout(() => {
    console.log('Timeout 2');
}, 0);

Promise.resolve().then(() => {
    console.log('Promise 1');
});

Promise.resolve().then(() => {
    console.log('Promise 2');
});

console.log('End');

// Output:
// Start
// End
// Promise 1
// Promise 2
// Timeout 1
// Timeout 2

// Explanation:
// 1. 'Start' - synchronous, executed immediately
// 2. setTimeout callbacks go to Web API, then to Callback Queue
// 3. Promise.then callbacks go to Microtask Queue
// 4. 'End' - synchronous, executed immediately
// 5. Call stack is empty, Event Loop checks Microtask Queue first
// 6. Promise callbacks executed (higher priority)
// 7. Then Callback Queue callbacks executed
```

**Complex Event Loop Example:**

```javascript
function complexEventLoopExample() {
    console.log('1: Start');
    
    // Immediate execution
    setTimeout(() => console.log('2: setTimeout 0ms'), 0);
    
    // Microtask
    Promise.resolve().then(() => {
        console.log('3: Promise 1');
        
        // Nested microtask
        Promise.resolve().then(() => {
            console.log('4: Nested Promise');
        });
        
        // Another setTimeout from within Promise
        setTimeout(() => console.log('5: setTimeout from Promise'), 0);
    });
    
    // Another microtask
    Promise.resolve().then(() => {
        console.log('6: Promise 2');
    });
    
    // queueMicrotask
    queueMicrotask(() => {
        console.log('7: queueMicrotask');
    });
    
    // Immediate execution
    console.log('8: End');
}

complexEventLoopExample();

// Output:
// 1: Start
// 8: End
// 3: Promise 1
// 6: Promise 2
// 7: queueMicrotask
// 4: Nested Promise
// 2: setTimeout 0ms
// 5: setTimeout from Promise
```

**Event Loop Phases (Node.js):**

```javascript
// Node.js has additional phases
const fs = require('fs');

console.log('Start');

// Timer phase
setTimeout(() => console.log('Timer'), 0);
setImmediate(() => console.log('Immediate'));

// I/O phase
fs.readFile(__filename, () => {
    console.log('File read');
    
    setTimeout(() => console.log('Timer in I/O'), 0);
    setImmediate(() => console.log('Immediate in I/O'));
});

// Microtasks
Promise.resolve().then(() => console.log('Promise'));
process.nextTick(() => console.log('nextTick'));

console.log('End');

// Typical output (order may vary for Timer vs Immediate):
// Start
// End
// nextTick
// Promise
// Timer
// Immediate
// File read
// Immediate in I/O
// Timer in I/O
```

**Practical Implications:**

```javascript
// 1. Blocking the Event Loop
function blockingOperation() {
    console.log('Start blocking operation');
    
    // This blocks the event loop
    const start = Date.now();
    while (Date.now() - start < 3000) {
        // Busy wait for 3 seconds
    }
    
    console.log('Blocking operation complete');
}

// This will prevent other operations from executing
setTimeout(() => console.log('This will be delayed'), 100);
blockingOperation();

// 2. Non-blocking alternative
function nonBlockingOperation(duration, callback) {
    const start = Date.now();
    
    function check() {
        if (Date.now() - start >= duration) {
            callback();
        } else {
            setTimeout(check, 0); // Yield control back to event loop
        }
    }
    
    check();
}

// This allows other operations to execute
setTimeout(() => console.log('This will execute on time'), 100);
nonBlockingOperation(3000, () => console.log('Non-blocking operation complete'));

// 3. Breaking up heavy computations
function processLargeArray(array, chunkSize = 1000) {
    return new Promise((resolve) => {
        const result = [];
        let index = 0;
        
        function processChunk() {
            const endIndex = Math.min(index + chunkSize, array.length);
            
            // Process chunk
            for (let i = index; i < endIndex; i++) {
                result.push(array[i] * 2); // Some processing
            }
            
            index = endIndex;
            
            if (index < array.length) {
                // Yield control and continue processing
                setTimeout(processChunk, 0);
            } else {
                resolve(result);
            }
        }
        
        processChunk();
    });
}

// Usage
const largeArray = Array.from({ length: 1000000 }, (_, i) => i);
processLargeArray(largeArray).then(result => {
    console.log('Processing complete:', result.length);
});

// Other operations can run while processing
setTimeout(() => console.log('Other operation'), 50);
```

**Event Loop Debugging:**

```javascript
// Measuring event loop lag
function measureEventLoopLag() {
    const start = process.hrtime.bigint();
    
    setImmediate(() => {
        const lag = Number(process.hrtime.bigint() - start) / 1000000; // Convert to ms
        console.log(`Event loop lag: ${lag.toFixed(2)}ms`);
        
        // Continue monitoring
        setTimeout(measureEventLoopLag, 1000);
    });
}

// Start monitoring
measureEventLoopLag();

// Simulate some load
setInterval(() => {
    const start = Date.now();
    while (Date.now() - start < 10) {
        // Simulate 10ms of blocking work
    }
}, 100);
```

---

### Q18: What are JavaScript Modules (ES6 Modules) and how do they work?
**Difficulty: Medium**

**Answer:**
ES6 Modules provide a standardized way to organize and share code between files. They use `import` and `export` statements and are statically analyzable.

**Basic Module Syntax:**

```javascript
// math.js - Named exports
export function add(a, b) {
    return a + b;
}

export function subtract(a, b) {
    return a - b;
}

export const PI = 3.14159;

// Alternative syntax
function multiply(a, b) {
    return a * b;
}

function divide(a, b) {
    return a / b;
}

export { multiply, divide };

// Default export
export default function calculator(operation, a, b) {
    switch (operation) {
        case 'add': return add(a, b);
        case 'subtract': return subtract(a, b);
        case 'multiply': return multiply(a, b);
        case 'divide': return divide(a, b);
        default: throw new Error('Unknown operation');
    }
}
```

---

## Advanced JavaScript Patterns and Modern Features

### Q19: What are JavaScript Generators and how do they work? Provide advanced examples.
**Difficulty: Hard**

**Answer:**
Generators are special functions that can be paused and resumed, allowing you to create iterators with custom behavior. They're defined using `function*` syntax and use the `yield` keyword.

**Basic Generator:**

```javascript
// Basic generator function
function* numberGenerator() {
    yield 1;
    yield 2;
    yield 3;
    return 'done';
}

const gen = numberGenerator();
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: 'done', done: true }

// Using for...of loop
for (const value of numberGenerator()) {
    console.log(value); // 1, 2, 3 (return value is ignored)
}
```

**Advanced Generator Patterns:**

```javascript
// 1. Infinite sequence generator
function* fibonacciGenerator() {
    let a = 0, b = 1;
    while (true) {
        yield a;
        [a, b] = [b, a + b];
    }
}

const fib = fibonacciGenerator();
const first10Fib = [];
for (let i = 0; i < 10; i++) {
    first10Fib.push(fib.next().value);
}
console.log(first10Fib); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

// 2. Generator with parameters and two-way communication
function* dataProcessor() {
    let data = yield 'Ready to receive data';
    while (data !== 'stop') {
        const processed = data.toUpperCase();
        data = yield `Processed: ${processed}`;
    }
    return 'Processing stopped';
}

const processor = dataProcessor();
console.log(processor.next()); // { value: 'Ready to receive data', done: false }
console.log(processor.next('hello')); // { value: 'Processed: HELLO', done: false }
console.log(processor.next('world')); // { value: 'Processed: WORLD', done: false }
console.log(processor.next('stop')); // { value: 'Processing stopped', done: true }

// 3. Async generator for handling streams
async function* asyncDataGenerator() {
    const urls = [
        'https://api.example.com/data1',
        'https://api.example.com/data2',
        'https://api.example.com/data3'
    ];
    
    for (const url of urls) {
        try {
            const response = await fetch(url);
            const data = await response.json();
            yield data;
        } catch (error) {
            yield { error: error.message };
        }
    }
}

// Usage with for await...of
async function processAsyncData() {
    for await (const data of asyncDataGenerator()) {
        console.log('Received:', data);
    }
}

// 4. Generator for tree traversal
class TreeNode {
    constructor(value, children = []) {
        this.value = value;
        this.children = children;
    }
    
    *depthFirstTraversal() {
        yield this.value;
        for (const child of this.children) {
            yield* child.depthFirstTraversal();
        }
    }
    
    *breadthFirstTraversal() {
        const queue = [this];
        while (queue.length > 0) {
            const node = queue.shift();
            yield node.value;
            queue.push(...node.children);
        }
    }
}

const tree = new TreeNode('root', [
    new TreeNode('child1', [
        new TreeNode('grandchild1'),
        new TreeNode('grandchild2')
    ]),
    new TreeNode('child2')
]);

console.log('DFS:', [...tree.depthFirstTraversal()]);
// ['root', 'child1', 'grandchild1', 'grandchild2', 'child2']

console.log('BFS:', [...tree.breadthFirstTraversal()]);
// ['root', 'child1', 'child2', 'grandchild1', 'grandchild2']
```

---

### Q20: Explain Proxy and Reflect in JavaScript with practical examples.
**Difficulty: Hard**

**Answer:**
Proxy allows you to intercept and customize operations performed on objects (property lookup, assignment, enumeration, function invocation, etc.). Reflect provides methods for interceptable JavaScript operations.

**Basic Proxy Usage:**

```javascript
// Basic proxy with get and set traps
const target = {
    name: 'John',
    age: 30
};

const proxy = new Proxy(target, {
    get(target, property, receiver) {
        console.log(`Getting property: ${property}`);
        return Reflect.get(target, property, receiver);
    },
    
    set(target, property, value, receiver) {
        console.log(`Setting property: ${property} = ${value}`);
        return Reflect.set(target, property, value, receiver);
    }
});

console.log(proxy.name); // Getting property: name -> 'John'
proxy.age = 31; // Setting property: age = 31
```

**Advanced Proxy Patterns:**

```javascript
// 1. Validation proxy
function createValidatedObject(schema) {
    return new Proxy({}, {
        set(target, property, value, receiver) {
            const validator = schema[property];
            if (validator && !validator(value)) {
                throw new Error(`Invalid value for ${property}: ${value}`);
            }
            return Reflect.set(target, property, value, receiver);
        },
        
        get(target, property, receiver) {
            if (!(property in target) && property in schema) {
                throw new Error(`Property ${property} is required but not set`);
            }
            return Reflect.get(target, property, receiver);
        }
    });
}

const userSchema = {
    name: value => typeof value === 'string' && value.length > 0,
    age: value => typeof value === 'number' && value >= 0 && value <= 150,
    email: value => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)
};

const user = createValidatedObject(userSchema);
user.name = 'John Doe'; // OK
user.age = 25; // OK
user.email = 'john@example.com'; // OK
// user.age = -5; // Error: Invalid value for age: -5

// 2. Observable object with change tracking
function createObservable(target, onChange) {
    return new Proxy(target, {
        set(target, property, value, receiver) {
            const oldValue = target[property];
            const result = Reflect.set(target, property, value, receiver);
            if (oldValue !== value) {
                onChange(property, oldValue, value);
            }
            return result;
        },
        
        deleteProperty(target, property) {
            const oldValue = target[property];
            const result = Reflect.deleteProperty(target, property);
            if (result) {
                onChange(property, oldValue, undefined);
            }
            return result;
        }
    });
}

const data = createObservable(
    { count: 0 },
    (property, oldValue, newValue) => {
        console.log(`${property} changed from ${oldValue} to ${newValue}`);
    }
);

data.count = 1; // count changed from 0 to 1
data.name = 'test'; // name changed from undefined to test
delete data.name; // name changed from test to undefined

// 3. Virtual properties and computed values
function createComputedProxy(target, computedProps) {
    return new Proxy(target, {
        get(target, property, receiver) {
            if (property in computedProps) {
                return computedProps[property].call(receiver);
            }
            return Reflect.get(target, property, receiver);
        },
        
        has(target, property) {
            return property in computedProps || Reflect.has(target, property);
        },
        
        ownKeys(target) {
            return [...Reflect.ownKeys(target), ...Object.keys(computedProps)];
        }
    });
}

const person = createComputedProxy(
    { firstName: 'John', lastName: 'Doe', birthYear: 1990 },
    {
        fullName() {
            return `${this.firstName} ${this.lastName}`;
        },
        age() {
            return new Date().getFullYear() - this.birthYear;
        }
    }
);

console.log(person.fullName); // 'John Doe'
console.log(person.age); // Current age based on birth year
console.log('fullName' in person); // true
console.log(Object.keys(person)); // ['firstName', 'lastName', 'birthYear', 'fullName', 'age']

// 4. Method interception and logging
function createLoggingProxy(target, className = 'Object') {
    return new Proxy(target, {
        get(target, property, receiver) {
            const value = Reflect.get(target, property, receiver);
            
            if (typeof value === 'function') {
                return function(...args) {
                    console.log(`[${className}] Calling ${property} with args:`, args);
                    const startTime = performance.now();
                    
                    try {
                        const result = value.apply(this, args);
                        const endTime = performance.now();
                        console.log(`[${className}] ${property} completed in ${endTime - startTime}ms`);
                        return result;
                    } catch (error) {
                        console.error(`[${className}] ${property} threw error:`, error);
                        throw error;
                    }
                };
            }
            
            return value;
        }
    });
}

class Calculator {
    add(a, b) {
        return a + b;
    }
    
    divide(a, b) {
        if (b === 0) throw new Error('Division by zero');
        return a / b;
    }
}

const loggedCalculator = createLoggingProxy(new Calculator(), 'Calculator');
console.log(loggedCalculator.add(5, 3)); // Logs method call and execution time
// loggedCalculator.divide(10, 0); // Logs error
```

---

### Q21: What are WeakMap and WeakSet? When should you use them?
**Difficulty: Medium-Hard**

**Answer:**
WeakMap and WeakSet are collections that hold "weak" references to their keys/values, meaning they don't prevent garbage collection of their contents when there are no other references.

**WeakMap Characteristics:**
- Keys must be objects (not primitives)
- Keys are held weakly (garbage collected when no other references exist)
- Not enumerable (no iteration methods)
- No size property

**WeakSet Characteristics:**
- Values must be objects (not primitives)
- Values are held weakly
- Not enumerable
- No size property

**Practical Examples:**

```javascript
// 1. Private data storage using WeakMap
const privateData = new WeakMap();

class User {
    constructor(name, email) {
        // Store private data
        privateData.set(this, {
            email: email,
            createdAt: new Date(),
            loginAttempts: 0
        });
        
        this.name = name;
    }
    
    getEmail() {
        return privateData.get(this).email;
    }
    
    incrementLoginAttempts() {
        const data = privateData.get(this);
        data.loginAttempts++;
    }
    
    getLoginAttempts() {
        return privateData.get(this).loginAttempts;
    }
}

const user = new User('John', 'john@example.com');
console.log(user.name); // 'John' (public)
console.log(user.getEmail()); // 'john@example.com' (private)
user.incrementLoginAttempts();
console.log(user.getLoginAttempts()); // 1

// Private data is automatically cleaned up when user is garbage collected

// 2. Metadata and annotations
const elementMetadata = new WeakMap();

function addMetadata(element, metadata) {
    elementMetadata.set(element, metadata);
}

function getMetadata(element) {
    return elementMetadata.get(element);
}

// Usage with DOM elements
const button = document.createElement('button');
addMetadata(button, {
    component: 'SubmitButton',
    version: '1.2.0',
    analytics: { trackClicks: true }
});

console.log(getMetadata(button));
// When button is removed from DOM and no other references exist,
// metadata is automatically cleaned up

// 3. Caching with automatic cleanup
class APICache {
    constructor() {
        this.cache = new WeakMap();
    }
    
    async getData(requestObject) {
        if (this.cache.has(requestObject)) {
            console.log('Cache hit');
            return this.cache.get(requestObject);
        }
        
        console.log('Cache miss - fetching data');
        const data = await this.fetchData(requestObject);
        this.cache.set(requestObject, data);
        return data;
    }
    
    async fetchData(requestObject) {
        // Simulate API call
        return new Promise(resolve => {
            setTimeout(() => {
                resolve({ data: `Data for ${requestObject.id}` });
            }, 100);
        });
    }
}

const cache = new APICache();
const request1 = { id: 'user123', type: 'user' };
const request2 = { id: 'user456', type: 'user' };

// First call - cache miss
cache.getData(request1).then(console.log);
// Second call with same object - cache hit
cache.getData(request1).then(console.log);
// Different object - cache miss
cache.getData(request2).then(console.log);

// 4. WeakSet for tracking objects
const processedElements = new WeakSet();

function processElement(element) {
    if (processedElements.has(element)) {
        console.log('Element already processed');
        return;
    }
    
    // Process the element
    console.log('Processing element:', element.id);
    element.classList.add('processed');
    
    // Mark as processed
    processedElements.add(element);
}

// Usage
const div1 = document.createElement('div');
div1.id = 'div1';
const div2 = document.createElement('div');
div2.id = 'div2';

processElement(div1); // Processing element: div1
processElement(div1); // Element already processed
processElement(div2); // Processing element: div2

// 5. Observer pattern with automatic cleanup
class EventEmitter {
    constructor() {
        this.listeners = new WeakMap();
    }
    
    addListener(target, event, callback) {
        if (!this.listeners.has(target)) {
            this.listeners.set(target, new Map());
        }
        
        const targetListeners = this.listeners.get(target);
        if (!targetListeners.has(event)) {
            targetListeners.set(event, new Set());
        }
        
        targetListeners.get(event).add(callback);
    }
    
    emit(target, event, data) {
        const targetListeners = this.listeners.get(target);
        if (targetListeners && targetListeners.has(event)) {
            targetListeners.get(event).forEach(callback => {
                callback(data);
            });
        }
    }
    
    removeListener(target, event, callback) {
        const targetListeners = this.listeners.get(target);
        if (targetListeners && targetListeners.has(event)) {
            targetListeners.get(event).delete(callback);
        }
    }
}

const emitter = new EventEmitter();
const component = { name: 'MyComponent' };

emitter.addListener(component, 'update', data => {
    console.log('Component updated:', data);
});

emitter.emit(component, 'update', { value: 42 });
// When component is garbage collected, listeners are automatically cleaned up
```

**When to use WeakMap/WeakSet:**
- **WeakMap**: Private data storage, metadata, caching, object annotations
- **WeakSet**: Tracking processed objects, marking objects, avoiding memory leaks
- **Both**: When you need automatic cleanup and don't want to prevent garbage collection

---

### Q22: Explain Symbol and its use cases in JavaScript.
**Difficulty: Medium-Hard**

**Answer:**
Symbol is a primitive data type introduced in ES6 that represents a unique identifier. Every Symbol value is unique, even if they have the same description.

**Basic Symbol Usage:**

```javascript
// Creating symbols
const sym1 = Symbol();
const sym2 = Symbol('description');
const sym3 = Symbol('description');

console.log(sym1 === sym2); // false
console.log(sym2 === sym3); // false (even with same description)
console.log(typeof sym1); // 'symbol'

// Symbol description
console.log(sym2.toString()); // 'Symbol(description)'
console.log(sym2.description); // 'description'
```

**Advanced Symbol Patterns:**

```javascript
// 1. Private object properties
const _id = Symbol('id');
const _secret = Symbol('secret');

class User {
    constructor(name, id, secret) {
        this.name = name;
        this[_id] = id;
        this[_secret] = secret;
    }
    
    getId() {
        return this[_id];
    }
    
    authenticate(secret) {
        return this[_secret] === secret;
    }
}

const user = new User('John', 123, 'password123');
console.log(user.name); // 'John'
console.log(user.getId()); // 123
console.log(user[_id]); // undefined (symbol not accessible without reference)

// Symbol properties are not enumerable
console.log(Object.keys(user)); // ['name']
console.log(Object.getOwnPropertyNames(user)); // ['name']
console.log(Object.getOwnPropertySymbols(user)); // [Symbol(id), Symbol(secret)]

// 2. Global Symbol Registry
const globalSym1 = Symbol.for('app.config');
const globalSym2 = Symbol.for('app.config');

console.log(globalSym1 === globalSym2); // true
console.log(Symbol.keyFor(globalSym1)); // 'app.config'

// Cross-module symbol sharing
// module1.js
const CONFIG_KEY = Symbol.for('app.config');
export { CONFIG_KEY };

// module2.js
const CONFIG_KEY = Symbol.for('app.config'); // Same symbol

// 3. Well-known symbols for custom behavior
class Collection {
    constructor(items = []) {
        this.items = items;
    }
    
    // Custom iterator
    *[Symbol.iterator]() {
        for (const item of this.items) {
            yield item;
        }
    }
    
    // Custom string conversion
    [Symbol.toPrimitive](hint) {
        if (hint === 'number') {
            return this.items.length;
        }
        if (hint === 'string') {
            return this.items.join(', ');
        }
        return this.items.length;
    }
    
    // Custom toString
    [Symbol.toStringTag]() {
        return 'Collection';
    }
    
    // Custom species for subclassing
    static get [Symbol.species]() {
        return this;
    }
}

const collection = new Collection(['a', 'b', 'c']);

// Using custom iterator
for (const item of collection) {
    console.log(item); // 'a', 'b', 'c'
}

// Using custom primitive conversion
console.log(+collection); // 3 (number hint)
console.log(`${collection}`); // 'a, b, c' (string hint)
console.log(collection + 0); // 3 (default hint)

// 4. Metadata and configuration system
class MetadataManager {
    constructor() {
        this.metadata = new WeakMap();
    }
    
    define(target, key, value) {
        if (!this.metadata.has(target)) {
            this.metadata.set(target, new Map());
        }
        this.metadata.get(target).set(key, value);
    }
    
    get(target, key) {
        const targetMetadata = this.metadata.get(target);
        return targetMetadata ? targetMetadata.get(key) : undefined;
    }
    
    has(target, key) {
        const targetMetadata = this.metadata.get(target);
        return targetMetadata ? targetMetadata.has(key) : false;
    }
}

// Metadata keys as symbols
const VALIDATION_RULES = Symbol('validationRules');
const SERIALIZATION_CONFIG = Symbol('serializationConfig');
const CACHE_CONFIG = Symbol('cacheConfig');

const metadata = new MetadataManager();

class Product {
    constructor(name, price) {
        this.name = name;
        this.price = price;
    }
}

// Define metadata
metadata.define(Product, VALIDATION_RULES, {
    name: { required: true, type: 'string' },
    price: { required: true, type: 'number', min: 0 }
});

metadata.define(Product, SERIALIZATION_CONFIG, {
    exclude: ['_internal'],
    transform: { price: value => `$${value.toFixed(2)}` }
});

metadata.define(Product, CACHE_CONFIG, {
    ttl: 3600,
    key: 'product:{{id}}'
});

// Use metadata
const validationRules = metadata.get(Product, VALIDATION_RULES);
const serializationConfig = metadata.get(Product, SERIALIZATION_CONFIG);

console.log(validationRules);
console.log(serializationConfig);

// 5. Plugin system with symbol-based hooks
class PluginSystem {
    constructor() {
        this.plugins = [];
        this.hooks = new Map();
    }
    
    registerHook(hookSymbol, description) {
        this.hooks.set(hookSymbol, {
            description,
            handlers: []
        });
    }
    
    addPlugin(plugin) {
        this.plugins.push(plugin);
        
        // Register plugin hooks
        for (const [hookSymbol, hook] of this.hooks) {
            if (typeof plugin[hookSymbol] === 'function') {
                hook.handlers.push(plugin[hookSymbol].bind(plugin));
            }
        }
    }
    
    async executeHook(hookSymbol, ...args) {
        const hook = this.hooks.get(hookSymbol);
        if (!hook) return;
        
        const results = [];
        for (const handler of hook.handlers) {
            try {
                const result = await handler(...args);
                results.push(result);
            } catch (error) {
                console.error(`Hook ${hookSymbol.description} failed:`, error);
            }
        }
        return results;
    }
}

// Define hook symbols
const BEFORE_SAVE = Symbol('beforeSave');
const AFTER_SAVE = Symbol('afterSave');
const VALIDATE = Symbol('validate');

const pluginSystem = new PluginSystem();

// Register hooks
pluginSystem.registerHook(BEFORE_SAVE, 'Before saving entity');
pluginSystem.registerHook(AFTER_SAVE, 'After saving entity');
pluginSystem.registerHook(VALIDATE, 'Validate entity');

// Create plugins
class AuditPlugin {
    [BEFORE_SAVE](entity) {
        entity.updatedAt = new Date();
        console.log('Audit: Setting updatedAt');
    }
    
    [AFTER_SAVE](entity) {
        console.log(`Audit: Entity ${entity.id} saved`);
    }
}

class ValidationPlugin {
    [VALIDATE](entity) {
        if (!entity.name) {
            throw new Error('Name is required');
        }
        console.log('Validation: Entity is valid');
    }
}

// Register plugins
pluginSystem.addPlugin(new AuditPlugin());
pluginSystem.addPlugin(new ValidationPlugin());

// Use the system
async function saveEntity(entity) {
    await pluginSystem.executeHook(VALIDATE, entity);
    await pluginSystem.executeHook(BEFORE_SAVE, entity);
    
    // Simulate save
    console.log('Saving entity:', entity);
    
    await pluginSystem.executeHook(AFTER_SAVE, entity);
}

const entity = { id: 1, name: 'Test Entity' };
saveEntity(entity);
```

**Symbol Use Cases:**
1. **Private Properties**: Create truly private object properties
2. **Global Registry**: Share symbols across modules using `Symbol.for()`
3. **Well-known Symbols**: Customize object behavior (iterator, toPrimitive, etc.)
4. **Metadata Systems**: Store metadata without property name conflicts
5. **Plugin Systems**: Define extensible hook points
6. **Constants**: Create unique constants that can't be accidentally duplicated

---

## Modern JavaScript Best Practices and Patterns

### Q23: What are the best practices for error handling in modern JavaScript?
**Difficulty: Medium-Hard**

**Answer:**
Modern JavaScript error handling involves multiple strategies and patterns to create robust, maintainable applications.

**1. Structured Error Handling:**

```javascript
// Custom error classes
class ValidationError extends Error {
    constructor(message, field) {
        super(message);
        this.name = 'ValidationError';
        this.field = field;
    }
}

class NetworkError extends Error {
    constructor(message, status, url) {
        super(message);
        this.name = 'NetworkError';
        this.status = status;
        this.url = url;
    }
}

class BusinessLogicError extends Error {
    constructor(message, code) {
        super(message);
        this.name = 'BusinessLogicError';
        this.code = code;
    }
}

// Error factory
class ErrorFactory {
    static createValidationError(field, value) {
        return new ValidationError(
            `Invalid value '${value}' for field '${field}'`,
            field
        );
    }
    
    static createNetworkError(response) {
        return new NetworkError(
            `Network request failed: ${response.statusText}`,
            response.status,
            response.url
        );
    }
    
    static createBusinessLogicError(code, message) {
        return new BusinessLogicError(message, code);
    }
}
```

**2. Async Error Handling Patterns:**

```javascript
// Result pattern for error handling
class Result {
    constructor(value, error) {
        this.value = value;
        this.error = error;
        this.isSuccess = !error;
        this.isFailure = !!error;
    }
    
    static success(value) {
        return new Result(value, null);
    }
    
    static failure(error) {
        return new Result(null, error);
    }
    
    map(fn) {
        if (this.isFailure) return this;
        try {
            return Result.success(fn(this.value));
        } catch (error) {
            return Result.failure(error);
        }
    }
    
    flatMap(fn) {
        if (this.isFailure) return this;
        try {
            return fn(this.value);
        } catch (error) {
            return Result.failure(error);
        }
    }
    
    catch(fn) {
        if (this.isSuccess) return this;
        try {
            return Result.success(fn(this.error));
        } catch (error) {
            return Result.failure(error);
        }
    }
}

// Safe async operations
async function safeAsync(asyncFn) {
    try {
        const result = await asyncFn();
        return Result.success(result);
    } catch (error) {
        return Result.failure(error);
    }
}

// Usage example
async function fetchUserData(userId) {
    const result = await safeAsync(() => fetch(`/api/users/${userId}`));
    
    return result
        .flatMap(response => {
            if (!response.ok) {
                return Result.failure(ErrorFactory.createNetworkError(response));
            }
            return safeAsync(() => response.json());
        })
        .map(userData => {
            if (!userData.id) {
                throw ErrorFactory.createValidationError('id', userData.id);
            }
            return userData;
        });
}

// Using the result
fetchUserData(123).then(result => {
    if (result.isSuccess) {
        console.log('User data:', result.value);
    } else {
        console.error('Error:', result.error);
    }
});
```

**3. Global Error Handling:**

```javascript
// Global error handler
class GlobalErrorHandler {
    constructor() {
        this.errorReporters = [];
        this.setupGlobalHandlers();
    }
    
    addReporter(reporter) {
        this.errorReporters.push(reporter);
    }
    
    setupGlobalHandlers() {
        // Unhandled promise rejections
        window.addEventListener('unhandledrejection', event => {
            this.handleError(event.reason, 'unhandledrejection');
            event.preventDefault(); // Prevent console error
        });
        
        // Global JavaScript errors
        window.addEventListener('error', event => {
            this.handleError(event.error, 'javascript');
        });
        
        // Resource loading errors
        window.addEventListener('error', event => {
            if (event.target !== window) {
                this.handleError(
                    new Error(`Failed to load resource: ${event.target.src || event.target.href}`),
                    'resource'
                );
            }
        }, true);
    }
    
    handleError(error, context) {
        const errorInfo = {
            message: error.message,
            stack: error.stack,
            context,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            url: window.location.href
        };
        
        // Report to all registered reporters
        this.errorReporters.forEach(reporter => {
            try {
                reporter.report(errorInfo);
            } catch (reporterError) {
                console.error('Error reporter failed:', reporterError);
            }
        });
    }
}

// Error reporters
class ConsoleErrorReporter {
    report(errorInfo) {
        console.group(`🚨 Error [${errorInfo.context}]`);
        console.error(errorInfo.message);
        console.error(errorInfo.stack);
        console.log('Context:', errorInfo);
        console.groupEnd();
    }
}

class RemoteErrorReporter {
    constructor(endpoint) {
        this.endpoint = endpoint;
        this.queue = [];
        this.isOnline = navigator.onLine;
        
        window.addEventListener('online', () => {
            this.isOnline = true;
            this.flushQueue();
        });
        
        window.addEventListener('offline', () => {
            this.isOnline = false;
        });
    }
    
    report(errorInfo) {
        if (this.isOnline) {
            this.sendError(errorInfo);
        } else {
            this.queue.push(errorInfo);
        }
    }
    
    async sendError(errorInfo) {
        try {
            await fetch(this.endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(errorInfo)
            });
        } catch (error) {
            this.queue.push(errorInfo);
        }
    }
    
    flushQueue() {
        while (this.queue.length > 0) {
            const errorInfo = this.queue.shift();
            this.sendError(errorInfo);
        }
    }
}

// Setup global error handling
const errorHandler = new GlobalErrorHandler();
errorHandler.addReporter(new ConsoleErrorReporter());
errorHandler.addReporter(new RemoteErrorReporter('/api/errors'));
```

**4. Retry and Circuit Breaker Patterns:**

```javascript
// Retry with exponential backoff
class RetryManager {
    static async withRetry(fn, options = {}) {
        const {
            maxAttempts = 3,
            baseDelay = 1000,
            maxDelay = 10000,
            backoffFactor = 2,
            retryCondition = () => true
        } = options;
        
        let lastError;
        
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                return await fn();
            } catch (error) {
                lastError = error;
                
                if (attempt === maxAttempts || !retryCondition(error)) {
                    throw error;
                }
                
                const delay = Math.min(
                    baseDelay * Math.pow(backoffFactor, attempt - 1),
                    maxDelay
                );
                
                console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        
        throw lastError;
    }
}

// Circuit breaker pattern
class CircuitBreaker {
    constructor(options = {}) {
        this.failureThreshold = options.failureThreshold || 5;
        this.resetTimeout = options.resetTimeout || 60000;
        this.monitoringPeriod = options.monitoringPeriod || 10000;
        
        this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
        this.failureCount = 0;
        this.lastFailureTime = null;
        this.successCount = 0;
    }
    
    async execute(fn) {
        if (this.state === 'OPEN') {
            if (Date.now() - this.lastFailureTime >= this.resetTimeout) {
                this.state = 'HALF_OPEN';
                this.successCount = 0;
            } else {
                throw new Error('Circuit breaker is OPEN');
            }
        }
        
        try {
            const result = await fn();
            this.onSuccess();
            return result;
        } catch (error) {
            this.onFailure();
            throw error;
        }
    }
    
    onSuccess() {
        this.failureCount = 0;
        
        if (this.state === 'HALF_OPEN') {
            this.successCount++;
            if (this.successCount >= 3) {
                this.state = 'CLOSED';
            }
        }
    }
    
    onFailure() {
        this.failureCount++;
        this.lastFailureTime = Date.now();
        
        if (this.failureCount >= this.failureThreshold) {
            this.state = 'OPEN';
        }
    }
    
    getState() {
        return {
            state: this.state,
            failureCount: this.failureCount,
            lastFailureTime: this.lastFailureTime
        };
    }
}

// Usage example
const apiCircuitBreaker = new CircuitBreaker({
    failureThreshold: 3,
    resetTimeout: 30000
});

async function callExternalAPI() {
    return await apiCircuitBreaker.execute(async () => {
        return await RetryManager.withRetry(
            () => fetch('/api/external-service'),
            {
                maxAttempts: 3,
                retryCondition: error => error.status >= 500
            }
        );
    });
}
```

**Best Practices Summary:**
1. **Use custom error classes** for different error types
2. **Implement Result pattern** for functional error handling
3. **Set up global error handlers** for unhandled errors
4. **Use retry mechanisms** with exponential backoff
5. **Implement circuit breakers** for external service calls
6. **Log errors appropriately** with context information
7. **Handle offline scenarios** gracefully
8. **Validate inputs** early and provide meaningful error messages
9. **Use TypeScript** for better error prevention
10. **Test error scenarios** thoroughly

```javascript
// main.js - Importing
import calculator, { add, subtract, PI } from './math.js';
import { multiply, divide } from './math.js';

// Using imports
console.log(add(5, 3)); // 8
console.log(subtract(10, 4)); // 6
console.log(PI); // 3.14159
console.log(calculator('multiply', 4, 5)); // 20

// Import all as namespace
import * as MathUtils from './math.js';
console.log(MathUtils.add(2, 3)); // 5
console.log(MathUtils.default('divide', 10, 2)); // 5

// Renaming imports
import { add as sum, subtract as diff } from './math.js';
console.log(sum(1, 2)); // 3
console.log(diff(5, 2)); // 3
```

**Advanced Module Patterns:**

```javascript
// config.js - Configuration module
const config = {
    apiUrl: process.env.NODE_ENV === 'production' 
        ? 'https://api.production.com' 
        : 'https://api.development.com',
    timeout: 5000,
    retries: 3
};

export default config;
export const { apiUrl, timeout, retries } = config;

// utils.js - Utility functions
export const debounce = (func, delay) => {
    let timeoutId;
    return (...args) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
};

export const throttle = (func, limit) => {
    let inThrottle;
    return (...args) => {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
};

export const deepClone = (obj) => {
    if (obj === null || typeof obj !== 'object') return obj;
    if (obj instanceof Date) return new Date(obj.getTime());
    if (obj instanceof Array) return obj.map(item => deepClone(item));
    if (typeof obj === 'object') {
        const clonedObj = {};
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                clonedObj[key] = deepClone(obj[key]);
            }
        }
        return clonedObj;
    }
};

// api.js - API module
import config from './config.js';
import { debounce } from './utils.js';

class ApiClient {
    constructor(baseUrl = config.apiUrl) {
        this.baseUrl = baseUrl;
        this.timeout = config.timeout;
    }
    
    async request(endpoint, options = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        const controller = new AbortController();
        
        const timeoutId = setTimeout(() => {
            controller.abort();
        }, this.timeout);
        
        try {
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            return await response.json();
        } catch (error) {
            clearTimeout(timeoutId);
            throw error;
        }
    }
    
    get(endpoint) {
        return this.request(endpoint, { method: 'GET' });
    }
    
    post(endpoint, data) {
        return this.request(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
    }
    
    put(endpoint, data) {
        return this.request(endpoint, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
    }
    
    delete(endpoint) {
        return this.request(endpoint, { method: 'DELETE' });
    }
}

// Create debounced search function
export const debouncedSearch = debounce(async (query) => {
    const api = new ApiClient();
    return await api.get(`/search?q=${encodeURIComponent(query)}`);
}, 300);

export default ApiClient;
```

**Dynamic Imports:**

```javascript
// Dynamic imports for code splitting
async function loadModule() {
    try {
        // Dynamic import returns a promise
        const module = await import('./heavy-module.js');
        
        // Use default export
        const result = module.default();
        
        // Use named exports
        const { utilityFunction } = module;
        utilityFunction();
        
    } catch (error) {
        console.error('Failed to load module:', error);
    }
}

// Conditional loading
if (someCondition) {
    import('./feature-module.js').then(module => {
        module.initializeFeature();
    });
}

// Loading modules based on user interaction
document.getElementById('load-chart').addEventListener('click', async () => {
    const { Chart } = await import('./chart-library.js');
    new Chart(document.getElementById('chart-container'));
});

// Module factory pattern
const moduleCache = new Map();

async function getModule(moduleName) {
    if (moduleCache.has(moduleName)) {
        return moduleCache.get(moduleName);
    }
    
    const module = await import(`./modules/${moduleName}.js`);
    moduleCache.set(moduleName, module);
    return module;
}
```

**Module Re-exports:**

```javascript
// index.js - Barrel exports
export { add, subtract, multiply, divide } from './math.js';
export { debounce, throttle, deepClone } from './utils.js';
export { default as ApiClient } from './api.js';
export { default as config } from './config.js';

// Re-export with renaming
export { default as MathCalculator } from './math.js';
export { PI as MATH_PI } from './math.js';

// Conditional exports
if (process.env.NODE_ENV === 'development') {
    export { debugUtils } from './debug.js';
}
```

---

### Q24: Explain error handling in JavaScript with try-catch, custom errors, and async error handling.
**Difficulty: Medium**

**Answer:**
JavaScript provides several mechanisms for handling errors: try-catch blocks, custom error types, and specialized handling for asynchronous operations.

**Basic Error Handling:**

```javascript
// Basic try-catch
try {
    const result = riskyOperation();
    console.log('Success:', result);
} catch (error) {
    console.error('Error occurred:', error.message);
} finally {
    console.log('This always executes');
}

// Catching specific error types
try {
    JSON.parse('invalid json');
} catch (error) {
    if (error instanceof SyntaxError) {
        console.error('JSON parsing failed:', error.message);
    } else if (error instanceof ReferenceError) {
        console.error('Reference error:', error.message);
    } else {
        console.error('Unknown error:', error);
    }
}

// Nested try-catch
try {
    try {
        const data = JSON.parse(jsonString);
        processData(data);
    } catch (parseError) {
        console.error('Parse error:', parseError.message);
        throw new Error('Data processing failed due to invalid JSON');
    }
} catch (processingError) {
    console.error('Processing error:', processingError.message);
    // Handle or re-throw
}
```

**Custom Error Classes:**

```javascript
// Custom error classes
class ValidationError extends Error {
    constructor(message, field) {
        super(message);
        this.name = 'ValidationError';
        this.field = field;
        this.timestamp = new Date().toISOString();
    }
}

class NetworkError extends Error {
    constructor(message, statusCode, url) {
        super(message);
        this.name = 'NetworkError';
        this.statusCode = statusCode;
        this.url = url;
        this.retryable = statusCode >= 500;
    }
}

class BusinessLogicError extends Error {
    constructor(message, code, details = {}) {
        super(message);
        this.name = 'BusinessLogicError';
        this.code = code;
        this.details = details;
        this.severity = 'high';
    }
}

// Usage of custom errors
function validateUser(user) {
    if (!user.email) {
        throw new ValidationError('Email is required', 'email');
    }
    
    if (!user.email.includes('@')) {
        throw new ValidationError('Invalid email format', 'email');
    }
    
    if (user.age < 18) {
        throw new BusinessLogicError(
            'User must be 18 or older',
            'AGE_RESTRICTION',
            { minAge: 18, providedAge: user.age }
        );
    }
}

// Error handling with custom errors
try {
    validateUser({ email: 'invalid-email', age: 16 });
} catch (error) {
    if (error instanceof ValidationError) {
        console.error(`Validation failed for ${error.field}: ${error.message}`);
        // Show field-specific error in UI
    } else if (error instanceof BusinessLogicError) {
        console.error(`Business rule violation [${error.code}]: ${error.message}`);
        console.error('Details:', error.details);
        // Handle business logic errors
    } else {
        console.error('Unexpected error:', error);
        // Handle unexpected errors
    }
}
```

**Async Error Handling:**

```javascript
// Promise error handling
function fetchUserData(userId) {
    return fetch(`/api/users/${userId}`)
        .then(response => {
            if (!response.ok) {
                throw new NetworkError(
                    `Failed to fetch user data`,
                    response.status,
                    response.url
                );
            }
            return response.json();
        })
        .then(data => {
            if (!data.id) {
                throw new ValidationError('Invalid user data: missing ID', 'id');
            }
            return data;
        })
        .catch(error => {
            if (error instanceof NetworkError && error.retryable) {
                console.log('Retrying request...');
                // Implement retry logic
                return retryRequest(() => fetchUserData(userId));
            }
            throw error; // Re-throw if not retryable
        });
}

// Async/await error handling
async function processUserData(userId) {
    try {
        const userData = await fetchUserData(userId);
        const processedData = await processData(userData);
        const savedData = await saveData(processedData);
        
        return savedData;
    } catch (error) {
        if (error instanceof NetworkError) {
            console.error('Network issue:', error.message);
            // Maybe show offline message
            throw new Error('Service temporarily unavailable');
        } else if (error instanceof ValidationError) {
            console.error('Data validation failed:', error.message);
            // Show user-friendly validation message
            throw new Error('Invalid data provided');
        } else {
            console.error('Unexpected error:', error);
            // Log to error reporting service
            logError(error);
            throw new Error('An unexpected error occurred');
        }
    }
}

// Multiple async operations with error handling
async function batchProcessUsers(userIds) {
    const results = [];
    const errors = [];
    
    for (const userId of userIds) {
        try {
            const result = await processUserData(userId);
            results.push({ userId, result, status: 'success' });
        } catch (error) {
            errors.push({ userId, error: error.message, status: 'error' });
        }
    }
    
    return { results, errors };
}

// Promise.allSettled for handling multiple promises
async function fetchMultipleUsers(userIds) {
    const promises = userIds.map(id => fetchUserData(id));
    const results = await Promise.allSettled(promises);
    
    const successful = [];
    const failed = [];
    
    results.forEach((result, index) => {
        if (result.status === 'fulfilled') {
            successful.push({ userId: userIds[index], data: result.value });
        } else {
            failed.push({ userId: userIds[index], error: result.reason.message });
        }
    });
    
    return { successful, failed };
}
```

**Error Handling Utilities:**

```javascript
// Retry utility with exponential backoff
async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return await fn();
        } catch (error) {
            if (attempt === maxRetries) {
                throw error;
            }
            
            const delay = baseDelay * Math.pow(2, attempt - 1);
            console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}

// Circuit breaker pattern
class CircuitBreaker {
    constructor(fn, threshold = 5, timeout = 60000) {
        this.fn = fn;
        this.threshold = threshold;
        this.timeout = timeout;
        this.failureCount = 0;
        this.lastFailureTime = null;
        this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    }
    
    async call(...args) {
        if (this.state === 'OPEN') {
            if (Date.now() - this.lastFailureTime > this.timeout) {
                this.state = 'HALF_OPEN';
            } else {
                throw new Error('Circuit breaker is OPEN');
            }
        }
        
        try {
            const result = await this.fn(...args);
            this.onSuccess();
            return result;
        } catch (error) {
            this.onFailure();
            throw error;
        }
    }
    
    onSuccess() {
        this.failureCount = 0;
        this.state = 'CLOSED';
    }
    
    onFailure() {
        this.failureCount++;
        this.lastFailureTime = Date.now();
        
        if (this.failureCount >= this.threshold) {
            this.state = 'OPEN';
        }
    }
}

// Usage
const protectedApiCall = new CircuitBreaker(fetchUserData, 3, 30000);

try {
    const userData = await protectedApiCall.call(userId);
    console.log('Data fetched:', userData);
} catch (error) {
    console.error('Protected call failed:', error.message);
}

// Global error handler
window.addEventListener('error', (event) => {
    console.error('Global error:', event.error);
    logError({
        message: event.error.message,
        stack: event.error.stack,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno
    });
});

// Unhandled promise rejection handler
window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    logError({
        type: 'unhandledrejection',
        reason: event.reason,
        promise: event.promise
    });
    
    // Prevent the default behavior (logging to console)
    event.preventDefault();
});

// Error logging utility
function logError(error) {
    const errorData = {
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href,
        userId: getCurrentUserId(),
        sessionId: getSessionId(),
        error: {
            name: error.name,
            message: error.message,
            stack: error.stack,
            ...error
        }
    };
    
    // Send to error reporting service
    fetch('/api/errors', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(errorData)
    }).catch(err => {
        console.error('Failed to log error:', err);
        // Fallback: store in localStorage for later retry
        const errors = JSON.parse(localStorage.getItem('pendingErrors') || '[]');
        errors.push(errorData);
        localStorage.setItem('pendingErrors', JSON.stringify(errors));
    });
}
```

---

### Q25: What is the difference between `call`, `apply`, and `bind` methods?
**Difficulty: Medium**

**Answer:**
These methods are used to control the `this` context and pass arguments to functions. They provide different ways to invoke functions with a specific `this` value.

**Basic Differences:**

```javascript
const person = {
    name: 'John',
    greet: function(greeting, punctuation) {
        return `${greeting}, I'm ${this.name}${punctuation}`;
    }
};

const anotherPerson = { name: 'Jane' };

// call() - invokes immediately with individual arguments
const result1 = person.greet.call(anotherPerson, 'Hello', '!');
console.log(result1); // "Hello, I'm Jane!"

// apply() - invokes immediately with arguments array
const result2 = person.greet.apply(anotherPerson, ['Hi', '.']);
console.log(result2); // "Hi, I'm Jane."

// bind() - returns a new function with bound context
const boundGreet = person.greet.bind(anotherPerson, 'Hey');
const result3 = boundGreet('?');
console.log(result3); // "Hey, I'm Jane?"
```

**Detailed Examples:**

```javascript
// 1. Using call()
function introduce(age, city) {
    return `Hi, I'm ${this.name}, ${age} years old from ${city}`;
}

const person1 = { name: 'Alice' };
const person2 = { name: 'Bob' };

// Call with different contexts
console.log(introduce.call(person1, 25, 'New York'));
// "Hi, I'm Alice, 25 years old from New York"

console.log(introduce.call(person2, 30, 'London'));
// "Hi, I'm Bob, 30 years old from London"

// 2. Using apply()
const numbers = [1, 2, 3, 4, 5];

// Find max using apply
const max = Math.max.apply(null, numbers);
console.log(max); // 5

// Modern alternative with spread operator
const maxModern = Math.max(...numbers);
console.log(maxModern); // 5

// Array concatenation with apply
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
Array.prototype.push.apply(arr1, arr2);
console.log(arr1); // [1, 2, 3, 4, 5, 6]

// 3. Using bind()
const calculator = {
    value: 0,
    add: function(num) {
        this.value += num;
        return this;
    },
    multiply: function(num) {
        this.value *= num;
        return this;
    },
    getValue: function() {
        return this.value;
    }
};

// Create bound methods
const boundAdd = calculator.add.bind(calculator);
const boundMultiply = calculator.multiply.bind(calculator);

// Use bound methods
boundAdd(5);
boundMultiply(3);
console.log(calculator.getValue()); // 15

// Partial application with bind
function multiply(a, b, c) {
    return a * b * c;
}

const multiplyByTwo = multiply.bind(null, 2);
const multiplyByTwoAndThree = multiply.bind(null, 2, 3);

console.log(multiplyByTwo(5, 10)); // 100 (2 * 5 * 10)
console.log(multiplyByTwoAndThree(4)); // 24 (2 * 3 * 4)
```

**Practical Use Cases:**

```javascript
// 1. Event handling with proper context
class Button {
    constructor(element) {
        this.element = element;
        this.clickCount = 0;
        
        // Bind method to maintain context
        this.handleClick = this.handleClick.bind(this);
        this.element.addEventListener('click', this.handleClick);
    }
    
    handleClick(event) {
        this.clickCount++;
        console.log(`Button clicked ${this.clickCount} times`);
    }
    
    destroy() {
        this.element.removeEventListener('click', this.handleClick);
    }
}

// 2. Method borrowing
const arrayLike = {
    0: 'a',
    1: 'b',
    2: 'c',
    length: 3
};

// Borrow array methods
const realArray = Array.prototype.slice.call(arrayLike);
console.log(realArray); // ['a', 'b', 'c']

// Convert NodeList to Array
const divs = document.querySelectorAll('div');
const divArray = Array.prototype.slice.call(divs);

// Modern alternative
const divArrayModern = Array.from(divs);
const divArraySpread = [...divs];

// 3. Function composition and currying
function compose(f, g) {
    return function(x) {
        return f.call(this, g.call(this, x));
    };
}

function addOne(x) {
    return x + 1;
}

function double(x) {
    return x * 2;
}

const addOneThenDouble = compose(double, addOne);
console.log(addOneThenDouble(3)); // 8 ((3 + 1) * 2)

// 4. Creating utility functions
function createLogger(prefix) {
    return console.log.bind(console, `[${prefix}]`);
}

const errorLogger = createLogger('ERROR');
const infoLogger = createLogger('INFO');

errorLogger('Something went wrong'); // [ERROR] Something went wrong
infoLogger('Process completed'); // [INFO] Process completed

// 5. Implementing inheritance patterns
function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function() {
    return `${this.name} makes a sound`;
};

function Dog(name, breed) {
    // Call parent constructor
    Animal.call(this, name);
    this.breed = breed;
}

// Set up inheritance
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.speak = function() {
    // Call parent method
    const parentResult = Animal.prototype.speak.call(this);
    return `${parentResult} - Woof!`;
};

const dog = new Dog('Buddy', 'Golden Retriever');
console.log(dog.speak()); // "Buddy makes a sound - Woof!"

// 6. Debouncing with proper context
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}

class SearchBox {
    constructor(input) {
        this.input = input;
        this.results = [];
        
        // Create debounced search method
        this.debouncedSearch = debounce(this.search, 300);
        this.input.addEventListener('input', this.debouncedSearch.bind(this));
    }
    
    search(event) {
        const query = event.target.value;
        console.log(`Searching for: ${query}`);
        // Perform search logic
    }
}
```

**Performance Considerations:**

```javascript
// bind() creates a new function each time
class Component {
    constructor() {
        this.state = { count: 0 };
    }
    
    // Bad: creates new function on each render
    render() {
        return {
            onClick: this.handleClick.bind(this) // New function each time
        };
    }
    
    // Good: bind once in constructor
    constructor() {
        this.state = { count: 0 };
        this.handleClick = this.handleClick.bind(this);
    }
    
    // Alternative: arrow function (lexically bound)
    handleClick = (event) => {
        this.setState({ count: this.state.count + 1 });
    }
    
    handleClick(event) {
        this.setState({ count: this.state.count + 1 });
    }
}

// Comparing performance
function testFunction() {
    return 'test';
}

const obj = { name: 'test' };

// call/apply are generally faster for one-time use
console.time('call');
for (let i = 0; i < 1000000; i++) {
    testFunction.call(obj);
}
console.timeEnd('call');

// bind is better for reuse
console.time('bind');
const boundFunction = testFunction.bind(obj);
for (let i = 0; i < 1000000; i++) {
    boundFunction();
}
console.timeEnd('bind');
```

---

## Advanced JavaScript Concepts

### Q26: Explain JavaScript Design Patterns with practical examples.
**Difficulty: Hard**

**Answer:**
Design patterns are reusable solutions to common programming problems.

**1. Module Pattern:**
```javascript
const UserModule = (function() {
  // Private variables and functions
  let users = [];
  let currentId = 0;
  
  function validateUser(user) {
    return user.name && user.email;
  }
  
  // Public API
  return {
    addUser(user) {
      if (validateUser(user)) {
        user.id = ++currentId;
        users.push(user);
        return user;
      }
      throw new Error('Invalid user data');
    },
    
    getUser(id) {
      return users.find(user => user.id === id);
    },
    
    getAllUsers() {
      return [...users]; // Return copy to prevent mutation
    },
    
    removeUser(id) {
      const index = users.findIndex(user => user.id === id);
      if (index !== -1) {
        return users.splice(index, 1)[0];
      }
      return null;
    }
  };
})();

// Usage
const user = UserModule.addUser({ name: 'John', email: 'john@example.com' });
console.log(UserModule.getUser(user.id));
```

**2. Observer Pattern:**
```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }
  
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
    
    // Return unsubscribe function
    return () => {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    };
  }
  
  emit(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(callback => callback(data));
    }
  }
  
  once(event, callback) {
    const unsubscribe = this.on(event, (data) => {
      callback(data);
      unsubscribe();
    });
    return unsubscribe;
  }
}

// Usage
const emitter = new EventEmitter();

const unsubscribe = emitter.on('user-login', (user) => {
  console.log(`User ${user.name} logged in`);
});

emitter.emit('user-login', { name: 'John', id: 1 });
unsubscribe(); // Stop listening
```

**3. Singleton Pattern:**
```javascript
class DatabaseConnection {
  constructor() {
    if (DatabaseConnection.instance) {
      return DatabaseConnection.instance;
    }
    
    this.connection = null;
    this.isConnected = false;
    DatabaseConnection.instance = this;
  }
  
  connect() {
    if (!this.isConnected) {
      this.connection = 'Connected to database';
      this.isConnected = true;
      console.log('Database connected');
    }
    return this.connection;
  }
  
  disconnect() {
    if (this.isConnected) {
      this.connection = null;
      this.isConnected = false;
      console.log('Database disconnected');
    }
  }
  
  query(sql) {
    if (!this.isConnected) {
      throw new Error('Database not connected');
    }
    return `Executing: ${sql}`;
  }
}

// Usage
const db1 = new DatabaseConnection();
const db2 = new DatabaseConnection();
console.log(db1 === db2); // true - same instance
```

**4. Factory Pattern:**
```javascript
class User {
  constructor(name, email, role) {
    this.name = name;
    this.email = email;
    this.role = role;
  }
  
  getPermissions() {
    return this.role.permissions;
  }
}

class AdminRole {
  constructor() {
    this.permissions = ['read', 'write', 'delete', 'admin'];
  }
}

class UserRole {
  constructor() {
    this.permissions = ['read'];
  }
}

class ModeratorRole {
  constructor() {
    this.permissions = ['read', 'write'];
  }
}

class UserFactory {
  static createUser(name, email, roleType) {
    let role;
    
    switch (roleType) {
      case 'admin':
        role = new AdminRole();
        break;
      case 'moderator':
        role = new ModeratorRole();
        break;
      case 'user':
      default:
        role = new UserRole();
        break;
    }
    
    return new User(name, email, role);
  }
}

// Usage
const admin = UserFactory.createUser('John', 'john@example.com', 'admin');
const user = UserFactory.createUser('Jane', 'jane@example.com', 'user');
console.log(admin.getPermissions()); // ['read', 'write', 'delete', 'admin']
```

---

### Q27: Explain JavaScript Prototypes and Prototype Chain in detail.
**Difficulty: Medium**

**Answer:**
Every JavaScript object has a prototype, which is another object from which it inherits properties and methods.

```javascript
// Constructor function
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// Adding methods to prototype
Person.prototype.greet = function() {
  return `Hello, I'm ${this.name} and I'm ${this.age} years old`;
};

Person.prototype.getAgeGroup = function() {
  if (this.age < 18) return 'Minor';
  if (this.age < 65) return 'Adult';
  return 'Senior';
};

// Creating instances
const john = new Person('John', 30);
const jane = new Person('Jane', 25);

console.log(john.greet()); // "Hello, I'm John and I'm 30 years old"
console.log(jane.getAgeGroup()); // "Adult"

// Prototype chain demonstration
console.log(john.__proto__ === Person.prototype); // true
console.log(Person.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__); // null

// Adding properties to prototype affects all instances
Person.prototype.species = 'Homo sapiens';
console.log(john.species); // "Homo sapiens"
console.log(jane.species); // "Homo sapiens"

// Inheritance with prototypes
function Employee(name, age, jobTitle) {
  Person.call(this, name, age); // Call parent constructor
  this.jobTitle = jobTitle;
}

// Set up inheritance
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;

// Add Employee-specific methods
Employee.prototype.work = function() {
  return `${this.name} is working as a ${this.jobTitle}`;
};

// Override parent method
Employee.prototype.greet = function() {
  return `Hello, I'm ${this.name}, a ${this.jobTitle}`;
};

const developer = new Employee('Alice', 28, 'Developer');
console.log(developer.greet()); // "Hello, I'm Alice, a Developer"
console.log(developer.work()); // "Alice is working as a Developer"
console.log(developer.getAgeGroup()); // "Adult" (inherited from Person)
```

**Modern ES6 Class Syntax:**
```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  greet() {
    return `Hello, I'm ${this.name} and I'm ${this.age} years old`;
  }
  
  getAgeGroup() {
    if (this.age < 18) return 'Minor';
    if (this.age < 65) return 'Adult';
    return 'Senior';
  }
  
  static getSpecies() {
    return 'Homo sapiens';
  }
}

class Employee extends Person {
  constructor(name, age, jobTitle) {
    super(name, age);
    this.jobTitle = jobTitle;
  }
  
  greet() {
    return `Hello, I'm ${this.name}, a ${this.jobTitle}`;
  }
  
  work() {
    return `${this.name} is working as a ${this.jobTitle}`;
  }
}

const developer = new Employee('Bob', 32, 'Developer');
console.log(developer.greet());
console.log(developer.getAgeGroup()); // Inherited method
```

---

### Q28: Explain Advanced Array Methods and their practical use cases.
**Difficulty: Medium**

**Answer:**
JavaScript provides powerful array methods for functional programming.

**1. Map, Filter, Reduce:**
```javascript
const users = [
  { id: 1, name: 'John', age: 30, salary: 50000, department: 'IT' },
  { id: 2, name: 'Jane', age: 25, salary: 60000, department: 'HR' },
  { id: 3, name: 'Bob', age: 35, salary: 70000, department: 'IT' },
  { id: 4, name: 'Alice', age: 28, salary: 55000, department: 'Finance' }
];

// Map - transform each element
const userNames = users.map(user => user.name);
const userSummaries = users.map(user => ({
  id: user.id,
  name: user.name,
  summary: `${user.name} (${user.age}) - ${user.department}`
}));

// Filter - select elements based on condition
const itUsers = users.filter(user => user.department === 'IT');
const highEarners = users.filter(user => user.salary > 55000);
const youngHighEarners = users.filter(user => user.age < 30 && user.salary > 55000);

// Reduce - accumulate values
const totalSalary = users.reduce((sum, user) => sum + user.salary, 0);
const averageSalary = totalSalary / users.length;

// Group by department
const usersByDepartment = users.reduce((groups, user) => {
  const dept = user.department;
  if (!groups[dept]) {
    groups[dept] = [];
  }
  groups[dept].push(user);
  return groups;
}, {});

// Find min/max salary
const salaries = users.map(user => user.salary);
const maxSalary = Math.max(...salaries);
const minSalary = Math.min(...salaries);

// Complex reduce example - department statistics
const departmentStats = users.reduce((stats, user) => {
  const dept = user.department;
  if (!stats[dept]) {
    stats[dept] = {
      count: 0,
      totalSalary: 0,
      employees: []
    };
  }
  
  stats[dept].count++;
  stats[dept].totalSalary += user.salary;
  stats[dept].employees.push(user.name);
  stats[dept].averageSalary = stats[dept].totalSalary / stats[dept].count;
  
  return stats;
}, {});

console.log(departmentStats);
```

**2. Advanced Array Methods:**
```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// find - returns first element that matches
const firstEven = numbers.find(n => n % 2 === 0); // 2
const firstGreaterThan5 = numbers.find(n => n > 5); // 6

// findIndex - returns index of first matching element
const firstEvenIndex = numbers.findIndex(n => n % 2 === 0); // 1

// some - returns true if at least one element matches
const hasEvenNumbers = numbers.some(n => n % 2 === 0); // true
const hasNegativeNumbers = numbers.some(n => n < 0); // false

// every - returns true if all elements match
const allPositive = numbers.every(n => n > 0); // true
const allEven = numbers.every(n => n % 2 === 0); // false

// includes - checks if array contains a value
const hasNumber5 = numbers.includes(5); // true
const hasNumber15 = numbers.includes(15); // false

// flatMap - maps and flattens result
const words = ['hello', 'world'];
const letters = words.flatMap(word => word.split(''));
console.log(letters); // ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']

// Complex example: nested array processing
const orders = [
  { id: 1, items: [{ name: 'laptop', price: 1000 }, { name: 'mouse', price: 20 }] },
  { id: 2, items: [{ name: 'keyboard', price: 50 }, { name: 'monitor', price: 300 }] }
];

// Get all items with flatMap
const allItems = orders.flatMap(order => order.items);

// Calculate total value
const totalValue = allItems.reduce((sum, item) => sum + item.price, 0);

// Group items by price range
const itemsByPriceRange = allItems.reduce((groups, item) => {
  let range;
  if (item.price < 50) range = 'low';
  else if (item.price < 500) range = 'medium';
  else range = 'high';
  
  if (!groups[range]) groups[range] = [];
  groups[range].push(item);
  return groups;
}, {});
```

**3. Array Sorting and Searching:**
```javascript
const products = [
  { name: 'Laptop', price: 1000, category: 'Electronics', rating: 4.5 },
  { name: 'Book', price: 15, category: 'Education', rating: 4.8 },
  { name: 'Phone', price: 800, category: 'Electronics', rating: 4.2 },
  { name: 'Desk', price: 200, category: 'Furniture', rating: 4.0 }
];

// Sort by price (ascending)
const sortedByPrice = [...products].sort((a, b) => a.price - b.price);

// Sort by price (descending)
const sortedByPriceDesc = [...products].sort((a, b) => b.price - a.price);

// Sort by name (alphabetical)
const sortedByName = [...products].sort((a, b) => a.name.localeCompare(b.name));

// Multi-level sorting: category first, then price
const sortedMultiple = [...products].sort((a, b) => {
  if (a.category !== b.category) {
    return a.category.localeCompare(b.category);
  }
  return a.price - b.price;
});

// Custom search function
function searchProducts(products, query) {
  const lowercaseQuery = query.toLowerCase();
  return products.filter(product => 
    product.name.toLowerCase().includes(lowercaseQuery) ||
    product.category.toLowerCase().includes(lowercaseQuery)
  );
}

// Advanced filtering with multiple criteria
function filterProducts(products, criteria) {
  return products.filter(product => {
    if (criteria.minPrice && product.price < criteria.minPrice) return false;
    if (criteria.maxPrice && product.price > criteria.maxPrice) return false;
    if (criteria.category && product.category !== criteria.category) return false;
    if (criteria.minRating && product.rating < criteria.minRating) return false;
    return true;
  });
}

// Usage
const expensiveElectronics = filterProducts(products, {
  category: 'Electronics',
  minPrice: 500,
  minRating: 4.0
});
```

---

### Q29: Explain Web APIs and Browser Features with practical examples.
**Difficulty: Medium**

**Answer:**
Modern browsers provide numerous APIs for enhanced functionality.

**1. Fetch API and HTTP Requests:**
```javascript
// Basic fetch usage
async function fetchUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const userData = await response.json();
    return userData;
  } catch (error) {
    console.error('Failed to fetch user data:', error);
    throw error;
  }
}

// POST request with JSON data
async function createUser(userData) {
  try {
    const response = await fetch('/api/users', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${getAuthToken()}`
      },
      body: JSON.stringify(userData)
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || 'Failed to create user');
    }
    
    return await response.json();
  } catch (error) {
    console.error('Failed to create user:', error);
    throw error;
  }
}

// File upload with FormData
async function uploadFile(file, metadata = {}) {
  const formData = new FormData();
  formData.append('file', file);
  
  Object.entries(metadata).forEach(([key, value]) => {
    formData.append(key, value);
  });
  
  try {
    const response = await fetch('/api/upload', {
      method: 'POST',
      body: formData
    });
    
    return await response.json();
  } catch (error) {
    console.error('Upload failed:', error);
    throw error;
  }
}

// Request with timeout and abort
function fetchWithTimeout(url, options = {}, timeout = 5000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  return fetch(url, {
    ...options,
    signal: controller.signal
  }).finally(() => {
    clearTimeout(timeoutId);
  });
}
```

**2. Local Storage and Session Storage:**
```javascript
class StorageManager {
  // Local Storage methods
  static setLocal(key, value) {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error('Failed to save to localStorage:', error);
    }
  }
  
  static getLocal(key, defaultValue = null) {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue;
    } catch (error) {
      console.error('Failed to read from localStorage:', error);
      return defaultValue;
    }
  }
  
  static removeLocal(key) {
    try {
      localStorage.removeItem(key);
    } catch (error) {
      console.error('Failed to remove from localStorage:', error);
    }
  }
  
  // Session Storage methods
  static setSession(key, value) {
    try {
      sessionStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error('Failed to save to sessionStorage:', error);
    }
  }
  
  static getSession(key, defaultValue = null) {
    try {
      const item = sessionStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue;
    } catch (error) {
      console.error('Failed to read from sessionStorage:', error);
      return defaultValue;
    }
  }
  
  // Storage with expiration
  static setWithExpiry(key, value, ttl) {
    const now = new Date();
    const item = {
      value: value,
      expiry: now.getTime() + ttl
    };
    this.setLocal(key, item);
  }
  
  static getWithExpiry(key) {
    const item = this.getLocal(key);
    if (!item) return null;
    
    const now = new Date();
    if (now.getTime() > item.expiry) {
      this.removeLocal(key);
      return null;
    }
    
    return item.value;
  }
}

// Usage
StorageManager.setLocal('user', { id: 1, name: 'John' });
const user = StorageManager.getLocal('user');

// Set data with 1 hour expiry
StorageManager.setWithExpiry('tempData', { token: 'abc123' }, 3600000);
```

**3. Geolocation API:**
```javascript
class LocationService {
  static async getCurrentPosition(options = {}) {
    const defaultOptions = {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 300000 // 5 minutes
    };
    
    const finalOptions = { ...defaultOptions, ...options };
    
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error('Geolocation is not supported'));
        return;
      }
      
      navigator.geolocation.getCurrentPosition(
        (position) => {
          resolve({
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            accuracy: position.coords.accuracy,
            timestamp: position.timestamp
          });
        },
        (error) => {
          let message;
          switch (error.code) {
            case error.PERMISSION_DENIED:
              message = 'Location access denied by user';
              break;
            case error.POSITION_UNAVAILABLE:
              message = 'Location information unavailable';
              break;
            case error.TIMEOUT:
              message = 'Location request timed out';
              break;
            default:
              message = 'Unknown location error';
              break;
          }
          reject(new Error(message));
        },
        finalOptions
      );
    });
  }
  
  static watchPosition(callback, errorCallback, options = {}) {
    if (!navigator.geolocation) {
      errorCallback(new Error('Geolocation is not supported'));
      return null;
    }
    
    return navigator.geolocation.watchPosition(
      callback,
      errorCallback,
      options
    );
  }
  
  static clearWatch(watchId) {
    if (navigator.geolocation && watchId) {
      navigator.geolocation.clearWatch(watchId);
    }
  }
}

// Usage
try {
  const location = await LocationService.getCurrentPosition();
  console.log(`Lat: ${location.latitude}, Lng: ${location.longitude}`);
} catch (error) {
  console.error('Location error:', error.message);
}
```

**4. Notification API:**
```javascript
class NotificationService {
  static async requestPermission() {
    if (!('Notification' in window)) {
      throw new Error('This browser does not support notifications');
    }
    
    if (Notification.permission === 'granted') {
      return true;
    }
    
    if (Notification.permission === 'denied') {
      throw new Error('Notification permission denied');
    }
    
    const permission = await Notification.requestPermission();
    return permission === 'granted';
  }
  
  static async showNotification(title, options = {}) {
    try {
      const hasPermission = await this.requestPermission();
      if (!hasPermission) {
        throw new Error('Notification permission not granted');
      }
      
      const defaultOptions = {
        icon: '/icon-192x192.png',
        badge: '/badge-72x72.png',
        vibrate: [200, 100, 200],
        requireInteraction: false
      };
      
      const notification = new Notification(title, {
        ...defaultOptions,
        ...options
      });
      
      // Auto-close after 5 seconds if not requiring interaction
      if (!options.requireInteraction) {
        setTimeout(() => notification.close(), 5000);
      }
      
      return notification;
    } catch (error) {
      console.error('Failed to show notification:', error);
      throw error;
    }
  }
}

// Usage
NotificationService.showNotification('New Message', {
  body: 'You have received a new message',
  icon: '/message-icon.png',
  tag: 'message-notification',
  data: { messageId: 123 }
});
```

---

### Q30: Explain Modern JavaScript Features (ES2020+) with examples.
**Difficulty: Medium**

**Answer:**
Modern JavaScript includes powerful features for better code organization and functionality.

**1. Optional Chaining (?.):**
```javascript
const user = {
  id: 1,
  name: 'John',
  address: {
    street: '123 Main St',
    city: 'New York',
    coordinates: {
      lat: 40.7128,
      lng: -74.0060
    }
  },
  preferences: {
    theme: 'dark',
    notifications: {
      email: true,
      push: false
    }
  }
};

// Without optional chaining (risky)
// const lat = user.address.coordinates.lat; // Could throw error

// With optional chaining (safe)
const lat = user.address?.coordinates?.lat; // 40.7128
const phone = user.contact?.phone; // undefined (no error)
const emailNotif = user.preferences?.notifications?.email; // true

// Optional chaining with arrays
const users = [
  { name: 'John', posts: [{ title: 'Hello' }] },
  { name: 'Jane' } // No posts property
];

const firstPostTitle = users[0]?.posts?.[0]?.title; // 'Hello'
const secondUserFirstPost = users[1]?.posts?.[0]?.title; // undefined

// Optional chaining with function calls
const api = {
  user: {
    getData: () => ({ name: 'John', age: 30 })
  }
};

const userData = api.user?.getData?.(); // Calls function if it exists
const nonExistentData = api.admin?.getData?.(); // undefined (no error)
```

**2. Nullish Coalescing (??):**
```javascript
// Nullish coalescing vs logical OR
const config = {
  timeout: 0,
  retries: null,
  debug: false,
  apiUrl: undefined
};

// Using logical OR (problematic with falsy values)
const timeoutOR = config.timeout || 5000; // 5000 (wrong! 0 is falsy)
const debugOR = config.debug || true; // true (wrong! false is falsy)

// Using nullish coalescing (only null/undefined trigger default)
const timeoutNC = config.timeout ?? 5000; // 0 (correct!)
const debugNC = config.debug ?? true; // false (correct!)
const retriesNC = config.retries ?? 3; // 3 (correct, null triggers default)
const apiUrlNC = config.apiUrl ?? 'https://api.example.com'; // default URL

// Practical example: user preferences
function getUserPreferences(user) {
  return {
    theme: user.preferences?.theme ?? 'light',
    language: user.preferences?.language ?? 'en',
    notifications: user.preferences?.notifications ?? true,
    autoSave: user.preferences?.autoSave ?? false // false is valid preference
  };
}

// Assignment with nullish coalescing
let userTheme;
userTheme ??= 'light'; // Assign only if userTheme is null/undefined
console.log(userTheme); // 'light'

userTheme = 'dark';
userTheme ??= 'light'; // No assignment, userTheme is already 'dark'
console.log(userTheme); // 'dark'
```

**3. BigInt for Large Numbers:**
```javascript
// Regular numbers have precision limits
const maxSafeInteger = Number.MAX_SAFE_INTEGER; // 9007199254740991
const beyondSafe = maxSafeInteger + 1; // 9007199254740992
const beyondSafe2 = maxSafeInteger + 2; // 9007199254740992 (same as above!)

console.log(beyondSafe === beyondSafe2); // true (precision lost)

// BigInt for arbitrary precision
const bigNum1 = BigInt(maxSafeInteger) + 1n; // 9007199254740992n
const bigNum2 = BigInt(maxSafeInteger) + 2n; // 9007199254740993n

console.log(bigNum1 === bigNum2); // false (precision maintained)

// BigInt operations
const a = 123456789012345678901234567890n;
const b = 987654321098765432109876543210n;

const sum = a + b;
const product = a * b;
const power = a ** 2n;

// Converting between BigInt and Number
const regularNum = 42;
const bigIntNum = BigInt(regularNum); // 42n
const backToNum = Number(bigIntNum); // 42

// Practical example: cryptocurrency calculations
class CryptoWallet {
  constructor() {
    this.balance = 0n; // Store as BigInt for precision
  }
  
  deposit(amount) {
    // Convert string/number to BigInt
    const amountBigInt = typeof amount === 'string' ? 
      BigInt(amount) : BigInt(Math.floor(amount));
    this.balance += amountBigInt;
  }
  
  withdraw(amount) {
    const amountBigInt = typeof amount === 'string' ? 
      BigInt(amount) : BigInt(Math.floor(amount));
    
    if (this.balance >= amountBigInt) {
      this.balance -= amountBigInt;
      return true;
    }
    return false;
  }
  
  getBalance() {
    return this.balance.toString(); // Convert to string for display
  }
}

const wallet = new CryptoWallet();
wallet.deposit('1000000000000000000000'); // Very large number
console.log(wallet.getBalance());
```

**4. Dynamic Imports:**
```javascript
// Static imports (traditional)
// import { utils } from './utils.js'; // Loaded at compile time

// Dynamic imports (ES2020)
async function loadUtilsWhenNeeded() {
  try {
    const { utils, helpers } = await import('./utils.js');
    return utils.processData(data);
  } catch (error) {
    console.error('Failed to load utils:', error);
  }
}

// Conditional loading
async function loadFeature(featureName) {
  let module;
  
  switch (featureName) {
    case 'charts':
      module = await import('./charts.js');
      break;
    case 'analytics':
      module = await import('./analytics.js');
      break;
    case 'reporting':
      module = await import('./reporting.js');
      break;
    default:
      throw new Error(`Unknown feature: ${featureName}`);
  }
  
  return module.default || module;
}

// Lazy loading with user interaction
class AdvancedEditor {
  constructor() {
    this.basicEditor = new BasicEditor();
    this.advancedFeatures = null;
  }
  
  async enableAdvancedMode() {
    if (!this.advancedFeatures) {
      try {
        const module = await import('./advanced-editor-features.js');
        this.advancedFeatures = new module.AdvancedFeatures();
      } catch (error) {
        console.error('Failed to load advanced features:', error);
        return false;
      }
    }
    
    this.advancedFeatures.activate();
    return true;
  }
}

// Dynamic import with error handling and fallback
async function loadWithFallback(primaryModule, fallbackModule) {
  try {
    return await import(primaryModule);
  } catch (error) {
    console.warn(`Failed to load ${primaryModule}, using fallback`);
    return await import(fallbackModule);
  }
}
```

**5. Promise.allSettled():**
```javascript
// Promise.all vs Promise.allSettled
const promises = [
  fetch('/api/users'),
  fetch('/api/posts'),
  fetch('/api/comments'),
  fetch('/api/invalid-endpoint') // This will fail
];

// Promise.all - fails if any promise rejects
try {
  const results = await Promise.all(promises);
  // This won't execute because one promise failed
} catch (error) {
  console.error('One or more requests failed:', error);
}

// Promise.allSettled - waits for all promises regardless of outcome
const results = await Promise.allSettled(promises);

results.forEach((result, index) => {
  if (result.status === 'fulfilled') {
    console.log(`Request ${index} succeeded:`, result.value);
  } else {
    console.log(`Request ${index} failed:`, result.reason);
  }
});

// Practical example: loading multiple data sources
async function loadDashboardData() {
  const dataPromises = [
    fetchUserStats(),
    fetchSalesData(),
    fetchAnalytics(),
    fetchNotifications()
  ];
  
  const results = await Promise.allSettled(dataPromises);
  
  const dashboard = {
    userStats: null,
    salesData: null,
    analytics: null,
    notifications: []
  };
  
  results.forEach((result, index) => {
    const keys = ['userStats', 'salesData', 'analytics', 'notifications'];
    
    if (result.status === 'fulfilled') {
      dashboard[keys[index]] = result.value;
    } else {
      console.warn(`Failed to load ${keys[index]}:`, result.reason);
      // Set default values or show error state
    }
  });
  
  return dashboard;
}
```

**6. String.prototype.matchAll():**
```javascript
// Traditional approach with regex.exec()
function findAllMatches(text, regex) {
  const matches = [];
  let match;
  
  while ((match = regex.exec(text)) !== null) {
    matches.push(match);
    if (!regex.global) break; // Prevent infinite loop
  }
  
  return matches;
}

// Modern approach with matchAll()
const text = 'The price is $25.99 and the tax is $3.50, total: $29.49';
const priceRegex = /\$(\d+\.\d{2})/g;

// Using matchAll
const matches = [...text.matchAll(priceRegex)];
matches.forEach((match, index) => {
  console.log(`Match ${index}: ${match[0]}, Amount: ${match[1]}`);
});

// Practical example: parsing structured data
function parseLogEntries(logText) {
  const logRegex = /\[(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\] (\w+): (.+)/g;
  const entries = [];
  
  for (const match of logText.matchAll(logRegex)) {
    entries.push({
      timestamp: new Date(match[1]),
      level: match[2],
      message: match[3]
    });
  }
  
  return entries;
}

const logText = `
[2023-01-01 10:30:15] INFO: Application started
[2023-01-01 10:30:16] DEBUG: Loading configuration
[2023-01-01 10:30:20] ERROR: Database connection failed
`;

const logEntries = parseLogEntries(logText);
console.log(logEntries);
```

---

## Modern JavaScript Features (ES2020-2023+)

### Q31: What are the latest JavaScript features and how do you use them?
**Difficulty: Advanced**

**Answer:**
Modern JavaScript includes many powerful features that improve code readability, performance, and developer experience.

**1. Top-level await (ES2022):**
```javascript
// Before: Had to wrap in async function
(async () => {
  const data = await fetch('/api/data');
  const json = await data.json();
  console.log(json);
})();

// Now: Can use await at module level
const data = await fetch('/api/data');
const json = await data.json();
console.log(json);

// Practical example: Module initialization
const config = await import('./config.js');
const db = await connectToDatabase(config.default.dbUrl);
export { db };
```

**2. Private class fields and methods (ES2022):**
```javascript
class BankAccount {
  // Private fields
  #balance = 0;
  #accountNumber;
  
  // Private method
  #validateAmount(amount) {
    if (amount <= 0) {
      throw new Error('Amount must be positive');
    }
    if (typeof amount !== 'number') {
      throw new Error('Amount must be a number');
    }
  }
  
  constructor(accountNumber, initialBalance = 0) {
    this.#accountNumber = accountNumber;
    this.#balance = initialBalance;
  }
  
  deposit(amount) {
    this.#validateAmount(amount);
    this.#balance += amount;
    return this.#balance;
  }
  
  withdraw(amount) {
    this.#validateAmount(amount);
    if (amount > this.#balance) {
      throw new Error('Insufficient funds');
    }
    this.#balance -= amount;
    return this.#balance;
  }
  
  get balance() {
    return this.#balance;
  }
  
  // Static private method
  static #generateAccountNumber() {
    return Math.random().toString(36).substr(2, 9).toUpperCase();
  }
  
  static createAccount(initialBalance = 0) {
    const accountNumber = this.#generateAccountNumber();
    return new BankAccount(accountNumber, initialBalance);
  }
}

const account = BankAccount.createAccount(1000);
console.log(account.balance); // 1000
// console.log(account.#balance); // SyntaxError: Private field '#balance' must be declared in an enclosing class
```

**3. Array.prototype.at() (ES2022):**
```javascript
const fruits = ['apple', 'banana', 'cherry', 'date', 'elderberry'];

// Traditional way to get last element
console.log(fruits[fruits.length - 1]); // 'elderberry'

// Modern way with at()
console.log(fruits.at(-1)); // 'elderberry'
console.log(fruits.at(-2)); // 'date'
console.log(fruits.at(0));  // 'apple'
console.log(fruits.at(1));  // 'banana'

// Works with strings too
const text = 'Hello World';
console.log(text.at(-1)); // 'd'
console.log(text.at(-6)); // ' '

// Practical example: Safe array access
function getLastNItems(array, n) {
  return Array.from({ length: n }, (_, i) => array.at(-(i + 1))).reverse();
}

console.log(getLastNItems(fruits, 3)); // ['cherry', 'date', 'elderberry']
```

**4. Object.hasOwn() (ES2022):**
```javascript
const obj = {
  name: 'John',
  age: 30
};

// Traditional way (can be problematic)
console.log(obj.hasOwnProperty('name')); // true

// Modern way (safer)
console.log(Object.hasOwn(obj, 'name')); // true
console.log(Object.hasOwn(obj, 'toString')); // false

// Why Object.hasOwn is better
const objWithoutPrototype = Object.create(null);
objWithoutPrototype.name = 'Jane';

// This would throw an error
// console.log(objWithoutPrototype.hasOwnProperty('name')); // TypeError

// This works fine
console.log(Object.hasOwn(objWithoutPrototype, 'name')); // true

// Practical example: Safe property checking
function safePropertyCheck(obj, prop) {
  return Object.hasOwn(obj, prop) ? obj[prop] : undefined;
}
```

**5. Error.cause (ES2022):**
```javascript
// Enhanced error handling with cause
class DatabaseError extends Error {
  constructor(message, cause) {
    super(message, { cause });
    this.name = 'DatabaseError';
  }
}

class UserService {
  async getUser(id) {
    try {
      const response = await fetch(`/api/users/${id}`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return await response.json();
    } catch (originalError) {
      // Wrap the original error with more context
      throw new DatabaseError(
        `Failed to fetch user with id ${id}`,
        originalError
      );
    }
  }
}

// Usage
try {
  const user = await userService.getUser(123);
} catch (error) {
  console.log(error.message); // "Failed to fetch user with id 123"
  console.log(error.cause);   // Original fetch error
  
  // Can trace the full error chain
  let currentError = error;
  while (currentError) {
    console.log(`Error: ${currentError.message}`);
    currentError = currentError.cause;
  }
}
```

**6. Array.prototype.findLast() and findLastIndex() (ES2023):**
```javascript
const numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

// Find last even number
const lastEven = numbers.findLast(n => n % 2 === 0);
console.log(lastEven); // 2

// Find index of last even number
const lastEvenIndex = numbers.findLastIndex(n => n % 2 === 0);
console.log(lastEvenIndex); // 7

// Practical example: Finding latest log entry
const logs = [
  { level: 'info', message: 'App started', timestamp: 1000 },
  { level: 'error', message: 'Connection failed', timestamp: 2000 },
  { level: 'info', message: 'Retrying...', timestamp: 3000 },
  { level: 'error', message: 'Still failing', timestamp: 4000 },
  { level: 'info', message: 'Connected', timestamp: 5000 }
];

const lastError = logs.findLast(log => log.level === 'error');
console.log(lastError); // { level: 'error', message: 'Still failing', timestamp: 4000 }
```

**7. Array.prototype.toReversed(), toSorted(), toSpliced(), with() (ES2023):**
```javascript
const original = [3, 1, 4, 1, 5, 9, 2, 6];

// Non-mutating array methods
const reversed = original.toReversed();
console.log(original); // [3, 1, 4, 1, 5, 9, 2, 6] (unchanged)
console.log(reversed); // [6, 2, 9, 5, 1, 4, 1, 3]

const sorted = original.toSorted();
console.log(sorted); // [1, 1, 2, 3, 4, 5, 6, 9]

const spliced = original.toSpliced(2, 2, 'a', 'b');
console.log(spliced); // [3, 1, 'a', 'b', 5, 9, 2, 6]

const modified = original.with(0, 'first');
console.log(modified); // ['first', 1, 4, 1, 5, 9, 2, 6]

// Practical example: Immutable state updates
class TodoList {
  constructor(todos = []) {
    this.todos = todos;
  }
  
  addTodo(todo) {
    return new TodoList([...this.todos, todo]);
  }
  
  removeTodo(index) {
    return new TodoList(this.todos.toSpliced(index, 1));
  }
  
  updateTodo(index, newTodo) {
    return new TodoList(this.todos.with(index, newTodo));
  }
  
  sortTodos() {
    return new TodoList(this.todos.toSorted((a, b) => a.priority - b.priority));
  }
}
```

---

## Advanced JavaScript Patterns

### Q32: What are some advanced JavaScript design patterns and when should you use them?
**Difficulty: Advanced**

**Answer:**
Advanced JavaScript patterns help solve complex problems and improve code organization.

**1. Module Pattern with Namespace:**
```javascript
const AppModule = (() => {
  // Private variables and functions
  let config = {
    apiUrl: 'https://api.example.com',
    timeout: 5000
  };
  
  const cache = new Map();
  
  function validateConfig(newConfig) {
    if (!newConfig.apiUrl) {
      throw new Error('API URL is required');
    }
  }
  
  // Public API
  return {
    // Configuration management
    configure(newConfig) {
      validateConfig(newConfig);
      config = { ...config, ...newConfig };
    },
    
    getConfig() {
      return { ...config }; // Return copy to prevent mutation
    },
    
    // HTTP utilities
    async request(endpoint, options = {}) {
      const url = `${config.apiUrl}${endpoint}`;
      const cacheKey = `${url}:${JSON.stringify(options)}`;
      
      // Check cache for GET requests
      if (!options.method || options.method === 'GET') {
        if (cache.has(cacheKey)) {
          return cache.get(cacheKey);
        }
      }
      
      try {
        const response = await fetch(url, {
          timeout: config.timeout,
          ...options
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Cache successful GET requests
        if (!options.method || options.method === 'GET') {
          cache.set(cacheKey, data);
        }
        
        return data;
      } catch (error) {
        console.error('Request failed:', error);
        throw error;
      }
    },
    
    // Cache management
    clearCache() {
      cache.clear();
    }
  };
})();

// Usage
AppModule.configure({ apiUrl: 'https://my-api.com' });
const users = await AppModule.request('/users');
```

**2. Observer Pattern with Event Emitter:**
```javascript
class EventEmitter {
  constructor() {
    this.events = new Map();
  }
  
  on(event, listener) {
    if (!this.events.has(event)) {
      this.events.set(event, new Set());
    }
    this.events.get(event).add(listener);
    
    // Return unsubscribe function
    return () => this.off(event, listener);
  }
  
  once(event, listener) {
    const unsubscribe = this.on(event, (...args) => {
      unsubscribe();
      listener(...args);
    });
    return unsubscribe;
  }
  
  off(event, listener) {
    if (this.events.has(event)) {
      this.events.get(event).delete(listener);
      if (this.events.get(event).size === 0) {
        this.events.delete(event);
      }
    }
  }
  
  emit(event, ...args) {
    if (this.events.has(event)) {
      this.events.get(event).forEach(listener => {
        try {
          listener(...args);
        } catch (error) {
          console.error(`Error in event listener for '${event}':`, error);
        }
      });
    }
  }
  
  removeAllListeners(event) {
    if (event) {
      this.events.delete(event);
    } else {
      this.events.clear();
    }
  }
}

// Application state management using Observer pattern
class StateManager extends EventEmitter {
  constructor(initialState = {}) {
    super();
    this.state = { ...initialState };
  }
  
  getState() {
    return { ...this.state };
  }
  
  setState(updates) {
    const prevState = { ...this.state };
    this.state = { ...this.state, ...updates };
    
    this.emit('stateChange', {
      prevState,
      newState: { ...this.state },
      updates
    });
  }
  
  subscribe(listener) {
    return this.on('stateChange', listener);
  }
}

// Usage
const stateManager = new StateManager({ count: 0, user: null });

const unsubscribe = stateManager.subscribe(({ prevState, newState, updates }) => {
  console.log('State changed:', { prevState, newState, updates });
});

stateManager.setState({ count: 1 });
stateManager.setState({ user: { name: 'John', id: 123 } });
```

**3. Command Pattern for Undo/Redo:**
```javascript
class Command {
  execute() {
    throw new Error('Execute method must be implemented');
  }
  
  undo() {
    throw new Error('Undo method must be implemented');
  }
}

class AddItemCommand extends Command {
  constructor(list, item) {
    super();
    this.list = list;
    this.item = item;
  }
  
  execute() {
    this.list.push(this.item);
  }
  
  undo() {
    const index = this.list.indexOf(this.item);
    if (index > -1) {
      this.list.splice(index, 1);
    }
  }
}

class RemoveItemCommand extends Command {
  constructor(list, index) {
    super();
    this.list = list;
    this.index = index;
    this.removedItem = null;
  }
  
  execute() {
    this.removedItem = this.list.splice(this.index, 1)[0];
  }
  
  undo() {
    if (this.removedItem !== null) {
      this.list.splice(this.index, 0, this.removedItem);
    }
  }
}

class CommandManager {
  constructor() {
    this.history = [];
    this.currentIndex = -1;
  }
  
  execute(command) {
    // Remove any commands after current index (for redo scenarios)
    this.history = this.history.slice(0, this.currentIndex + 1);
    
    command.execute();
    this.history.push(command);
    this.currentIndex++;
  }
  
  undo() {
    if (this.canUndo()) {
      const command = this.history[this.currentIndex];
      command.undo();
      this.currentIndex--;
    }
  }
  
  redo() {
    if (this.canRedo()) {
      this.currentIndex++;
      const command = this.history[this.currentIndex];
      command.execute();
    }
  }
  
  canUndo() {
    return this.currentIndex >= 0;
  }
  
  canRedo() {
    return this.currentIndex < this.history.length - 1;
  }
}

// Usage
const list = [];
const commandManager = new CommandManager();

// Execute commands
commandManager.execute(new AddItemCommand(list, 'Item 1'));
commandManager.execute(new AddItemCommand(list, 'Item 2'));
commandManager.execute(new RemoveItemCommand(list, 0));

console.log(list); // ['Item 2']

// Undo operations
commandManager.undo(); // Undoes remove
console.log(list); // ['Item 1', 'Item 2']

commandManager.undo(); // Undoes add Item 2
console.log(list); // ['Item 1']

// Redo operations
commandManager.redo(); // Redoes add Item 2
console.log(list); // ['Item 1', 'Item 2']
```

**4. Strategy Pattern for Algorithm Selection:**
```javascript
class SortingStrategy {
  sort(array) {
    throw new Error('Sort method must be implemented');
  }
}

class BubbleSortStrategy extends SortingStrategy {
  sort(array) {
    const arr = [...array];
    const n = arr.length;
    
    for (let i = 0; i < n - 1; i++) {
      for (let j = 0; j < n - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        }
      }
    }
    
    return arr;
  }
}

class QuickSortStrategy extends SortingStrategy {
  sort(array) {
    if (array.length <= 1) return [...array];
    
    const pivot = array[Math.floor(array.length / 2)];
    const left = array.filter(x => x < pivot);
    const middle = array.filter(x => x === pivot);
    const right = array.filter(x => x > pivot);
    
    return [...this.sort(left), ...middle, ...this.sort(right)];
  }
}

class NativeSortStrategy extends SortingStrategy {
  sort(array) {
    return [...array].sort((a, b) => a - b);
  }
}

class Sorter {
  constructor(strategy) {
    this.strategy = strategy;
  }
  
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  
  sort(array) {
    const startTime = performance.now();
    const result = this.strategy.sort(array);
    const endTime = performance.now();
    
    return {
      result,
      executionTime: endTime - startTime,
      strategy: this.strategy.constructor.name
    };
  }
}

// Usage
const data = [64, 34, 25, 12, 22, 11, 90];
const sorter = new Sorter(new QuickSortStrategy());

let result = sorter.sort(data);
console.log(result);

// Switch strategy based on data size
if (data.length < 10) {
  sorter.setStrategy(new BubbleSortStrategy());
} else if (data.length < 1000) {
  sorter.setStrategy(new QuickSortStrategy());
} else {
  sorter.setStrategy(new NativeSortStrategy());
}

result = sorter.sort(data);
console.log(result);
```

---

## Memory Management

### Q33: Explain JavaScript memory management and garbage collection. How can you prevent memory leaks?
**Difficulty: Hard**

**Answer:**
JavaScript memory management is handled automatically through garbage collection, but understanding how it works is crucial for writing efficient applications.

**Memory Lifecycle:**
1. **Allocation** - JavaScript automatically allocates memory when objects are created
2. **Usage** - Reading and writing to allocated memory
3. **Release** - Garbage collector frees memory when objects are no longer needed

**Garbage Collection Algorithms:**

1. **Reference Counting:**
   - Counts references to each object
   - When count reaches zero, memory is freed
   - Problem: Cannot handle circular references

```javascript
function referenceCountingIssue() {
    let obj1 = {};
    let obj2 = {};
    
    // Circular reference
    obj1.ref = obj2;
    obj2.ref = obj1;
    
    // Both objects go out of scope but won't be collected
    // if using only reference counting
    return "done";
}
```

2. **Mark and Sweep:**
   - Modern browsers use this algorithm
   - Starts from "roots" (global objects)
   - Marks all reachable objects
   - Sweeps and frees unmarked objects
   - Can handle circular references

**Common Memory Leak Causes:**

1. **Accidental Global Variables:**
```javascript
function leakyFunction() {
    notDeclared = "I'm a global variable"; // Missing 'let/const/var'
    this.anotherGlobal = []; // 'this' refers to window in non-strict mode
}
```

2. **Forgotten Timers and Callbacks:**
```javascript
function setupLeakyTimer() {
    const largeData = new Array(1000000).fill('x');
    
    setInterval(() => {
        // This reference prevents largeData from being garbage collected
        console.log(largeData.length);
    }, 1000);
}
```

3. **Closures Capturing Variables:**
```javascript
function createLeak() {
    const largeData = new Array(1000000).fill('x');
    
    return function() {
        // Closure keeps reference to largeData even if only length is needed
        console.log(largeData.length);
    };
}

const leakyFunction = createLeak(); // largeData stays in memory
```

4. **DOM References Outside of DOM:**
```javascript
let elements = [];

function cacheElements() {
    // Store DOM elements
    elements.push(document.getElementById('element'));
    
    // Even if element is removed from DOM, it stays in memory
    document.body.removeChild(document.getElementById('element'));
}
```

5. **Event Listeners Not Removed:**
```javascript
function addLeakyListener() {
    const element = document.getElementById('button');
    const largeData = new Array(1000000).fill('x');
    
    element.addEventListener('click', function() {
        // This function captures largeData
        console.log(largeData.length);
    });
    
    // If element is removed without removing listener, leak occurs
}
```

**Preventing Memory Leaks:**

1. **Use Block Scope and Strict Mode:**
```javascript
'use strict';

function safeFunction() {
    let localVar = "I'm properly scoped";
    // localVar is garbage collected when function exits
}
```

2. **Clear Timers and Event Listeners:**
```javascript
function safeTimerUsage() {
    const largeData = new Array(1000000).fill('x');
    
    const timerId = setInterval(() => {
        console.log('Processing...');
    }, 1000);
    
    // Later, when done:
    clearInterval(timerId);
    // Now largeData can be garbage collected
}

function safeEventListener() {
    const element = document.getElementById('button');
    const largeData = new Array(1000000).fill('x');
    
    const clickHandler = function() {
        console.log(largeData.length);
    };
    
    element.addEventListener('click', clickHandler);
    
    // When done:
    element.removeEventListener('click', clickHandler);
    // Now largeData can be garbage collected
}
```

3. **Nullify References:**
```javascript
function processData() {
    let largeData = new Array(1000000).fill('x');
    
    // Process data...
    
    // When done, explicitly nullify
    largeData = null;
}
```

4. **Use WeakMap and WeakSet:**
```javascript
// Regular Map keeps strong references
const regularMap = new Map();
let obj = { data: "some data" };
regularMap.set(obj, "metadata");

// obj reference is maintained by regularMap
obj = null; // Original reference removed, but object still in memory

// WeakMap allows garbage collection of keys
const weakMap = new WeakMap();
let obj2 = { data: "some data" };
weakMap.set(obj2, "metadata");

// When obj2 has no other references, it can be garbage collected
// along with its associated data in weakMap
obj2 = null;
```

5. **Avoid Circular References or Break Them:**
```javascript
function handleCircularReferences() {
    let parent = { name: 'parent' };
    let child = { name: 'child' };
    
    // Create circular reference
    parent.child = child;
    child.parent = parent;
    
    // Use the objects...
    
    // Break circular reference when done
    child.parent = null;
    // Now both objects can be garbage collected when they go out of scope
}
```

6. **Use Chrome DevTools Memory Profiler:**
   - Take heap snapshots
   - Compare snapshots to find memory growth
   - Analyze retention paths

**Advanced Memory Management Techniques:**

1. **Object Pooling for Frequent Allocations:**
```javascript
class ObjectPool {
    constructor(createFn, initialSize = 10) {
        this.createFn = createFn;
        this.pool = Array(initialSize).fill().map(() => createFn());
    }
    
    acquire() {
        return this.pool.pop() || this.createFn();
    }
    
    release(obj) {
        this.pool.push(obj);
    }
}

// Usage for expensive objects
const vectorPool = new ObjectPool(() => ({ x: 0, y: 0 }));

function processVectors() {
    const v = vectorPool.acquire();
    v.x = 10;
    v.y = 20;
    
    // Use vector...
    
    // Return to pool instead of letting GC handle it
    vectorPool.release(v);
}
```

2. **Incremental Processing for Large Data:**
```javascript
function processLargeDataIncrementally(data, chunkSize = 1000) {
    let index = 0;
    
    function processChunk() {
        const chunk = data.slice(index, index + chunkSize);
        
        // Process chunk
        chunk.forEach(item => {
            // Do something with item
        });
        
        index += chunkSize;
        
        // Continue processing if more data
        if (index < data.length) {
            // Use setTimeout to avoid blocking the main thread
            setTimeout(processChunk, 0);
        }
    }
    
    processChunk();
}
```

**Memory Leak Detection Tools:**

1. Chrome DevTools Memory Panel
2. Heap Snapshot Comparison
3. Allocation Timeline
4. `performance.memory` API (Chrome only)
5. Node.js `--inspect` flag with Chrome DevTools

**Best Practices Summary:**

1. Understand the memory lifecycle and garbage collection mechanisms
2. Use appropriate data structures (WeakMap/WeakSet when needed)
3. Clean up event listeners, timers, and references
4. Avoid accidental globals with strict mode
5. Profile memory usage regularly
6. Consider object pooling for performance-critical code
7. Break circular references when no longer needed
8. Use incremental processing for large datasets

---

## Performance Optimization

### Q34: How do you optimize JavaScript performance and manage memory effectively?
**Difficulty: Advanced**

**Answer:**
JavaScript performance optimization involves understanding the event loop, memory management, and efficient coding patterns.

**1. Memory Management and Garbage Collection:**
```javascript
// Memory-efficient object pooling
class ObjectPool {
  constructor(createFn, resetFn, initialSize = 10) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.pool = [];
    
    // Pre-populate pool
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.createFn());
    }
  }
  
  acquire() {
    if (this.pool.length > 0) {
      return this.pool.pop();
    }
    return this.createFn();
  }
  
  release(obj) {
    this.resetFn(obj);
    this.pool.push(obj);
  }
  
  get size() {
    return this.pool.length;
  }
}

// Example: Particle system with object pooling
class Particle {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.vx = 0;
    this.vy = 0;
    this.life = 1.0;
    this.active = false;
  }
  
  update(deltaTime) {
    if (!this.active) return;
    
    this.x += this.vx * deltaTime;
    this.y += this.vy * deltaTime;
    this.life -= deltaTime;
    
    if (this.life <= 0) {
      this.active = false;
    }
  }
}

const particlePool = new ObjectPool(
  () => new Particle(),
  (particle) => {
    particle.x = 0;
    particle.y = 0;
    particle.vx = 0;
    particle.vy = 0;
    particle.life = 1.0;
    particle.active = false;
  },
  100
);

class ParticleSystem {
  constructor() {
    this.particles = [];
  }
  
  emit(x, y, count = 10) {
    for (let i = 0; i < count; i++) {
      const particle = particlePool.acquire();
      particle.x = x;
      particle.y = y;
      particle.vx = (Math.random() - 0.5) * 200;
      particle.vy = (Math.random() - 0.5) * 200;
      particle.life = Math.random() * 2 + 1;
      particle.active = true;
      
      this.particles.push(particle);
    }
  }
  
  update(deltaTime) {
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const particle = this.particles[i];
      particle.update(deltaTime);
      
      if (!particle.active) {
        // Return to pool instead of creating garbage
        particlePool.release(particle);
        this.particles.splice(i, 1);
      }
    }
  }
}
```

**2. Efficient DOM Manipulation:**
```javascript
// Batch DOM operations to minimize reflows
class DOMBatcher {
  constructor() {
    this.operations = [];
    this.scheduled = false;
  }
  
  add(operation) {
    this.operations.push(operation);
    this.schedule();
  }
  
  schedule() {
    if (!this.scheduled) {
      this.scheduled = true;
      requestAnimationFrame(() => this.flush());
    }
  }
  
  flush() {
    // Batch read operations first
    const reads = this.operations.filter(op => op.type === 'read');
    const writes = this.operations.filter(op => op.type === 'write');
    
    // Execute all reads first
    reads.forEach(op => op.execute());
    
    // Then execute all writes
    writes.forEach(op => op.execute());
    
    this.operations = [];
    this.scheduled = false;
  }
}

const domBatcher = new DOMBatcher();

// Usage
function updateElements(elements, data) {
  elements.forEach((element, index) => {
    // Batch read operations
    domBatcher.add({
      type: 'read',
      execute: () => {
        const rect = element.getBoundingClientRect();
        data[index].width = rect.width;
      }
    });
    
    // Batch write operations
    domBatcher.add({
      type: 'write',
      execute: () => {
        element.style.transform = `translateX(${data[index].x}px)`;
        element.textContent = data[index].text;
      }
    });
  });
}

// Virtual scrolling for large lists
class VirtualList {
  constructor(container, itemHeight, renderItem) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.renderItem = renderItem;
    this.items = [];
    this.visibleItems = new Map();
    
    this.container.addEventListener('scroll', () => this.onScroll());
    window.addEventListener('resize', () => this.onResize());
  }
  
  setItems(items) {
    this.items = items;
    this.container.style.height = `${items.length * this.itemHeight}px`;
    this.render();
  }
  
  onScroll() {
    this.render();
  }
  
  onResize() {
    this.render();
  }
  
  render() {
    const scrollTop = this.container.scrollTop;
    const containerHeight = this.container.clientHeight;
    
    const startIndex = Math.floor(scrollTop / this.itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(containerHeight / this.itemHeight) + 1,
      this.items.length
    );
    
    // Remove items that are no longer visible
    for (const [index, element] of this.visibleItems) {
      if (index < startIndex || index >= endIndex) {
        element.remove();
        this.visibleItems.delete(index);
      }
    }
    
    // Add new visible items
    for (let i = startIndex; i < endIndex; i++) {
      if (!this.visibleItems.has(i)) {
        const element = this.renderItem(this.items[i], i);
        element.style.position = 'absolute';
        element.style.top = `${i * this.itemHeight}px`;
        element.style.height = `${this.itemHeight}px`;
        
        this.container.appendChild(element);
        this.visibleItems.set(i, element);
      }
    }
  }
}
```

**3. Advanced Async Patterns:**
```javascript
// Async queue with concurrency control
class AsyncQueue {
  constructor(concurrency = 3) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }
  
  async add(task) {
    return new Promise((resolve, reject) => {
      this.queue.push({
        task,
        resolve,
        reject
      });
      
      this.process();
    });
  }
  
  async process() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const { task, resolve, reject } = this.queue.shift();
    
    try {
      const result = await task();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process();
    }
  }
  
  get pending() {
    return this.queue.length;
  }
  
  get active() {
    return this.running;
  }
}

// Retry mechanism with exponential backoff
class RetryableOperation {
  constructor(operation, options = {}) {
    this.operation = operation;
    this.maxRetries = options.maxRetries || 3;
    this.baseDelay = options.baseDelay || 1000;
    this.maxDelay = options.maxDelay || 30000;
    this.backoffFactor = options.backoffFactor || 2;
  }
  
  async execute() {
    let lastError;
    
    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
      try {
        return await this.operation();
      } catch (error) {
        lastError = error;
        
        if (attempt === this.maxRetries) {
          throw error;
        }
        
        const delay = Math.min(
          this.baseDelay * Math.pow(this.backoffFactor, attempt),
          this.maxDelay
        );
        
        console.warn(`Operation failed (attempt ${attempt + 1}), retrying in ${delay}ms:`, error.message);
        await this.delay(delay);
      }
    }
    
    throw lastError;
  }
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Circuit breaker pattern
class CircuitBreaker {
  constructor(operation, options = {}) {
    this.operation = operation;
    this.failureThreshold = options.failureThreshold || 5;
    this.timeout = options.timeout || 60000;
    this.monitoringPeriod = options.monitoringPeriod || 10000;
    
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.successCount = 0;
  }
  
  async execute(...args) {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime >= this.timeout) {
        this.state = 'HALF_OPEN';
        this.successCount = 0;
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }
    
    try {
      const result = await this.operation(...args);
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  onSuccess() {
    this.failureCount = 0;
    
    if (this.state === 'HALF_OPEN') {
      this.successCount++;
      if (this.successCount >= 3) {
        this.state = 'CLOSED';
      }
    }
  }
  
  onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
    }
  }
  
  get isOpen() {
    return this.state === 'OPEN';
  }
  
  reset() {
    this.state = 'CLOSED';
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.successCount = 0;
  }
}

// Usage examples
const queue = new AsyncQueue(2);

// Add multiple async operations
const results = await Promise.all([
  queue.add(() => fetch('/api/data1').then(r => r.json())),
  queue.add(() => fetch('/api/data2').then(r => r.json())),
  queue.add(() => fetch('/api/data3').then(r => r.json())),
  queue.add(() => fetch('/api/data4').then(r => r.json()))
]);

// Retryable operation
const retryableRequest = new RetryableOperation(
  () => fetch('/api/unreliable-endpoint').then(r => r.json()),
  { maxRetries: 3, baseDelay: 1000 }
);

try {
  const data = await retryableRequest.execute();
  console.log('Data received:', data);
} catch (error) {
  console.error('Operation failed after retries:', error);
}

// Circuit breaker
const circuitBreaker = new CircuitBreaker(
  (url) => fetch(url).then(r => r.json()),
  { failureThreshold: 3, timeout: 30000 }
);

try {
  const data = await circuitBreaker.execute('/api/protected-endpoint');
  console.log('Data received:', data);
} catch (error) {
  if (circuitBreaker.isOpen) {
    console.log('Circuit breaker is open, using fallback');
    // Use cached data or alternative service
  } else {
    console.error('Request failed:', error);
  }
}
```

**4. Performance Monitoring and Optimization:**
```javascript
// Performance monitoring utility
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.observers = [];
  }
  
  // Measure function execution time
  measure(name, fn) {
    return async (...args) => {
      const start = performance.now();
      
      try {
        const result = await fn(...args);
        const duration = performance.now() - start;
        this.recordMetric(name, duration);
        return result;
      } catch (error) {
        const duration = performance.now() - start;
        this.recordMetric(`${name}_error`, duration);
        throw error;
      }
    };
  }
  
  // Record custom metrics
  recordMetric(name, value) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    
    const values = this.metrics.get(name);
    values.push({
      value,
      timestamp: Date.now()
    });
    
    // Keep only last 100 measurements
    if (values.length > 100) {
      values.shift();
    }
    
    this.notifyObservers(name, value);
  }
  
  // Get metric statistics
  getStats(name) {
    const values = this.metrics.get(name);
    if (!values || values.length === 0) {
      return null;
    }
    
    const nums = values.map(v => v.value);
    const sum = nums.reduce((a, b) => a + b, 0);
    const avg = sum / nums.length;
    const min = Math.min(...nums);
    const max = Math.max(...nums);
    
    // Calculate percentiles
    const sorted = [...nums].sort((a, b) => a - b);
    const p50 = sorted[Math.floor(sorted.length * 0.5)];
    const p95 = sorted[Math.floor(sorted.length * 0.95)];
    const p99 = sorted[Math.floor(sorted.length * 0.99)];
    
    return {
      count: nums.length,
      sum,
      avg,
      min,
      max,
      p50,
      p95,
      p99
    };
  }
  
  // Subscribe to metric updates
  subscribe(callback) {
    this.observers.push(callback);
    return () => {
      const index = this.observers.indexOf(callback);
      if (index > -1) {
        this.observers.splice(index, 1);
      }
    };
  }
  
  notifyObservers(name, value) {
    this.observers.forEach(callback => {
      try {
        callback(name, value);
      } catch (error) {
        console.error('Error in performance monitor observer:', error);
      }
    });
  }
  
  // Monitor Core Web Vitals
  monitorWebVitals() {
    // Largest Contentful Paint
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const lastEntry = entries[entries.length - 1];
      this.recordMetric('LCP', lastEntry.startTime);
    }).observe({ entryTypes: ['largest-contentful-paint'] });
    
    // First Input Delay
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        this.recordMetric('FID', entry.processingStart - entry.startTime);
      });
    }).observe({ entryTypes: ['first-input'] });
    
    // Cumulative Layout Shift
    let clsValue = 0;
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      });
      this.recordMetric('CLS', clsValue);
    }).observe({ entryTypes: ['layout-shift'] });
  }
}

// Usage
const monitor = new PerformanceMonitor();

// Monitor web vitals
monitor.monitorWebVitals();

// Wrap functions for automatic measurement
const measuredFetch = monitor.measure('api_request', fetch);
const measuredProcessData = monitor.measure('data_processing', processData);

// Subscribe to performance updates
monitor.subscribe((name, value) => {
  if (value > 1000) { // Alert if operation takes more than 1 second
    console.warn(`Performance alert: ${name} took ${value}ms`);
  }
});

// Get performance statistics
setInterval(() => {
  const apiStats = monitor.getStats('api_request');
  if (apiStats) {
    console.log('API Request Performance:', apiStats);
  }
}, 30000);
```

This comprehensive JavaScript guide now covers modern ES2020-2023+ features, advanced design patterns, performance optimization, memory management, and sophisticated async patterns. Each section provides practical, production-ready examples that demonstrate real-world usage patterns for building high-performance JavaScript applications.

---

## Browser APIs

### Q35: Explain the Intersection Observer API and how it can be used for performance optimization.
**Difficulty: Hard**

**Answer:**
The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with the document's viewport. It's particularly useful for implementing lazy loading, infinite scrolling, and performance optimizations.

**Basic Usage:**

```javascript
const options = {
  root: null, // Use the viewport as the root
  rootMargin: '0px', // No margin around the root
  threshold: 0.1 // Trigger when 10% of the target is visible
};

const callback = (entries, observer) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log('Element is now visible in the viewport!');
      // Do something with the visible element
      const element = entry.target;
      
      // Example: Lazy load an image
      if (element.dataset.src) {
        element.src = element.dataset.src;
        // Stop observing after loading
        observer.unobserve(element);
      }
    }
  });
};

const observer = new IntersectionObserver(callback, options);

// Start observing elements
const elements = document.querySelectorAll('.lazy-load');
elements.forEach(element => observer.observe(element));
```

**Configuration Options Explained:**

1. **root**: The element that is used as the viewport for checking visibility
   - `null` means use the browser viewport
   - Can be any ancestor element of the targets

2. **rootMargin**: Margin around the root, specified as CSS margin property
   - Expands or shrinks the effective size of the root element
   - Example: '50px 0px' creates a 50px margin at top and bottom

3. **threshold**: Percentage of the target's visibility needed to trigger the callback
   - 0.0 means as soon as even one pixel is visible
   - 1.0 means the entire element must be visible
   - Can be an array like [0, 0.25, 0.5, 0.75, 1] for multiple triggers

**Advanced Use Cases:**

1. **Lazy Loading Images:**

```javascript
document.addEventListener('DOMContentLoaded', () => {
  const imageObserver = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        const src = img.dataset.src;
        
        if (src) {
          img.src = src;
          img.onload = () => {
            img.classList.add('loaded');
          };
          observer.unobserve(img);
        }
      }
    });
  }, {
    rootMargin: '200px 0px', // Start loading 200px before the image enters viewport
    threshold: 0.01
  });
  
  // Select all images with data-src attribute
  const lazyImages = document.querySelectorAll('img[data-src]');
  lazyImages.forEach(img => imageObserver.observe(img));
});
```

2. **Infinite Scrolling:**

```javascript
function createInfiniteScroll() {
  let page = 1;
  let loading = false;
  const contentContainer = document.getElementById('content');
  const loadingIndicator = document.getElementById('loading');
  
  const loadMoreContent = async () => {
    if (loading) return;
    
    loading = true;
    loadingIndicator.style.display = 'block';
    
    try {
      const response = await fetch(`/api/content?page=${page}`);
      const data = await response.json();
      
      if (data.items.length === 0) {
        // No more content to load
        observer.unobserve(loadingIndicator);
        loadingIndicator.textContent = 'No more content';
        return;
      }
      
      // Append new content
      data.items.forEach(item => {
        const element = document.createElement('div');
        element.classList.add('content-item');
        element.textContent = item.title;
        contentContainer.appendChild(element);
      });
      
      page++;
    } catch (error) {
      console.error('Error loading content:', error);
    } finally {
      loading = false;
      loadingIndicator.style.display = 'none';
    }
  };
  
  const observer = new IntersectionObserver((entries) => {
    if (entries[0].isIntersecting) {
      loadMoreContent();
    }
  }, {
    rootMargin: '100px 0px'
  });
  
  observer.observe(loadingIndicator);
  
  return {
    destroy: () => observer.disconnect()
  };
}

// Initialize infinite scroll
const infiniteScroll = createInfiniteScroll();

// Clean up when needed
// infiniteScroll.destroy();
```

3. **Animation Triggers:**

```javascript
function setupAnimationObserver() {
  const animationObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('animate');
        
        // Optional: run the animation only once
        if (entry.target.dataset.animateOnce === 'true') {
          animationObserver.unobserve(entry.target);
        }
      } else if (!entry.target.dataset.animateOnce) {
        // Remove animation class when element leaves viewport
        // unless it's set to animate only once
        entry.target.classList.remove('animate');
      }
    });
  }, {
    threshold: 0.2 // Element must be 20% visible before animating
  });
  
  const animatedElements = document.querySelectorAll('.animate-on-scroll');
  animatedElements.forEach(el => animationObserver.observe(el));
  
  return animationObserver;
}
```

4. **Viewport Analytics:**

```javascript
function trackElementVisibility() {
  const analyticsObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      const elementId = entry.target.id;
      
      if (entry.isIntersecting) {
        // Element entered viewport
        const visibleTime = Date.now();
        entry.target.dataset.visibleSince = visibleTime;
        
        console.log(`Element ${elementId} became visible at ${new Date(visibleTime).toISOString()}`);
        // Send analytics event: element visible
        sendAnalyticsEvent('element_visible', { elementId });
      } else if (entry.target.dataset.visibleSince) {
        // Element left viewport
        const visibleSince = parseInt(entry.target.dataset.visibleSince);
        const visibleDuration = Date.now() - visibleSince;
        
        console.log(`Element ${elementId} was visible for ${visibleDuration}ms`);
        // Send analytics event: element hidden with duration
        sendAnalyticsEvent('element_hidden', { elementId, visibleDuration });
        
        delete entry.target.dataset.visibleSince;
      }
    });
  }, {
    threshold: [0, 0.5, 1.0] // Track at different visibility thresholds
  });
  
  const trackedElements = document.querySelectorAll('[data-track-visibility]');
  trackedElements.forEach(el => analyticsObserver.observe(el));
  
  function sendAnalyticsEvent(eventName, data) {
    // Implementation would depend on your analytics provider
    console.log('Analytics event:', eventName, data);
    // Example: gtag('event', eventName, data);
  }
  
  return analyticsObserver;
}
```

5. **Performance Optimization with Disconnection:**

```javascript
class ViewportManager {
  constructor() {
    this.observers = new Map();
    this.visibleElements = new Set();
  }
  
  observe(elements, options = {}, callback) {
    const defaultOptions = {
      root: null,
      rootMargin: '0px',
      threshold: 0.1,
      once: false
    };
    
    const mergedOptions = { ...defaultOptions, ...options };
    const { once, ...observerOptions } = mergedOptions;
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const element = entry.target;
        
        if (entry.isIntersecting) {
          this.visibleElements.add(element);
          callback(element, true);
          
          if (once) {
            observer.unobserve(element);
          }
        } else if (this.visibleElements.has(element)) {
          this.visibleElements.delete(element);
          callback(element, false);
        }
      });
    }, observerOptions);
    
    // Store observer reference for cleanup
    const id = Symbol('observer');
    this.observers.set(id, { observer, elements: new Set(elements) });
    
    // Start observing elements
    elements.forEach(element => observer.observe(element));
    
    // Return id for later reference
    return id;
  }
  
  unobserve(id) {
    if (!this.observers.has(id)) return false;
    
    const { observer, elements } = this.observers.get(id);
    elements.forEach(element => {
      observer.unobserve(element);
      this.visibleElements.delete(element);
    });
    
    this.observers.delete(id);
    return true;
  }
  
  disconnect() {
    this.observers.forEach(({ observer }) => observer.disconnect());
    this.observers.clear();
    this.visibleElements.clear();
  }
}

// Usage
const viewportManager = new ViewportManager();

const lazyLoadId = viewportManager.observe(
  document.querySelectorAll('.lazy-image'),
  { rootMargin: '200px', once: true },
  (element, isVisible) => {
    if (isVisible && element.dataset.src) {
      element.src = element.dataset.src;
    }
  }
);

// Later, when no longer needed
// viewportManager.unobserve(lazyLoadId);

// When page changes or component unmounts
// viewportManager.disconnect();
```

**Browser Compatibility and Polyfills:**

The Intersection Observer API is supported in all modern browsers, but for older browsers like IE, you may need a polyfill:

```javascript
// Check if IntersectionObserver is supported
if (!('IntersectionObserver' in window)) {
  // Load polyfill
  const script = document.createElement('script');
  script.src = 'https://polyfill.io/v3/polyfill.min.js?features=IntersectionObserver';
  document.head.appendChild(script);
}
```

**Performance Benefits:**

1. **Reduced DOM Operations**: Only process elements when they become visible
2. **Efficient Event Handling**: No need for scroll event listeners which can cause performance issues
3. **Optimized Resource Loading**: Load resources only when needed
4. **Smoother User Experience**: Prevent layout thrashing and jank
5. **Battery Efficiency**: Especially important for mobile devices

**Best Practices:**

1. Always unobserve elements when you're done with them to prevent memory leaks
2. Use appropriate thresholds based on your use case
3. Consider using rootMargin to load content before it's visible for smoother experience
4. Implement error handling for resources that fail to load
5. Use a polyfill for older browsers if needed
6. Combine with other performance techniques like debouncing and throttling for optimal results

### Q36: Explain Web Workers in JavaScript and how they can improve application performance.
**Difficulty: Hard**

**Answer:**
Web Workers provide a way to run JavaScript code in background threads, separate from the main execution thread of a web application. This enables true multi-threading in JavaScript, allowing CPU-intensive tasks to run without blocking the user interface.

**Basic Concepts:**

1. **Types of Web Workers:**
   - **Dedicated Workers**: Used by a single script
   - **Shared Workers**: Can be shared between multiple scripts or windows
   - **Service Workers**: Act as proxy servers that sit between web applications, the browser, and the network

2. **Limitations:**
   - No direct access to the DOM, window, or parent objects
   - Limited access to browser APIs
   - Communication only through messaging
   - Cannot use certain methods like `alert()` or `confirm()`

**Creating and Using a Dedicated Worker:**

```javascript
// main.js - Main thread code
function startWorker() {
  // Create a new worker
  const worker = new Worker('worker.js');
  
  // Send data to the worker
  worker.postMessage({
    command: 'calculate',
    data: { numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] }
  });
  
  // Listen for messages from the worker
  worker.onmessage = function(event) {
    console.log('Result received from worker:', event.data);
    document.getElementById('result').textContent = event.data.result;
  };
  
  // Handle errors
  worker.onerror = function(error) {
    console.error('Worker error:', error.message);
  };
  
  return worker;
}

// Terminate worker when done
function stopWorker(worker) {
  worker.terminate();
  console.log('Worker terminated');
}

// Usage
const myWorker = startWorker();
// Later when done
// stopWorker(myWorker);
```

```javascript
// worker.js - Worker thread code
self.onmessage = function(event) {
  const { command, data } = event.data;
  
  if (command === 'calculate') {
    // CPU-intensive task
    const result = performComplexCalculation(data.numbers);
    
    // Send the result back to the main thread
    self.postMessage({
      result: result
    });
  }
};

function performComplexCalculation(numbers) {
  // Simulate a CPU-intensive task
  let result = 0;
  
  // Fibonacci calculation as an example of CPU-intensive work
  for (const num of numbers) {
    result += fibonacci(num);
  }
  
  return result;
}

function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

**Transferable Objects for Better Performance:**

When passing large data between the main thread and workers, you can use transferable objects to avoid the cost of copying:

```javascript
// In main thread
const hugeArray = new Uint8Array(100 * 1024 * 1024); // 100MB array
fillWithData(hugeArray); // Fill with some data

// Transfer ownership to worker (much faster than copying)
worker.postMessage({ data: hugeArray }, [hugeArray.buffer]);

// hugeArray is now neutered/emptied in the main thread
console.log(hugeArray.length); // 0
```

**Shared Workers:**

Shared Workers allow multiple scripts to share the same worker instance:

```javascript
// In multiple scripts/windows
const sharedWorker = new SharedWorker('shared-worker.js');

// Communication happens through a port object
sharedWorker.port.start();
sharedWorker.port.postMessage('Hello from script A');

sharedWorker.port.onmessage = function(event) {
  console.log('Message received from shared worker:', event.data);
};
```

```javascript
// shared-worker.js
const connections = new Set();

// Handle connections from different scripts
self.onconnect = function(event) {
  const port = event.ports[0];
  connections.add(port);
  
  port.start();
  
  port.onmessage = function(event) {
    console.log('Shared worker received:', event.data);
    
    // Broadcast to all connected ports
    for (const connection of connections) {
      connection.postMessage('Broadcasting: ' + event.data);
    }
  };
  
  port.postMessage('Connected to shared worker');
};
```

**Worker Pools for Task Management:**

For managing multiple workers efficiently:

```javascript
class WorkerPool {
  constructor(workerScript, numWorkers = navigator.hardwareConcurrency || 4) {
    this.workerScript = workerScript;
    this.workers = [];
    this.taskQueue = [];
    this.activeWorkers = 0;
    
    // Create worker pool
    for (let i = 0; i < numWorkers; i++) {
      const worker = new Worker(workerScript);
      
      worker.onmessage = (event) => {
        // Get the callback for this task
        const callback = worker.currentCallback;
        delete worker.currentCallback;
        
        // Mark worker as free
        worker.busy = false;
        this.activeWorkers--;
        
        // Execute callback with result
        if (callback) {
          callback(null, event.data);
        }
        
        // Process next task if any
        this.processQueue();
      };
      
      worker.onerror = (error) => {
        const callback = worker.currentCallback;
        delete worker.currentCallback;
        
        worker.busy = false;
        this.activeWorkers--;
        
        if (callback) {
          callback(error, null);
        }
        
        this.processQueue();
      };
      
      worker.busy = false;
      this.workers.push(worker);
    }
  }
  
  processQueue() {
    // If no tasks or all workers busy, return
    if (this.taskQueue.length === 0) return;
    
    // Find a free worker
    const freeWorker = this.workers.find(worker => !worker.busy);
    if (!freeWorker) return;
    
    // Get next task
    const task = this.taskQueue.shift();
    const { data, callback, transferables } = task;
    
    // Assign task to worker
    freeWorker.busy = true;
    freeWorker.currentCallback = callback;
    this.activeWorkers++;
    
    // Execute task
    if (transferables) {
      freeWorker.postMessage(data, transferables);
    } else {
      freeWorker.postMessage(data);
    }
  }
  
  addTask(data, callback, transferables = null) {
    this.taskQueue.push({ data, callback, transferables });
    this.processQueue();
    
    return this.taskQueue.length + this.activeWorkers;
  }
  
  terminate() {
    this.workers.forEach(worker => worker.terminate());
    this.workers = [];
    this.taskQueue = [];
    this.activeWorkers = 0;
  }
}

// Usage
const pool = new WorkerPool('calculation-worker.js', 4);

pool.addTask({ type: 'fibonacci', n: 40 }, (error, result) => {
  if (error) {
    console.error('Task failed:', error);
  } else {
    console.log('Task completed with result:', result);
  }
});

// Add more tasks as needed
for (let i = 0; i < 10; i++) {
  pool.addTask({ type: 'complex-math', value: i * 1000 }, (err, result) => {
    console.log(`Task ${i} result:`, result);
  });
}

// When completely done
// pool.terminate();
```

**Web Worker Use Cases:**

1. **Data Processing and Analysis:**
   - Parsing large JSON/XML files
   - Processing images or video frames
   - Analyzing datasets for visualization

2. **Computation-Heavy Tasks:**
   - Complex mathematical calculations
   - Cryptography and encryption
   - Physics simulations

3. **Background Synchronization:**
   - Syncing local data with servers
   - Periodic data fetching and processing

4. **Real-time Data Processing:**
   - Processing WebSocket streams
   - Handling high-frequency updates

**Advanced Patterns:**

1. **Comlink Library for Easier Communication:**

```javascript
// Using Comlink to simplify worker communication
import * as Comlink from 'comlink';

// In worker.js
const api = {
  calculateFibonacci(n) {
    // Complex calculation
    return fibonacci(n);
  },
  
  processData(data) {
    // Process data
    return transformedData;
  }
};

Comlink.expose(api);

// In main.js
async function init() {
  const worker = new Worker('worker.js');
  const api = Comlink.wrap(worker);
  
  // Use worker functions as if they were local
  const result = await api.calculateFibonacci(40);
  console.log('Fibonacci result:', result);
}
```

2. **Workbox for Service Worker Management:**

```javascript
// Using Workbox for service worker management
importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.1.5/workbox-sw.js');

workbox.routing.registerRoute(
  ({request}) => request.destination === 'image',
  new workbox.strategies.CacheFirst({
    cacheName: 'images',
    plugins: [
      new workbox.expiration.ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);
```

**Performance Considerations:**

1. **When to Use Web Workers:**
   - Tasks taking more than 100ms
   - CPU-intensive operations
   - Tasks that would otherwise freeze the UI

2. **When NOT to Use Web Workers:**
   - Simple, quick calculations
   - DOM manipulation (must be done on main thread)
   - Tasks requiring frequent small data exchanges

3. **Measuring Performance Gains:**

```javascript
function measurePerformance(withWorker = false) {
  const startTime = performance.now();
  
  if (withWorker) {
    const worker = new Worker('heavy-task.js');
    
    return new Promise((resolve) => {
      worker.onmessage = function(event) {
        const endTime = performance.now();
        worker.terminate();
        resolve({
          result: event.data,
          time: endTime - startTime,
          uiBlocked: false
        });
      };
      
      worker.postMessage({ command: 'start' });
    });
  } else {
    // Run on main thread
    const result = performHeavyTask();
    const endTime = performance.now();
    
    return Promise.resolve({
      result,
      time: endTime - startTime,
      uiBlocked: true
    });
  }
}

// Compare performance
async function comparePerformance() {
  console.log('Running on main thread...');
  const mainThreadResult = await measurePerformance(false);
  
  console.log('Running in worker...');
  const workerResult = await measurePerformance(true);
  
  console.log(`Main thread: ${mainThreadResult.time.toFixed(2)}ms (UI Blocked)`); 
  console.log(`Worker: ${workerResult.time.toFixed(2)}ms (UI Responsive)`);
  console.log(`Performance difference: ${(mainThreadResult.time / workerResult.time).toFixed(2)}x`);
}
```

**Browser Compatibility and Fallbacks:**

```javascript
function createWorkerFallback(workerScript) {
  if (typeof Worker !== 'undefined') {
    // Browsers that support Web Workers
    return new Worker(workerScript);
  } else {
    // Fallback for browsers without Web Worker support
    return {
      postMessage: function(data) {
        setTimeout(() => {
          // Execute the worker code in the main thread
          // This is a simplified fallback
          const result = performTaskSynchronously(data);
          if (this.onmessage) {
            this.onmessage({ data: result });
          }
        }, 0);
      },
      terminate: function() {
        // Nothing to terminate in the fallback
      }
    };
  }
}

// Usage with fallback
const worker = createWorkerFallback('worker.js');
worker.postMessage({ data: [1, 2, 3, 4, 5] });
```

**Best Practices:**

1. **Optimize Communication:**
   - Batch messages to reduce overhead
   - Use transferable objects for large data
   - Keep message frequency reasonable

2. **Error Handling:**
   - Always implement error handlers
   - Gracefully recover from worker failures
   - Consider restarting crashed workers

3. **Resource Management:**
   - Terminate workers when no longer needed
   - Limit the number of concurrent workers
   - Consider device capabilities when creating workers

4. **Testing and Debugging:**
   - Use `console.log()` inside workers for debugging
   - Chrome DevTools has dedicated Workers panel
   - Test on various devices with different CPU capabilities

5. **Security Considerations:**
   - Workers follow same-origin policy
   - Be cautious with data passed to workers
   - Validate all messages between threads

### Q37: Explain the Fetch API and how it compares to XMLHttpRequest.
**Difficulty: Medium**

**Answer:**
The Fetch API provides a modern, promise-based interface for making HTTP requests in JavaScript. It offers a more powerful and flexible feature set compared to the older XMLHttpRequest (XHR) object.

**Basic Usage:**

```javascript
// Simple GET request
fetch('https://api.example.com/data')
  .then(response => {
    // Check if the request was successful
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json(); // Parse JSON response
  })
  .then(data => {
    console.log('Data received:', data);
  })
  .catch(error => {
    console.error('Fetch error:', error);
  });
```

**Advanced Configuration:**

```javascript
// POST request with various options
fetch('https://api.example.com/submit', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token123'
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  }),
  credentials: 'include', // Include cookies
  mode: 'cors', // Cross-origin resource sharing mode
  cache: 'no-cache', // Cache control
  redirect: 'follow', // Handle redirects
  referrerPolicy: 'no-referrer', // Control the Referer header
  signal: abortController.signal // For request cancellation
})
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.error('Error:', error));
```

**Working with Response Objects:**

```javascript
fetch('https://api.example.com/data')
  .then(response => {
    // Response properties
    console.log('Status:', response.status); // HTTP status code
    console.log('OK?', response.ok); // true if status is 200-299
    console.log('Status text:', response.statusText);
    console.log('Headers:', response.headers);
    console.log('URL:', response.url);
    console.log('Type:', response.type); // basic, cors, etc.
    
    // Response methods (each returns a Promise)
    // Choose ONE of these methods to read the body
    return response.json(); // Parse as JSON
    // return response.text(); // Read as text
    // return response.blob(); // Read as binary data
    // return response.formData(); // Parse as FormData
    // return response.arrayBuffer(); // Read as ArrayBuffer
  })
  .then(data => {
    // Process the data
  });
```

**Handling Different Response Types:**

```javascript
// Function to handle different response types
async function fetchData(url, responseType = 'json') {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    switch (responseType) {
      case 'json':
        return await response.json();
      case 'text':
        return await response.text();
      case 'blob':
        return await response.blob();
      case 'formData':
        return await response.formData();
      case 'arrayBuffer':
        return await response.arrayBuffer();
      default:
        return await response.json();
    }
  } catch (error) {
    console.error('Fetch error:', error);
    throw error;
  }
}

// Usage
async function loadImage() {
  try {
    const imageBlob = await fetchData('https://example.com/image.jpg', 'blob');
    const imageUrl = URL.createObjectURL(imageBlob);
    const imgElement = document.createElement('img');
    imgElement.src = imageUrl;
    document.body.appendChild(imgElement);
  } catch (error) {
    console.error('Failed to load image:', error);
  }
}
```

**Request Cancellation with AbortController:**

```javascript
function fetchWithTimeout(url, options = {}, timeoutMs = 5000) {
  const controller = new AbortController();
  const { signal } = controller;
  
  // Set up timeout
  const timeout = setTimeout(() => {
    controller.abort();
  }, timeoutMs);
  
  return fetch(url, { ...options, signal })
    .then(response => {
      clearTimeout(timeout);
      return response;
    })
    .catch(error => {
      clearTimeout(timeout);
      if (error.name === 'AbortError') {
        throw new Error(`Request timed out after ${timeoutMs}ms`);
      }
      throw error;
    });
}

// Usage
fetchWithTimeout('https://api.example.com/data', {}, 3000)
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

**Streaming Responses:**

```javascript
async function streamResponse() {
  try {
    const response = await fetch('https://api.example.com/large-data');
    
    // Get a reader from the response body stream
    const reader = response.body.getReader();
    
    // Read the stream
    while (true) {
      const { done, value } = await reader.read();
      
      if (done) {
        console.log('Stream complete');
        break;
      }
      
      // value is a Uint8Array
      console.log('Received chunk of data:', value.length);
      processChunk(value);
    }
  } catch (error) {
    console.error('Stream error:', error);
  }
}

function processChunk(chunk) {
  // Process each chunk of data as it arrives
  // For example, update a progress bar or display partial results
}
```

**Uploading Files:**

```javascript
async function uploadFile(file) {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('fileName', file.name);
  
  try {
    const response = await fetch('https://api.example.com/upload', {
      method: 'POST',
      body: formData
    });
    
    if (!response.ok) {
      throw new Error(`Upload failed with status: ${response.status}`);
    }
    
    const result = await response.json();
    return result;
  } catch (error) {
    console.error('Upload error:', error);
    throw error;
  }
}

// Usage with file input
document.getElementById('fileInput').addEventListener('change', async (event) => {
  const file = event.target.files[0];
  if (file) {
    try {
      const result = await uploadFile(file);
      console.log('Upload successful:', result);
    } catch (error) {
      console.error('Upload failed:', error);
    }
  }
});
```

**Comparison with XMLHttpRequest:**

| Feature | Fetch API | XMLHttpRequest |
|---------|-----------|----------------|
| **API Design** | Promise-based, modern | Callback-based, older |
| **Syntax** | Clean, concise | More verbose |
| **Error Handling** | Promise catch blocks | onerror callbacks |
| **Streaming** | Supports streaming | Limited support |
| **Progress Events** | Limited built-in support | Built-in progress events |
| **Request Cancellation** | Via AbortController | Via xhr.abort() |
| **CORS** | More seamless handling | Requires more configuration |
| **Timeout Control** | Manual implementation | Built-in xhr.timeout |
| **Synchronous Requests** | Not supported | Supported (but discouraged) |
| **Browser Support** | Modern browsers | All browsers including legacy |

**XMLHttpRequest Example (for comparison):**

```javascript
// Equivalent XMLHttpRequest code
function makeRequest(url, method = 'GET', data = null) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    
    xhr.open(method, url);
    
    xhr.setRequestHeader('Content-Type', 'application/json');
    
    xhr.onload = function() {
      if (xhr.status >= 200 && xhr.status < 300) {
        resolve(JSON.parse(xhr.response));
      } else {
        reject(new Error(`HTTP error! Status: ${xhr.status}`));
      }
    };
    
    xhr.onerror = function() {
      reject(new Error('Network error'));
    };
    
    xhr.ontimeout = function() {
      reject(new Error('Request timed out'));
    };
    
    xhr.timeout = 5000; // 5 seconds
    
    // Progress tracking (not available in Fetch)
    xhr.upload.onprogress = function(event) {
      if (event.lengthComputable) {
        const percentComplete = (event.loaded / event.total) * 100;
        console.log(`Upload progress: ${percentComplete.toFixed(2)}%`);
      }
    };
    
    if (data) {
      xhr.send(JSON.stringify(data));
    } else {
      xhr.send();
    }
  });
}

// Usage
makeRequest('https://api.example.com/data')
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

**When to Use Fetch vs. XMLHttpRequest:**

**Use Fetch when:**
- Building modern applications
- Working with promises and async/await
- Need for a cleaner API with less code
- Streaming responses is important
- Working with service workers

**Use XMLHttpRequest when:**
- Need to support older browsers without polyfills
- Detailed progress monitoring is required
- Need for synchronous requests (though rarely recommended)
- Working with existing code that uses XHR

**Best Practices with Fetch API:**

1. **Always check response.ok:**
```javascript
fetch('/api/data')
  .then(response => {
    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
    return response.json();
  })
  .then(data => console.log(data));
```

2. **Handle network errors properly:**
```javascript
fetch('/api/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => {
    console.error('Fetch error:', error);
    // Show user-friendly error message
    displayErrorMessage('Failed to load data. Please try again later.');
  });
```

3. **Set appropriate request timeouts:**
```javascript
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 5000);

fetch('/api/data', { signal: controller.signal })
  .then(response => {
    clearTimeout(timeoutId);
    return response.json();
  })
  .catch(error => {
    clearTimeout(timeoutId);
    if (error.name === 'AbortError') {
      console.log('Request timed out');
    } else {
      console.error('Fetch error:', error);
    }
  });
```

4. **Create reusable fetch utilities:**
```javascript
const api = {
  async request(url, options = {}) {
    const defaultOptions = {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${getAuthToken()}`
      },
      credentials: 'include'
    };
    
    const mergedOptions = { ...defaultOptions, ...options };
    
    if (options.body && typeof options.body === 'object') {
      mergedOptions.body = JSON.stringify(options.body);
    }
    
    const response = await fetch(url, mergedOptions);
    
    if (!response.ok) {
      const error = new Error(`HTTP error! Status: ${response.status}`);
      error.response = response;
      throw error;
    }
    
    return response.json();
  },
  
  get(url, options = {}) {
    return this.request(url, { ...options, method: 'GET' });
  },
  
  post(url, data, options = {}) {
    return this.request(url, { ...options, method: 'POST', body: data });
  },
  
  put(url, data, options = {}) {
    return this.request(url, { ...options, method: 'PUT', body: data });
  },
  
  delete(url, options = {}) {
    return this.request(url, { ...options, method: 'DELETE' });
  }
};

// Usage
async function getUserData(userId) {
  try {
    return await api.get(`/api/users/${userId}`);
  } catch (error) {
    console.error('Failed to fetch user data:', error);
    throw error;
  }
}
```

### Q38: Explain Service Workers and how they enable Progressive Web Applications (PWAs).
**Difficulty: Hard**

**Answer:**
Service Workers are a type of web worker that act as a programmable network proxy, allowing you to control how network requests from your page are handled. They run in a separate thread from the main JavaScript execution, enabling powerful features like offline functionality, background sync, push notifications, and resource caching—all essential components of Progressive Web Applications (PWAs).

**Service Worker Lifecycle:**

1. **Registration:**
```javascript
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/service-worker.js')
      .then(registration => {
        console.log('Service Worker registered with scope:', registration.scope);
      })
      .catch(error => {
        console.error('Service Worker registration failed:', error);
      });
  });
}
```

2. **Installation:**
```javascript
// Inside service-worker.js
const CACHE_NAME = 'my-site-cache-v1';
const urlsToCache = [
  '/',
  '/styles/main.css',
  '/scripts/main.js',
  '/images/logo.png'
];

self.addEventListener('install', event => {
  // Perform install steps
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        console.log('Opened cache');
        return cache.addAll(urlsToCache);
      })
  );
  
  // Optional: Force activation without waiting for existing instances to be closed
  // self.skipWaiting();
});
```

3. **Activation:**
```javascript
self.addEventListener('activate', event => {
  const cacheWhitelist = ['my-site-cache-v1'];
  
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheWhitelist.indexOf(cacheName) === -1) {
            // Delete old caches that are not in the whitelist
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
  
  // Optional: Claim clients so the service worker takes control immediately
  // self.clients.claim();
});
```

4. **Fetch Handling:**
```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // Cache hit - return response from cache
        if (response) {
          return response;
        }
        
        // Clone the request because it's a one-time use stream
        const fetchRequest = event.request.clone();
        
        return fetch(fetchRequest).then(response => {
          // Check if we received a valid response
          if (!response || response.status !== 200 || response.type !== 'basic') {
            return response;
          }
          
          // Clone the response because it's a one-time use stream
          const responseToCache = response.clone();
          
          caches.open(CACHE_NAME)
            .then(cache => {
              cache.put(event.request, responseToCache);
            });
            
          return response;
        });
      })
  );
});
```

**Caching Strategies:**

1. **Cache First (Offline First):**
```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        return response || fetch(event.request);
      })
  );
});
```

2. **Network First (Stale While Revalidate):**
```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    fetch(event.request)
      .then(response => {
        // Clone the response to store in cache
        const responseToCache = response.clone();
        
        caches.open(CACHE_NAME)
          .then(cache => {
            cache.put(event.request, responseToCache);
          });
          
        return response;
      })
      .catch(() => {
        return caches.match(event.request);
      })
  );
});
```

3. **Stale While Revalidate:**
```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.open(CACHE_NAME).then(cache => {
      return cache.match(event.request).then(response => {
        const fetchPromise = fetch(event.request).then(networkResponse => {
          cache.put(event.request, networkResponse.clone());
          return networkResponse;
        });
        
        // Return the cached response if available, otherwise wait for the network response
        return response || fetchPromise;
      });
    })
  );
});
```

4. **Cache with Network Fallback (with timeout):**
```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    Promise.race([
      // Try network and set a timeout
      new Promise((resolve, reject) => {
        setTimeout(() => reject(new Error('timeout')), 3000);
        fetch(event.request).then(resolve, reject);
      }),
      // Try cache
      caches.match(event.request)
    ])
    .catch(() => {
      // If both fail, show offline page
      return caches.match('/offline.html');
    })
  );
});
```

**Background Sync:**

```javascript
// In your web app
document.querySelector('#submit-form').addEventListener('submit', event => {
  event.preventDefault();
  const data = new FormData(event.target);
  
  if (navigator.serviceWorker && 'SyncManager' in window) {
    navigator.serviceWorker.ready
      .then(registration => {
        // Store the form data in IndexedDB
        return saveFormDataToIndexedDB(data)
          .then(() => {
            // Register a sync event
            return registration.sync.register('submit-form');
          });
      })
      .then(() => {
        console.log('Form queued for background sync');
        showSuccessMessage('Your form will be submitted when you go online');
      })
      .catch(error => {
        console.error('Background sync registration failed:', error);
        // Fall back to regular form submission
        submitFormImmediately(data);
      });
  } else {
    // No service worker or sync support, submit immediately
    submitFormImmediately(data);
  }
});

// In your service worker
self.addEventListener('sync', event => {
  if (event.tag === 'submit-form') {
    event.waitUntil(
      getFormDataFromIndexedDB()
        .then(dataArray => {
          return Promise.all(
            dataArray.map(data => {
              return fetch('/api/submit', {
                method: 'POST',
                body: JSON.stringify(data),
                headers: {
                  'Content-Type': 'application/json'
                }
              })
              .then(response => {
                if (response.ok) {
                  // Remove from IndexedDB if successful
                  return removeFormDataFromIndexedDB(data.id);
                }
                throw new Error('Network response was not ok');
              });
            })
          );
        })
    );
  }
});
```

**Push Notifications:**

```javascript
// In your web app
function subscribeToPushNotifications() {
  navigator.serviceWorker.ready
    .then(registration => {
      // Check if subscription already exists
      return registration.pushManager.getSubscription()
        .then(subscription => {
          if (subscription) {
            return subscription;
          }
          
          // Get the server's public key
          return fetch('/api/vapid-public-key')
            .then(response => response.json())
            .then(data => {
              const vapidPublicKey = urlBase64ToUint8Array(data.publicKey);
              
              // Subscribe the user
              return registration.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: vapidPublicKey
              });
            });
        });
    })
    .then(subscription => {
      // Send the subscription to your server
      return fetch('/api/save-subscription', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(subscription)
      });
    })
    .then(response => {
      if (response.ok) {
        console.log('Push notification subscription saved');
      }
    })
    .catch(error => {
      console.error('Error subscribing to push notifications:', error);
    });
}

// Helper function to convert base64 to Uint8Array
function urlBase64ToUint8Array(base64String) {
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding)
    .replace(/-/g, '+')
    .replace(/_/g, '/');
  
  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  
  return outputArray;
}

// In your service worker
self.addEventListener('push', event => {
  let notificationData = {};
  
  try {
    notificationData = event.data.json();
  } catch (e) {
    notificationData = {
      title: 'New Notification',
      body: event.data ? event.data.text() : 'No payload',
      icon: '/images/icon.png'
    };
  }
  
  event.waitUntil(
    self.registration.showNotification(notificationData.title, {
      body: notificationData.body,
      icon: notificationData.icon,
      badge: '/images/badge.png',
      data: notificationData.data || {},
      actions: notificationData.actions || []
    })
  );
});

self.addEventListener('notificationclick', event => {
  event.notification.close();
  
  const urlToOpen = event.notification.data.url || '/';
  
  event.waitUntil(
    clients.matchAll({ type: 'window' })
      .then(clientList => {
        // Check if a window is already open
        for (const client of clientList) {
          if (client.url === urlToOpen && 'focus' in client) {
            return client.focus();
          }
        }
        
        // If no window is open, open a new one
        if (clients.openWindow) {
          return clients.openWindow(urlToOpen);
        }
      })
  );
});
```

**Service Worker Precaching with Workbox:**

Workbox is a set of libraries that simplifies service worker implementation:

```javascript
// service-worker.js using Workbox
importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js');

workbox.setConfig({ debug: false });

// Cache page navigations
workbox.routing.registerRoute(
  ({ request }) => request.mode === 'navigate',
  new workbox.strategies.NetworkFirst({
    cacheName: 'pages-cache',
    plugins: [
      new workbox.expiration.ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 30 * 24 * 60 * 60 // 30 days
      })
    ]
  })
);

// Cache CSS, JS, and Web Worker requests with a Stale While Revalidate strategy
workbox.routing.registerRoute(
  ({ request }) =>
    request.destination === 'style' ||
    request.destination === 'script' ||
    request.destination === 'worker',
  new workbox.strategies.StaleWhileRevalidate({
    cacheName: 'assets-cache',
    plugins: [
      new workbox.expiration.ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60 // 30 days
      })
    ]
  })
);

// Cache images with a Cache First strategy
workbox.routing.registerRoute(
  ({ request }) => request.destination === 'image',
  new workbox.strategies.CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new workbox.expiration.ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60 // 30 days
      })
    ]
  })
);

// Cache the Google Fonts stylesheets with a Stale While Revalidate strategy
workbox.routing.registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new workbox.strategies.StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets'
  })
);

// Cache the Google Fonts webfont files with a Cache First strategy for 1 year
workbox.routing.registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new workbox.strategies.CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new workbox.cacheableResponse.CacheableResponsePlugin({
        statuses: [0, 200]
      }),
      new workbox.expiration.ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
        maxEntries: 30
      })
    ]
  })
);

// Background sync for form submissions
workbox.routing.registerRoute(
  ({ url }) => url.pathname === '/api/submit',
  new workbox.strategies.NetworkOnly({
    plugins: [
      new workbox.backgroundSync.BackgroundSyncPlugin('formQueue', {
        maxRetentionTime: 24 * 60 // Retry for max of 24 Hours (specified in minutes)
      })
    ]
  }),
  'POST'
);

// Precache static assets
workbox.precaching.precacheAndRoute([
  { url: '/', revision: '1' },
  { url: '/index.html', revision: '1' },
  { url: '/styles/main.css', revision: '1' },
  { url: '/scripts/main.js', revision: '1' },
  { url: '/images/logo.png', revision: '1' },
  { url: '/offline.html', revision: '1' }
]);
```

**Progressive Web App Features Enabled by Service Workers:**

1. **Offline Functionality:**
   - Caching critical assets during installation
   - Serving cached content when offline
   - Providing custom offline pages

2. **Improved Performance:**
   - Serving cached resources instantly
   - Implementing various caching strategies based on resource type
   - Precaching important resources

3. **Background Processing:**
   - Performing tasks in the background
   - Syncing data when connectivity is restored
   - Processing large data sets without blocking the main thread

4. **Push Notifications:**
   - Receiving push messages from a server
   - Displaying notifications to users
   - Handling notification clicks

5. **App-like Experience:**
   - Fast loading times from cache
   - Reliable performance regardless of network conditions
   - Smooth transitions between pages

**Web App Manifest for PWAs:**

A Web App Manifest is a JSON file that provides information about a web application, allowing it to be installed on a user's device:

```json
{
  "name": "My Progressive Web App",
  "short_name": "MyPWA",
  "description": "A fully featured Progressive Web Application",
  "start_url": "/index.html",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#2196f3",
  "orientation": "portrait-primary",
  "icons": [
    {
      "src": "/images/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/images/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/images/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/images/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/images/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/images/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/images/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/images/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ],
  "screenshots": [
    {
      "src": "/images/screenshots/screenshot1.png",
      "sizes": "1280x720",
      "type": "image/png"
    },
    {
      "src": "/images/screenshots/screenshot2.png",
      "sizes": "1280x720",
      "type": "image/png"
    }
  ],
  "related_applications": [
    {
      "platform": "play",
      "url": "https://play.google.com/store/apps/details?id=com.example.app",
      "id": "com.example.app"
    }
  ],
  "prefer_related_applications": false,
  "shortcuts": [
    {
      "name": "Start New Chat",
      "short_name": "New Chat",
      "description": "Start a new conversation",
      "url": "/chat/new",
      "icons": [{ "src": "/images/icons/chat.png", "sizes": "192x192" }]
    },
    {
      "name": "View Profile",
      "short_name": "Profile",
      "description": "View your user profile",
      "url": "/profile",
      "icons": [{ "src": "/images/icons/profile.png", "sizes": "192x192" }]
    }
  ],
  "categories": ["productivity", "utilities"],
  "lang": "en-US",
  "dir": "ltr"
}
```

**Best Practices for Service Workers:**

1. **Progressive Enhancement:**
   - Always check for service worker support before registering
   - Provide fallbacks for browsers that don't support service workers

2. **Versioning:**
   - Version your cache names
   - Implement a strategy to clean up old caches during activation

3. **Scope Management:**
   - Be mindful of the service worker scope (determined by its location)
   - Place the service worker file at the root to control the entire site

4. **Performance Considerations:**
   - Don't cache everything—be strategic
   - Use different caching strategies for different types of resources
   - Implement cache size and age limits

5. **Debugging:**
   - Use Chrome DevTools' Application tab for debugging
   - Implement logging in development mode
   - Use `skipWaiting()` and `clients.claim()` during development for faster updates

6. **Security:**
   - Always serve service workers over HTTPS
   - Validate data received in push notifications
   - Be careful with caching sensitive information

7. **Testing:**
   - Test offline functionality regularly
   - Test on various devices and browsers
   - Use Lighthouse to audit your PWA

**Limitations of Service Workers:**

1. **Browser Support:**
   - Not supported in all browsers (particularly older versions)
   - Features like Background Sync and Push have varying support

2. **Scope Restrictions:**
   - Service workers can only control pages within their scope
   - Cannot access DOM directly

3. **No Access to:**
   - `window` object
   - `document` object
   - Synchronous XHR
   - `localStorage`

4. **Lifecycle Complexity:**
   - Understanding the installation, activation, and update processes
   - Managing version transitions

5. **Debugging Challenges:**
   - Running in a separate thread makes debugging more complex
   - Cache-related issues can be difficult to diagnose

### Q39: Explain the History API and how it enables client-side routing in single-page applications.
**Difficulty: Medium**

**Answer:**
The History API provides methods to manipulate the browser's session history stack, allowing developers to change the URL displayed in the browser without triggering a full page reload. This capability is fundamental to modern single-page applications (SPAs), enabling client-side routing that creates a smoother, more app-like user experience.

**Core Methods of the History API:**

1. **history.pushState():**
```javascript
history.pushState(stateObj, title, url);
```
- Adds a new entry to the browser's history stack
- `stateObj`: JavaScript object associated with the new history entry
- `title`: Currently ignored by most browsers (use empty string or document title)
- `url`: The new URL to display in the address bar (must be same-origin)

2. **history.replaceState():**
```javascript
history.replaceState(stateObj, title, url);
```
- Similar to pushState, but replaces the current history entry instead of adding a new one
- Useful for updating the URL without creating a new history entry

3. **history.state:**
```javascript
const currentState = history.state;
```
- Returns the current state object

4. **Navigation Methods:**
```javascript
history.back();     // Equivalent to clicking the browser's back button
history.forward();  // Equivalent to clicking the browser's forward button
history.go(-2);     // Navigate back 2 pages
history.go(1);      // Navigate forward 1 page
```

**The popstate Event:**

```javascript
window.addEventListener('popstate', event => {
  // event.state contains the state object passed to pushState or replaceState
  console.log('Navigation occurred, new state:', event.state);
  
  // Handle the navigation (e.g., render the appropriate view)
  if (event.state && event.state.page) {
    renderPage(event.state.page);
  }
});
```

**Important:** The `popstate` event is only triggered when navigating through history (back/forward buttons) or using `history.back()`, `history.forward()`, or `history.go()`. It is **not** triggered by `pushState()` or `replaceState()`.

**Basic Client-Side Router Implementation:**

```javascript
class Router {
  constructor(routes) {
    this.routes = routes;
    
    // Handle initial route
    this.handleLocation();
    
    // Handle browser back/forward navigation
    window.addEventListener('popstate', this.handleLocation.bind(this));
    
    // Intercept link clicks for client-side routing
    document.addEventListener('click', e => {
      if (e.target.matches('a')) {
        const href = e.target.getAttribute('href');
        
        // Only handle internal links
        if (href.startsWith('/')) {
          e.preventDefault();
          this.navigate(href);
        }
      }
    });
  }
  
  handleLocation() {
    const path = window.location.pathname;
    const route = this.routes[path] || this.routes['404'];
    
    // Render the appropriate component/view
    const mainContent = document.getElementById('app');
    mainContent.innerHTML = '';
    mainContent.appendChild(route());
    
    // Update page title if needed
    document.title = route.title || 'My SPA';
  }
  
  navigate(path) {
    // Update the URL
    history.pushState({ path }, '', path);
    
    // Render the new route
    this.handleLocation();
  }
}

// Usage
const routes = {
  '/': () => {
    const element = document.createElement('div');
    element.innerHTML = '<h1>Home Page</h1><p>Welcome to our SPA!</p>';
    return element;
  },
  '/about': () => {
    const element = document.createElement('div');
    element.innerHTML = '<h1>About Us</h1><p>Learn about our company.</p>';
    return element;
  },
  '/contact': () => {
    const element = document.createElement('div');
    element.innerHTML = '<h1>Contact</h1><p>Get in touch with us.</p>';
    return element;
  },
  '404': () => {
    const element = document.createElement('div');
    element.innerHTML = '<h1>404</h1><p>Page not found.</p>';
    return element;
  }
};

// Initialize the router
const router = new Router(routes);

// Navigation buttons
document.getElementById('home-btn').addEventListener('click', () => router.navigate('/'));
document.getElementById('about-btn').addEventListener('click', () => router.navigate('/about'));
document.getElementById('contact-btn').addEventListener('click', () => router.navigate('/contact'));
```

**More Advanced Router with Parameters:**

```javascript
class AdvancedRouter {
  constructor() {
    this.routes = [];
    this.notFoundHandler = () => {
      const element = document.createElement('div');
      element.innerHTML = '<h1>404</h1><p>Page not found.</p>';
      return element;
    };
    
    // Handle initial route
    window.addEventListener('DOMContentLoaded', () => this.handleLocation());
    
    // Handle browser back/forward navigation
    window.addEventListener('popstate', () => this.handleLocation());
  }
  
  addRoute(path, handler) {
    // Convert path pattern to regex for parameter matching
    const paramNames = [];
    const pattern = path
      .replace(/\/\//g, '\/')
      .replace(/:(\w+)/g, (_, paramName) => {
        paramNames.push(paramName);
        return '([^\\/]+)';
      });
    
    const regex = new RegExp(`^${pattern}$`);
    
    this.routes.push({
      regex,
      paramNames,
      handler
    });
    
    return this;
  }
  
  setNotFound(handler) {
    this.notFoundHandler = handler;
    return this;
  }
  
  handleLocation() {
    const path = window.location.pathname;
    
    // Find matching route
    for (const route of this.routes) {
      const match = path.match(route.regex);
      
      if (match) {
        // Extract parameters
        const params = {};
        match.slice(1).forEach((value, i) => {
          params[route.paramNames[i]] = value;
        });
        
        // Get state from history API
        const state = history.state || {};
        
        // Render the route with parameters
        const mainContent = document.getElementById('app');
        mainContent.innerHTML = '';
        mainContent.appendChild(route.handler(params, state));
        return;
      }
    }
    
    // No route matched, show 404
    const mainContent = document.getElementById('app');
    mainContent.innerHTML = '';
    mainContent.appendChild(this.notFoundHandler());
  }
  
  navigate(path, state = {}) {
    history.pushState(state, '', path);
    this.handleLocation();
  }
  
  replace(path, state = {}) {
    history.replaceState(state, '', path);
    this.handleLocation();
  }
}

// Usage
const router = new AdvancedRouter();

router
  .addRoute('/', () => {
    const element = document.createElement('div');
    element.innerHTML = '<h1>Home</h1><p>Welcome to our SPA!</p>';
    return element;
  })
  .addRoute('/users/:id', (params, state) => {
    const element = document.createElement('div');
    element.innerHTML = `<h1>User Profile</h1><p>Viewing user ${params.id}</p>`;
    
    if (state.userData) {
      element.innerHTML += `<p>Name: ${state.userData.name}</p>`;
    }
    
    return element;
  })
  .addRoute('/products/:category/:id', (params) => {
    const element = document.createElement('div');
    element.innerHTML = `
      <h1>Product Details</h1>
      <p>Category: ${params.category}</p>
      <p>Product ID: ${params.id}</p>
    `;
    return element;
  })
  .setNotFound(() => {
    const element = document.createElement('div');
    element.innerHTML = '<h1>404</h1><p>Page not found.</p>';
    return element;
  });

// Navigate with parameters and state
document.getElementById('view-user').addEventListener('click', () => {
  router.navigate('/users/123', {
    userData: { name: 'John Doe', email: 'john@example.com' }
  });
});

document.getElementById('view-product').addEventListener('click', () => {
  router.navigate('/products/electronics/456');
});
```

**Integration with Popular Frontend Frameworks:**

1. **React Router (React):**
```jsx
import { BrowserRouter, Routes, Route, Link, useParams, useNavigate } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
        <Link to="/users/123">User Profile</Link>
      </nav>
      
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/users/:id" element={<UserProfile />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </BrowserRouter>
  );
}

function UserProfile() {
  const { id } = useParams();
  const navigate = useNavigate();
  
  return (
    <div>
      <h1>User Profile</h1>
      <p>User ID: {id}</p>
      <button onClick={() => navigate('/')}>Go Home</button>
    </div>
  );
}
```

2. **Vue Router (Vue.js):**
```javascript
import { createRouter, createWebHistory } from 'vue-router';

const routes = [
  { path: '/', component: Home },
  { path: '/about', component: About },
  { path: '/users/:id', component: UserProfile, props: true },
  { path: '/:pathMatch(.*)*', component: NotFound }
];

const router = createRouter({
  history: createWebHistory(),
  routes
});

// In UserProfile.vue component
export default {
  props: ['id'],
  methods: {
    goHome() {
      this.$router.push('/');
    }
  },
  template: `
    <div>
      <h1>User Profile</h1>
      <p>User ID: {{ id }}</p>
      <button @click="goHome">Go Home</button>
    </div>
  `
};
```

3. **Angular Router (Angular):**
```typescript
// app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'about', component: AboutComponent },
  { path: 'users/:id', component: UserProfileComponent },
  { path: '**', component: NotFoundComponent }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

// user-profile.component.ts
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';

@Component({
  selector: 'app-user-profile',
  template: `
    <h1>User Profile</h1>
    <p>User ID: {{ userId }}</p>
    <button (click)="goHome()">Go Home</button>
  `
})
export class UserProfileComponent implements OnInit {
  userId: string;
  
  constructor(
    private route: ActivatedRoute,
    private router: Router
  ) { }
  
  ngOnInit() {
    this.route.params.subscribe(params => {
      this.userId = params['id'];
    });
  }
  
  goHome() {
    this.router.navigate(['/']);
  }
}
```

**Server-Side Considerations:**

When using the History API for client-side routing, the server must be configured to handle all routes properly:

1. **The server should serve the same HTML file for all routes:**
   - For Apache, use an .htaccess file:
   ```apache
   <IfModule mod_rewrite.c>
     RewriteEngine On
     RewriteBase /
     RewriteRule ^index\.html$ - [L]
     RewriteCond %{REQUEST_FILENAME} !-f
     RewriteCond %{REQUEST_FILENAME} !-d
     RewriteRule . /index.html [L]
   </IfModule>
   ```

   - For Nginx:
   ```nginx
   location / {
     try_files $uri $uri/ /index.html;
   }
   ```

   - For Express.js:
   ```javascript
   const express = require('express');
   const path = require('path');
   const app = express();
   
   // Serve static files
   app.use(express.static(path.join(__dirname, 'public')));
   
   // Handle all routes
   app.get('*', (req, res) => {
     res.sendFile(path.join(__dirname, 'public', 'index.html'));
   });
   
   app.listen(3000);
   ```

2. **Handling 404s:**
   - With client-side routing, 404 errors are typically handled by the client-side router
   - The server returns the main HTML file for all routes, and the client-side router determines if the route exists

**Best Practices:**

1. **Always provide fallbacks for browsers that don't support the History API:**
   ```javascript
   if (!window.history || !window.history.pushState) {
     // Use hash-based routing or full page reloads as fallback
   }
   ```

2. **Handle initial page load correctly:**
   - Ensure your router correctly handles the initial URL when the page first loads
   - Consider server-side rendering for better SEO and initial load performance

3. **Manage scroll position:**
   ```javascript
   // Scroll to top on navigation
   function navigate(path) {
     history.pushState(null, '', path);
     window.scrollTo(0, 0);
     renderRoute(path);
   }
   
   // Or restore scroll position for back/forward navigation
   window.addEventListener('popstate', (event) => {
     if (event.state && event.state.scrollY) {
       setTimeout(() => {
         window.scrollTo(0, event.state.scrollY);
       }, 0);
     } else {
       window.scrollTo(0, 0);
     }
     renderRoute(window.location.pathname);
   });
   
   // Save scroll position before navigation
   function navigateWithScroll(path) {
     const currentScroll = window.scrollY;
     history.pushState({ scrollY: currentScroll }, '', path);
     window.scrollTo(0, 0);
     renderRoute(path);
   }
   ```

4. **Handle browser refresh properly:**
   - Ensure your application state can be reconstructed from the URL
   - Consider storing additional state in localStorage if needed

5. **Use canonical URLs:**
   ```html
   <link rel="canonical" href="https://example.com/current-page" />
   ```

**Comparison with Hash-Based Routing:**

| Feature | History API Routing | Hash-Based Routing |
|---------|--------------------|-----------------|
| URL Format | `/users/123` | `/#/users/123` |
| Server Configuration | Requires special configuration | Works without server changes |
| SEO | Better (clean URLs) | Worse (hash fragments aren't sent to server) |
| Browser Support | Modern browsers only | All browsers |
| Server Requests | Server receives the full path | Server only receives the part before the hash |
| Bookmarking | Works normally | Works, but URLs are less clean |
| Analytics | Standard tracking works | Requires custom tracking setup |

**Limitations and Considerations:**

1. **Same-Origin Restriction:**
   - `pushState()` and `replaceState()` can only modify URLs within the same origin
   - Attempting to navigate to a different domain will cause an error

2. **SEO Challenges:**
   - Search engines have improved at handling SPAs, but server-side rendering or pre-rendering is still recommended for optimal SEO

3. **Initial Load Performance:**
   - SPAs may have longer initial load times as they need to load the entire application before rendering
   - Consider code splitting and lazy loading to improve performance

4. **Accessibility:**
   - Ensure proper focus management during navigation
   - Announce route changes for screen readers
   ```javascript
   function announceRouteChange(newPageTitle) {
     const announcer = document.getElementById('route-announcer');
     announcer.textContent = `Navigated to ${newPageTitle}`;
   }
   ```

### Q40: Explain the Geolocation API and how to implement location-based features in web applications.
**Difficulty: Medium**

**Answer:**
The Geolocation API allows web applications to access a user's geographical location information. This browser API provides methods to determine the device's position (latitude, longitude, altitude, etc.) and can be used to create location-aware web applications such as maps, local search, and location-based services.

**Basic Usage:**

```javascript
// Check if Geolocation API is supported
if ('geolocation' in navigator) {
  // Get current position
  navigator.geolocation.getCurrentPosition(
    // Success callback
    position => {
      const latitude = position.coords.latitude;
      const longitude = position.coords.longitude;
      console.log(`Location: ${latitude}, ${longitude}`);
      
      // Do something with the location data
      displayMap(latitude, longitude);
    },
    // Error callback
    error => {
      console.error('Error getting location:', error.message);
      switch (error.code) {
        case error.PERMISSION_DENIED:
          console.error('User denied the request for geolocation');
          break;
        case error.POSITION_UNAVAILABLE:
          console.error('Location information is unavailable');
          break;
        case error.TIMEOUT:
          console.error('The request to get user location timed out');
          break;
        case error.UNKNOWN_ERROR:
          console.error('An unknown error occurred');
          break;
      }
    },
    // Options
    {
      enableHighAccuracy: true, // Use GPS if available
      timeout: 5000,           // Time to wait for location (ms)
      maximumAge: 0            // Don't use cached position
    }
  );
} else {
  console.error('Geolocation is not supported by this browser');
}
```

**Continuous Location Tracking:**

```javascript
// Watch position (continuous tracking)
const watchId = navigator.geolocation.watchPosition(
  // Success callback
  position => {
    const { latitude, longitude, accuracy } = position.coords;
    console.log(`Updated location: ${latitude}, ${longitude} (accuracy: ${accuracy} meters)`);
    
    // Update map or other UI elements
    updateUserMarker(latitude, longitude);
  },
  // Error callback
  error => {
    console.error('Error tracking location:', error.message);
  },
  // Options
  {
    enableHighAccuracy: true,
    timeout: 5000,
    maximumAge: 0
  }
);

// Stop watching location when no longer needed
function stopTracking() {
  navigator.geolocation.clearWatch(watchId);
  console.log('Location tracking stopped');
}

// Example: Stop tracking after 5 minutes
setTimeout(stopTracking, 5 * 60 * 1000);
```

**Accessing Additional Geolocation Data:**

```javascript
navigator.geolocation.getCurrentPosition(position => {
  // Basic coordinates
  const latitude = position.coords.latitude;
  const longitude = position.coords.longitude;
  
  // Additional data (may not be available on all devices)
  const accuracy = position.coords.accuracy;       // Accuracy in meters
  const altitude = position.coords.altitude;       // Height in meters (null if unavailable)
  const altitudeAccuracy = position.coords.altitudeAccuracy; // Accuracy of altitude
  const heading = position.coords.heading;         // Direction in degrees (0-360)
  const speed = position.coords.speed;             // Speed in meters/second
  
  // Timestamp of when the position was acquired
  const timestamp = position.timestamp;
  const positionTime = new Date(timestamp).toLocaleTimeString();
  
  console.log(`Position acquired at ${positionTime}`);
  console.log(`Coordinates: ${latitude}, ${longitude} (±${accuracy}m)`);
  
  if (altitude !== null) {
    console.log(`Altitude: ${altitude}m (±${altitudeAccuracy}m)`);
  }
  
  if (heading !== null) {
    console.log(`Heading: ${heading}° from North`);
  }
  
  if (speed !== null) {
    console.log(`Speed: ${speed} m/s (${(speed * 3.6).toFixed(1)} km/h)`);
  }
});
```

**Handling Permissions:**

```javascript
async function checkGeolocationPermission() {
  // For browsers that support the Permissions API
  if ('permissions' in navigator) {
    try {
      const permissionStatus = await navigator.permissions.query({ name: 'geolocation' });
      
      switch (permissionStatus.state) {
        case 'granted':
          console.log('Permission to use geolocation has been granted');
          return true;
        case 'prompt':
          console.log('Permission to use geolocation will be requested');
          return 'prompt';
        case 'denied':
          console.log('Permission to use geolocation has been denied');
          return false;
      }
      
      // Listen for permission changes
      permissionStatus.addEventListener('change', () => {
        console.log(`Geolocation permission changed to: ${permissionStatus.state}`);
      });
      
    } catch (error) {
      console.error('Error checking geolocation permission:', error);
      return 'unknown';
    }
  } else {
    // Fallback for browsers without Permissions API
    return 'unknown';
  }
}

// Usage
async function initializeGeolocation() {
  const permission = await checkGeolocationPermission();
  
  if (permission === true) {
    // Permission already granted, get location
    getLocation();
  } else if (permission === 'prompt') {
    // Show UI explaining why we need location
    showLocationExplanation();
  } else if (permission === false) {
    // Show instructions on how to enable location
    showEnableLocationInstructions();
  } else {
    // Unknown permission state, try getting location anyway
    getLocation();
  }
}

function showLocationExplanation() {
  const explanation = document.getElementById('location-explanation');
  explanation.style.display = 'block';
  
  document.getElementById('allow-location-btn').addEventListener('click', () => {
    explanation.style.display = 'none';
    getLocation();
  });
}

function showEnableLocationInstructions() {
  document.getElementById('enable-location-instructions').style.display = 'block';
}
```

**Implementing a Distance Calculator:**

```javascript
// Calculate distance between two points using the Haversine formula
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371e3; // Earth's radius in meters
  const φ1 = lat1 * Math.PI / 180;
  const φ2 = lat2 * Math.PI / 180;
  const Δφ = (lat2 - lat1) * Math.PI / 180;
  const Δλ = (lon2 - lon1) * Math.PI / 180;
  
  const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
           Math.cos(φ1) * Math.cos(φ2) *
           Math.sin(Δλ/2) * Math.sin(Δλ/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  const distance = R * c;
  
  return distance; // Distance in meters
}

// Example: Calculate distance between user and a point of interest
function distanceToPointOfInterest(poiLat, poiLon) {
  return new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(
      position => {
        const userLat = position.coords.latitude;
        const userLon = position.coords.longitude;
        
        const distance = calculateDistance(userLat, userLon, poiLat, poiLon);
        
        // Format the distance for display
        let formattedDistance;
        if (distance < 1000) {
          formattedDistance = `${Math.round(distance)} meters`;
        } else {
          formattedDistance = `${(distance / 1000).toFixed(2)} km`;
        }
        
        resolve({
          distance,
          formattedDistance,
          userLocation: { lat: userLat, lon: userLon }
        });
      },
      error => {
        reject(error);
      }
    );
  });
}

// Usage
async function showNearbyPlaces() {
  const coffeeShop = { name: 'Coffee Shop', lat: 40.7128, lon: -74.0060 };
  
  try {
    const result = await distanceToPointOfInterest(coffeeShop.lat, coffeeShop.lon);
    console.log(`${coffeeShop.name} is ${result.formattedDistance} away from you`);
    
    // Check if within 1km
    if (result.distance < 1000) {
      showSpecialOffer(coffeeShop.name);
    }
  } catch (error) {
    console.error('Could not calculate distance:', error);
  }
}
```

**Integrating with Mapping Libraries:**

```javascript
// Using Leaflet.js as an example
function initMap() {
  // Create a map centered at a default location
  const map = L.map('map').setView([51.505, -0.09], 13);
  
  // Add tile layer (OpenStreetMap)
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
  }).addTo(map);
  
  // Get user's location and center the map
  navigator.geolocation.getCurrentPosition(
    position => {
      const userLat = position.coords.latitude;
      const userLon = position.coords.longitude;
      
      // Center map on user's location
      map.setView([userLat, userLon], 15);
      
      // Add a marker for the user's location
      const userMarker = L.marker([userLat, userLon])
        .addTo(map)
        .bindPopup('You are here')
        .openPopup();
      
      // Add accuracy circle
      const accuracyCircle = L.circle([userLat, userLon], {
        radius: position.coords.accuracy,
        color: 'blue',
        fillColor: '#3388ff',
        fillOpacity: 0.2
      }).addTo(map);
      
      // Find nearby points of interest
      fetchNearbyPlaces(userLat, userLon)
        .then(places => {
          places.forEach(place => {
            L.marker([place.lat, place.lon])
              .addTo(map)
              .bindPopup(`<b>${place.name}</b><br>${place.description}`);
          });
        });
    },
    error => {
      console.error('Error getting location:', error);
      alert('Could not get your location. Using default location instead.');
    }
  );
  
  return map;
}

// Simulate fetching nearby places from an API
function fetchNearbyPlaces(lat, lon) {
  // In a real app, this would be an API call
  return Promise.resolve([
    { name: 'Coffee Shop', description: 'Great coffee', lat: lat + 0.002, lon: lon + 0.001 },
    { name: 'Restaurant', description: 'Delicious food', lat: lat - 0.001, lon: lon + 0.003 },
    { name: 'Park', description: 'Beautiful park', lat: lat + 0.003, lon: lon - 0.002 }
  ]);
}
```

**Implementing Geofencing:**

```javascript
class Geofence {
  constructor(name, centerLat, centerLon, radiusMeters, onEnter, onExit) {
    this.name = name;
    this.center = { lat: centerLat, lon: centerLon };
    this.radius = radiusMeters;
    this.onEnter = onEnter;
    this.onExit = onExit;
    this.isInside = false;
    this.watchId = null;
  }
  
  start() {
    if (this.watchId !== null) {
      console.warn('Geofence already started');
      return;
    }
    
    this.watchId = navigator.geolocation.watchPosition(
      position => {
        const distance = calculateDistance(
          position.coords.latitude,
          position.coords.longitude,
          this.center.lat,
          this.center.lon
        );
        
        const wasInside = this.isInside;
        this.isInside = distance <= this.radius;
        
        // Trigger events if state changed
        if (this.isInside && !wasInside) {
          this.onEnter(this.name, distance);
        } else if (!this.isInside && wasInside) {
          this.onExit(this.name, distance);
        }
      },
      error => {
        console.error('Geofence error:', error);
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      }
    );
    
    console.log(`Geofence "${this.name}" started`);
    return this;
  }
  
  stop() {
    if (this.watchId !== null) {
      navigator.geolocation.clearWatch(this.watchId);
      this.watchId = null;
      console.log(`Geofence "${this.name}" stopped`);
    }
    return this;
  }
}

// Usage
const storeGeofence = new Geofence(
  'Downtown Store',
  40.7128,  // latitude
  -74.0060, // longitude
  100,      // radius in meters
  (name, distance) => {
    console.log(`Welcome to ${name}!`);
    showWelcomeNotification();
  },
  (name, distance) => {
    console.log(`You left ${name}. Hope to see you again soon!`);
    sendFeedbackRequest();
  }
).start();

// Stop geofence when no longer needed
// storeGeofence.stop();
```

**Privacy and Best Practices:**

1. **Always request location only when necessary:**
```javascript
document.getElementById('find-nearby-btn').addEventListener('click', () => {
  // Only request location when user explicitly asks for it
  getLocation();
});
```

2. **Clearly communicate why you need location:**
```html
<div class="location-explanation">
  <p>We need your location to show you nearby stores and provide directions.</p>
  <p>Your location data is only used while you're using the app and is never stored on our servers.</p>
  <button id="allow-location-btn">Allow Location Access</button>
</div>
```

3. **Provide fallbacks for users who deny location access:**
```javascript
function handleLocationDenied() {
  // Show manual location input
  document.getElementById('manual-location-input').style.display = 'block';
  
  // Or use IP-based geolocation as a less accurate fallback
  fetchIPBasedLocation()
    .then(location => {
      console.log('Using approximate location from IP:', location);
      showApproximateLocationNotice();
      initializeWithLocation(location);
    });
}
```

4. **Respect battery life with appropriate settings:**
```javascript
// For high-precision but battery-intensive tracking
const highPrecisionOptions = {
  enableHighAccuracy: true,
  timeout: 5000,
  maximumAge: 0
};

// For battery-friendly tracking
const batterySavingOptions = {
  enableHighAccuracy: false,
  timeout: 10000,
  maximumAge: 60000 // Accept positions up to 1 minute old
};

// Adjust based on application needs
const trackingOptions = isHighPrecisionRequired() ? 
  highPrecisionOptions : batterySavingOptions;
```

**Browser Compatibility and Limitations:**

1. **Feature Detection:**
```javascript
function getLocationSupport() {
  const support = {
    basic: 'geolocation' in navigator,
    permissions: 'permissions' in navigator,
    highAccuracy: false, // Will be determined by testing
    secure: window.isSecureContext
  };
  
  // Geolocation API requires a secure context (HTTPS)
  if (!support.secure) {
    console.warn('Geolocation API requires a secure context (HTTPS)');
  }
  
  return support;
}
```

2. **Mobile vs. Desktop Differences:**
   - Mobile devices typically provide more accurate GPS-based locations
   - Desktop browsers often rely on IP-based or Wi-Fi-based location
   - Mobile devices may have additional battery considerations

3. **Accuracy Limitations:**
   - Indoor locations may have reduced accuracy
   - Urban environments with tall buildings can cause GPS reflections
   - Network-based geolocation can be very imprecise (city-level only)

**Real-World Applications:**

1. **Store Locator:**
```javascript
async function findNearestStores() {
  try {
    const position = await getCurrentPositionPromise();
    const { latitude, longitude } = position.coords;
    
    const stores = await fetchStoresFromAPI(latitude, longitude, 10); // 10km radius
    
    // Sort stores by distance
    stores.sort((a, b) => a.distance - b.distance);
    
    // Display stores
    displayStoresList(stores);
    displayStoresOnMap(stores, { lat: latitude, lon: longitude });
    
  } catch (error) {
    console.error('Error finding stores:', error);
    showLocationErrorMessage();
  }
}

// Helper function to promisify getCurrentPosition
function getCurrentPositionPromise(options = {}) {
  return new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(resolve, reject, options);
  });
}
```

2. **Weather Application:**
```javascript
async function getLocalWeather() {
  try {
    const position = await getCurrentPositionPromise();
    const { latitude, longitude } = position.coords;
    
    const weatherData = await fetch(
      `https://api.weather.example/forecast?lat=${latitude}&lon=${longitude}&units=metric`
    ).then(response => response.json());
    
    displayWeather(weatherData);
    
  } catch (error) {
    console.error('Error getting weather:', error);
    showWeatherFallback();
  }
}
```

3. **Fitness Tracking:**
```javascript
class RunTracker {
  constructor() {
    this.isTracking = false;
    this.watchId = null;
    this.startTime = null;
    this.distance = 0;
    this.path = [];
    this.lastPosition = null;
  }
  
  start() {
    if (this.isTracking) return;
    
    this.isTracking = true;
    this.startTime = new Date();
    this.distance = 0;
    this.path = [];
    
    this.watchId = navigator.geolocation.watchPosition(
      this.handlePosition.bind(this),
      this.handleError.bind(this),
      { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
    );
    
    // Keep screen on if possible
    if ('wakeLock' in navigator) {
      navigator.wakeLock.request('screen')
        .then(lock => this.wakeLock = lock)
        .catch(err => console.warn('Wake Lock not available', err));
    }
  }
  
  handlePosition(position) {
    const { latitude, longitude, accuracy } = position.coords;
    const timestamp = position.timestamp;
    
    // Only use positions with reasonable accuracy
    if (accuracy > 20) return; // Ignore if accuracy worse than 20 meters
    
    const newPosition = { lat: latitude, lon: longitude, time: timestamp };
    
    // Calculate distance if we have a previous position
    if (this.lastPosition) {
      const segmentDistance = calculateDistance(
        this.lastPosition.lat, this.lastPosition.lon,
        newPosition.lat, newPosition.lon
      );
      
      // Ignore unrealistic movements (potential GPS errors)
      const timeDiff = (timestamp - this.lastPosition.time) / 1000; // seconds
      const speed = segmentDistance / timeDiff; // m/s
      
      if (speed < 10) { // Less than 36 km/h, reasonable for running/biking
        this.distance += segmentDistance;
        this.path.push(newPosition);
        this.updateUI();
      }
    } else {
      // First position
      this.path.push(newPosition);
    }
    
    this.lastPosition = newPosition;
  }
  
  handleError(error) {
    console.error('Tracking error:', error);
    alert('There was a problem tracking your location. Please check your GPS settings.');
  }
  
  stop() {
    if (!this.isTracking) return;
    
    navigator.geolocation.clearWatch(this.watchId);
    this.isTracking = false;
    this.watchId = null;
    
    const duration = (new Date() - this.startTime) / 1000; // seconds
    const result = {
      distance: this.distance,
      duration: duration,
      averageSpeed: this.distance / duration,
      path: this.path
    };
    
    // Release wake lock if we have one
    if (this.wakeLock) {
      this.wakeLock.release();
      this.wakeLock = null;
    }
    
    return result;
  }
  
  updateUI() {
    const durationSeconds = (new Date() - this.startTime) / 1000;
    const durationFormatted = formatDuration(durationSeconds);
    const distanceKm = (this.distance / 1000).toFixed(2);
    const paceMinPerKm = durationSeconds / 60 / (this.distance / 1000);
    
    document.getElementById('tracking-distance').textContent = `${distanceKm} km`;
    document.getElementById('tracking-duration').textContent = durationFormatted;
    document.getElementById('tracking-pace').textContent = `${formatPace(paceMinPerKm)} min/km`;
  }
}

function formatDuration(seconds) {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  
  return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

function formatPace(minPerKm) {
  const mins = Math.floor(minPerKm);
  const secs = Math.floor((minPerKm - mins) * 60);
  
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}
```

### Q41: Explain WebRTC (Web Real-Time Communication) and how to implement peer-to-peer communication in web applications.
**Difficulty: Hard**

**Answer:**
WebRTC (Web Real-Time Communication) is an open-source project and collection of APIs that enables real-time communication directly between browsers without requiring plugins or native apps. It allows web applications to establish peer-to-peer connections for sharing audio, video, and data directly between clients, reducing latency and server load.

**Core Components of WebRTC:**

1. **MediaStream (getUserMedia)**: Accesses the user's camera and microphone
2. **RTCPeerConnection**: Establishes and manages the peer-to-peer connection
3. **RTCDataChannel**: Enables bidirectional data transfer between peers

**Basic WebRTC Architecture:**

```
┌────────────┐                                  ┌────────────┐
│            │                                  │            │
│  Browser A │                                  │  Browser B │
│            │                                  │            │
└─────┬──────┘                                  └──────┬─────┘
      │                                                │
      │  ┌────────────────────────────────────┐       │
      │  │                                    │       │
      └──┤  Signaling Server (e.g., WebSocket)├───────┘
         │                                    │
         └────────────────────────────────────┘
                          │
                          ▼
         ┌────────────────────────────────────┐
         │                                    │
         │  STUN/TURN Servers (NAT traversal) │
         │                                    │
         └────────────────────────────────────┘
```

**Basic Implementation Steps:**

1. **Setting Up a Simple Video Call:**

```javascript
// 1. Access media devices
async function startVideoCall() {
  try {
    // Get local media stream (camera and microphone)
    const localStream = await navigator.mediaDevices.getUserMedia({
      audio: true,
      video: true
    });
    
    // Display local video
    const localVideo = document.getElementById('localVideo');
    localVideo.srcObject = localStream;
    
    // Initialize peer connection
    const peerConnection = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' }, // Free public STUN server
        // Add TURN servers for production environments
      ]
    });
    
    // Add local tracks to the peer connection
    localStream.getTracks().forEach(track => {
      peerConnection.addTrack(track, localStream);
    });
    
    // Handle incoming remote tracks
    peerConnection.ontrack = event => {
      const remoteVideo = document.getElementById('remoteVideo');
      if (remoteVideo.srcObject !== event.streams[0]) {
        remoteVideo.srcObject = event.streams[0];
        console.log('Received remote stream');
      }
    };
    
    // Handle ICE candidates
    peerConnection.onicecandidate = event => {
      if (event.candidate) {
        // Send the candidate to the remote peer via signaling server
        sendToSignalingServer({
          type: 'ice-candidate',
          candidate: event.candidate
        });
      }
    };
    
    // Connection state changes
    peerConnection.onconnectionstatechange = event => {
      console.log('Connection state:', peerConnection.connectionState);
      switch(peerConnection.connectionState) {
        case 'connected':
          console.log('Peers connected!');
          break;
        case 'disconnected':
        case 'failed':
          console.log('Connection lost or failed');
          break;
        case 'closed':
          console.log('Connection closed');
          break;
      }
    };
    
    return peerConnection;
    
  } catch (error) {
    console.error('Error accessing media devices:', error);
  }
}

// 2. Create and send offer (caller)
async function createOffer(peerConnection) {
  try {
    // Create offer
    const offer = await peerConnection.createOffer();
    
    // Set local description
    await peerConnection.setLocalDescription(offer);
    
    // Send offer to remote peer via signaling server
    sendToSignalingServer({
      type: 'offer',
      offer: peerConnection.localDescription
    });
    
  } catch (error) {
    console.error('Error creating offer:', error);
  }
}

// 3. Handle offer and create answer (callee)
async function handleOfferAndCreateAnswer(peerConnection, offer) {
  try {
    // Set remote description based on received offer
    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
    
    // Create answer
    const answer = await peerConnection.createAnswer();
    
    // Set local description
    await peerConnection.setLocalDescription(answer);
    
    // Send answer to remote peer via signaling server
    sendToSignalingServer({
      type: 'answer',
      answer: peerConnection.localDescription
    });
    
  } catch (error) {
    console.error('Error creating answer:', error);
  }
}

// 4. Handle answer (caller)
async function handleAnswer(peerConnection, answer) {
  try {
    await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
  } catch (error) {
    console.error('Error handling answer:', error);
  }
}

// 5. Handle ICE candidate
async function handleIceCandidate(peerConnection, candidate) {
  try {
    if (candidate) {
      await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    }
  } catch (error) {
    console.error('Error adding ICE candidate:', error);
  }
}

// Placeholder for signaling server communication
function sendToSignalingServer(message) {
  // In a real implementation, this would send the message to a signaling server
  // For example, using WebSockets:
  // signalingSocket.send(JSON.stringify(message));
  console.log('Sending to signaling server:', message);
}
```

**Implementing a Signaling Server:**

WebRTC requires a signaling mechanism to exchange session information. Here's a simple implementation using Node.js and WebSockets:

```javascript
// server.js (Node.js with Express and Socket.io)
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = socketIo(server);

// Serve static files
app.use(express.static('public'));

// Store connected users
const users = {};

io.on('connection', socket => {
  console.log('User connected:', socket.id);
  
  // User joins a room
  socket.on('join-room', roomId => {
    socket.join(roomId);
    users[socket.id] = { roomId };
    
    // Notify others in the room
    socket.to(roomId).emit('user-connected', socket.id);
    
    console.log(`User ${socket.id} joined room ${roomId}`);
  });
  
  // Handle WebRTC signaling
  socket.on('offer', payload => {
    const { target, offer } = payload;
    socket.to(target).emit('offer', {
      from: socket.id,
      offer
    });
  });
  
  socket.on('answer', payload => {
    const { target, answer } = payload;
    socket.to(target).emit('answer', {
      from: socket.id,
      answer
    });
  });
  
  socket.on('ice-candidate', payload => {
    const { target, candidate } = payload;
    socket.to(target).emit('ice-candidate', {
      from: socket.id,
      candidate
    });
  });
  
  // Handle disconnection
  socket.on('disconnect', () => {
    const roomId = users[socket.id]?.roomId;
    if (roomId) {
      socket.to(roomId).emit('user-disconnected', socket.id);
      delete users[socket.id];
    }
    console.log('User disconnected:', socket.id);
  });
});

server.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

**Client-Side Integration with Signaling Server:**

```javascript
// client.js
const socket = io('/');
let peerConnection;
let localStream;
let remoteStream;

// Join a room
const roomId = 'room-123'; // In a real app, this could be from URL parameters
socket.emit('join-room', roomId);

// Initialize WebRTC
async function init() {
  try {
    localStream = await navigator.mediaDevices.getUserMedia({
      audio: true,
      video: true
    });
    
    document.getElementById('localVideo').srcObject = localStream;
    
    // Create peer connection with STUN/TURN servers
    peerConnection = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        // Add TURN servers for production
      ]
    });
    
    // Add local tracks to peer connection
    localStream.getTracks().forEach(track => {
      peerConnection.addTrack(track, localStream);
    });
    
    // Handle remote tracks
    peerConnection.ontrack = event => {
      document.getElementById('remoteVideo').srcObject = event.streams[0];
      remoteStream = event.streams[0];
    };
    
    // Handle ICE candidates
    peerConnection.onicecandidate = event => {
      if (event.candidate) {
        socket.emit('ice-candidate', {
          target: remoteUserId, // This would be set when a user connects
          candidate: event.candidate
        });
      }
    };
    
  } catch (error) {
    console.error('Error initializing:', error);
  }
}

// Handle new user connection
socket.on('user-connected', userId => {
  console.log('New user connected:', userId);
  remoteUserId = userId;
  
  // Create and send offer
  createAndSendOffer(userId);
});

// Create and send offer
async function createAndSendOffer(targetUserId) {
  try {
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    
    socket.emit('offer', {
      target: targetUserId,
      offer: peerConnection.localDescription
    });
    
  } catch (error) {
    console.error('Error creating offer:', error);
  }
}

// Handle incoming offer
socket.on('offer', async ({ from, offer }) => {
  try {
    remoteUserId = from;
    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
    
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    
    socket.emit('answer', {
      target: from,
      answer: peerConnection.localDescription
    });
    
  } catch (error) {
    console.error('Error handling offer:', error);
  }
});

// Handle incoming answer
socket.on('answer', async ({ from, answer }) => {
  try {
    await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
  } catch (error) {
    console.error('Error handling answer:', error);
  }
});

// Handle ICE candidates
socket.on('ice-candidate', async ({ from, candidate }) => {
  try {
    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
  } catch (error) {
    console.error('Error adding ICE candidate:', error);
  }
});

// Handle user disconnection
socket.on('user-disconnected', userId => {
  console.log('User disconnected:', userId);
  // Clean up resources if needed
});

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', init);
```

**Implementing Data Channels for Text Chat:**

```javascript
let dataChannel;

// Create data channel (caller)
function createDataChannel(peerConnection) {
  dataChannel = peerConnection.createDataChannel('chat');
  setupDataChannel(dataChannel);
}

// Handle data channel (callee)
peerConnection.ondatachannel = event => {
  dataChannel = event.channel;
  setupDataChannel(dataChannel);
};

// Setup data channel event handlers
function setupDataChannel(channel) {
  channel.onopen = () => {
    console.log('Data channel is open');
    document.getElementById('chat-input').disabled = false;
  };
  
  channel.onclose = () => {
    console.log('Data channel is closed');
    document.getElementById('chat-input').disabled = true;
  };
  
  channel.onmessage = event => {
    // Display received message
    const message = event.data;
    const chatBox = document.getElementById('chat-box');
    const messageElement = document.createElement('div');
    messageElement.className = 'received-message';
    messageElement.textContent = `Peer: ${message}`;
    chatBox.appendChild(messageElement);
    chatBox.scrollTop = chatBox.scrollHeight;
  };
}

// Send message through data channel
function sendMessage() {
  const input = document.getElementById('chat-input');
  const message = input.value.trim();
  
  if (message && dataChannel && dataChannel.readyState === 'open') {
    // Send the message
    dataChannel.send(message);
    
    // Display sent message
    const chatBox = document.getElementById('chat-box');
    const messageElement = document.createElement('div');
    messageElement.className = 'sent-message';
    messageElement.textContent = `You: ${message}`;
    chatBox.appendChild(messageElement);
    chatBox.scrollTop = chatBox.scrollHeight;
    
    // Clear input
    input.value = '';
  }
}

// Add event listener to send button
document.getElementById('send-button').addEventListener('click', sendMessage);

// Add event listener for Enter key
document.getElementById('chat-input').addEventListener('keypress', event => {
  if (event.key === 'Enter') {
    sendMessage();
  }
});
```

**File Sharing with WebRTC Data Channels:**

```javascript
// Send a file through data channel
async function sendFile() {
  const fileInput = document.getElementById('file-input');
  const file = fileInput.files[0];
  
  if (!file) {
    alert('Please select a file');
    return;
  }
  
  if (!dataChannel || dataChannel.readyState !== 'open') {
    alert('Data channel is not open');
    return;
  }
  
  // Send file metadata first
  dataChannel.send(JSON.stringify({
    type: 'file-metadata',
    name: file.name,
    size: file.size,
    mimeType: file.type
  }));
  
  // Read and send the file in chunks
  const chunkSize = 16384; // 16KB chunks
  const reader = new FileReader();
  let offset = 0;
  
  reader.onload = event => {
    if (dataChannel.readyState === 'open') {
      dataChannel.send(event.target.result);
      offset += event.target.result.byteLength;
      
      // Update progress
      const progress = Math.min(100, Math.floor((offset / file.size) * 100));
      document.getElementById('send-progress').style.width = `${progress}%`;
      document.getElementById('send-progress-text').textContent = `${progress}%`;
      
      // Check if file has been completely sent
      if (offset < file.size) {
        readSlice(offset);
      } else {
        console.log('File sent successfully');
        // Send end of file marker
        dataChannel.send(JSON.stringify({ type: 'file-complete' }));
      }
    }
  };
  
  function readSlice(o) {
    const slice = file.slice(o, o + chunkSize);
    reader.readAsArrayBuffer(slice);
  }
  
  // Start reading the first slice
  readSlice(0);
}

// Handle receiving files
let receiveBuffer = [];
let receivedSize = 0;
let fileInfo = null;

// Update data channel message handler for file reception
channel.onmessage = event => {
  const data = event.data;
  
  // Check if the message is text or file data
  if (typeof data === 'string') {
    try {
      const message = JSON.parse(data);
      
      // Handle file metadata
      if (message.type === 'file-metadata') {
        console.log('Receiving file:', message.name);
        fileInfo = message;
        receiveBuffer = [];
        receivedSize = 0;
        
        // Show file reception UI
        document.getElementById('file-receive-name').textContent = message.name;
        document.getElementById('file-receive-container').style.display = 'block';
      }
      
      // Handle file completion
      else if (message.type === 'file-complete') {
        // Combine chunks into a single buffer
        const received = new Blob(receiveBuffer, { type: fileInfo.mimeType });
        receiveBuffer = [];
        
        // Create download link
        const downloadLink = document.getElementById('download-link');
        downloadLink.href = URL.createObjectURL(received);
        downloadLink.download = fileInfo.name;
        downloadLink.textContent = `Download ${fileInfo.name}`;
        downloadLink.style.display = 'block';
        
        console.log(`File received successfully: ${fileInfo.name}`);
      }
      
      // Handle regular chat messages
      else {
        displayChatMessage(message, false);
      }
    } catch (e) {
      // Not JSON, treat as regular chat message
      displayChatMessage(data, false);
    }
  }
  // Handle binary data (file chunks)
  else {
    if (fileInfo) {
      receiveBuffer.push(data);
      receivedSize += data.byteLength;
      
      // Update progress
      const progress = Math.min(100, Math.floor((receivedSize / fileInfo.size) * 100));
      document.getElementById('receive-progress').style.width = `${progress}%`;
      document.getElementById('receive-progress-text').textContent = `${progress}%`;
    }
  }
};
```

**Advanced WebRTC Features:**

1. **Screen Sharing:**

```javascript
async function startScreenSharing() {
  try {
    // Get screen sharing stream
    const screenStream = await navigator.mediaDevices.getDisplayMedia({
      video: true
    });
    
    // Replace video track
    const videoTrack = screenStream.getVideoTracks()[0];
    
    // Find the video sender in the peer connection
    const senders = peerConnection.getSenders();
    const videoSender = senders.find(sender => 
      sender.track && sender.track.kind === 'video'
    );
    
    if (videoSender) {
      await videoSender.replaceTrack(videoTrack);
    }
    
    // Update local video display
    document.getElementById('localVideo').srcObject = screenStream;
    
    // Handle the end of screen sharing
    videoTrack.onended = async () => {
      // Revert to camera
      const cameraStream = await navigator.mediaDevices.getUserMedia({ video: true });
      const cameraTrack = cameraStream.getVideoTracks()[0];
      
      await videoSender.replaceTrack(cameraTrack);
      document.getElementById('localVideo').srcObject = cameraStream;
    };
    
  } catch (error) {
    console.error('Error starting screen sharing:', error);
  }
}
```

2. **Multi-Party Conferencing (Mesh Architecture):**

```javascript
// Simplified multi-party WebRTC (mesh architecture)
const peers = {};

// Handle new user connection
socket.on('user-connected', userId => {
  console.log('New user connected:', userId);
  
  // Create a new peer connection for this user
  const peerConnection = createPeerConnection(userId);
  peers[userId] = peerConnection;
  
  // Create and send offer
  createAndSendOffer(userId, peerConnection);
});

// Create peer connection for a specific user
function createPeerConnection(userId) {
  const peerConnection = new RTCPeerConnection({
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' }
    ]
  });
  
  // Add local tracks
  localStream.getTracks().forEach(track => {
    peerConnection.addTrack(track, localStream);
  });
  
  // Handle ICE candidates
  peerConnection.onicecandidate = event => {
    if (event.candidate) {
      socket.emit('ice-candidate', {
        target: userId,
        candidate: event.candidate
      });
    }
  };
  
  // Create video element for this peer
  const videoElement = document.createElement('video');
  videoElement.id = `video-${userId}`;
  videoElement.autoplay = true;
  videoElement.playsInline = true;
  document.getElementById('videos-container').appendChild(videoElement);
  
  // Handle remote tracks
  peerConnection.ontrack = event => {
    videoElement.srcObject = event.streams[0];
  };
  
  return peerConnection;
}

// Handle user disconnection
socket.on('user-disconnected', userId => {
  console.log('User disconnected:', userId);
  
  // Close peer connection
  if (peers[userId]) {
    peers[userId].close();
    delete peers[userId];
  }
  
  // Remove video element
  const videoElement = document.getElementById(`video-${userId}`);
  if (videoElement) {
    videoElement.remove();
  }
});
```

**WebRTC Security Considerations:**

1. **Encryption:**
   - WebRTC media is encrypted by default using DTLS-SRTP
   - Data channels are encrypted using DTLS

2. **Permission Model:**
   - Access to camera and microphone requires explicit user permission
   - Screen sharing requires additional permission

3. **Best Practices:**
   - Always use HTTPS for your signaling server
   - Implement proper authentication for your signaling mechanism
   - Consider using a TURN server with authentication
   - Validate all signaling messages before processing

```javascript
// Example of validating signaling messages
socket.on('offer', async ({ from, offer }) => {
  // Validate the offer structure before processing
  if (!offer || !offer.type || !offer.sdp) {
    console.error('Invalid offer received');
    return;
  }
  
  // Validate the sender identity (in a real app, this would be more robust)
  if (!isValidUser(from)) {
    console.error('Offer received from unknown user');
    return;
  }
  
  // Process the offer
  try {
    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
    // ... rest of the handler
  } catch (error) {
    console.error('Error handling offer:', error);
  }
});

// Example function to validate user
function isValidUser(userId) {
  // In a real app, this would check against authenticated users
  return Boolean(userId && typeof userId === 'string');
}
```

**Browser Compatibility and Limitations:**

1. **Feature Detection:**

```javascript
function checkWebRTCSupport() {
  const support = {
    webRTC: Boolean(window.RTCPeerConnection),
    getUserMedia: Boolean(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
    screen: Boolean(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia),
    dataChannel: Boolean(window.RTCPeerConnection && 'createDataChannel' in RTCPeerConnection.prototype)
  };
  
  return support;
}

// Usage
const rtcSupport = checkWebRTCSupport();
if (!rtcSupport.webRTC) {
  showFallbackInterface('Your browser does not support WebRTC');
}
```

2. **Mobile Considerations:**
   - Battery usage can be high with continuous video streaming
   - Network transitions (WiFi to cellular) can disrupt connections
   - Implement bandwidth adaptation for varying network conditions

```javascript
// Example of setting bandwidth constraints
function limitBandwidth(peerConnection) {
  // Get the video sender
  const sender = peerConnection.getSenders().find(s => 
    s.track && s.track.kind === 'video'
  );
  
  if (sender) {
    const parameters = sender.getParameters();
    
    // Check if encodings array exists
    if (!parameters.encodings) {
      parameters.encodings = [{}];
    }
    
    // Set maximum bitrate (1.5 Mbps)
    parameters.encodings[0].maxBitrate = 1500000;
    
    // Apply the changes
    return sender.setParameters(parameters);
  }
  
  return Promise.resolve();
}
```

**Best Practices for WebRTC Applications:**

1. **Connection Management:**
   - Implement reconnection logic for dropped connections
   - Handle ICE failures gracefully
   - Monitor connection quality and adapt accordingly

2. **User Experience:**
   - Provide clear feedback on connection status
   - Implement mute/unmute and video on/off controls
   - Show network quality indicators

```javascript
// Example of connection quality monitoring
peerConnection.oniceconnectionstatechange = () => {
  const state = peerConnection.iceConnectionState;
  const qualityIndicator = document.getElementById('connection-quality');
  
  switch (state) {
    case 'checking':
      qualityIndicator.className = 'quality-connecting';
      qualityIndicator.textContent = 'Connecting...';
      break;
    case 'connected':
    case 'completed':
      qualityIndicator.className = 'quality-good';
      qualityIndicator.textContent = 'Good Connection';
      break;
    case 'disconnected':
      qualityIndicator.className = 'quality-poor';
      qualityIndicator.textContent = 'Poor Connection';
      attemptReconnection();
      break;
    case 'failed':
      qualityIndicator.className = 'quality-failed';
      qualityIndicator.textContent = 'Connection Failed';
      handleConnectionFailure();
      break;
    case 'closed':
      qualityIndicator.className = 'quality-closed';
      qualityIndicator.textContent = 'Connection Closed';
      break;
  }
};

// Monitor media statistics
function monitorConnectionStats() {
  const statsInterval = setInterval(async () => {
    if (!peerConnection) {
      clearInterval(statsInterval);
      return;
    }
    
    try {
      const stats = await peerConnection.getStats();
      let videoBitrate = 0;
      let videoPacketLoss = 0;
      let audioPacketLoss = 0;
      
      stats.forEach(report => {
        if (report.type === 'inbound-rtp' && report.kind === 'video') {
          // Calculate video bitrate
          if (report.bytesReceived && lastVideoStats && lastVideoStats.bytesReceived) {
            const bitrate = 8 * (report.bytesReceived - lastVideoStats.bytesReceived) / 
                           (report.timestamp - lastVideoStats.timestamp) * 1000;
            videoBitrate = Math.round(bitrate);
          }
          
          // Get packet loss
          if (report.packetsLost !== undefined) {
            videoPacketLoss = report.packetsLost;
          }
          
          lastVideoStats = report;
        }
        
        if (report.type === 'inbound-rtp' && report.kind === 'audio') {
          // Get audio packet loss
          if (report.packetsLost !== undefined) {
            audioPacketLoss = report.packetsLost;
          }
        }
      });
      
      // Update UI with stats
      document.getElementById('video-bitrate').textContent = `${videoBitrate} kbps`;
      document.getElementById('video-packet-loss').textContent = videoPacketLoss;
      document.getElementById('audio-packet-loss').textContent = audioPacketLoss;
      
    } catch (error) {
      console.error('Error getting stats:', error);
    }
  }, 1000);
}
```

3. **Fallback Mechanisms:**
   - Provide alternative communication methods when WebRTC fails
   - Consider using a relay server for challenging network environments

```javascript
function handleConnectionFailure() {
  // Show fallback UI
  document.getElementById('webrtc-container').style.display = 'none';
  document.getElementById('fallback-container').style.display = 'block';
  
  // Offer alternative communication method
  document.getElementById('fallback-button').addEventListener('click', () => {
    // Example: Redirect to a server-relayed video solution
    window.location.href = `/fallback-video-chat?room=${roomId}&user=${userId}`;
  });
}
```

**Real-World Applications of WebRTC:**

1. **Video Conferencing Systems**
2. **Live Streaming Platforms**
3. **Remote Assistance Applications**
4. **Gaming and Interactive Entertainment**
5. **IoT Device Communication**
6. **Remote Healthcare Consultations**

**Conclusion:**
WebRTC represents a powerful technology for building real-time communication applications directly in the browser. By understanding its core components, signaling requirements, and best practices, developers can create robust peer-to-peer applications that deliver high-quality audio, video, and data sharing experiences with minimal latency.

### Q42: Explain the Web Audio API and how to create advanced audio applications in the browser.
**Difficulty: Hard**

**Answer:**
The Web Audio API is a powerful, high-level JavaScript API for processing and synthesizing audio in web applications. It provides a flexible system for controlling audio on the web, enabling developers to create complex audio applications like music synthesizers, audio visualizers, spatial audio systems, and sound effects processors directly in the browser.

**Core Concepts of the Web Audio API:**

1. **Audio Context**: The central object that manages and processes all audio operations
2. **Audio Nodes**: Building blocks that process audio data (sources, effects, analyzers, destinations)
3. **Audio Routing**: Connecting nodes together to create an audio processing graph
4. **Modular Design**: Allows for complex audio processing chains with precise timing

**Basic Audio Graph Architecture:**

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│             │     │             │     │             │     │             │
│  Source     │────▶│  Effect     │────▶│  Analyzer   │────▶│ Destination │
│  Nodes      │     │  Nodes      │     │  Nodes      │     │ (Speakers)  │
│             │     │             │     │             │     │             │
└─────────────┘     └─────────────┘     └─────────────┘     └─────────────┘
```

**Creating a Basic Audio Application:**

```javascript
// 1. Create an Audio Context
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioContext = new AudioContext();

// 2. Create a simple oscillator (sound source)
function playTone(frequency = 440, type = 'sine') {
  // Create an oscillator node
  const oscillator = audioContext.createOscillator();
  
  // Configure the oscillator
  oscillator.type = type; // 'sine', 'square', 'sawtooth', 'triangle'
  oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
  
  // Create a gain node for volume control
  const gainNode = audioContext.createGain();
  gainNode.gain.setValueAtTime(0, audioContext.currentTime); // Start silent
  gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.1); // Fade in
  
  // Connect the nodes: oscillator -> gain -> destination
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  
  // Start the oscillator
  oscillator.start();
  
  // Stop the oscillator after 1 second with a fade out
  gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
  oscillator.stop(audioContext.currentTime + 1.1);
  
  return { oscillator, gainNode };
}

// Usage
document.getElementById('play-button').addEventListener('click', () => {
  // Resume audio context if it's suspended (needed for Chrome's autoplay policy)
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
  
  // Play an A note (440Hz)
  playTone(440, 'sine');
});
```

**Loading and Playing Audio Files:**

```javascript
async function loadAndPlayAudio(url) {
  try {
    // Fetch the audio file
    const response = await fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    
    // Decode the audio data
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
    
    // Create a buffer source node
    const source = audioContext.createBufferSource();
    source.buffer = audioBuffer;
    
    // Create a gain node for volume control
    const gainNode = audioContext.createGain();
    gainNode.gain.value = 0.5; // 50% volume
    
    // Connect the nodes
    source.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    // Play the audio
    source.start();
    
    return { source, gainNode };
    
  } catch (error) {
    console.error('Error loading audio:', error);
  }
}

// Usage
document.getElementById('play-sample').addEventListener('click', () => {
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
  
  loadAndPlayAudio('path/to/audio/file.mp3');
});
```

**Creating an Audio Visualizer:**

```javascript
function createAudioVisualizer(audioElement) {
  // Create an audio source from the HTML audio element
  const source = audioContext.createMediaElementSource(audioElement);
  
  // Create an analyzer node
  const analyser = audioContext.createAnalyser();
  analyser.fftSize = 2048; // Must be a power of 2
  const bufferLength = analyser.frequencyBinCount; // Half of fftSize
  const dataArray = new Uint8Array(bufferLength);
  
  // Connect the source to the analyzer and the destination
  source.connect(analyser);
  analyser.connect(audioContext.destination);
  
  // Get the canvas and its context
  const canvas = document.getElementById('visualizer');
  const canvasCtx = canvas.getContext('2d');
  
  // Function to draw the visualization
  function draw() {
    // Request next animation frame
    requestAnimationFrame(draw);
    
    // Get the frequency data
    analyser.getByteFrequencyData(dataArray);
    
    // Clear the canvas
    canvasCtx.fillStyle = 'rgb(0, 0, 0)';
    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw the frequency bars
    const barWidth = (canvas.width / bufferLength) * 2.5;
    let x = 0;
    
    for (let i = 0; i < bufferLength; i++) {
      const barHeight = dataArray[i] / 2;
      
      // Use the frequency data to determine color
      const r = dataArray[i] + 25;
      const g = 250 - dataArray[i];
      const b = 50;
      
      canvasCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
      canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
      
      x += barWidth + 1;
    }
  }
  
  // Start the visualization
  draw();
  
  return { source, analyser };
}

// Usage
const audioElement = document.getElementById('audio-player');
document.getElementById('start-visualizer').addEventListener('click', () => {
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
  
  createAudioVisualizer(audioElement);
  audioElement.play();
});
```

**Creating a Simple Synthesizer:**

```javascript
class Synthesizer {
  constructor() {
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    this.masterGain = this.audioContext.createGain();
    this.masterGain.gain.value = 0.7;
    this.masterGain.connect(this.audioContext.destination);
    
    // Add effects chain
    this.compressor = this.audioContext.createDynamicsCompressor();
    this.compressor.threshold.value = -24;
    this.compressor.knee.value = 30;
    this.compressor.ratio.value = 12;
    this.compressor.attack.value = 0.003;
    this.compressor.release.value = 0.25;
    this.compressor.connect(this.masterGain);
    
    this.activeOscillators = {};
  }
  
  playNote(note, octave = 4) {
    // Resume audio context if suspended
    if (this.audioContext.state === 'suspended') {
      this.audioContext.resume();
    }
    
    // Calculate frequency using equal temperament
    // A4 = 440Hz, each semitone is a factor of 2^(1/12)
    const notes = { 'C': -9, 'C#': -8, 'D': -7, 'D#': -6, 'E': -5, 'F': -4, 'F#': -3, 'G': -2, 'G#': -1, 'A': 0, 'A#': 1, 'B': 2 };
    const semitoneOffset = notes[note];
    const octaveOffset = octave - 4; // A4 is the reference
    const frequency = 440 * Math.pow(2, (semitoneOffset / 12) + octaveOffset);
    
    // Create unique ID for this note
    const noteId = `${note}${octave}`;
    
    // Create oscillator
    const osc = this.audioContext.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
    
    // Create envelope
    const envelope = this.audioContext.createGain();
    envelope.gain.setValueAtTime(0, this.audioContext.currentTime);
    envelope.gain.linearRampToValueAtTime(1, this.audioContext.currentTime + 0.05); // Attack
    
    // Create filter
    const filter = this.audioContext.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 1500;
    filter.Q.value = 5;
    
    // Connect nodes: oscillator -> envelope -> filter -> compressor -> master
    osc.connect(envelope);
    envelope.connect(filter);
    filter.connect(this.compressor);
    
    // Start oscillator
    osc.start();
    
    // Store active oscillator and its envelope
    this.activeOscillators[noteId] = { osc, envelope, filter };
    
    return noteId;
  }
  
  releaseNote(noteId) {
    if (this.activeOscillators[noteId]) {
      const { osc, envelope } = this.activeOscillators[noteId];
      
      // Release envelope
      const now = this.audioContext.currentTime;
      envelope.gain.cancelScheduledValues(now);
      envelope.gain.setValueAtTime(envelope.gain.value, now);
      envelope.gain.exponentialRampToValueAtTime(0.001, now + 0.5); // Release time
      
      // Stop oscillator after release
      osc.stop(now + 0.5);
      
      // Remove from active oscillators after release
      setTimeout(() => {
        delete this.activeOscillators[noteId];
      }, 500);
    }
  }
  
  setFilterFrequency(value) {
    // Update filter frequency for all active notes
    const minFreq = 50;
    const maxFreq = 15000;
    const frequency = minFreq * Math.pow(maxFreq / minFreq, value);
    
    Object.values(this.activeOscillators).forEach(({ filter }) => {
      filter.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
    });
  }
  
  setFilterResonance(value) {
    // Update filter Q for all active notes
    const q = value * 30;
    
    Object.values(this.activeOscillators).forEach(({ filter }) => {
      filter.Q.setValueAtTime(q, this.audioContext.currentTime);
    });
  }
}

// Usage
const synth = new Synthesizer();

// Map keyboard keys to notes
const keyboardMapping = {
  'a': { note: 'C', octave: 4 },
  'w': { note: 'C#', octave: 4 },
  's': { note: 'D', octave: 4 },
  'e': { note: 'D#', octave: 4 },
  'd': { note: 'E', octave: 4 },
  'f': { note: 'F', octave: 4 },
  't': { note: 'F#', octave: 4 },
  'g': { note: 'G', octave: 4 },
  'y': { note: 'G#', octave: 4 },
  'h': { note: 'A', octave: 4 },
  'u': { note: 'A#', octave: 4 },
  'j': { note: 'B', octave: 4 },
  'k': { note: 'C', octave: 5 },
};

// Keep track of pressed keys
const pressedKeys = {};

// Add event listeners for keyboard
window.addEventListener('keydown', (event) => {
  const key = event.key.toLowerCase();
  
  // Check if key is mapped and not already pressed
  if (keyboardMapping[key] && !pressedKeys[key]) {
    const { note, octave } = keyboardMapping[key];
    const noteId = synth.playNote(note, octave);
    pressedKeys[key] = noteId;
    
    // Highlight the key on the virtual keyboard
    document.querySelector(`[data-note="${note}${octave}"]`)?.classList.add('active');
  }
});

window.addEventListener('keyup', (event) => {
  const key = event.key.toLowerCase();
  
  // Check if key is mapped and currently pressed
  if (keyboardMapping[key] && pressedKeys[key]) {
    const noteId = pressedKeys[key];
    synth.releaseNote(noteId);
    delete pressedKeys[key];
    
    // Remove highlight from the virtual keyboard
    const { note, octave } = keyboardMapping[key];
    document.querySelector(`[data-note="${note}${octave}"]`)?.classList.remove('active');
  }
});

// Add event listeners for filter controls
document.getElementById('filter-cutoff').addEventListener('input', (event) => {
  synth.setFilterFrequency(event.target.value);
});

document.getElementById('filter-resonance').addEventListener('input', (event) => {
  synth.setFilterResonance(event.target.value);
});
```

**Creating 3D Spatial Audio:**

```javascript
function createSpatialAudio(audioUrl) {
  // Create a listener (represents the user's position and orientation)
  const listener = audioContext.listener;
  
  // Set listener position (if using an older browser API)
  if (listener.positionX) {
    listener.positionX.value = 0;
    listener.positionY.value = 0;
    listener.positionZ.value = 0;
  } else {
    listener.setPosition(0, 0, 0);
  }
  
  // Set listener orientation (forward and up vectors)
  if (listener.forwardX) {
    listener.forwardX.value = 0;
    listener.forwardY.value = 0;
    listener.forwardZ.value = -1;
    listener.upX.value = 0;
    listener.upY.value = 1;
    listener.upZ.value = 0;
  } else {
    listener.setOrientation(0, 0, -1, 0, 1, 0);
  }
  
  // Load audio
  return fetch(audioUrl)
    .then(response => response.arrayBuffer())
    .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
    .then(audioBuffer => {
      // Create a panner node for 3D positioning
      const panner = audioContext.createPanner();
      panner.panningModel = 'HRTF'; // Head-related transfer function for realistic 3D audio
      panner.distanceModel = 'inverse';
      panner.refDistance = 1;
      panner.maxDistance = 10000;
      panner.rolloffFactor = 1;
      
      // Set initial position
      if (panner.positionX) {
        panner.positionX.value = 0;
        panner.positionY.value = 0;
        panner.positionZ.value = 0;
      } else {
        panner.setPosition(0, 0, 0);
      }
      
      // Create a buffer source
      const source = audioContext.createBufferSource();
      source.buffer = audioBuffer;
      
      // Connect nodes: source -> panner -> destination
      source.connect(panner);
      panner.connect(audioContext.destination);
      
      return { source, panner };
    });
}

// Usage: Create a sound that moves in 3D space
let soundObject;

document.getElementById('start-spatial').addEventListener('click', async () => {
  if (audioContext.state === 'suspended') {
    await audioContext.resume();
  }
  
  soundObject = await createSpatialAudio('path/to/sound.mp3');
  soundObject.source.loop = true;
  soundObject.source.start();
  
  // Animate the sound position in a circle around the listener
  let angle = 0;
  function animateSound() {
    // Calculate position on a circle
    const radius = 5;
    const x = Math.sin(angle) * radius;
    const z = Math.cos(angle) * radius;
    
    // Update panner position
    if (soundObject.panner.positionX) {
      soundObject.panner.positionX.value = x;
      soundObject.panner.positionZ.value = z;
    } else {
      soundObject.panner.setPosition(x, 0, z);
    }
    
    // Increment angle
    angle += 0.01;
    
    // Continue animation
    requestAnimationFrame(animateSound);
  }
  
  animateSound();
});
```

**Creating an Audio Worklet for Custom Audio Processing:**

Audio Worklets allow you to run custom audio processing code in a separate thread, providing low-latency audio processing capabilities.

1. First, create a worklet processor file (e.g., `noise-processor.js`):

```javascript
// noise-processor.js
class NoiseProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.phase = 0;
    this.phaseIncrement = 0.01;
  }
  
  process(inputs, outputs, parameters) {
    const output = outputs[0];
    
    for (let channel = 0; channel < output.length; ++channel) {
      const outputChannel = output[channel];
      
      for (let i = 0; i < outputChannel.length; ++i) {
        // Generate white noise
        outputChannel[i] = Math.random() * 2 - 1;
      }
    }
    
    // Return true to keep the processor alive
    return true;
  }
}

registerProcessor('noise-processor', NoiseProcessor);
```

2. Then, use the worklet in your main code:

```javascript
async function setupNoiseGenerator() {
  // Load and register the audio worklet
  await audioContext.audioWorklet.addModule('noise-processor.js');
  
  // Create a worklet node
  const noiseGenerator = new AudioWorkletNode(audioContext, 'noise-processor');
  
  // Create a gain node for volume control
  const gainNode = audioContext.createGain();
  gainNode.gain.value = 0.1; // Low volume
  
  // Connect nodes
  noiseGenerator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  
  return { noiseGenerator, gainNode };
}

// Usage
document.getElementById('start-noise').addEventListener('click', async () => {
  if (audioContext.state === 'suspended') {
    await audioContext.resume();
  }
  
  const { gainNode } = await setupNoiseGenerator();
  
  // Add volume control
  document.getElementById('noise-volume').addEventListener('input', (event) => {
    gainNode.gain.value = event.target.value;
  });
});
```

**Creating a Multi-Track Recorder:**

```javascript
class AudioRecorder {
  constructor(audioContext) {
    this.audioContext = audioContext;
    this.tracks = [];
    this.isRecording = false;
    this.startTime = 0;
  }
  
  async createNewTrack() {
    try {
      // Get user media stream
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      // Create a media stream source
      const source = this.audioContext.createMediaStreamSource(stream);
      
      // Create a recorder using MediaRecorder API
      const mediaRecorder = new MediaRecorder(stream);
      
      // Create an analyzer for visualization
      const analyzer = this.audioContext.createAnalyser();
      analyzer.fftSize = 2048;
      source.connect(analyzer);
      
      // Create a gain node for this track
      const gainNode = this.audioContext.createGain();
      gainNode.gain.value = 1.0;
      
      // Store recorded chunks
      const audioChunks = [];
      
      mediaRecorder.ondataavailable = (event) => {
        audioChunks.push(event.data);
      };
      
      mediaRecorder.onstop = async () => {
        // Create a blob from the recorded chunks
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        
        // Create an object URL for the blob
        const audioUrl = URL.createObjectURL(audioBlob);
        
        // Fetch and decode the audio data
        const arrayBuffer = await audioBlob.arrayBuffer();
        const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
        
        // Update the track with the recorded buffer
        const trackIndex = this.tracks.findIndex(t => t.mediaRecorder === mediaRecorder);
        if (trackIndex !== -1) {
          this.tracks[trackIndex].buffer = audioBuffer;
          this.tracks[trackIndex].url = audioUrl;
        }
        
        // Notify that recording is complete
        this.onTrackRecorded && this.onTrackRecorded(trackIndex);
      };
      
      // Create a new track object
      const track = {
        source,
        mediaRecorder,
        analyzer,
        gainNode,
        buffer: null,
        url: null,
        stream,
        muted: false
      };
      
      // Add the track to the tracks array
      this.tracks.push(track);
      
      return this.tracks.length - 1; // Return the track index
      
    } catch (error) {
      console.error('Error creating track:', error);
      return -1;
    }
  }
  
  startRecording() {
    if (this.isRecording) return;
    
    this.isRecording = true;
    this.startTime = this.audioContext.currentTime;
    
    // Start recording on all tracks
    this.tracks.forEach(track => {
      if (track.mediaRecorder.state === 'inactive') {
        track.mediaRecorder.start();
      }
    });
  }
  
  stopRecording() {
    if (!this.isRecording) return;
    
    this.isRecording = false;
    
    // Stop recording on all tracks
    this.tracks.forEach(track => {
      if (track.mediaRecorder.state === 'recording') {
        track.mediaRecorder.stop();
      }
    });
  }
  
  playAllTracks() {
    // Create buffer sources for all tracks that have recorded audio
    const currentTime = this.audioContext.currentTime;
    
    this.tracks.forEach(track => {
      if (track.buffer) {
        // Create a buffer source
        const source = this.audioContext.createBufferSource();
        source.buffer = track.buffer;
        
        // Connect through the track's gain node
        source.connect(track.gainNode);
        track.gainNode.connect(this.audioContext.destination);
        
        // Start playback
        source.start(currentTime);
        
        // Store the source for potential stopping
        track.playbackSource = source;
      }
    });
  }
  
  stopAllPlayback() {
    this.tracks.forEach(track => {
      if (track.playbackSource) {
        track.playbackSource.stop();
        track.playbackSource = null;
      }
    });
  }
  
  muteTrack(trackIndex, mute) {
    if (trackIndex >= 0 && trackIndex < this.tracks.length) {
      const track = this.tracks[trackIndex];
      track.muted = mute;
      track.gainNode.gain.value = mute ? 0 : 1;
    }
  }
  
  setTrackVolume(trackIndex, volume) {
    if (trackIndex >= 0 && trackIndex < this.tracks.length) {
      const track = this.tracks[trackIndex];
      if (!track.muted) {
        track.gainNode.gain.value = volume;
      }
    }
  }
  
  exportMix() {
    // Create an offline audio context for rendering
    let maxDuration = 0;
    
    // Find the longest track duration
    this.tracks.forEach(track => {
      if (track.buffer && track.buffer.duration > maxDuration) {
        maxDuration = track.buffer.duration;
      }
    });
    
    if (maxDuration === 0) return null;
    
    // Create an offline context with the max duration
    const offlineContext = new OfflineAudioContext(
      2, // stereo output
      this.audioContext.sampleRate * maxDuration,
      this.audioContext.sampleRate
    );
    
    // Add all tracks to the offline context
    this.tracks.forEach(track => {
      if (track.buffer && !track.muted) {
        const source = offlineContext.createBufferSource();
        source.buffer = track.buffer;
        
        const gain = offlineContext.createGain();
        gain.gain.value = track.gainNode.gain.value;
        
        source.connect(gain);
        gain.connect(offlineContext.destination);
        
        source.start(0);
      }
    });
    
    // Render the audio
    return offlineContext.startRendering().then(renderedBuffer => {
      // Convert the rendered buffer to a WAV file
      const wavBlob = this.bufferToWave(renderedBuffer);
      return URL.createObjectURL(wavBlob);
    });
  }
  
  // Helper function to convert AudioBuffer to WAV Blob
  bufferToWave(buffer) {
    const numOfChannels = buffer.numberOfChannels;
    const length = buffer.length * numOfChannels * 2;
    const sampleRate = buffer.sampleRate;
    
    // Create the buffer for the WAV file
    const arrayBuffer = new ArrayBuffer(44 + length);
    const view = new DataView(arrayBuffer);
    
    // RIFF chunk descriptor
    this.writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + length, true);
    this.writeString(view, 8, 'WAVE');
    
    // FMT sub-chunk
    this.writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true); // subchunk1size
    view.setUint16(20, 1, true); // audio format (1 for PCM)
    view.setUint16(22, numOfChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * numOfChannels * 2, true); // byte rate
    view.setUint16(32, numOfChannels * 2, true); // block align
    view.setUint16(34, 16, true); // bits per sample
    
    // Data sub-chunk
    this.writeString(view, 36, 'data');
    view.setUint32(40, length, true);
    
    // Write the PCM samples
    const offset = 44;
    let pos = 0;
    
    for (let i = 0; i < buffer.length; i++) {
      for (let channel = 0; channel < numOfChannels; channel++) {
        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
        const int16 = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
        view.setInt16(offset + pos, int16, true);
        pos += 2;
      }
    }
    
    return new Blob([view], { type: 'audio/wav' });
  }
  
  writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }
}

// Usage
const recorder = new AudioRecorder(audioContext);

// Create a new track
document.getElementById('add-track').addEventListener('click', async () => {
  if (audioContext.state === 'suspended') {
    await audioContext.resume();
  }
  
  const trackIndex = await recorder.createNewTrack();
  if (trackIndex !== -1) {
    // Create UI for the new track
    createTrackUI(trackIndex);
  }
});

// Start recording
document.getElementById('start-recording').addEventListener('click', () => {
  recorder.startRecording();
  document.getElementById('start-recording').disabled = true;
  document.getElementById('stop-recording').disabled = false;
});

// Stop recording
document.getElementById('stop-recording').addEventListener('click', () => {
  recorder.stopRecording();
  document.getElementById('start-recording').disabled = false;
  document.getElementById('stop-recording').disabled = true;
});

// Play all tracks
document.getElementById('play-all').addEventListener('click', () => {
  recorder.playAllTracks();
});

// Export mix
document.getElementById('export-mix').addEventListener('click', async () => {
  const mixUrl = await recorder.exportMix();
  if (mixUrl) {
    const downloadLink = document.getElementById('download-mix');
    downloadLink.href = mixUrl;
    downloadLink.download = 'mix.wav';
    downloadLink.style.display = 'block';
  }
});

// Helper function to create UI for a track
function createTrackUI(trackIndex) {
  const tracksContainer = document.getElementById('tracks-container');
  
  const trackDiv = document.createElement('div');
  trackDiv.className = 'track';
  trackDiv.dataset.trackIndex = trackIndex;
  
  // Create track controls
  const muteButton = document.createElement('button');
  muteButton.textContent = 'Mute';
  muteButton.addEventListener('click', () => {
    const isMuted = muteButton.classList.toggle('muted');
    recorder.muteTrack(trackIndex, isMuted);
    muteButton.textContent = isMuted ? 'Unmute' : 'Mute';
  });
  
  const volumeSlider = document.createElement('input');
  volumeSlider.type = 'range';
  volumeSlider.min = '0';
  volumeSlider.max = '1';
  volumeSlider.step = '0.01';
  volumeSlider.value = '1';
  volumeSlider.addEventListener('input', () => {
    recorder.setTrackVolume(trackIndex, parseFloat(volumeSlider.value));
  });
  
  // Create canvas for visualization
  const canvas = document.createElement('canvas');
  canvas.width = 300;
  canvas.height = 50;
  
  // Add elements to track div
  trackDiv.appendChild(document.createTextNode(`Track ${trackIndex + 1}`));
  trackDiv.appendChild(muteButton);
  trackDiv.appendChild(volumeSlider);
  trackDiv.appendChild(canvas);
  
  // Add track div to container
  tracksContainer.appendChild(trackDiv);
  
  // Set up visualization
  const canvasCtx = canvas.getContext('2d');
  const analyzer = recorder.tracks[trackIndex].analyzer;
  const bufferLength = analyzer.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);
  
  function drawVisualization() {
    requestAnimationFrame(drawVisualization);
    
    analyzer.getByteTimeDomainData(dataArray);
    
    canvasCtx.fillStyle = 'rgb(200, 200, 200)';
    canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
    
    canvasCtx.lineWidth = 2;
    canvasCtx.strokeStyle = 'rgb(0, 0, 0)';
    canvasCtx.beginPath();
    
    const sliceWidth = canvas.width / bufferLength;
    let x = 0;
    
    for (let i = 0; i < bufferLength; i++) {
      const v = dataArray[i] / 128.0;
      const y = v * canvas.height / 2;
      
      if (i === 0) {
        canvasCtx.moveTo(x, y);
      } else {
        canvasCtx.lineTo(x, y);
      }
      
      x += sliceWidth;
    }
    
    canvasCtx.lineTo(canvas.width, canvas.height / 2);
    canvasCtx.stroke();
  }
  
  drawVisualization();
}

// Set callback for when a track is recorded
recorder.onTrackRecorded = (trackIndex) => {
  console.log(`Track ${trackIndex + 1} recording complete`);
};
```

**Advanced Audio Processing with Convolution Reverb:**

```javascript
async function createReverbEffect(impulseResponseUrl) {
  // Fetch the impulse response file
  const response = await fetch(impulseResponseUrl);
  const arrayBuffer = await response.arrayBuffer();
  const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
  
  // Create a convolver node
  const convolver = audioContext.createConvolver();
  convolver.buffer = audioBuffer;
  
  // Create a dry/wet mix control
  const dryGain = audioContext.createGain();
  const wetGain = audioContext.createGain();
  
  dryGain.gain.value = 0.5; // 50% dry signal
  wetGain.gain.value = 0.5; // 50% wet (reverb) signal
  
  // Create input and output gain nodes
  const inputGain = audioContext.createGain();
  const outputGain = audioContext.createGain();
  
  // Connect the nodes
  // Input -> inputGain -> [dryGain, convolver -> wetGain] -> outputGain -> Output
  inputGain.connect(dryGain);
  inputGain.connect(convolver);
  convolver.connect(wetGain);
  dryGain.connect(outputGain);
  wetGain.connect(outputGain);
  
  return {
    input: inputGain,
    output: outputGain,
    setDryWetRatio(dryWet) { // 0 = all dry, 1 = all wet
      dryGain.gain.value = 1 - dryWet;
      wetGain.gain.value = dryWet;
    }
  };
}

// Usage
async function setupReverbDemo() {
  // Create an oscillator for testing
  const oscillator = audioContext.createOscillator();
  oscillator.type = 'sawtooth';
  oscillator.frequency.value = 220; // A3
  
  // Create an envelope
  const envelope = audioContext.createGain();
  envelope.gain.value = 0;
  
  // Create the reverb effect
  const reverb = await createReverbEffect('path/to/concert-hall.wav');
  
  // Connect the nodes
  oscillator.connect(envelope);
  envelope.connect(reverb.input);
  reverb.output.connect(audioContext.destination);
  
  // Start the oscillator
  oscillator.start();
  
  // Function to trigger a note with reverb
  function playNote() {
    const now = audioContext.currentTime;
    
    // Attack
    envelope.gain.cancelScheduledValues(now);
    envelope.gain.setValueAtTime(0, now);
    envelope.gain.linearRampToValueAtTime(0.5, now + 0.01);
    
    // Decay and sustain
    envelope.gain.linearRampToValueAtTime(0.3, now + 0.3);
    
    // Release
    envelope.gain.linearRampToValueAtTime(0, now + 2);
  }
  
  // Add event listeners
  document.getElementById('play-reverb').addEventListener('click', () => {
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }
    
    playNote();
  });
  
  document.getElementById('reverb-amount').addEventListener('input', (event) => {
    reverb.setDryWetRatio(parseFloat(event.target.value));
  });
  
  return { oscillator, envelope, reverb };
}

// Initialize the reverb demo
setupReverbDemo();
```

**Browser Compatibility and Limitations:**

1. **Feature Detection:**

```javascript
function checkWebAudioSupport() {
  const support = {
    webAudio: Boolean(window.AudioContext || window.webkitAudioContext),
    audioWorklet: Boolean(window.AudioContext && AudioContext.prototype.audioWorklet),
    mediaRecorder: Boolean(window.MediaRecorder),
    getUserMedia: Boolean(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)
  };
  
  return support;
}

// Usage
const audioSupport = checkWebAudioSupport();
if (!audioSupport.webAudio) {
  showFallbackInterface('Your browser does not support Web Audio API');
}
```

2. **Mobile Considerations:**
   - Audio playback may require user interaction first (autoplay restrictions)
   - Limited background audio processing on some mobile browsers
   - Performance considerations for complex audio graphs

```javascript
// Example of handling autoplay restrictions
document.addEventListener('click', function initAudioContext() {
  if (audioContext.state === 'suspended') {
    audioContext.resume().then(() => {
      console.log('Audio context resumed successfully');
    });
  }
  document.removeEventListener('click', initAudioContext);
}, { once: true });
```

**Best Practices for Web Audio Applications:**

1. **Performance Optimization:**
   - Reuse audio nodes when possible instead of creating new ones
   - Disconnect unused nodes to free up resources
   - Use appropriate buffer sizes for different use cases
   - Consider using AudioWorklet for intensive processing

2. **User Experience:**
   - Always provide visual feedback for audio operations
   - Handle autoplay restrictions gracefully
   - Implement proper volume controls and mute options
   - Provide fallbacks for unsupported features

3. **Memory Management:**

```javascript
function cleanupAudioResources() {
  // Disconnect all nodes
  source.disconnect();
  gainNode.disconnect();
  analyser.disconnect();
  
  // Release references
  source = null;
  gainNode = null;
  analyser = null;
  
  // If you have any AudioBuffers, you can help GC by clearing references
  audioBuffer = null;
}
```

**Real-World Applications of Web Audio API:**

1. **Music Production Applications**
2. **Interactive Sound Installations**
3. **Audio Visualization Tools**
4. **Game Sound Engines**
5. **Speech Recognition and Processing**
6. **Virtual Instruments and Synthesizers**
7. **Audio Editing and Mixing Tools**

**Conclusion:**
The Web Audio API provides a powerful platform for creating sophisticated audio applications directly in the browser. By understanding its core concepts, node-based architecture, and advanced features, developers can create immersive audio experiences ranging from simple sound players to complex digital audio workstations, all running natively in modern web browsers.

### Q43: Explain IndexedDB and how to use it for client-side storage in web applications.
**Difficulty: Medium**

**Answer:**
IndexedDB is a low-level, transactional, client-side storage API that allows web applications to store and retrieve significant amounts of structured data, including files and blobs. Unlike localStorage, which is limited to storing simple key-value pairs, IndexedDB provides a robust solution for storing complex data structures and performing advanced queries.

**Core Concepts of IndexedDB:**

1. **Object Store-Based**: Similar to tables in relational databases, but stores JavaScript objects
2. **Schema-Free**: No predefined schema required, though you define object stores and indexes
3. **Transactional**: All operations are part of a transaction, ensuring data integrity
4. **Asynchronous API**: Non-blocking operations using promises or event callbacks
5. **Same-Origin Policy**: Data is restricted to the domain that created it
6. **Significant Storage Capacity**: Much larger than localStorage (typically several GB vs 5-10MB)

**Basic IndexedDB Operations:**

1. **Opening a Database:**

```javascript
function openDatabase() {
  return new Promise((resolve, reject) => {
    // Open (or create) the database
    const request = indexedDB.open('MyAppDatabase', 1);
    
    // Handle database upgrade (runs if database doesn't exist or version changes)
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      
      // Create an object store (similar to a table)
      // If you want auto-incrementing IDs, pass { autoIncrement: true }
      const store = db.createObjectStore('users', { keyPath: 'id' });
      
      // Create indexes for searching
      store.createIndex('email', 'email', { unique: true });
      store.createIndex('name', 'name', { unique: false });
      
      console.log('Database setup complete');
    };
    
    // Handle success
    request.onsuccess = (event) => {
      const db = event.target.result;
      resolve(db);
    };
    
    // Handle errors
    request.onerror = (event) => {
      console.error('IndexedDB error:', event.target.error);
      reject('Error opening database');
    };
  });
}
```

2. **Adding Data:**

```javascript
async function addUser(user) {
  try {
    const db = await openDatabase();
    
    return new Promise((resolve, reject) => {
      // Start a transaction
      const transaction = db.transaction(['users'], 'readwrite');
      const store = transaction.objectStore('users');
      
      // Add the user object to the store
      const request = store.add(user);
      
      request.onsuccess = () => {
        resolve(request.result); // Returns the key of the added object
      };
      
      request.onerror = () => {
        reject('Error adding user: ' + request.error);
      };
      
      // Close the database when the transaction is complete
      transaction.oncomplete = () => {
        db.close();
      };
    });
  } catch (error) {
    console.error('Error in addUser:', error);
    throw error;
  }
}

// Usage
addUser({
  id: 1,
  name: 'John Doe',
  email: 'john@example.com',
  age: 30
}).then(key => {
  console.log('User added with key:', key);
}).catch(error => {
  console.error(error);
});
```

3. **Retrieving Data:**

```javascript
async function getUser(id) {
  try {
    const db = await openDatabase();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['users'], 'readonly');
      const store = transaction.objectStore('users');
      
      // Get the user with the specified ID
      const request = store.get(id);
      
      request.onsuccess = () => {
        resolve(request.result); // Returns the user object or undefined
      };
      
      request.onerror = () => {
        reject('Error getting user: ' + request.error);
      };
      
      transaction.oncomplete = () => {
        db.close();
      };
    });
  } catch (error) {
    console.error('Error in getUser:', error);
    throw error;
  }
}

// Usage
getUser(1).then(user => {
  if (user) {
    console.log('Found user:', user);
  } else {
    console.log('User not found');
  }
}).catch(error => {
  console.error(error);
});
```

4. **Updating Data:**

```javascript
async function updateUser(user) {
  try {
    const db = await openDatabase();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['users'], 'readwrite');
      const store = transaction.objectStore('users');
      
      // Put will add the object if it doesn't exist, or update it if it does
      const request = store.put(user);
      
      request.onsuccess = () => {
        resolve(true);
      };
      
      request.onerror = () => {
        reject('Error updating user: ' + request.error);
      };
      
      transaction.oncomplete = () => {
        db.close();
      };
    });
  } catch (error) {
    console.error('Error in updateUser:', error);
    throw error;
  }
}

// Usage
updateUser({
  id: 1,
  name: 'John Doe',
  email: 'john@example.com',
  age: 31 // Updated age
}).then(() => {
  console.log('User updated successfully');
}).catch(error => {
  console.error(error);
});
```

5. **Deleting Data:**

```javascript
async function deleteUser(id) {
  try {
    const db = await openDatabase();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['users'], 'readwrite');
      const store = transaction.objectStore('users');
      
      // Delete the user with the specified ID
      const request = store.delete(id);
      
      request.onsuccess = () => {
        resolve(true);
      };
      
      request.onerror = () => {
        reject('Error deleting user: ' + request.error);
      };
      
      transaction.oncomplete = () => {
        db.close();
      };
    });
  } catch (error) {
    console.error('Error in deleteUser:', error);
    throw error;
  }
}

// Usage
deleteUser(1).then(() => {
  console.log('User deleted successfully');
}).catch(error => {
  console.error(error);
});
```

6. **Querying with Indexes:**

```javascript
async function getUserByEmail(email) {
  try {
    const db = await openDatabase();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['users'], 'readonly');
      const store = transaction.objectStore('users');
      
      // Use the email index to find the user
      const index = store.index('email');
      const request = index.get(email);
      
      request.onsuccess = () => {
        resolve(request.result); // Returns the user object or undefined
      };
      
      request.onerror = () => {
        reject('Error getting user by email: ' + request.error);
      };
      
      transaction.oncomplete = () => {
        db.close();
      };
    });
  } catch (error) {
    console.error('Error in getUserByEmail:', error);
    throw error;
  }
}

// Usage
getUserByEmail('john@example.com').then(user => {
  if (user) {
    console.log('Found user:', user);
  } else {
    console.log('User not found');
  }
}).catch(error => {
  console.error(error);
});
```

7. **Getting All Records:**

```javascript
async function getAllUsers() {
  try {
    const db = await openDatabase();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['users'], 'readonly');
      const store = transaction.objectStore('users');
      
      // Open a cursor to iterate through all records
      const request = store.openCursor();
      const users = [];
      
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        
        if (cursor) {
          // Add the current user to our array
          users.push(cursor.value);
          
          // Move to the next record
          cursor.continue();
        } else {
          // No more records, resolve with the array of users
          resolve(users);
        }
      };
      
      request.onerror = () => {
        reject('Error getting all users: ' + request.error);
      };
      
      transaction.oncomplete = () => {
        db.close();
      };
    });
  } catch (error) {
    console.error('Error in getAllUsers:', error);
    throw error;
  }
}

// Usage
getAllUsers().then(users => {
  console.log('All users:', users);
}).catch(error => {
  console.error(error);
});
```

8. **Using Range Queries:**

```javascript
async function getUsersByAgeRange(minAge, maxAge) {
  try {
    const db = await openDatabase();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['users'], 'readonly');
      const store = transaction.objectStore('users');
      
      // Ensure we have an index on the age property
      // This should be created in the onupgradeneeded event handler
      // store.createIndex('age', 'age', { unique: false });
      const index = store.index('age');
      
      // Create a range for the query
      const range = IDBKeyRange.bound(minAge, maxAge);
      
      // Open a cursor with the range
      const request = index.openCursor(range);
      const users = [];
      
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        
        if (cursor) {
          users.push(cursor.value);
          cursor.continue();
        } else {
          resolve(users);
        }
      };
      
      request.onerror = () => {
        reject('Error getting users by age range: ' + request.error);
      };
      
      transaction.oncomplete = () => {
        db.close();
      };
    });
  } catch (error) {
    console.error('Error in getUsersByAgeRange:', error);
    throw error;
  }
}

// Usage
getUsersByAgeRange(25, 35).then(users => {
  console.log('Users between 25 and 35:', users);
}).catch(error => {
  console.error(error);
});
```

**Advanced IndexedDB Patterns:**

1. **Using Promises with IndexedDB:**

Creating a wrapper to make IndexedDB more ergonomic with Promises:

```javascript
class IndexedDBWrapper {
  constructor(dbName, version) {
    this.dbName = dbName;
    this.version = version;
    this.db = null;
  }
  
  async open() {
    if (this.db) return this.db;
    
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        this.setupDatabase(db);
      };
      
      request.onsuccess = (event) => {
        this.db = event.target.result;
        resolve(this.db);
      };
      
      request.onerror = (event) => {
        reject('Error opening database: ' + event.target.error);
      };
    });
  }
  
  setupDatabase(db) {
    // This method should be overridden by subclasses
    // to define the database schema
  }
  
  async transaction(storeNames, mode) {
    const db = await this.open();
    return db.transaction(storeNames, mode);
  }
  
  async add(storeName, item) {
    const tx = await this.transaction([storeName], 'readwrite');
    const store = tx.objectStore(storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.add(item);
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
      
      tx.oncomplete = () => this.db.close();
    });
  }
  
  async get(storeName, key) {
    const tx = await this.transaction([storeName], 'readonly');
    const store = tx.objectStore(storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.get(key);
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
      
      tx.oncomplete = () => this.db.close();
    });
  }
  
  async getAll(storeName) {
    const tx = await this.transaction([storeName], 'readonly');
    const store = tx.objectStore(storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.getAll();
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
      
      tx.oncomplete = () => this.db.close();
    });
  }
  
  async put(storeName, item) {
    const tx = await this.transaction([storeName], 'readwrite');
    const store = tx.objectStore(storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.put(item);
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
      
      tx.oncomplete = () => this.db.close();
    });
  }
  
  async delete(storeName, key) {
    const tx = await this.transaction([storeName], 'readwrite');
    const store = tx.objectStore(storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.delete(key);
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
      
      tx.oncomplete = () => this.db.close();
    });
  }
  
  async clear(storeName) {
    const tx = await this.transaction([storeName], 'readwrite');
    const store = tx.objectStore(storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.clear();
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
      
      tx.oncomplete = () => this.db.close();
    });
  }
}

// Usage example
class UserDatabase extends IndexedDBWrapper {
  constructor() {
    super('UserDB', 1);
  }
  
  setupDatabase(db) {
    const store = db.createObjectStore('users', { keyPath: 'id' });
    store.createIndex('email', 'email', { unique: true });
    store.createIndex('name', 'name', { unique: false });
    store.createIndex('age', 'age', { unique: false });
  }
  
  async addUser(user) {
    return this.add('users', user);
  }
  
  async getUser(id) {
    return this.get('users', id);
  }
  
  async getAllUsers() {
    return this.getAll('users');
  }
  
  async updateUser(user) {
    return this.put('users', user);
  }
  
  async deleteUser(id) {
    return this.delete('users', id);
  }
}

// Using the wrapper
const userDB = new UserDatabase();

// Add a user
userDB.addUser({
  id: 1,
  name: 'Jane Smith',
  email: 'jane@example.com',
  age: 28
}).then(id => {
  console.log('Added user with ID:', id);
  
  // Get all users
  return userDB.getAllUsers();
}).then(users => {
  console.log('All users:', users);
}).catch(error => {
  console.error('Error:', error);
});
```

2. **Storing and Retrieving Binary Data (Blobs/Files):**

```javascript
async function storeFile(file) {
  try {
    const db = await openDatabase();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['files'], 'readwrite');
      const store = transaction.objectStore('files');
      
      // Create a file object with metadata
      const fileObj = {
        id: Date.now(), // Using timestamp as ID
        name: file.name,
        type: file.type,
        size: file.size,
        lastModified: file.lastModified,
        content: file // Store the actual File/Blob object
      };
      
      const request = store.add(fileObj);
      
      request.onsuccess = () => {
        resolve(request.result);
      };
      
      request.onerror = () => {
        reject('Error storing file: ' + request.error);
      };
      
      transaction.oncomplete = () => {
        db.close();
      };
    });
  } catch (error) {
    console.error('Error in storeFile:', error);
    throw error;
  }
}

async function retrieveFile(id) {
  try {
    const db = await openDatabase();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['files'], 'readonly');
      const store = transaction.objectStore('files');
      
      const request = store.get(id);
      
      request.onsuccess = () => {
        if (request.result) {
          // Create a URL for the blob that can be used in an <img>, <audio>, etc.
          const url = URL.createObjectURL(request.result.content);
          resolve({
            metadata: {
              name: request.result.name,
              type: request.result.type,
              size: request.result.size,
              lastModified: request.result.lastModified
            },
            blob: request.result.content,
            url: url
          });
        } else {
          resolve(null);
        }
      };
      
      request.onerror = () => {
        reject('Error retrieving file: ' + request.error);
      };
      
      transaction.oncomplete = () => {
        db.close();
      };
    });
  } catch (error) {
    console.error('Error in retrieveFile:', error);
    throw error;
  }
}

// Usage with file input
document.getElementById('fileInput').addEventListener('change', async (event) => {
  const file = event.target.files[0];
  if (file) {
    try {
      const fileId = await storeFile(file);
      console.log('File stored with ID:', fileId);
      
      // Retrieve and display the file
      const fileData = await retrieveFile(fileId);
      
      if (fileData) {
        // Display image if it's an image
        if (fileData.metadata.type.startsWith('image/')) {
          const img = document.createElement('img');
          img.src = fileData.url;
          document.body.appendChild(img);
        }
        
        // Create download link
        const link = document.createElement('a');
        link.href = fileData.url;
        link.download = fileData.metadata.name;
        link.textContent = `Download ${fileData.metadata.name}`;
        document.body.appendChild(link);
      }
    } catch (error) {
      console.error('Error handling file:', error);
    }
  }
});
```

3. **Implementing Versioned Database Migrations:**

```javascript
class DatabaseMigration {
  constructor() {
    this.dbName = 'AppDatabase';
    this.migrations = [
      // Version 1: Initial schema
      {
        version: 1,
        migrate: (db) => {
          const userStore = db.createObjectStore('users', { keyPath: 'id' });
          userStore.createIndex('email', 'email', { unique: true });
        }
      },
      // Version 2: Add tasks store
      {
        version: 2,
        migrate: (db) => {
          const taskStore = db.createObjectStore('tasks', { keyPath: 'id', autoIncrement: true });
          taskStore.createIndex('userId', 'userId', { unique: false });
          taskStore.createIndex('completed', 'completed', { unique: false });
        }
      },
      // Version 3: Add name index to users
      {
        version: 3,
        migrate: (db) => {
          const userStore = db.transaction.objectStore('users');
          userStore.createIndex('name', 'name', { unique: false });
        }
      },
      // Version 4: Add settings store
      {
        version: 4,
        migrate: (db) => {
          db.createObjectStore('settings', { keyPath: 'key' });
        }
      }
    ];
  }
  
  get currentVersion() {
    return this.migrations.length;
  }
  
  async openDatabase() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.currentVersion);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        const oldVersion = event.oldVersion;
        
        // Apply all migrations that are newer than the old version
        for (const migration of this.migrations) {
          if (migration.version > oldVersion) {
            console.log(`Applying migration to version ${migration.version}`);
            migration.migrate(db);
          }
        }
      };
      
      request.onsuccess = (event) => {
        resolve(event.target.result);
      };
      
      request.onerror = (event) => {
        reject('Error opening database: ' + event.target.error);
      };
    });
  }
}

// Usage
const dbMigration = new DatabaseMigration();
dbMigration.openDatabase().then(db => {
  console.log('Database opened successfully with version:', db.version);
  // Use the database...
}).catch(error => {
  console.error('Error opening database:', error);
});
```

**Practical Use Cases for IndexedDB:**

1. **Offline Web Applications:**
   - Store application data locally for offline use
   - Sync with server when connection is restored

2. **Caching API Responses:**
   - Store API responses to reduce network requests
   - Implement a cache-first strategy for faster loading

3. **Large Dataset Management:**
   - Handle datasets too large for memory or localStorage
   - Implement pagination and filtering on client-side data

4. **File Storage and Management:**
   - Store user-uploaded files before sending to server
   - Create browser-based file managers or media libraries

5. **Progressive Web Apps (PWAs):**
   - Store application state and user data
   - Enable full offline functionality

**Example: Building a Simple Offline-Capable Todo App:**

```javascript
class TodoApp {
  constructor() {
    this.dbName = 'TodoApp';
    this.dbVersion = 1;
    this.db = null;
    this.initUI();
    this.openDatabase().then(() => {
      this.loadTodos();
    });
  }
  
  async openDatabase() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Create todos store with auto-incrementing ID
        const store = db.createObjectStore('todos', { keyPath: 'id', autoIncrement: true });
        store.createIndex('completed', 'completed', { unique: false });
        store.createIndex('createdAt', 'createdAt', { unique: false });
      };
      
      request.onsuccess = (event) => {
        this.db = event.target.result;
        resolve();
      };
      
      request.onerror = (event) => {
        console.error('Error opening database:', event.target.error);
        reject(event.target.error);
      };
    });
  }
  
  initUI() {
    // Create UI elements
    this.todoList = document.getElementById('todo-list');
    this.todoForm = document.getElementById('todo-form');
    this.todoInput = document.getElementById('todo-input');
    
    // Add event listeners
    this.todoForm.addEventListener('submit', (e) => {
      e.preventDefault();
      this.addTodo();
    });
    
    // Add sync status indicator
    this.syncStatus = document.getElementById('sync-status');
    window.addEventListener('online', () => this.updateSyncStatus());
    window.addEventListener('offline', () => this.updateSyncStatus());
    this.updateSyncStatus();
  }
  
  updateSyncStatus() {
    if (navigator.onLine) {
      this.syncStatus.textContent = 'Online - Changes will sync';
      this.syncStatus.className = 'online';
      this.syncWithServer();
    } else {
      this.syncStatus.textContent = 'Offline - Changes saved locally';
      this.syncStatus.className = 'offline';
    }
  }
  
  async addTodo() {
    const text = this.todoInput.value.trim();
    if (!text) return;
    
    const todo = {
      text: text,
      completed: false,
      createdAt: new Date().toISOString(),
      synced: false
    };
    
    try {
      const id = await this.saveTodo(todo);
      todo.id = id;
      this.renderTodo(todo);
      this.todoInput.value = '';
      
      // Try to sync if online
      if (navigator.onLine) {
        this.syncWithServer();
      }
    } catch (error) {
      console.error('Error adding todo:', error);
    }
  }
  
  async saveTodo(todo) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['todos'], 'readwrite');
      const store = transaction.objectStore('todos');
      
      const request = store.add(todo);
      
      request.onsuccess = () => {
        resolve(request.result);
      };
      
      request.onerror = () => {
        reject(request.error);
      };
    });
  }
  
  async updateTodo(id, updates) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['todos'], 'readwrite');
      const store = transaction.objectStore('todos');
      
      // First get the current todo
      const getRequest = store.get(id);
      
      getRequest.onsuccess = () => {
        const todo = getRequest.result;
        if (!todo) {
          reject(new Error('Todo not found'));
          return;
        }
        
        // Apply updates
        Object.assign(todo, updates, { synced: false });
        
        // Save the updated todo
        const updateRequest = store.put(todo);
        
        updateRequest.onsuccess = () => {
          resolve(todo);
        };
        
        updateRequest.onerror = () => {
          reject(updateRequest.error);
        };
      };
      
      getRequest.onerror = () => {
        reject(getRequest.error);
      };
    });
  }
  
  async deleteTodo(id) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['todos'], 'readwrite');
      const store = transaction.objectStore('todos');
      
      const request = store.delete(id);
      
      request.onsuccess = () => {
        resolve();
      };
      
      request.onerror = () => {
        reject(request.error);
      };
    });
  }
  
  async loadTodos() {
    try {
      const todos = await this.getAllTodos();
      this.todoList.innerHTML = '';
      todos.forEach(todo => {
        this.renderTodo(todo);
      });
    } catch (error) {
      console.error('Error loading todos:', error);
    }
  }
  
  async getAllTodos() {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['todos'], 'readonly');
      const store = transaction.objectStore('todos');
      const index = store.index('createdAt');
      
      const request = index.openCursor(null, 'prev'); // Get newest first
      const todos = [];
      
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          todos.push(cursor.value);
          cursor.continue();
        } else {
          resolve(todos);
        }
      };
      
      request.onerror = () => {
        reject(request.error);
      };
    });
  }
  
  renderTodo(todo) {
    const li = document.createElement('li');
    li.dataset.id = todo.id;
    li.className = todo.completed ? 'completed' : '';
    
    // Create checkbox
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = todo.completed;
    checkbox.addEventListener('change', () => {
      this.toggleTodoCompleted(todo.id, checkbox.checked);
    });
    
    // Create text span
    const span = document.createElement('span');
    span.textContent = todo.text;
    
    // Create delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Delete';
    deleteBtn.addEventListener('click', () => {
      this.removeTodo(todo.id);
    });
    
    // Create sync indicator
    const syncIndicator = document.createElement('span');
    syncIndicator.className = `sync-indicator ${todo.synced ? 'synced' : 'not-synced'}`;
    syncIndicator.title = todo.synced ? 'Synced with server' : 'Not yet synced';
    
    // Append elements
    li.appendChild(checkbox);
    li.appendChild(span);
    li.appendChild(deleteBtn);
    li.appendChild(syncIndicator);
    
    this.todoList.appendChild(li);
  }
  
  async toggleTodoCompleted(id, completed) {
    try {
      const todo = await this.updateTodo(id, { completed });
      
      // Update UI
      const li = this.todoList.querySelector(`li[data-id="${id}"]`);
      if (li) {
        li.className = completed ? 'completed' : '';
        const syncIndicator = li.querySelector('.sync-indicator');
        syncIndicator.className = 'sync-indicator not-synced';
        syncIndicator.title = 'Not yet synced';
      }
      
      // Try to sync if online
      if (navigator.onLine) {
        this.syncWithServer();
      }
    } catch (error) {
      console.error('Error toggling todo:', error);
    }
  }
  
  async removeTodo(id) {
    try {
      await this.deleteTodo(id);
      
      // Update UI
      const li = this.todoList.querySelector(`li[data-id="${id}"]`);
      if (li) {
        li.remove();
      }
      
      // If online, sync the deletion with server
      if (navigator.onLine) {
        // In a real app, you would send a DELETE request to the server
        console.log('Syncing deletion with server for todo ID:', id);
      }
    } catch (error) {
      console.error('Error removing todo:', error);
    }
  }
  
  async syncWithServer() {
    try {
      // Get all unsynced todos
      const unsyncedTodos = await this.getUnsyncedTodos();
      
      if (unsyncedTodos.length === 0) return;
      
      console.log('Syncing todos with server:', unsyncedTodos);
      
      // In a real app, you would send these to your server API
      // For this example, we'll simulate a successful sync
      for (const todo of unsyncedTodos) {
        // Simulate API call
        await this.simulateApiSync(todo);
        
        // Mark as synced in local DB
        await this.updateTodo(todo.id, { synced: true });
        
        // Update UI
        const li = this.todoList.querySelector(`li[data-id="${todo.id}"]`);
        if (li) {
          const syncIndicator = li.querySelector('.sync-indicator');
          syncIndicator.className = 'sync-indicator synced';
          syncIndicator.title = 'Synced with server';
        }
      }
      
      console.log('Sync complete');
    } catch (error) {
      console.error('Error syncing with server:', error);
    }
  }
  
  async getUnsyncedTodos() {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(['todos'], 'readonly');
      const store = transaction.objectStore('todos');
      
      const request = store.openCursor();
      const unsyncedTodos = [];
      
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          if (!cursor.value.synced) {
            unsyncedTodos.push(cursor.value);
          }
          cursor.continue();
        } else {
          resolve(unsyncedTodos);
        }
      };
      
      request.onerror = () => {
        reject(request.error);
      };
    });
  }
  
  // Simulate API call to sync a todo
  async simulateApiSync(todo) {
    return new Promise(resolve => {
      // Simulate network delay
      setTimeout(() => {
        console.log('Todo synced with server:', todo);
        resolve({ success: true });
      }, 500);
    });
  }
}

// Initialize the app when the DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  new TodoApp();
});
```

**Browser Compatibility and Limitations:**

1. **Browser Support:**
   - Supported in all modern browsers (Chrome, Firefox, Safari, Edge)
   - Limited support in older browsers
   - Mobile browsers generally have good support

2. **Storage Limits:**
   - Storage limits vary by browser and device
   - Chrome and Firefox typically allow several GB per origin
   - Safari has stricter limits (often around 1GB)
   - Mobile browsers may have lower limits

3. **Performance Considerations:**
   - Avoid storing very large objects in a single record
   - Use indexes for frequently queried properties
   - Be mindful of transaction scope and duration
   - Consider using web workers for intensive operations

**Best Practices for Using IndexedDB:**

1. **Error Handling:**
   - Always implement proper error handling for all database operations
   - Provide fallbacks for browsers that don't support IndexedDB

2. **Transaction Management:**
   - Keep transactions short-lived
   - Don't mix async operations with transactions
   - Use separate transactions for unrelated operations

3. **Schema Design:**
   - Plan for future schema migrations
   - Use appropriate indexes for query patterns
   - Consider data access patterns when designing object stores

4. **Security Considerations:**
   - Never store sensitive data unencrypted
   - Remember that IndexedDB is subject to same-origin policy
   - Clear sensitive data when no longer needed

5. **Offline Synchronization:**
   - Implement a robust sync strategy for offline-first applications
   - Use a queue for pending server operations
   - Handle conflict resolution between local and server data

**Conclusion:**
IndexedDB provides a powerful solution for client-side storage in web applications, enabling complex data management, offline capabilities, and improved performance. By understanding its asynchronous nature, transaction model, and proper usage patterns, developers can create robust web applications that work reliably regardless of network connectivity.

---

## Security

### Q44: Explain common JavaScript security vulnerabilities and how to prevent them.
**Difficulty: Hard**

**Answer:**
JavaScript security is critical for protecting web applications from various attacks. Understanding common vulnerabilities and implementing proper defenses is essential for any senior developer.

**1. Cross-Site Scripting (XSS):**

XSS attacks occur when attackers inject malicious scripts into web pages viewed by other users.

**Types of XSS:**
- **Reflected XSS**: Malicious script comes from the current HTTP request
- **Stored XSS**: Malicious script is stored on the server and delivered later
- **DOM-based XSS**: Vulnerability exists in client-side code

**Example Vulnerability:**
```javascript
// Dangerous: Directly inserting user input into the DOM
function displayComment(comment) {
  const commentSection = document.getElementById('comments');
  commentSection.innerHTML += `<div class="comment">${comment}</div>`; // Vulnerable to XSS
}

// User input: <img src="x" onerror="alert(document.cookie)">
```

**Prevention:**
```javascript
// 1. Output Encoding
function escapeHTML(str) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

function displayComment(comment) {
  const commentSection = document.getElementById('comments');
  commentSection.innerHTML += `<div class="comment">${escapeHTML(comment)}</div>`;
}

// 2. Using safe DOM methods instead of innerHTML
function displayCommentSafely(comment) {
  const commentSection = document.getElementById('comments');
  const commentDiv = document.createElement('div');
  commentDiv.className = 'comment';
  commentDiv.textContent = comment; // Automatically escapes HTML
  commentSection.appendChild(commentDiv);
}

// 3. Using DOMPurify library for sanitization
import DOMPurify from 'dompurify';

function displayFormattedComment(comment) {
  const commentSection = document.getElementById('comments');
  // Sanitize HTML but allow some formatting
  const sanitized = DOMPurify.sanitize(comment, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a'],
    ALLOWED_ATTR: ['href']
  });
  commentSection.innerHTML += `<div class="comment">${sanitized}</div>`;
}
```

**2. Cross-Site Request Forgery (CSRF):**

CSRF attacks trick users into performing unwanted actions on a site they're authenticated to.

**Example Vulnerability:**
```html
<!-- Malicious site with hidden form -->
<form id="csrf-form" action="https://bank.com/transfer" method="POST" style="display:none">
  <input type="hidden" name="recipient" value="attacker" />
  <input type="hidden" name="amount" value="1000" />
</form>
<script>
  document.getElementById('csrf-form').submit();
</script>
```

**Prevention:**
```javascript
// 1. CSRF Tokens
function setupCSRFProtection() {
  // Get CSRF token from meta tag
  const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
  
  // Add to all fetch/XHR requests
  const originalFetch = window.fetch;
  window.fetch = function(url, options = {}) {
    options.headers = options.headers || {};
    options.headers['X-CSRF-Token'] = csrfToken;
    return originalFetch(url, options);
  };
  
  // For XMLHttpRequest
  const originalOpen = XMLHttpRequest.prototype.open;
  XMLHttpRequest.prototype.open = function() {
    const method = arguments[0];
    const xhr = this;
    
    if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(method.toUpperCase())) {
      xhr.addEventListener('readystatechange', function() {
        if (xhr.readyState === 1) { // OPENED
          xhr.setRequestHeader('X-CSRF-Token', csrfToken);
        }
      });
    }
    
    return originalOpen.apply(this, arguments);
  };
}

// 2. SameSite Cookies
// Set in your server response headers:
// Set-Cookie: sessionid=abc123; SameSite=Strict; Secure; HttpOnly
```

**3. Content Security Policy (CSP):**

CSP helps prevent XSS and data injection attacks by controlling which resources can be loaded.

**Implementation:**
```javascript
// Add CSP meta tag
function addCSPMetaTag() {
  const meta = document.createElement('meta');
  meta.httpEquiv = 'Content-Security-Policy';
  meta.content = "default-src 'self'; script-src 'self' https://trusted-cdn.com; style-src 'self' https://trusted-cdn.com; img-src 'self' https://trusted-images.com data:; connect-src 'self' https://api.myservice.com;";
  document.head.appendChild(meta);
}

// Better approach: Set CSP via HTTP header on the server
// Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted-cdn.com;
```

**4. JSON Injection:**

**Example Vulnerability:**
```javascript
// Dangerous: Parsing JSON with embedded JavaScript
function processUserData(jsonString) {
  const userData = eval('(' + jsonString + ')'); // Extremely dangerous!
  return userData;
}
```

**Prevention:**
```javascript
// Always use JSON.parse instead of eval
function processUserData(jsonString) {
  try {
    const userData = JSON.parse(jsonString);
    return userData;
  } catch (e) {
    console.error('Invalid JSON:', e);
    return null;
  }
}
```

**5. Prototype Pollution:**

Prototype pollution occurs when an attacker is able to modify JavaScript's Object prototype.

**Example Vulnerability:**
```javascript
function mergeDeep(target, source) {
  for (const key in source) {
    if (source[key] && typeof source[key] === 'object') {
      if (!target[key]) target[key] = {};
      mergeDeep(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
  return target;
}

// Attacker input: { "__proto__": { "isAdmin": true } }
// Now every object will have isAdmin=true!
```

**Prevention:**
```javascript
function mergeDeepSafely(target, source) {
  for (const key in source) {
    // Prevent prototype pollution
    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      continue;
    }
    
    if (source[key] && typeof source[key] === 'object') {
      if (!target[key]) target[key] = {};
      mergeDeepSafely(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
  return target;
}

// Using Object.create(null) for safer objects
function createSafeObject() {
  return Object.create(null); // No prototype, no pollution
}
```

**6. Insecure Direct Object References (IDOR):**

**Example Vulnerability:**
```javascript
// Client-side code that doesn't validate authorization
async function getUserData(userId) {
  const response = await fetch(`/api/users/${userId}`);
  return response.json();
}

// Attacker can simply change userId to access other users' data
```

**Prevention:**
```javascript
// Always validate on the server side
// Client-side should also implement checks
async function getUserData(userId) {
  // Ensure userId belongs to current user
  if (userId !== currentUser.id && !currentUser.isAdmin) {
    throw new Error('Unauthorized access attempt');
  }
  
  const response = await fetch(`/api/users/${userId}`, {
    headers: {
      'Authorization': `Bearer ${getAuthToken()}`
    }
  });
  
  if (!response.ok) {
    throw new Error('Access denied');
  }
  
  return response.json();
}
```

**7. Sensitive Data Exposure:**

**Example Vulnerability:**
```javascript
// Logging sensitive data
function processPayment(creditCard) {
  console.log('Processing payment for card:', creditCard);
  // Card number now in browser logs, network logs, etc.
}

// Storing sensitive data in localStorage
localStorage.setItem('authToken', token);
localStorage.setItem('userDetails', JSON.stringify(userDetails));
```

**Prevention:**
```javascript
// Mask sensitive data before logging
function processPayment(creditCard) {
  const maskedCard = maskCreditCard(creditCard);
  console.log('Processing payment for card:', maskedCard);
}

function maskCreditCard(cardNumber) {
  return cardNumber.slice(-4).padStart(cardNumber.length, '*');
}

// Use secure storage options
function storeAuthData(token, expiry) {
  // Use sessionStorage for short-lived sensitive data
  sessionStorage.setItem('authToken', token);
  
  // Set expiry
  const expiryTime = expiry || Date.now() + 3600000; // 1 hour default
  sessionStorage.setItem('tokenExpiry', expiryTime);
  
  // For longer sessions, consider httpOnly cookies set by the server
}
```

**8. Insecure Randomness:**

**Example Vulnerability:**
```javascript
// Using Math.random() for security purposes
function generateSessionId() {
  return Math.random().toString(36).substring(2);
}
```

**Prevention:**
```javascript
// Use Crypto API for secure random values
function generateSecureToken(length = 32) {
  const array = new Uint8Array(length);
  window.crypto.getRandomValues(array);
  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
}
```

**9. Third-Party Library Vulnerabilities:**

**Prevention:**
```javascript
// Regular security audits
function auditDependencies() {
  // Use tools like npm audit, Snyk, or OWASP Dependency Check
  const { execSync } = require('child_process');
  try {
    const output = execSync('npm audit --json');
    const results = JSON.parse(output);
    return results;
  } catch (e) {
    console.error('Dependency audit failed:', e);
    return null;
  }
}

// Subresource Integrity for CDN resources
function addScriptWithIntegrity(url, integrity) {
  const script = document.createElement('script');
  script.src = url;
  script.integrity = integrity;
  script.crossOrigin = 'anonymous';
  document.head.appendChild(script);
}
```

**10. Server-Side JavaScript Injection (for Node.js):**

**Example Vulnerability:**
```javascript
// Using eval with user input in Node.js
app.get('/calculate', (req, res) => {
  const { formula } = req.query;
  try {
    const result = eval(formula); // Extremely dangerous!
    res.send({ result });
  } catch (e) {
    res.status(400).send({ error: 'Invalid formula' });
  }
});
```

**Prevention:**
```javascript
// Use a safe math evaluation library
const { evaluate } = require('mathjs');

app.get('/calculate', (req, res) => {
  const { formula } = req.query;
  try {
    // Configure mathjs for safety
    const safeEvaluate = evaluate.limited({
      upper: 1000000 // Limit computation size
    });
    
    const result = safeEvaluate(formula);
    res.send({ result });
  } catch (e) {
    res.status(400).send({ error: 'Invalid formula' });
  }
});
```

**Security Best Practices Summary:**

1. **Input Validation**: Validate all input on both client and server sides
2. **Output Encoding**: Always encode output when displaying user-generated content
3. **Use Safe Methods**: Prefer `textContent` over `innerHTML`
4. **Content Security Policy**: Implement strict CSP headers
5. **HTTPS Everywhere**: Use secure connections for all traffic
6. **Secure Cookies**: Use `Secure`, `HttpOnly`, and `SameSite` flags
7. **Principle of Least Privilege**: Limit what your JavaScript can access
8. **Keep Dependencies Updated**: Regularly audit and update libraries
9. **Implement CSRF Protection**: Use tokens and SameSite cookies
10. **Avoid Dangerous Functions**: Never use `eval()`, `Function()`, `document.write()`, etc.
11. **Sanitize HTML**: Use libraries like DOMPurify for user-generated HTML
12. **Secure Storage**: Be careful what you store in localStorage/sessionStorage
13. **Use Modern APIs**: Prefer modern, secure APIs like Fetch over older alternatives
14. **Error Handling**: Don't expose sensitive information in error messages
15. **Regular Security Testing**: Perform security audits and penetration testing

---

## Modern JavaScript ES2024+ Features and Advanced Patterns

### Q45: How do you implement advanced functional programming patterns in modern JavaScript?
**Difficulty: Expert**

**Answer:**
Modern JavaScript supports sophisticated functional programming patterns that enable elegant, composable, and maintainable code.

**1. Advanced Function Composition and Currying:**
```javascript
// Advanced function composition with type safety
const compose = (...fns) => (value) => fns.reduceRight((acc, fn) => fn(acc), value);
const pipe = (...fns) => (value) => fns.reduce((acc, fn) => fn(acc), value);

// Currying with automatic arity detection
const curry = (fn) => {
  const arity = fn.length;
  return function curried(...args) {
    if (args.length >= arity) {
      return fn.apply(this, args);
    }
    return function(...nextArgs) {
      return curried.apply(this, args.concat(nextArgs));
    };
  };
};

// Partial application with placeholders
const _ = Symbol('placeholder');
const partial = (fn, ...partialArgs) => {
  return (...args) => {
    const finalArgs = [];
    let argIndex = 0;
    
    for (let i = 0; i < partialArgs.length; i++) {
      if (partialArgs[i] === _) {
        finalArgs[i] = args[argIndex++];
      } else {
        finalArgs[i] = partialArgs[i];
      }
    }
    
    return fn(...finalArgs, ...args.slice(argIndex));
  };
};

// Advanced memoization with cache strategies
const memoize = (fn, options = {}) => {
  const {
    maxSize = 100,
    ttl = Infinity,
    keyGenerator = (...args) => JSON.stringify(args),
    onEvict = () => {}
  } = options;
  
  const cache = new Map();
  const timestamps = new Map();
  
  return function memoized(...args) {
    const key = keyGenerator(...args);
    const now = Date.now();
    
    // Check if cached value exists and is not expired
    if (cache.has(key)) {
      const timestamp = timestamps.get(key);
      if (now - timestamp < ttl) {
        return cache.get(key);
      } else {
        cache.delete(key);
        timestamps.delete(key);
      }
    }
    
    // Evict oldest entries if cache is full
    if (cache.size >= maxSize) {
      const oldestKey = cache.keys().next().value;
      const evictedValue = cache.get(oldestKey);
      cache.delete(oldestKey);
      timestamps.delete(oldestKey);
      onEvict(oldestKey, evictedValue);
    }
    
    const result = fn.apply(this, args);
    cache.set(key, result);
    timestamps.set(key, now);
    
    return result;
  };
};

// Usage examples
const add = curry((a, b, c) => a + b + c);
const addFive = add(5);
const addFiveAndTen = addFive(10);
console.log(addFiveAndTen(3)); // 18

const multiply = (a, b) => a * b;
const double = partial(multiply, 2, _);
console.log(double(5)); // 10

// Function composition for data transformation
const users = [
  { name: 'Alice', age: 25, active: true },
  { name: 'Bob', age: 30, active: false },
  { name: 'Charlie', age: 35, active: true }
];

const getActiveUsers = (users) => users.filter(user => user.active);
const getUserNames = (users) => users.map(user => user.name);
const sortNames = (names) => names.sort();
const joinNames = (names) => names.join(', ');

const getActiveUserNames = pipe(
  getActiveUsers,
  getUserNames,
  sortNames,
  joinNames
);

console.log(getActiveUserNames(users)); // "Alice, Charlie"
```

**2. Advanced Monadic Patterns:**
```javascript
// Maybe Monad for null safety
class Maybe {
  constructor(value) {
    this.value = value;
  }
  
  static of(value) {
    return new Maybe(value);
  }
  
  static none() {
    return new Maybe(null);
  }
  
  isNone() {
    return this.value === null || this.value === undefined;
  }
  
  map(fn) {
    return this.isNone() ? Maybe.none() : Maybe.of(fn(this.value));
  }
  
  flatMap(fn) {
    return this.isNone() ? Maybe.none() : fn(this.value);
  }
  
  filter(predicate) {
    return this.isNone() || !predicate(this.value) ? Maybe.none() : this;
  }
  
  getOrElse(defaultValue) {
    return this.isNone() ? defaultValue : this.value;
  }
  
  fold(onNone, onSome) {
    return this.isNone() ? onNone() : onSome(this.value);
  }
}

// Either Monad for error handling
class Either {
  constructor(value, isLeft = false) {
    this.value = value;
    this.isLeft = isLeft;
  }
  
  static left(value) {
    return new Either(value, true);
  }
  
  static right(value) {
    return new Either(value, false);
  }
  
  map(fn) {
    return this.isLeft ? this : Either.right(fn(this.value));
  }
  
  flatMap(fn) {
    return this.isLeft ? this : fn(this.value);
  }
  
  mapLeft(fn) {
    return this.isLeft ? Either.left(fn(this.value)) : this;
  }
  
  fold(onLeft, onRight) {
    return this.isLeft ? onLeft(this.value) : onRight(this.value);
  }
  
  getOrElse(defaultValue) {
    return this.isLeft ? defaultValue : this.value;
  }
}

// IO Monad for side effects
class IO {
  constructor(effect) {
    this.effect = effect;
  }
  
  static of(value) {
    return new IO(() => value);
  }
  
  map(fn) {
    return new IO(() => fn(this.effect()));
  }
  
  flatMap(fn) {
    return new IO(() => fn(this.effect()).effect());
  }
  
  run() {
    return this.effect();
  }
}

// Usage examples
const safeParseInt = (str) => {
  const parsed = parseInt(str, 10);
  return isNaN(parsed) ? Maybe.none() : Maybe.of(parsed);
};

const safeDivide = (a, b) => {
  return b === 0 ? Either.left('Division by zero') : Either.right(a / b);
};

// Chaining operations safely
const result = Maybe.of('42')
  .map(str => parseInt(str, 10))
  .filter(num => num > 0)
  .map(num => num * 2)
  .getOrElse(0);

console.log(result); // 84

// Error handling with Either
const calculation = Either.right(10)
  .flatMap(x => safeDivide(x, 2))
  .flatMap(x => safeDivide(x, 0)) // This will fail
  .map(x => x * 2);

calculation.fold(
  error => console.error('Error:', error),
  value => console.log('Result:', value)
); // Error: Division by zero

// IO for side effects
const readFile = (filename) => new IO(() => {
  // Simulate file reading
  return `Contents of ${filename}`;
});

const processFile = readFile('data.txt')
  .map(content => content.toUpperCase())
  .map(content => content.split(' '));

console.log(processFile.run()); // ["CONTENTS", "OF", "DATA.TXT"]
```

**3. Advanced Async Patterns and Reactive Programming:**
```javascript
// Observable implementation with operators
class Observable {
  constructor(subscribe) {
    this.subscribe = subscribe;
  }
  
  static of(...values) {
    return new Observable(observer => {
      values.forEach(value => observer.next(value));
      observer.complete();
    });
  }
  
  static fromEvent(element, eventName) {
    return new Observable(observer => {
      const handler = event => observer.next(event);
      element.addEventListener(eventName, handler);
      return () => element.removeEventListener(eventName, handler);
    });
  }
  
  static interval(ms) {
    return new Observable(observer => {
      let count = 0;
      const id = setInterval(() => observer.next(count++), ms);
      return () => clearInterval(id);
    });
  }
  
  static merge(...observables) {
    return new Observable(observer => {
      const subscriptions = observables.map(obs => 
        obs.subscribe({
          next: value => observer.next(value),
          error: error => observer.error(error),
          complete: () => {
            // Complete only when all observables complete
            if (subscriptions.every(sub => sub.closed)) {
              observer.complete();
            }
          }
        })
      );
      
      return () => subscriptions.forEach(sub => sub.unsubscribe());
    });
  }
  
  map(fn) {
    return new Observable(observer => {
      return this.subscribe({
        next: value => observer.next(fn(value)),
        error: error => observer.error(error),
        complete: () => observer.complete()
      });
    });
  }
  
  filter(predicate) {
    return new Observable(observer => {
      return this.subscribe({
        next: value => predicate(value) && observer.next(value),
        error: error => observer.error(error),
        complete: () => observer.complete()
      });
    });
  }
  
  debounce(ms) {
    return new Observable(observer => {
      let timeoutId;
      return this.subscribe({
        next: value => {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => observer.next(value), ms);
        },
        error: error => observer.error(error),
        complete: () => observer.complete()
      });
    });
  }
  
  throttle(ms) {
    return new Observable(observer => {
      let lastEmit = 0;
      return this.subscribe({
        next: value => {
          const now = Date.now();
          if (now - lastEmit >= ms) {
            lastEmit = now;
            observer.next(value);
          }
        },
        error: error => observer.error(error),
        complete: () => observer.complete()
      });
    });
  }
  
  scan(accumulator, seed) {
    return new Observable(observer => {
      let acc = seed;
      return this.subscribe({
        next: value => {
          acc = accumulator(acc, value);
          observer.next(acc);
        },
        error: error => observer.error(error),
        complete: () => observer.complete()
      });
    });
  }
  
  switchMap(fn) {
    return new Observable(observer => {
      let innerSubscription;
      return this.subscribe({
        next: value => {
          if (innerSubscription) {
            innerSubscription.unsubscribe();
          }
          innerSubscription = fn(value).subscribe(observer);
        },
        error: error => observer.error(error),
        complete: () => observer.complete()
      });
    });
  }
}

// Advanced async utilities
class AsyncUtils {
  // Retry with exponential backoff
  static async retry(fn, options = {}) {
    const {
      maxAttempts = 3,
      baseDelay = 1000,
      maxDelay = 30000,
      backoffFactor = 2,
      jitter = true
    } = options;
    
    let attempt = 0;
    
    while (attempt < maxAttempts) {
      try {
        return await fn();
      } catch (error) {
        attempt++;
        
        if (attempt >= maxAttempts) {
          throw error;
        }
        
        let delay = Math.min(baseDelay * Math.pow(backoffFactor, attempt - 1), maxDelay);
        
        if (jitter) {
          delay *= (0.5 + Math.random() * 0.5); // Add jitter
        }
        
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  // Circuit breaker pattern
  static createCircuitBreaker(fn, options = {}) {
    const {
      failureThreshold = 5,
      resetTimeout = 60000,
      monitoringPeriod = 10000
    } = options;
    
    let state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    let failureCount = 0;
    let lastFailureTime = null;
    let successCount = 0;
    
    return async (...args) => {
      if (state === 'OPEN') {
        if (Date.now() - lastFailureTime >= resetTimeout) {
          state = 'HALF_OPEN';
          successCount = 0;
        } else {
          throw new Error('Circuit breaker is OPEN');
        }
      }
      
      try {
        const result = await fn(...args);
        
        if (state === 'HALF_OPEN') {
          successCount++;
          if (successCount >= 3) {
            state = 'CLOSED';
            failureCount = 0;
          }
        } else {
          failureCount = 0;
        }
        
        return result;
      } catch (error) {
        failureCount++;
        lastFailureTime = Date.now();
        
        if (failureCount >= failureThreshold) {
          state = 'OPEN';
        }
        
        throw error;
      }
    };
  }
  
  // Rate limiter
  static createRateLimiter(maxRequests, windowMs) {
    const requests = [];
    
    return async (fn) => {
      const now = Date.now();
      
      // Remove old requests outside the window
      while (requests.length > 0 && now - requests[0] >= windowMs) {
        requests.shift();
      }
      
      if (requests.length >= maxRequests) {
        const oldestRequest = requests[0];
        const waitTime = windowMs - (now - oldestRequest);
        await new Promise(resolve => setTimeout(resolve, waitTime));
        return this.createRateLimiter(maxRequests, windowMs)(fn);
      }
      
      requests.push(now);
      return fn();
    };
  }
}

// Usage examples
// Observable usage
const searchInput = document.getElementById('search');
const search$ = Observable.fromEvent(searchInput, 'input')
  .map(event => event.target.value)
  .filter(text => text.length > 2)
  .debounce(300)
  .switchMap(query => 
    new Observable(observer => {
      fetch(`/api/search?q=${query}`)
        .then(response => response.json())
        .then(data => {
          observer.next(data);
          observer.complete();
        })
        .catch(error => observer.error(error));
    })
  );

search$.subscribe({
  next: results => console.log('Search results:', results),
  error: error => console.error('Search error:', error)
});

// Async utilities usage
const unreliableAPI = async () => {
  if (Math.random() < 0.7) {
    throw new Error('API failed');
  }
  return { data: 'success' };
};

const reliableAPI = AsyncUtils.createCircuitBreaker(
  () => AsyncUtils.retry(unreliableAPI, { maxAttempts: 3 }),
  { failureThreshold: 3 }
);

const rateLimitedAPI = AsyncUtils.createRateLimiter(5, 1000);

// Usage
rateLimitedAPI(() => reliableAPI())
  .then(result => console.log('API result:', result))
  .catch(error => console.error('API error:', error));
```

### Q46: How do you implement advanced state management patterns in vanilla JavaScript?
**Difficulty: Expert**

**Answer:**
Modern JavaScript applications require sophisticated state management patterns that provide predictability, debugging capabilities, and performance optimization.

**1. Advanced State Machine Implementation:**
```javascript
// Finite State Machine with guards and actions
class StateMachine {
  constructor(config) {
    this.states = config.states;
    this.initialState = config.initialState;
    this.context = config.context || {};
    this.currentState = this.initialState;
    this.listeners = [];
    this.history = [];
    this.maxHistorySize = config.maxHistorySize || 100;
  }
  
  // Transition to a new state
  transition(event, payload = {}) {
    const currentStateConfig = this.states[this.currentState];
    const transition = currentStateConfig.on?.[event];
    
    if (!transition) {
      console.warn(`No transition for event '${event}' in state '${this.currentState}'`);
      return false;
    }
    
    const { target, guard, actions } = transition;
    
    // Check guard condition
    if (guard && !guard(this.context, payload)) {
      console.warn(`Guard condition failed for transition '${event}'`);
      return false;
    }
    
    // Store previous state in history
    this.history.push({
      state: this.currentState,
      event,
      payload,
      timestamp: Date.now(),
      context: { ...this.context }
    });
    
    // Limit history size
    if (this.history.length > this.maxHistorySize) {
      this.history.shift();
    }
    
    // Execute exit actions
    if (currentStateConfig.exit) {
      currentStateConfig.exit(this.context, payload);
    }
    
    // Execute transition actions
    if (actions) {
      actions.forEach(action => action(this.context, payload));
    }
    
    // Change state
    const previousState = this.currentState;
    this.currentState = target;
    
    // Execute entry actions
    const newStateConfig = this.states[this.currentState];
    if (newStateConfig.entry) {
      newStateConfig.entry(this.context, payload);
    }
    
    // Notify listeners
    this.notifyListeners({
      type: 'STATE_CHANGE',
      previousState,
      currentState: this.currentState,
      event,
      payload,
      context: this.context
    });
    
    return true;
  }
  
  // Get current state
  getState() {
    return {
      state: this.currentState,
      context: { ...this.context },
      canTransition: (event) => {
        const currentStateConfig = this.states[this.currentState];
        return !!currentStateConfig.on?.[event];
      }
    };
  }
  
  // Subscribe to state changes
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      const index = this.listeners.indexOf(listener);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }
  
  notifyListeners(event) {
    this.listeners.forEach(listener => {
      try {
        listener(event);
      } catch (error) {
        console.error('Error in state machine listener:', error);
      }
    });
  }
  
  // Get state history
  getHistory() {
    return [...this.history];
  }
  
  // Reset to initial state
  reset() {
    this.currentState = this.initialState;
    this.context = {};
    this.history = [];
    this.notifyListeners({
      type: 'RESET',
      currentState: this.currentState
    });
  }
}

// Usage example: User authentication state machine
const authStateMachine = new StateMachine({
  initialState: 'idle',
  context: {
    user: null,
    token: null,
    loginAttempts: 0
  },
  states: {
    idle: {
      on: {
        LOGIN_START: {
          target: 'authenticating',
          actions: [(context, payload) => {
            context.loginAttempts++;
          }]
        },
        CHECK_AUTH: {
          target: 'authenticated',
          guard: (context) => !!context.token
        }
      }
    },
    authenticating: {
      entry: (context, payload) => {
        console.log('Starting authentication...');
      },
      on: {
        LOGIN_SUCCESS: {
          target: 'authenticated',
          actions: [(context, payload) => {
            context.user = payload.user;
            context.token = payload.token;
            context.loginAttempts = 0;
          }]
        },
        LOGIN_FAILURE: {
          target: 'idle',
          guard: (context) => context.loginAttempts < 3,
          actions: [(context, payload) => {
            console.error('Login failed:', payload.error);
          }]
        },
        LOGIN_FAILURE: {
          target: 'locked',
          guard: (context) => context.loginAttempts >= 3
        }
      }
    },
    authenticated: {
      entry: (context) => {
        console.log('User authenticated:', context.user);
      },
      on: {
        LOGOUT: {
          target: 'idle',
          actions: [(context) => {
            context.user = null;
            context.token = null;
          }]
        },
        TOKEN_EXPIRED: {
          target: 'idle',
          actions: [(context) => {
            context.token = null;
          }]
        }
      }
    },
    locked: {
      entry: (context) => {
        console.log('Account locked due to too many failed attempts');
      },
      on: {
        UNLOCK: {
          target: 'idle',
          actions: [(context) => {
            context.loginAttempts = 0;
          }]
        }
      }
    }
  }
});
```

**2. Advanced Store Pattern with Time Travel:**
```javascript
// Advanced store with time travel debugging
class TimeravelStore {
  constructor(initialState = {}, options = {}) {
    this.state = initialState;
    this.history = [{ state: initialState, action: { type: '@@INIT' }, timestamp: Date.now() }];
    this.currentIndex = 0;
    this.maxHistorySize = options.maxHistorySize || 50;
    this.middleware = [];
    this.subscribers = [];
    this.devMode = options.devMode || false;
  }
  
  // Add middleware
  use(middleware) {
    this.middleware.push(middleware);
  }
  
  // Dispatch action
  dispatch(action) {
    // Apply middleware
    let processedAction = action;
    for (const middleware of this.middleware) {
      processedAction = middleware(this.state, processedAction) || processedAction;
    }
    
    // Create new state
    const newState = this.reduce(this.state, processedAction);
    
    // Add to history
    this.history = this.history.slice(0, this.currentIndex + 1);
    this.history.push({
      state: newState,
      action: processedAction,
      timestamp: Date.now()
    });
    
    // Limit history size
    if (this.history.length > this.maxHistorySize) {
      this.history.shift();
    } else {
      this.currentIndex++;
    }
    
    this.state = newState;
    
    // Notify subscribers
    this.notifySubscribers();
    
    if (this.devMode) {
      console.group(`Action: ${processedAction.type}`);
      console.log('Previous State:', this.history[this.currentIndex - 1]?.state);
      console.log('Action:', processedAction);
      console.log('New State:', newState);
      console.groupEnd();
    }
  }
  
  // Reducer function (to be overridden)
  reduce(state, action) {
    return state;
  }
  
  // Get current state
  getState() {
    return this.state;
  }
  
  // Subscribe to state changes
  subscribe(callback) {
    this.subscribers.push(callback);
    return () => {
      const index = this.subscribers.indexOf(callback);
      if (index > -1) {
        this.subscribers.splice(index, 1);
      }
    };
  }
  
  notifySubscribers() {
    this.subscribers.forEach(callback => {
      try {
        callback(this.state);
      } catch (error) {
        console.error('Error in store subscriber:', error);
      }
    });
  }
  
  // Time travel methods
  undo() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      this.state = this.history[this.currentIndex].state;
      this.notifySubscribers();
      return true;
    }
    return false;
  }
  
  redo() {
    if (this.currentIndex < this.history.length - 1) {
      this.currentIndex++;
      this.state = this.history[this.currentIndex].state;
      this.notifySubscribers();
      return true;
    }
    return false;
  }
  
  jumpToState(index) {
    if (index >= 0 && index < this.history.length) {
      this.currentIndex = index;
      this.state = this.history[index].state;
      this.notifySubscribers();
      return true;
    }
    return false;
  }
  
  // Get history for debugging
  getHistory() {
    return this.history.map((entry, index) => ({
      ...entry,
      isCurrent: index === this.currentIndex
    }));
  }
  
  // Export/import state for persistence
  exportState() {
    return {
      state: this.state,
      history: this.history,
      currentIndex: this.currentIndex
    };
  }
  
  importState(exportedState) {
    this.state = exportedState.state;
    this.history = exportedState.history;
    this.currentIndex = exportedState.currentIndex;
    this.notifySubscribers();
  }
}

// Example store implementation
class TodoStore extends TimeravelStore {
  constructor() {
    super({
      todos: [],
      filter: 'all',
      nextId: 1
    }, { devMode: true });
    
    // Add logging middleware
    this.use((state, action) => {
      console.log(`[${new Date().toISOString()}] ${action.type}`);
      return action;
    });
    
    // Add validation middleware
    this.use((state, action) => {
      if (action.type === 'ADD_TODO' && !action.payload.text) {
        console.warn('Cannot add todo without text');
        return null; // Cancel action
      }
      return action;
    });
  }
  
  reduce(state, action) {
    switch (action.type) {
      case 'ADD_TODO':
        return {
          ...state,
          todos: [...state.todos, {
            id: state.nextId,
            text: action.payload.text,
            completed: false,
            createdAt: Date.now()
          }],
          nextId: state.nextId + 1
        };
        
      case 'TOGGLE_TODO':
        return {
          ...state,
          todos: state.todos.map(todo =>
            todo.id === action.payload.id
              ? { ...todo, completed: !todo.completed }
              : todo
          )
        };
        
      case 'DELETE_TODO':
        return {
          ...state,
          todos: state.todos.filter(todo => todo.id !== action.payload.id)
        };
        
      case 'SET_FILTER':
        return {
          ...state,
          filter: action.payload.filter
        };
        
      default:
        return state;
    }
  }
  
  // Action creators
  addTodo(text) {
    this.dispatch({ type: 'ADD_TODO', payload: { text } });
  }
  
  toggleTodo(id) {
    this.dispatch({ type: 'TOGGLE_TODO', payload: { id } });
  }
  
  deleteTodo(id) {
    this.dispatch({ type: 'DELETE_TODO', payload: { id } });
  }
  
  setFilter(filter) {
    this.dispatch({ type: 'SET_FILTER', payload: { filter } });
  }
  
  // Selectors
  getTodos() {
    const state = this.getState();
    switch (state.filter) {
      case 'active':
        return state.todos.filter(todo => !todo.completed);
      case 'completed':
        return state.todos.filter(todo => todo.completed);
      default:
        return state.todos;
    }
  }
  
  getStats() {
    const state = this.getState();
    return {
      total: state.todos.length,
      completed: state.todos.filter(todo => todo.completed).length,
      active: state.todos.filter(todo => !todo.completed).length
    };
  }
}

// Usage
const todoStore = new TodoStore();

// Subscribe to changes
todoStore.subscribe(state => {
  console.log('State updated:', state);
  updateUI();
});

// Add todos
todoStore.addTodo('Learn JavaScript');
todoStore.addTodo('Build awesome apps');

// Toggle completion
todoStore.toggleTodo(1);

// Time travel
console.log('Undoing last action...');
todoStore.undo();

console.log('Redoing action...');
todoStore.redo();

// Export state for persistence
const savedState = todoStore.exportState();
localStorage.setItem('todoState', JSON.stringify(savedState));

// Import state on app load
const loadedState = JSON.parse(localStorage.getItem('todoState') || '{}');
if (loadedState.state) {
  todoStore.importState(loadedState);
}

function updateUI() {
  const todos = todoStore.getTodos();
  const stats = todoStore.getStats();
  
  // Update DOM
  document.getElementById('todo-list').innerHTML = todos
    .map(todo => `
      <li class="${todo.completed ? 'completed' : ''}">
        <input type="checkbox" ${todo.completed ? 'checked' : ''} 
               onchange="todoStore.toggleTodo(${todo.id})">
        <span>${todo.text}</span>
        <button onclick="todoStore.deleteTodo(${todo.id})">Delete</button>
      </li>
    `).join('');
    
  document.getElementById('stats').textContent = 
    `Total: ${stats.total}, Active: ${stats.active}, Completed: ${stats.completed}`;
}
```

---

### Q47: How do you implement advanced JavaScript metaprogramming and reflection patterns?
**Difficulty: Expert**

**Answer:**
Advanced metaprogramming in JavaScript involves dynamic code generation, reflection, and runtime manipulation of objects and functions.

**1. Advanced Proxy Patterns:**
```javascript
// Dynamic API client with automatic method generation
class DynamicAPIClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.options = options;
    
    return new Proxy(this, {
      get(target, prop) {
        if (prop in target) {
          return target[prop];
        }
        
        // Generate API methods dynamically
        if (typeof prop === 'string') {
          return target.createAPIMethod(prop);
        }
      }
    });
  }
  
  createAPIMethod(endpoint) {
    return new Proxy(() => {}, {
      apply: (target, thisArg, args) => {
        const [method = 'GET', data, config = {}] = args;
        return this.request(endpoint, method, data, config);
      },
      
      get: (target, prop) => {
        if (prop === 'get') return (config) => this.request(endpoint, 'GET', null, config);
        if (prop === 'post') return (data, config) => this.request(endpoint, 'POST', data, config);
        if (prop === 'put') return (data, config) => this.request(endpoint, 'PUT', data, config);
        if (prop === 'delete') return (config) => this.request(endpoint, 'DELETE', null, config);
        
        // Nested endpoints
        return this.createAPIMethod(`${endpoint}/${prop}`);
      }
    });
  }
  
  async request(endpoint, method, data, config) {
    const url = `${this.baseURL}/${endpoint}`;
    const options = {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...this.options.headers,
        ...config.headers
      },
      ...config
    };
    
    if (data) {
      options.body = JSON.stringify(data);
    }
    
    const response = await fetch(url, options);
    return response.json();
  }
}

// Usage
const api = new DynamicAPIClient('https://api.example.com');

// All these work dynamically
const users = await api.users.get();
const user = await api.users(1).get();
const newUser = await api.users.post({ name: 'John' });
const posts = await api.users(1).posts.get();
```

**2. Advanced Reflection and Metadata:**
```javascript
// Metadata system with decorators
const MetadataStore = new WeakMap();

function getMetadata(target, key) {
  if (!MetadataStore.has(target)) {
    MetadataStore.set(target, new Map());
  }
  return MetadataStore.get(target).get(key);
}

function setMetadata(target, key, value) {
  if (!MetadataStore.has(target)) {
    MetadataStore.set(target, new Map());
  }
  MetadataStore.get(target).set(key, value);
}

// Validation decorator
function validate(schema) {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function(...args) {
      // Validate arguments
      const errors = validateArgs(args, schema);
      if (errors.length > 0) {
        throw new ValidationError(errors);
      }
      
      return originalMethod.apply(this, args);
    };
    
    // Store validation metadata
    setMetadata(target.constructor, `validation:${propertyKey}`, schema);
  };
}

// Cache decorator with TTL
function cache(ttl = 60000) {
  const cacheStore = new Map();
  
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function(...args) {
      const key = `${propertyKey}:${JSON.stringify(args)}`;
      const cached = cacheStore.get(key);
      
      if (cached && Date.now() - cached.timestamp < ttl) {
        return cached.value;
      }
      
      const result = originalMethod.apply(this, args);
      cacheStore.set(key, { value: result, timestamp: Date.now() });
      
      return result;
    };
  };
}

// Usage
class UserService {
  @validate({
    id: { type: 'number', required: true },
    options: { type: 'object', default: {} }
  })
  @cache(30000)
  async getUser(id, options = {}) {
    // Fetch user logic
    return { id, name: 'John Doe', ...options };
  }
}
```

---

### Q48: How do you implement advanced JavaScript performance optimization and memory management?
**Difficulty: Expert**

**Answer:**
Advanced performance optimization involves sophisticated techniques for memory management, execution optimization, and resource efficiency.

**1. Advanced Memory Management:**
```javascript
// Object pool for reducing GC pressure
class ObjectPool {
  constructor(createFn, resetFn, maxSize = 100) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.maxSize = maxSize;
    this.pool = [];
    this.activeObjects = new Set();
  }
  
  acquire() {
    let obj;
    
    if (this.pool.length > 0) {
      obj = this.pool.pop();
    } else {
      obj = this.createFn();
    }
    
    this.activeObjects.add(obj);
    return obj;
  }
  
  release(obj) {
    if (!this.activeObjects.has(obj)) {
      return false;
    }
    
    this.activeObjects.delete(obj);
    
    if (this.pool.length < this.maxSize) {
      this.resetFn(obj);
      this.pool.push(obj);
    }
    
    return true;
  }
  
  clear() {
    this.pool.length = 0;
    this.activeObjects.clear();
  }
  
  getStats() {
    return {
      poolSize: this.pool.length,
      activeCount: this.activeObjects.size,
      totalCreated: this.pool.length + this.activeObjects.size
    };
  }
}

// Usage for expensive objects
const vectorPool = new ObjectPool(
  () => ({ x: 0, y: 0, z: 0 }),
  (obj) => { obj.x = obj.y = obj.z = 0; }
);

function performCalculations() {
  const vectors = [];
  
  // Acquire objects from pool
  for (let i = 0; i < 1000; i++) {
    const vector = vectorPool.acquire();
    vector.x = Math.random();
    vector.y = Math.random();
    vector.z = Math.random();
    vectors.push(vector);
  }
  
  // Perform calculations...
  
  // Release objects back to pool
  vectors.forEach(vector => vectorPool.release(vector));
}
```

**2. Advanced Execution Optimization:**
```javascript
// Memoization with LRU cache and weak references
class AdvancedMemoizer {
  constructor(maxSize = 1000, ttl = 300000) {
    this.maxSize = maxSize;
    this.ttl = ttl;
    this.cache = new Map();
    this.accessOrder = new Map();
    this.timers = new Map();
  }
  
  memoize(fn) {
    return (...args) => {
      const key = this.createKey(args);
      
      if (this.cache.has(key)) {
        this.updateAccess(key);
        return this.cache.get(key).value;
      }
      
      const result = fn.apply(this, args);
      this.set(key, result);
      
      return result;
    };
  }
  
  createKey(args) {
    return JSON.stringify(args, (key, value) => {
      if (typeof value === 'object' && value !== null) {
        return Object.keys(value)
          .sort()
          .reduce((sorted, key) => {
            sorted[key] = value[key];
            return sorted;
          }, {});
      }
      return value;
    });
  }
  
  set(key, value) {
    // Remove oldest if at capacity
    if (this.cache.size >= this.maxSize) {
      const oldestKey = this.accessOrder.keys().next().value;
      this.delete(oldestKey);
    }
    
    const entry = { value, timestamp: Date.now() };
    this.cache.set(key, entry);
    this.updateAccess(key);
    
    // Set TTL timer
    if (this.ttl > 0) {
      const timer = setTimeout(() => this.delete(key), this.ttl);
      this.timers.set(key, timer);
    }
  }
  
  updateAccess(key) {
    this.accessOrder.delete(key);
    this.accessOrder.set(key, Date.now());
  }
  
  delete(key) {
    this.cache.delete(key);
    this.accessOrder.delete(key);
    
    const timer = this.timers.get(key);
    if (timer) {
      clearTimeout(timer);
      this.timers.delete(key);
    }
  }
  
  clear() {
    this.cache.clear();
    this.accessOrder.clear();
    this.timers.forEach(timer => clearTimeout(timer));
    this.timers.clear();
  }
  
  getStats() {
    return {
      size: this.cache.size,
      hitRate: this.hitCount / (this.hitCount + this.missCount) || 0,
      memoryUsage: this.estimateMemoryUsage()
    };
  }
  
  estimateMemoryUsage() {
    let size = 0;
    for (const [key, value] of this.cache) {
      size += key.length * 2; // Rough string size
      size += JSON.stringify(value).length * 2;
    }
    return size;
  }
}

// Usage
const memoizer = new AdvancedMemoizer(500, 60000);

const expensiveCalculation = memoizer.memoize((x, y, options) => {
  // Simulate expensive calculation
  let result = 0;
  for (let i = 0; i < 1000000; i++) {
    result += Math.sin(x * i) * Math.cos(y * i);
  }
  return result * (options.multiplier || 1);
});
```

---

### Q49: How do you implement advanced JavaScript ES2024+ features including Records, Tuples, and Pattern Matching?

**Answer:**
ES2024+ introduces powerful new features like Records and Tuples for immutable data structures, pattern matching for complex conditional logic, and enhanced temporal APIs for better date/time handling.

**Records and Tuples (Immutable Data Structures):**
```javascript
// Records - Immutable objects with value semantics
const userRecord = #{ 
  id: 1, 
  name: "John Doe", 
  email: "john@example.com",
  preferences: #{
    theme: "dark",
    notifications: true
  }
};

// Tuples - Immutable arrays with value semantics
const coordinates = #[40.7128, -74.0060, "New York"];
const rgbColor = #[255, 128, 0];

// Advanced Record manipulation
class UserManager {
  constructor() {
    this.users = new Map();
    this.userHistory = new Map();
  }
  
  createUser(userData) {
    const user = #{
      id: this.generateId(),
      ...userData,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      version: 1
    };
    
    this.users.set(user.id, user);
    this.userHistory.set(user.id, #[user]);
    return user;
  }
  
  updateUser(id, updates) {
    const currentUser = this.users.get(id);
    if (!currentUser) {
      throw new Error(`User ${id} not found`);
    }
    
    // Create new immutable user record
    const updatedUser = #{
      ...currentUser,
      ...updates,
      updatedAt: new Date().toISOString(),
      version: currentUser.version + 1
    };
    
    // Update user and maintain history
    this.users.set(id, updatedUser);
    const history = this.userHistory.get(id);
    this.userHistory.set(id, #[...history, updatedUser]);
    
    return updatedUser;
  }
  
  getUserHistory(id) {
    return this.userHistory.get(id) || #[];
  }
  
  // Advanced querying with Records
  findUsers(predicate) {
    const results = #[];
    for (const user of this.users.values()) {
      if (predicate(user)) {
        results = #[...results, user];
      }
    }
    return results;
  }
  
  // Batch operations with immutable data
  batchUpdate(updates) {
    const results = #{};
    const errors = #{};
    
    for (const [id, updateData] of Object.entries(updates)) {
      try {
        const updated = this.updateUser(id, updateData);
        results = #{...results, [id]: updated};
      } catch (error) {
        errors = #{...errors, [id]: error.message};
      }
    }
    
    return #{ results, errors };
  }
  
  private generateId() {
    return Math.random().toString(36).substring(2, 15);
  }
}

// Advanced Tuple operations
class GeometryCalculator {
  static distance(point1, point2) {
    const [x1, y1] = point1;
    const [x2, y2] = point2;
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
  }
  
  static midpoint(point1, point2) {
    const [x1, y1] = point1;
    const [x2, y2] = point2;
    return #[(x1 + x2) / 2, (y1 + y2) / 2];
  }
  
  static translatePoint(point, vector) {
    const [x, y] = point;
    const [dx, dy] = vector;
    return #[x + dx, y + dy];
  }
  
  static rotatePoint(point, angle, origin = #[0, 0]) {
    const [x, y] = point;
    const [ox, oy] = origin;
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    
    const translatedX = x - ox;
    const translatedY = y - oy;
    
    const rotatedX = translatedX * cos - translatedY * sin;
    const rotatedY = translatedX * sin + translatedY * cos;
    
    return #[rotatedX + ox, rotatedY + oy];
  }
  
  // Advanced polygon operations
  static calculatePolygonArea(vertices) {
    let area = 0;
    const n = vertices.length;
    
    for (let i = 0; i < n; i++) {
      const [x1, y1] = vertices[i];
      const [x2, y2] = vertices[(i + 1) % n];
      area += x1 * y2 - x2 * y1;
    }
    
    return Math.abs(area) / 2;
  }
}

// Color manipulation with Tuples
class ColorUtils {
  static rgbToHsl(rgb) {
    const [r, g, b] = rgb.map(c => c / 255);
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const diff = max - min;
    
    let h = 0;
    if (diff !== 0) {
      switch (max) {
        case r: h = ((g - b) / diff) % 6; break;
        case g: h = (b - r) / diff + 2; break;
        case b: h = (r - g) / diff + 4; break;
      }
    }
    
    const l = (max + min) / 2;
    const s = diff === 0 ? 0 : diff / (1 - Math.abs(2 * l - 1));
    
    return #[Math.round(h * 60), Math.round(s * 100), Math.round(l * 100)];
  }
  
  static blendColors(color1, color2, ratio = 0.5) {
    const [r1, g1, b1] = color1;
    const [r2, g2, b2] = color2;
    
    return #[
      Math.round(r1 * (1 - ratio) + r2 * ratio),
      Math.round(g1 * (1 - ratio) + g2 * ratio),
      Math.round(b1 * (1 - ratio) + b2 * ratio)
    ];
  }
  
  static generatePalette(baseColor, count = 5) {
    const palette = #[baseColor];
    const [h, s, l] = this.rgbToHsl(baseColor);
    
    for (let i = 1; i < count; i++) {
      const newH = (h + (360 / count) * i) % 360;
      const newColor = this.hslToRgb(#[newH, s, l]);
      palette = #[...palette, newColor];
    }
    
    return palette;
  }
  
  static hslToRgb(hsl) {
    const [h, s, l] = [hsl[0] / 360, hsl[1] / 100, hsl[2] / 100];
    
    const c = (1 - Math.abs(2 * l - 1)) * s;
    const x = c * (1 - Math.abs((h * 6) % 2 - 1));
    const m = l - c / 2;
    
    let r, g, b;
    
    if (h < 1/6) [r, g, b] = [c, x, 0];
    else if (h < 2/6) [r, g, b] = [x, c, 0];
    else if (h < 3/6) [r, g, b] = [0, c, x];
    else if (h < 4/6) [r, g, b] = [0, x, c];
    else if (h < 5/6) [r, g, b] = [x, 0, c];
    else [r, g, b] = [c, 0, x];
    
    return #[
      Math.round((r + m) * 255),
      Math.round((g + m) * 255),
      Math.round((b + m) * 255)
    ];
  }
}
```

**Pattern Matching (Proposed Feature):**
```javascript
// Advanced pattern matching for complex data structures
class DataProcessor {
  static processApiResponse(response) {
    return match (response) {
      when ({ status: 200, data: { users: Array } }) => {
        return this.processUsers(response.data.users);
      }
      when ({ status: 200, data: { user: Object } }) => {
        return this.processSingleUser(response.data.user);
      }
      when ({ status: 404 }) => {
        throw new Error('Resource not found');
      }
      when ({ status: Number if status >= 400 && status < 500 }) => {
        throw new Error(`Client error: ${response.message}`);
      }
      when ({ status: Number if status >= 500 }) => {
        throw new Error(`Server error: ${response.message}`);
      }
      default => {
        throw new Error('Unknown response format');
      }
    };
  }
  
  static processEvent(event) {
    return match (event) {
      when ({ type: 'user:created', payload: { id: String, email: String } }) => {
        return this.handleUserCreated(event.payload);
      }
      when ({ type: 'user:updated', payload: { id: String, changes: Object } }) => {
        return this.handleUserUpdated(event.payload);
      }
      when ({ type: 'user:deleted', payload: { id: String } }) => {
        return this.handleUserDeleted(event.payload);
      }
      when ({ type: String if type.startsWith('order:') }) => {
        return this.handleOrderEvent(event);
      }
      when ({ type: String if type.startsWith('payment:') }) => {
        return this.handlePaymentEvent(event);
      }
      default => {
        console.warn('Unhandled event type:', event.type);
      }
    };
  }
  
  // Advanced pattern matching with destructuring
  static analyzeUserBehavior(actions) {
    return match (actions) {
      when ([{ type: 'login' }, ...rest] if rest.length === 0) => {
        return 'single_login';
      }
      when ([{ type: 'login' }, { type: 'view_product' }, { type: 'purchase' }]) => {
        return 'quick_purchase';
      }
      when ([{ type: 'login' }, ...middle, { type: 'logout' }] if middle.every(a => a.type !== 'purchase')) => {
        return 'browsing_session';
      }
      when (Array if actions.filter(a => a.type === 'purchase').length > 3) => {
        return 'power_shopper';
      }
      when (Array if actions.length > 50) => {
        return 'heavy_user';
      }
      default => {
        return 'normal_user';
      }
    };
  }
  
  // Pattern matching with complex conditions
  static calculateShipping(order) {
    return match (order) {
      when ({ 
        items: Array if items.length > 0,
        total: Number if total > 100,
        destination: { country: 'US' }
      }) => {
        return { cost: 0, method: 'free_shipping' };
      }
      when ({ 
        items: Array if items.some(item => item.category === 'electronics'),
        destination: { country: String if ['US', 'CA'].includes(country) }
      }) => {
        return { cost: 15, method: 'express' };
      }
      when ({ 
        total: Number if total < 25,
        destination: { country: 'US' }
      }) => {
        return { cost: 5, method: 'standard' };
      }
      when ({ destination: { country: String if !['US', 'CA'].includes(country) } }) => {
        return { cost: 25, method: 'international' };
      }
      default => {
        return { cost: 10, method: 'standard' };
      }
    };
  }
}

// State machine with pattern matching
class OrderStateMachine {
  constructor(initialState = 'pending') {
    this.state = initialState;
    this.history = [initialState];
  }
  
  transition(event) {
    const newState = match ([this.state, event]) {
      when (['pending', { type: 'payment_received' }]) => 'processing';
      when (['pending', { type: 'cancel' }]) => 'cancelled';
      when (['processing', { type: 'items_shipped' }]) => 'shipped';
      when (['processing', { type: 'payment_failed' }]) => 'payment_failed';
      when (['shipped', { type: 'delivered' }]) => 'completed';
      when (['shipped', { type: 'return_requested' }]) => 'return_pending';
      when (['payment_failed', { type: 'payment_retry_success' }]) => 'processing';
      when (['return_pending', { type: 'return_approved' }]) => 'returned';
      when (['return_pending', { type: 'return_denied' }]) => 'completed';
      default => {
        throw new Error(`Invalid transition from ${this.state} with event ${event.type}`);
      }
    };
    
    this.state = newState;
    this.history.push(newState);
    return newState;
  }
  
  canTransition(eventType) {
    try {
      match ([this.state, { type: eventType }]) {
        when (['pending', { type: 'payment_received' }]) => true;
        when (['pending', { type: 'cancel' }]) => true;
        when (['processing', { type: 'items_shipped' }]) => true;
        when (['processing', { type: 'payment_failed' }]) => true;
        when (['shipped', { type: 'delivered' }]) => true;
        when (['shipped', { type: 'return_requested' }]) => true;
        when (['payment_failed', { type: 'payment_retry_success' }]) => true;
        when (['return_pending', { type: 'return_approved' }]) => true;
        when (['return_pending', { type: 'return_denied' }]) => true;
        default => false;
      };
      return true;
    } catch {
      return false;
    }
  }
}
```

---

### Q50: How do you implement advanced JavaScript temporal APIs and modern asynchronous patterns with AbortController and Structured Concurrency?

**Answer:**
Modern JavaScript provides powerful temporal APIs for precise date/time handling and advanced asynchronous patterns with AbortController for cancellation and structured concurrency for better async flow control.

**Advanced Temporal API Usage:**
```javascript
// Advanced date/time operations with Temporal API
class AdvancedScheduler {
  constructor() {
    this.events = new Map();
    this.timezones = new Map();
    this.recurringEvents = new Map();
  }
  
  // Create timezone-aware events
  createEvent(eventData) {
    const event = {
      id: this.generateId(),
      title: eventData.title,
      startTime: Temporal.ZonedDateTime.from(eventData.startTime),
      endTime: Temporal.ZonedDateTime.from(eventData.endTime),
      timezone: eventData.timezone,
      recurrence: eventData.recurrence,
      attendees: eventData.attendees || [],
      created: Temporal.Now.zonedDateTimeISO()
    };
    
    this.events.set(event.id, event);
    
    if (event.recurrence) {
      this.setupRecurringEvent(event);
    }
    
    return event;
  }
  
  // Advanced timezone conversions
  convertEventToTimezone(eventId, targetTimezone) {
    const event = this.events.get(eventId);
    if (!event) throw new Error('Event not found');
    
    return {
      ...event,
      startTime: event.startTime.withTimeZone(targetTimezone),
      endTime: event.endTime.withTimeZone(targetTimezone),
      originalTimezone: event.timezone,
      convertedTo: targetTimezone
    };
  }
  
  // Find optimal meeting times across timezones
  findOptimalMeetingTime(attendees, duration, dateRange) {
    const startDate = Temporal.PlainDate.from(dateRange.start);
    const endDate = Temporal.PlainDate.from(dateRange.end);
    const durationObj = Temporal.Duration.from(duration);
    
    const candidates = [];
    
    for (let date = startDate; Temporal.PlainDate.compare(date, endDate) <= 0; date = date.add({ days: 1 })) {
      // Check business hours (9 AM - 6 PM) for each timezone
      for (let hour = 9; hour <= 18 - durationObj.hours; hour++) {
        const timeSlots = attendees.map(attendee => {
          const localTime = date.toZonedDateTime({
            timeZone: attendee.timezone,
            plainTime: Temporal.PlainTime.from({ hour })
          });
          
          return {
            attendee: attendee.name,
            localTime,
            businessHours: this.isBusinessHours(localTime),
            conflicts: this.checkConflicts(attendee.id, localTime, durationObj)
          };
        });
        
        const viableSlot = timeSlots.every(slot => 
          slot.businessHours && slot.conflicts.length === 0
        );
        
        if (viableSlot) {
          candidates.push({
            utcTime: timeSlots[0].localTime.withTimeZone('UTC'),
            localTimes: timeSlots,
            score: this.calculateTimeSlotScore(timeSlots)
          });
        }
      }
    }
    
    return candidates.sort((a, b) => b.score - a.score);
  }
  
  // Advanced recurring event handling
  setupRecurringEvent(event) {
    const recurrence = event.recurrence;
    const instances = [];
    
    let currentDate = event.startTime.toPlainDate();
    const endDate = Temporal.PlainDate.from(recurrence.until || '2025-12-31');
    
    while (Temporal.PlainDate.compare(currentDate, endDate) <= 0) {
      if (this.matchesRecurrencePattern(currentDate, recurrence)) {
        const instanceStart = currentDate.toZonedDateTime({
          timeZone: event.timezone,
          plainTime: event.startTime.toPlainTime()
        });
        
        const instanceEnd = instanceStart.add(
          event.endTime.since(event.startTime)
        );
        
        instances.push({
          ...event,
          id: `${event.id}_${currentDate.toString()}`,
          startTime: instanceStart,
          endTime: instanceEnd,
          isRecurring: true,
          parentEventId: event.id
        });
      }
      
      currentDate = this.getNextRecurrenceDate(currentDate, recurrence);
    }
    
    this.recurringEvents.set(event.id, instances);
    return instances;
  }
  
  // Business logic helpers
  isBusinessHours(zonedDateTime) {
    const hour = zonedDateTime.hour;
    const dayOfWeek = zonedDateTime.dayOfWeek;
    return dayOfWeek >= 1 && dayOfWeek <= 5 && hour >= 9 && hour <= 17;
  }
  
  calculateTimeSlotScore(timeSlots) {
    // Score based on how close to preferred times (10 AM - 2 PM)
    const preferredStart = 10;
    const preferredEnd = 14;
    
    return timeSlots.reduce((score, slot) => {
      const hour = slot.localTime.hour;
      if (hour >= preferredStart && hour <= preferredEnd) {
        return score + 10;
      } else if (hour >= 9 && hour <= 17) {
        return score + 5;
      }
      return score;
    }, 0);
  }
  
  // Duration calculations and comparisons
  calculateEventDuration(eventId) {
    const event = this.events.get(eventId);
    if (!event) throw new Error('Event not found');
    
    return event.endTime.since(event.startTime);
  }
  
  findLongestEvents(limit = 10) {
    return Array.from(this.events.values())
      .map(event => ({
        ...event,
        duration: this.calculateEventDuration(event.id)
      }))
      .sort((a, b) => Temporal.Duration.compare(b.duration, a.duration))
      .slice(0, limit);
  }
  
  private generateId() {
    return Math.random().toString(36).substring(2, 15);
  }
  
  private matchesRecurrencePattern(date, recurrence) {
    switch (recurrence.frequency) {
      case 'daily':
        return true;
      case 'weekly':
        return recurrence.daysOfWeek?.includes(date.dayOfWeek) ?? true;
      case 'monthly':
        return date.day === recurrence.dayOfMonth;
      case 'yearly':
        return date.month === recurrence.month && date.day === recurrence.dayOfMonth;
      default:
        return false;
    }
  }
  
  private getNextRecurrenceDate(currentDate, recurrence) {
    switch (recurrence.frequency) {
      case 'daily':
        return currentDate.add({ days: recurrence.interval || 1 });
      case 'weekly':
        return currentDate.add({ weeks: recurrence.interval || 1 });
      case 'monthly':
        return currentDate.add({ months: recurrence.interval || 1 });
      case 'yearly':
        return currentDate.add({ years: recurrence.interval || 1 });
      default:
        return currentDate.add({ days: 1 });
    }
  }
}

// Advanced AbortController patterns
class AdvancedAsyncManager {
  constructor() {
    this.activeOperations = new Map();
    this.operationGroups = new Map();
  }
  
  // Structured concurrency with automatic cleanup
  async withConcurrencyScope(operations, options = {}) {
    const { timeout, maxConcurrency = Infinity, failFast = true } = options;
    const controller = new AbortController();
    const scopeId = this.generateId();
    
    // Setup timeout if specified
    let timeoutId;
    if (timeout) {
      timeoutId = setTimeout(() => {
        controller.abort(new Error(`Operation timed out after ${timeout}ms`));
      }, timeout);
    }
    
    try {
      // Limit concurrency using semaphore pattern
      const semaphore = new Semaphore(maxConcurrency);
      const results = [];
      const errors = [];
      
      const wrappedOperations = operations.map(async (operation, index) => {
        await semaphore.acquire();
        
        try {
          if (controller.signal.aborted) {
            throw new Error('Operation aborted');
          }
          
          const result = await operation(controller.signal);
          results[index] = result;
          return result;
        } catch (error) {
          errors[index] = error;
          
          if (failFast) {
            controller.abort(error);
          }
          
          throw error;
        } finally {
          semaphore.release();
        }
      });
      
      if (failFast) {
        await Promise.all(wrappedOperations);
      } else {
        await Promise.allSettled(wrappedOperations);
      }
      
      return { results, errors };
    } finally {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      
      // Cleanup any remaining operations
      controller.abort(new Error('Scope cleanup'));
      this.operationGroups.delete(scopeId);
    }
  }
  
  // Advanced retry with exponential backoff and jitter
  async retryWithBackoff(operation, options = {}) {
    const {
      maxRetries = 3,
      baseDelay = 1000,
      maxDelay = 30000,
      backoffFactor = 2,
      jitter = true,
      retryCondition = () => true
    } = options;
    
    const controller = new AbortController();
    let lastError;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await operation(controller.signal, attempt);
      } catch (error) {
        lastError = error;
        
        if (attempt === maxRetries || !retryCondition(error, attempt)) {
          throw error;
        }
        
        // Calculate delay with exponential backoff and optional jitter
        let delay = Math.min(baseDelay * Math.pow(backoffFactor, attempt), maxDelay);
        
        if (jitter) {
          delay = delay * (0.5 + Math.random() * 0.5); // Add 0-50% jitter
        }
        
        await this.delay(delay, controller.signal);
      }
    }
    
    throw lastError;
  }
  
  // Advanced timeout with custom cleanup
  async withTimeout(operation, timeoutMs, cleanup) {
    const controller = new AbortController();
    
    const timeoutPromise = new Promise((_, reject) => {
      const timeoutId = setTimeout(() => {
        controller.abort();
        reject(new Error(`Operation timed out after ${timeoutMs}ms`));
      }, timeoutMs);
      
      controller.signal.addEventListener('abort', () => {
        clearTimeout(timeoutId);
      });
    });
    
    try {
      return await Promise.race([
        operation(controller.signal),
        timeoutPromise
      ]);
    } catch (error) {
      if (cleanup) {
        await cleanup(error);
      }
      throw error;
    }
  }
  
  // Cancellable fetch with progress tracking
  async fetchWithProgress(url, options = {}) {
    const controller = new AbortController();
    const { onProgress, ...fetchOptions } = options;
    
    try {
      const response = await fetch(url, {
        ...fetchOptions,
        signal: controller.signal
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      if (!onProgress || !response.body) {
        return response;
      }
      
      const contentLength = parseInt(response.headers.get('content-length') || '0');
      let receivedLength = 0;
      
      const reader = response.body.getReader();
      const chunks = [];
      
      while (true) {
        const { done, value } = await reader.read();
        
        if (done) break;
        
        chunks.push(value);
        receivedLength += value.length;
        
        onProgress({
          loaded: receivedLength,
          total: contentLength,
          percentage: contentLength ? (receivedLength / contentLength) * 100 : 0
        });
      }
      
      // Create new response with collected chunks
      const allChunks = new Uint8Array(receivedLength);
      let position = 0;
      
      for (const chunk of chunks) {
        allChunks.set(chunk, position);
        position += chunk.length;
      }
      
      return new Response(allChunks, {
        status: response.status,
        statusText: response.statusText,
        headers: response.headers
      });
    } catch (error) {
      if (error.name === 'AbortError') {
        throw new Error('Request was cancelled');
      }
      throw error;
    }
  }
  
  private async delay(ms, signal) {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(resolve, ms);
      
      signal?.addEventListener('abort', () => {
        clearTimeout(timeoutId);
        reject(new Error('Delay aborted'));
      });
    });
  }
  
  private generateId() {
    return Math.random().toString(36).substring(2, 15);
  }
}

// Semaphore for concurrency control
class Semaphore {
  constructor(maxConcurrency) {
    this.maxConcurrency = maxConcurrency;
    this.currentConcurrency = 0;
    this.waitingQueue = [];
  }
  
  async acquire() {
    if (this.currentConcurrency < this.maxConcurrency) {
      this.currentConcurrency++;
      return;
    }
    
    return new Promise(resolve => {
      this.waitingQueue.push(resolve);
    });
  }
  
  release() {
    this.currentConcurrency--;
    
    if (this.waitingQueue.length > 0) {
      const next = this.waitingQueue.shift();
      this.currentConcurrency++;
      next();
    }
  }
}

// Usage examples
const scheduler = new AdvancedScheduler();
const asyncManager = new AdvancedAsyncManager();

// Create timezone-aware events
const meeting = scheduler.createEvent({
  title: 'Global Team Standup',
  startTime: '2024-03-15T09:00:00[America/New_York]',
  endTime: '2024-03-15T10:00:00[America/New_York]',
  timezone: 'America/New_York',
  attendees: [
    { id: '1', name: 'Alice', timezone: 'America/New_York' },
    { id: '2', name: 'Bob', timezone: 'Europe/London' },
    { id: '3', name: 'Charlie', timezone: 'Asia/Tokyo' }
  ]
});

// Advanced async operations with structured concurrency
async function processDataPipeline() {
  const operations = [
    signal => fetchData('/api/users', { signal }),
    signal => fetchData('/api/orders', { signal }),
    signal => fetchData('/api/products', { signal })
  ];
  
  const { results, errors } = await asyncManager.withConcurrencyScope(operations, {
    timeout: 30000,
    maxConcurrency: 2,
    failFast: false
  });
  
  return { results, errors };
}
```

This enhanced JavaScript guide now includes cutting-edge functional programming patterns, advanced monadic structures, sophisticated reactive programming with custom Observable implementations, state machines, time-travel debugging capabilities, advanced metaprogramming, reflection patterns, ES2024+ features including Records and Tuples, pattern matching, advanced temporal APIs, modern asynchronous patterns with AbortController and structured concurrency, and performance optimization techniques essential for building modern, maintainable JavaScript applications.

## JavaScript Fundamentals Deep Dive

### Q51: What is the difference between `null` and `undefined` in JavaScript?
**Difficulty: Easy**

**Answer:**
Both `null` and `undefined` represent the absence of a value in JavaScript, but they're used in different contexts:

**`undefined`:**
- Represents a variable that has been declared but not assigned a value
- Default return value of functions that don't explicitly return anything
- Indicates missing parameters in functions
- Property that doesn't exist in an object
- Represents the value of a variable that hasn't been defined

**`null`:**
- Represents an intentional absence of any object value
- Must be explicitly assigned
- Used when you want to explicitly indicate "no value" or "empty"

```javascript
// undefined examples
let a;
console.log(a); // undefined

function noReturn() {}
console.log(noReturn()); // undefined

function greet(name) {
  console.log(name); // undefined if no argument is passed
}
greet();

const obj = {};
console.log(obj.nonExistentProperty); // undefined

// null examples
let empty = null;
console.log(empty); // null

function findUser(id) {
  // No user found
  return null;
}

let user = findUser(42);
if (user === null) {
  console.log('No user found');
}
```

**Type Checking:**
```javascript
console.log(typeof undefined); // "undefined"
console.log(typeof null);      // "object" (this is a historical bug in JavaScript)

console.log(null === undefined); // false
console.log(null == undefined);  // true (loose equality performs type coercion)
```

**Best Practices:**
- Use `undefined` for unintentional absence of value
- Use `null` for intentional absence of value
- Use strict equality (`===`) when checking for either value
- Avoid setting variables to `undefined` explicitly; let JavaScript do that
- Use `null` when you want to explicitly clear a variable's value

### Q52: Explain closures in JavaScript with advanced examples and use cases.
**Difficulty: Medium**

**Answer:**
A closure is a function that has access to its own scope, the scope of the outer function, and the global scope, even after the outer function has returned. Closures are created every time a function is created, at function creation time.

**Core Characteristics:**
1. Access to outer function's variables even after the outer function has returned
2. Preservation of the execution context
3. Data encapsulation and privacy

**Basic Closure Example:**
```javascript
function createCounter() {
  let count = 0; // Private variable
  
  return function() {
    count++;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

// Each call to createCounter creates a new closure with its own count variable
const counter2 = createCounter();
console.log(counter2()); // 1
```

**Advanced Use Cases:**

**1. Module Pattern:**
```javascript
const calculator = (function() {
  // Private variables and functions
  let result = 0;
  
  function validate(num) {
    return typeof num === 'number' && !isNaN(num);
  }
  
  // Public API
  return {
    add: function(num) {
      if (validate(num)) result += num;
      return this; // For method chaining
    },
    subtract: function(num) {
      if (validate(num)) result -= num;
      return this;
    },
    multiply: function(num) {
      if (validate(num)) result *= num;
      return this;
    },
    divide: function(num) {
      if (validate(num) && num !== 0) result /= num;
      return this;
    },
    getResult: function() {
      return result;
    },
    reset: function() {
      result = 0;
      return this;
    }
  };
})();

console.log(calculator.add(5).multiply(2).subtract(3).divide(2).getResult()); // 3.5
```

**2. Memoization for Performance:**
```javascript
function memoize(fn) {
  const cache = {};
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (cache[key] === undefined) {
      cache[key] = fn.apply(this, args);
      console.log('Calculated result for', key);
    } else {
      console.log('Returning cached result for', key);
    }
    
    return cache[key];
  };
}

// Expensive function to calculate fibonacci
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFib = memoize(function(n) {
  if (n <= 1) return n;
  return memoizedFib(n - 1) + memoizedFib(n - 2);
});

console.log(memoizedFib(40)); // Much faster than regular fibonacci
```

**3. Partial Application and Currying:**
```javascript
function partial(fn, ...presetArgs) {
  return function(...laterArgs) {
    return fn(...presetArgs, ...laterArgs);
  };
}

function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function(...args2) {
        return curried.apply(this, args.concat(args2));
      };
    }
  };
}

// Usage examples
function add(a, b, c) {
  return a + b + c;
}

const add5 = partial(add, 5);
console.log(add5(10, 15)); // 30

const curriedAdd = curry(add);
console.log(curriedAdd(5)(10)(15)); // 30
```

**4. Event Handlers with Preserved State:**
```javascript
function setupButtonHandler(buttonId, initialCount) {
  let count = initialCount || 0;
  
  document.getElementById(buttonId).addEventListener('click', function() {
    count++;
    console.log(`Button ${buttonId} clicked ${count} times`);
    this.textContent = `Clicked ${count} times`;
  });
}

// Usage
// setupButtonHandler('btn1', 0);
// setupButtonHandler('btn2', 10);
```

**5. Asynchronous Closures:**
```javascript
function fetchDataWithRetry(url, maxRetries = 3) {
  let retries = 0;
  
  return new Promise((resolve, reject) => {
    function attemptFetch() {
      fetch(url)
        .then(response => {
          if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
          return response.json();
        })
        .then(resolve)
        .catch(error => {
          retries++;
          console.log(`Attempt ${retries} failed: ${error.message}`);
          
          if (retries < maxRetries) {
            const delay = Math.pow(2, retries) * 1000; // Exponential backoff
            console.log(`Retrying in ${delay}ms...`);
            setTimeout(attemptFetch, delay);
          } else {
            reject(new Error(`Failed after ${maxRetries} attempts: ${error.message}`));
          }
        });
    }
    
    attemptFetch();
  });
}

// Usage
// fetchDataWithRetry('https://api.example.com/data')
//   .then(data => console.log('Success:', data))
//   .catch(error => console.error('Error:', error));
```

**Common Closure Pitfalls:**

**1. Memory Leaks:**
```javascript
function setupEventHandlers() {
  let data = { /* large data structure */ };
  
  document.getElementById('myButton').addEventListener('click', function() {
    // This closure holds a reference to 'data' even if it's not used
    console.log('Button clicked');
  });
  
  // The 'data' variable will not be garbage collected as long as the event handler exists
}
```

**2. Loop Variables in Closures:**
```javascript
// Problem
function createFunctions() {
  var funcs = [];
  
  for (var i = 0; i < 3; i++) {
    funcs.push(function() {
      console.log(i); // Will always log 3
    });
  }
  
  return funcs;
}

// Solution 1: Using let instead of var
function createFunctionsFixed1() {
  const funcs = [];
  
  for (let i = 0; i < 3; i++) {
    funcs.push(function() {
      console.log(i); // 0, 1, 2
    });
  }
  
  return funcs;
}

// Solution 2: Using an IIFE
function createFunctionsFixed2() {
  var funcs = [];
  
  for (var i = 0; i < 3; i++) {
    funcs.push((function(value) {
      return function() {
        console.log(value); // 0, 1, 2
      };
    })(i));
  }
  
  return funcs;
}
```

### Q53: Explain JavaScript Promises in depth with advanced patterns and error handling.
**Difficulty: Medium-Hard**

**Answer:**
Promises are objects representing the eventual completion or failure of an asynchronous operation and its resulting value. They provide a cleaner alternative to callback-based asynchronous code.

**Promise States:**
- **Pending**: Initial state, neither fulfilled nor rejected
- **Fulfilled**: Operation completed successfully
- **Rejected**: Operation failed
- **Settled**: Promise is either fulfilled or rejected, but not pending

**Basic Promise Usage:**
```javascript
const fetchData = () => {
  return new Promise((resolve, reject) => {
    // Asynchronous operation
    setTimeout(() => {
      const success = Math.random() > 0.3;
      if (success) {
        resolve({ data: 'Success data', timestamp: Date.now() });
      } else {
        reject(new Error('Failed to fetch data'));
      }
    }, 1000);
  });
};

fetchData()
  .then(result => console.log('Success:', result))
  .catch(error => console.error('Error:', error.message));
```

**Promise Chaining:**
```javascript
fetchUserData(userId)
  .then(userData => {
    console.log('User data:', userData);
    return fetchUserPosts(userData.id); // Returns a new promise
  })
  .then(posts => {
    console.log('User posts:', posts);
    return fetchPostComments(posts[0].id); // Returns a new promise
  })
  .then(comments => {
    console.log('Post comments:', comments);
  })
  .catch(error => {
    // Catches any error in the chain
    console.error('Error in promise chain:', error);
  })
  .finally(() => {
    // Always executes regardless of success or failure
    console.log('Promise chain completed');
  });
```

**Advanced Promise Patterns:**

**1. Promise.all - Parallel Execution:**
```javascript
const fetchAllData = () => {
  const promises = [
    fetch('/api/users').then(res => res.json()),
    fetch('/api/posts').then(res => res.json()),
    fetch('/api/comments').then(res => res.json())
  ];
  
  return Promise.all(promises);
};

fetchAllData()
  .then(([users, posts, comments]) => {
    console.log('All data fetched successfully:', { users, posts, comments });
  })
  .catch(error => {
    // If any promise rejects, the entire operation fails
    console.error('One or more requests failed:', error);
  });
```

**2. Promise.allSettled - Handle Mixed Results:**
```javascript
const fetchAllDataWithFallbacks = () => {
  const promises = [
    fetch('/api/critical-data').then(res => res.json()),
    fetch('/api/optional-data-1').then(res => res.json()),
    fetch('/api/optional-data-2').then(res => res.json())
  ];
  
  return Promise.allSettled(promises);
};

fetchAllDataWithFallbacks()
  .then(results => {
    // Process all results, regardless of success or failure
    const successful = results
      .filter(result => result.status === 'fulfilled')
      .map(result => result.value);
      
    const failed = results
      .filter(result => result.status === 'rejected')
      .map(result => result.reason);
    
    console.log(`${successful.length} requests succeeded, ${failed.length} failed`);
    console.log('Successful data:', successful);
    console.log('Failed requests reasons:', failed);
  });
```

**3. Promise.race - First to Complete:**
```javascript
const fetchWithTimeout = (url, timeout = 5000) => {
  const fetchPromise = fetch(url).then(res => res.json());
  
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error(`Request to ${url} timed out`)), timeout);
  });
  
  return Promise.race([fetchPromise, timeoutPromise]);
};

fetchWithTimeout('/api/data', 3000)
  .then(data => console.log('Data received before timeout:', data))
  .catch(error => console.error('Error or timeout:', error.message));
```

**4. Promise.any - First Successful Result:**
```javascript
const fetchFromMultipleAPIs = (query) => {
  const apis = [
    `https://api1.example.com/search?q=${query}`,
    `https://api2.example.com/search?q=${query}`,
    `https://api3.example.com/search?q=${query}`
  ];
  
  const promises = apis.map(url => 
    fetch(url)
      .then(res => {
        if (!res.ok) throw new Error(`API error: ${res.status}`);
        return res.json();
      })
  );
  
  return Promise.any(promises);
};

fetchFromMultipleAPIs('javascript')
  .then(firstResult => console.log('First successful result:', firstResult))
  .catch(error => {
    // AggregateError is thrown when all promises reject
    console.error('All APIs failed:', error);
  });
```

**5. Sequential Promise Execution:**
```javascript
async function processSequentially(items, asyncOperation) {
  const results = [];
  
  for (const item of items) {
    try {
      // Wait for each operation to complete before starting the next
      const result = await asyncOperation(item);
      results.push({ item, result, status: 'fulfilled' });
    } catch (error) {
      results.push({ item, error, status: 'rejected' });
    }
  }
  
  return results;
}

// Usage
const items = [1, 2, 3, 4, 5];
processSequentially(items, async (item) => {
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 1000));
  return item * 2;
}).then(results => console.log('Sequential processing complete:', results));
```

**6. Controlled Concurrency:**
```javascript
async function processWithConcurrencyLimit(items, asyncOperation, concurrencyLimit = 3) {
  const results = [];
  const executing = new Set();
  
  for (const [index, item] of items.entries()) {
    const promise = Promise.resolve().then(() => asyncOperation(item, index));
    results.push(promise);
    
    // Add to executing set
    executing.add(promise);
    
    // Remove from executing set when complete
    const clean = () => executing.delete(promise);
    promise.then(clean).catch(clean);
    
    // If we reach the concurrency limit, wait for one to complete
    if (executing.size >= concurrencyLimit) {
      await Promise.race(executing);
    }
  }
  
  return Promise.all(results);
}

// Usage
const urls = Array.from({ length: 20 }, (_, i) => `https://api.example.com/item/${i}`);
processWithConcurrencyLimit(urls, async (url) => {
  const response = await fetch(url);
  return response.json();
}, 5).then(results => console.log('Batch processing complete'));
```

**Advanced Error Handling:**

**1. Error Types and Custom Errors:**
```javascript
class NetworkError extends Error {
  constructor(message, status) {
    super(message);
    this.name = 'NetworkError';
    this.status = status;
  }
}

class ValidationError extends Error {
  constructor(message, validationErrors) {
    super(message);
    this.name = 'ValidationError';
    this.validationErrors = validationErrors;
  }
}

async function fetchWithErrorHandling(url) {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      if (response.status >= 500) {
        throw new NetworkError('Server error', response.status);
      } else if (response.status === 400) {
        const data = await response.json();
        throw new ValidationError('Validation failed', data.errors);
      } else {
        throw new Error(`HTTP error: ${response.status}`);
      }
    }
    
    return response.json();
  } catch (error) {
    if (error instanceof NetworkError) {
      console.error(`Network error (${error.status}):`, error.message);
      // Retry logic could go here
    } else if (error instanceof ValidationError) {
      console.error('Validation errors:', error.validationErrors);
      // Handle validation errors
    } else if (error.name === 'AbortError') {
      console.error('Request was aborted');
    } else {
      console.error('Unexpected error:', error);
    }
    throw error; // Re-throw for further handling
  }
}
```

**2. Retry Pattern with Exponential Backoff:**
```javascript
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  const { retryDelay = 1000, retryMultiplier = 2, ...fetchOptions } = options;
  
  let lastError;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fetch(url, fetchOptions);
    } catch (error) {
      lastError = error;
      
      if (attempt < maxRetries) {
        const delay = retryDelay * Math.pow(retryMultiplier, attempt);
        console.log(`Attempt ${attempt + 1} failed, retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  throw new Error(`Failed after ${maxRetries} retries: ${lastError.message}`);
}
```

**3. Promise Cancellation with AbortController:**
```javascript
function fetchWithCancellation(url) {
  const controller = new AbortController();
  const { signal } = controller;
  
  const promise = fetch(url, { signal })
    .then(response => response.json());
  
  // Return both the promise and a cancel function
  return {
    promise,
    cancel: () => controller.abort()
  };
}

// Usage
const { promise, cancel } = fetchWithCancellation('/api/large-data');

// Set up timeout
const timeoutId = setTimeout(() => {
  console.log('Request taking too long, cancelling...');
  cancel();
}, 5000);

promise
  .then(data => {
    clearTimeout(timeoutId);
    console.log('Data received:', data);
  })
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('Request was cancelled');
    } else {
      console.error('Request failed:', error);
    }
  });
```

**Best Practices:**

1. Always return promises from functions that perform asynchronous operations
2. Use `catch` to handle errors in promise chains
3. Avoid nesting promises; use chaining instead
4. Use `finally` for cleanup operations
5. Consider using async/await for more readable asynchronous code
6. Be careful with `Promise.all` when all operations must succeed
7. Use appropriate concurrency patterns based on your use case
8. Implement proper error handling with specific error types
9. Consider implementing retry mechanisms for network operations
10. Use AbortController for cancellable operations

### Q54: Explain async/await in JavaScript with advanced patterns and best practices.
**Difficulty: Medium-Hard**

**Answer:**
async/await is syntactic sugar built on top of Promises, introduced in ES2017 (ES8) to make asynchronous code look and behave more like synchronous code. It makes asynchronous code more readable and easier to debug.

**Basic Syntax:**
```javascript
async function fetchUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    
    const userData = await response.json();
    return userData;
  } catch (error) {
    console.error('Error fetching user data:', error);
    throw error; // Re-throw to allow calling code to handle it
  }
}

// Usage
fetchUserData(123)
  .then(userData => console.log('User data:', userData))
  .catch(error => console.error('Failed to fetch user:', error));
```

**Key Concepts:**

1. **`async` functions:**
   - Always return a Promise
   - If the function returns a value, the Promise is resolved with that value
   - If the function throws an exception, the Promise is rejected with that exception

2. **`await` operator:**
   - Can only be used inside `async` functions
   - Pauses execution until the Promise is settled
   - Returns the resolved value of the Promise
   - If the Promise is rejected, it throws an exception that can be caught with try/catch

**Advanced Patterns:**

**1. Sequential vs. Parallel Execution:**

```javascript
// Sequential execution - each fetch waits for the previous one
async function fetchSequential() {
  console.time('sequential');
  
  const users = await fetch('/api/users').then(r => r.json());
  const posts = await fetch('/api/posts').then(r => r.json());
  const comments = await fetch('/api/comments').then(r => r.json());
  
  console.timeEnd('sequential');
  return { users, posts, comments };
}

// Parallel execution - all fetches happen simultaneously
async function fetchParallel() {
  console.time('parallel');
  
  const usersPromise = fetch('/api/users').then(r => r.json());
  const postsPromise = fetch('/api/posts').then(r => r.json());
  const commentsPromise = fetch('/api/comments').then(r => r.json());
  
  const users = await usersPromise;
  const posts = await postsPromise;
  const comments = await commentsPromise;
  
  console.timeEnd('parallel');
  return { users, posts, comments };
}

// Even cleaner parallel execution with Promise.all
async function fetchParallelAll() {
  console.time('parallel-all');
  
  const [users, posts, comments] = await Promise.all([
    fetch('/api/users').then(r => r.json()),
    fetch('/api/posts').then(r => r.json()),
    fetch('/api/comments').then(r => r.json())
  ]);
  
  console.timeEnd('parallel-all');
  return { users, posts, comments };
}
```

**2. Error Handling Patterns:**

```javascript
// Basic try/catch
async function fetchWithErrorHandling(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
    return await response.json();
  } catch (error) {
    console.error(`Error fetching ${url}:`, error);
    return null; // Return a default value or re-throw based on requirements
  }
}

// Higher-order function for error handling
function withErrorHandling(asyncFn) {
  return async function(...args) {
    try {
      return await asyncFn(...args);
    } catch (error) {
      console.error(`Error in ${asyncFn.name}:`, error);
      // Could also report to monitoring service here
      throw error;
    }
  };
}

// Usage
const safeFetch = withErrorHandling(async (url) => {
  const response = await fetch(url);
  if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
  return response.json();
});

// Error boundaries pattern
async function fetchWithErrorBoundary(urls) {
  const results = [];
  const errors = [];
  
  for (const url of urls) {
    try {
      const data = await fetch(url).then(r => r.json());
      results.push({ url, data, status: 'fulfilled' });
    } catch (error) {
      errors.push({ url, error, status: 'rejected' });
    }
  }
  
  return { results, errors };
}
```

**3. Timeout Pattern:**

```javascript
async function fetchWithTimeout(url, timeoutMs = 5000) {
  const controller = new AbortController();
  const { signal } = controller;
  
  // Set up timeout
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  
  try {
    const response = await fetch(url, { signal });
    clearTimeout(timeoutId);
    
    if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
    return await response.json();
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === 'AbortError') {
      throw new Error(`Request to ${url} timed out after ${timeoutMs}ms`);
    }
    throw error;
  }
}

// Usage
try {
  const data = await fetchWithTimeout('/api/data', 3000);
  console.log('Data:', data);
} catch (error) {
  console.error('Error or timeout:', error.message);
}
```

**4. Retry Pattern:**

```javascript
async function fetchWithRetry(url, options = {}) {
  const { retries = 3, delay = 1000, backoff = 2 } = options;
  
  let lastError;
  
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      return await fetch(url);
    } catch (error) {
      console.log(`Attempt ${attempt + 1} failed: ${error.message}`);
      lastError = error;
      
      if (attempt < retries) {
        const delayTime = delay * Math.pow(backoff, attempt);
        console.log(`Retrying in ${delayTime}ms...`);
        await new Promise(resolve => setTimeout(resolve, delayTime));
      }
    }
  }
  
  throw new Error(`Failed after ${retries} retries: ${lastError.message}`);
}
```

**5. Async Iteration:**

```javascript
// Process items sequentially with controlled flow
async function processItems(items) {
  for await (const item of asyncIterator(items)) {
    console.log('Processed:', item);
  }
}

// Custom async iterator
async function* asyncIterator(items) {
  for (const item of items) {
    // Simulate async processing
    await new Promise(resolve => setTimeout(resolve, 100));
    yield `Item ${item} processed at ${new Date().toISOString()}`;
  }
}

// Process items with rate limiting
async function processWithRateLimit(items, rateLimit) {
  const delay = 1000 / rateLimit; // ms between operations
  
  for (const item of items) {
    const startTime = Date.now();
    
    // Process item
    await processItem(item);
    
    // Calculate remaining time to respect rate limit
    const elapsedTime = Date.now() - startTime;
    const waitTime = Math.max(0, delay - elapsedTime);
    
    if (waitTime > 0) {
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
  }
}
```

**6. Async Function Composition:**

```javascript
// Compose async functions
const composeAsync = (...fns) => async (initialValue) => {
  return fns.reduce(
    async (value, fn) => fn(await value),
    Promise.resolve(initialValue)
  );
};

// Usage
const fetchUser = async (id) => {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
};

const fetchUserPosts = async (user) => {
  const response = await fetch(`/api/users/${user.id}/posts`);
  const posts = await response.json();
  return { ...user, posts };
};

const fetchPostComments = async (userData) => {
  const firstPost = userData.posts[0];
  if (!firstPost) return userData;
  
  const response = await fetch(`/api/posts/${firstPost.id}/comments`);
  const comments = await response.json();
  
  return {
    ...userData,
    posts: [
      { ...firstPost, comments },
      ...userData.posts.slice(1)
    ]
  };
};

const getUserData = composeAsync(
  fetchUser,
  fetchUserPosts,
  fetchPostComments
);

// Get complete user data
const userData = await getUserData(123);
```

**7. Async IIFE (Immediately Invoked Function Expression):**

```javascript
// For top-level await in environments that don't support it
(async () => {
  try {
    const data = await fetch('/api/data').then(r => r.json());
    console.log('Data loaded:', data);
    
    // More async operations...
    const processedData = await processData(data);
    await saveResults(processedData);
  } catch (error) {
    console.error('Failed:', error);
  }
})();
```

**Best Practices:**

1. **Always handle errors properly**
   - Use try/catch blocks around await statements
   - Consider higher-order functions for consistent error handling

2. **Be mindful of execution flow**
   - Use sequential await for dependent operations
   - Use Promise.all for parallel independent operations

3. **Avoid unnecessary async/await**
   - Don't use async/await when simple Promise chaining is clearer
   - Remember that every async function adds Promise overhead

4. **Understand the event loop**
   - await yields control back to the event loop
   - Long chains of awaits can block the main thread if not careful

5. **Use Promise combinators appropriately**
   - Promise.all for parallel operations that all need to succeed
   - Promise.allSettled for operations where some can fail
   - Promise.race for timeout patterns
   - Promise.any for getting the first successful result

6. **Avoid the async/await "pyramid of doom"**
   - Extract complex logic into separate async functions
   - Use composition patterns for cleaner code

7. **Remember that async functions always return Promises**
   - Even if you return a simple value, it will be wrapped in a Promise
   - You must await or .then() the result of an async function

8. **Use async IIFE for top-level await in environments that don't support it**
   - Browsers and Node.js modules now support top-level await
   - For older environments, wrap in an async IIFE

### Q55: Explain the JavaScript Event Loop in detail with examples.
**Difficulty: Hard**

**Answer:**
The Event Loop is a fundamental concept in JavaScript that enables its non-blocking, asynchronous behavior despite being single-threaded. It's responsible for executing code, collecting and processing events, and executing queued sub-tasks.

**Core Components:**

1. **Call Stack**: Where JavaScript code execution happens, one frame at a time
2. **Web APIs**: Browser-provided threads for handling async operations (DOM, AJAX, setTimeout, etc.)
3. **Callback Queue (Task Queue)**: Where callbacks from async operations wait to be executed
4. **Microtask Queue**: Higher priority queue for Promises and mutation observer callbacks
5. **Event Loop**: Constantly checks if the call stack is empty, then processes microtasks, then tasks

**Visual Representation:**
```
┌─────────────────────┐     ┌───────────────┐
│      Call Stack     │     │   Web APIs    │
└─────────────────────┘     └───────────────┘
          ▲                        │
          │                        ▼
          │                ┌───────────────┐
          │                │ Callback Queue│
          │                └───────────────┘
          │                        ▲
┌─────────────────────┐            │
│     Event Loop     │────────────┘
└─────────────────────┘
          │
          ▼
┌─────────────────────┐
│   Microtask Queue   │
└─────────────────────┘
```

**Basic Event Loop Flow:**

```javascript
console.log('Start'); // 1. Added to call stack and executed immediately

setTimeout(() => {
  console.log('Timeout callback'); // 4. Executed after call stack is empty
}, 0);

Promise.resolve().then(() => {
  console.log('Promise callback'); // 3. Executed after call stack is empty but before timeout
});

console.log('End'); // 2. Added to call stack and executed immediately

// Output:
// Start
// End
// Promise callback
// Timeout callback
```

**Detailed Explanation:**

1. **Call Stack Execution:**
   - JavaScript executes code line by line on the call stack
   - When a function is called, it's added to the stack
   - When a function returns, it's removed from the stack

2. **Handling Asynchronous Operations:**
   - Async operations (like setTimeout, fetch, event listeners) are delegated to Web APIs
   - When the async operation completes, its callback is placed in the appropriate queue

3. **Task Queue vs. Microtask Queue:**
   - Task Queue (Macrotask Queue): setTimeout, setInterval, setImmediate, I/O, UI rendering
   - Microtask Queue: Promise callbacks, queueMicrotask(), MutationObserver
   - Microtasks are processed after the current task completes and before the next task
   - All microtasks are processed before the next task is taken from the task queue

**Advanced Examples:**

**1. Nested Timeouts and Promises:**

```javascript
console.log('Script start'); // 1

setTimeout(() => {
  console.log('setTimeout 1'); // 5
  
  Promise.resolve().then(() => {
    console.log('Promise inside setTimeout'); // 6
  });
}, 0);

Promise.resolve().then(() => {
  console.log('Promise 1'); // 3
  
  setTimeout(() => {
    console.log('setTimeout inside Promise'); // 7
  }, 0);
});

console.log('Script end'); // 2

// Output:
// Script start
// Script end
// Promise 1
// setTimeout 1
// Promise inside setTimeout
// setTimeout inside Promise
```

**2. Microtask Queue Draining:**

```javascript
console.log('Start'); // 1

setTimeout(() => {
  console.log('Timeout 1'); // 8
}, 0);

Promise.resolve().then(() => {
  console.log('Promise 1'); // 3
  
  // Adding more microtasks during microtask execution
  Promise.resolve().then(() => {
    console.log('Promise 2'); // 5
    
    Promise.resolve().then(() => {
      console.log('Promise 4'); // 7
    });
  });
  
  Promise.resolve().then(() => {
    console.log('Promise 3'); // 6
  });
});

console.log('End'); // 2

setTimeout(() => {
  console.log('Timeout 2'); // 9
}, 0);

// Output:
// Start
// End
// Promise 1
// Promise 2
// Promise 3
// Promise 4
// Timeout 1
// Timeout 2
```

**3. Event Loop with Rendering:**

```javascript
const button = document.querySelector('button');
const container = document.querySelector('.container');

button.addEventListener('click', () => {
  console.log('Button clicked'); // 1
  
  // Synchronous code that blocks the main thread
  const startTime = Date.now();
  while (Date.now() - startTime < 2000) {
    // Blocking for 2 seconds
  }
  
  console.log('Heavy operation finished'); // 2
  
  // DOM manipulation
  container.style.backgroundColor = 'red'; // Applied but not rendered yet
  
  Promise.resolve().then(() => {
    console.log('Promise after DOM change'); // 3
    container.style.backgroundColor = 'blue'; // Batched with previous change
  });
  
  setTimeout(() => {
    console.log('Timeout after DOM changes'); // 4
    container.style.backgroundColor = 'green'; // Will cause another render
  }, 0);
});

// When button is clicked, the output is:
// Button clicked
// Heavy operation finished
// Promise after DOM change
// Timeout after DOM changes
// (The container will briefly be blue, then green)
```

**4. requestAnimationFrame and the Render Queue:**

```javascript
console.log('Start'); // 1

// Task
setTimeout(() => {
  console.log('Timeout'); // 5
}, 0);

// Will execute before the next repaint
requestAnimationFrame(() => {
  console.log('Animation frame'); // 4
});

// Microtask
Promise.resolve().then(() => {
  console.log('Promise'); // 3
});

// Synchronous code
console.log('End'); // 2

// Output (may vary slightly based on browser timing):
// Start
// End
// Promise
// Animation frame
// Timeout
```

**5. Node.js Event Loop Phases:**

Node.js has a more complex event loop with multiple phases:

```javascript
const fs = require('fs');

// Timers phase
setTimeout(() => {
  console.log('Timeout 1'); // 2
}, 0);

// I/O callbacks phase
fs.readFile('example.txt', () => {
  console.log('File read'); // 3
  
  // nextTick queue - runs after current operation, before other phases
  process.nextTick(() => {
    console.log('Next tick inside I/O'); // 4
  });
  
  // Microtask queue
  Promise.resolve().then(() => {
    console.log('Promise inside I/O'); // 5
  });
  
  // Back to timers phase in next loop iteration
  setTimeout(() => {
    console.log('Timeout inside I/O'); // 7
  }, 0);
});

// nextTick queue - highest priority
process.nextTick(() => {
  console.log('Next tick'); // 1
});

// Check phase (setImmediate)
setImmediate(() => {
  console.log('Immediate'); // 6
});

// Output (may vary based on file system timing):
// Next tick
// Timeout 1
// File read
// Next tick inside I/O
// Promise inside I/O
// Immediate
// Timeout inside I/O
```

**Common Misconceptions:**

1. **setTimeout(fn, 0) doesn't execute immediately**
   - It schedules the callback for the next event loop iteration
   - There's a minimum delay (usually 4ms) in most browsers

2. **Promises aren't truly synchronous**
   - Promise callbacks execute asynchronously in the microtask queue
   - They just have higher priority than regular tasks

3. **The event loop isn't part of the JavaScript engine**
   - It's provided by the host environment (browser, Node.js)
   - Different environments have slightly different implementations

**Performance Implications:**

1. **Long-running tasks block the event loop**
   - Causes UI freezing in browsers
   - Prevents processing other callbacks
   - Solution: Break up heavy work with setTimeout/requestAnimationFrame

2. **Microtask queue starvation**
   - If microtasks keep adding more microtasks, the task queue never gets processed
   - Can cause timeouts and UI updates to be delayed indefinitely

3. **Task partitioning**
   - For heavy processing, split work into smaller chunks
   - Use setTimeout(fn, 0) to yield to the event loop

```javascript
function processLargeArray(array, processItem) {
  const chunk = 1000;
  let index = 0;
  
  function doChunk() {
    const stop = Math.min(index + chunk, array.length);
    
    while (index < stop) {
      processItem(array[index]);
      index++;
    }
    
    if (index < array.length) {
      // Schedule next chunk and yield to the event loop
      setTimeout(doChunk, 0);
    }
  }
  
  doChunk();
}

// Usage
const largeArray = Array.from({ length: 1000000 }, (_, i) => i);
processLargeArray(largeArray, item => {
  // Process each item without blocking the UI
  console.log(item);
});
```

**Debugging the Event Loop:**

```javascript
// Add visual indicators for different queue types
const log = (msg, type) => {
  const types = {
    sync: 'color: black',
    task: 'color: red',
    microtask: 'color: blue',
    render: 'color: green'
  };
  
  console.log(`%c${msg}`, types[type] || 'color: black');
};

log('Synchronous code start', 'sync');

setTimeout(() => {
  log('Timeout callback (task queue)', 'task');
}, 0);

Promise.resolve().then(() => {
  log('Promise.then (microtask queue)', 'microtask');
  
  // Adding more work to the microtask queue
  Promise.resolve().then(() => {
    log('Nested promise (microtask queue)', 'microtask');
  });
});

requestAnimationFrame(() => {
  log('Animation frame (before render)', 'render');
});

log('Synchronous code end', 'sync');
```

**Key Takeaways:**

1. JavaScript is single-threaded but can handle asynchronous operations through the event loop
2. The event loop processes tasks in order: call stack → microtasks → tasks
3. Microtasks (Promises) have priority over tasks (setTimeout, events)
4. Long-running operations should be broken up to avoid blocking the event loop
5. Understanding the event loop is crucial for writing efficient, non-blocking JavaScript code

## JavaScript Advanced Concepts

### Q56: Explain JavaScript's prototype-based inheritance in depth with examples.
**Difficulty: Hard**

**Answer:**
JavaScript uses prototype-based inheritance rather than class-based inheritance found in languages like Java or C++. This mechanism allows objects to inherit properties and methods from other objects through a prototype chain.

**Core Concepts:**

1. **Prototype Chain**: Every JavaScript object has a prototype (accessible via `__proto__` or `Object.getPrototypeOf()`)
2. **Constructor Functions**: Used to create objects with shared properties and methods
3. **`prototype` Property**: Where shared methods and properties are defined for instances
4. **`__proto__`**: Reference to the prototype of an object (the internal `[[Prototype]]` property)
5. **Property Lookup**: When accessing a property, JavaScript looks up the prototype chain

**Basic Prototype Inheritance:**

```javascript
// Constructor function
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// Adding a method to the prototype
Person.prototype.greet = function() {
  return `Hello, my name is ${this.name} and I'm ${this.age} years old`;
};

// Creating instances
const alice = new Person('Alice', 28);
const bob = new Person('Bob', 32);

console.log(alice.greet()); // "Hello, my name is Alice and I'm 28 years old"
console.log(bob.greet());   // "Hello, my name is Bob and I'm 32 years old"

// Both instances share the same greet method
console.log(alice.greet === bob.greet); // true

// Prototype chain
console.log(alice.__proto__ === Person.prototype); // true
console.log(Person.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__); // null (end of the chain)
```

**Prototype Chain Visualization:**

```
alice ---> Person.prototype ---> Object.prototype ---> null
  |             |                     |
  |             |                     |
  v             v                     v
{name: 'Alice', {greet: function(){}} {toString: function(){}, ...}
 age: 28}                           
```

**Property Lookup Process:**

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  return `Hello, I'm ${this.name}`;
};

const john = new Person('John');

// 1. Look for property on the object itself
console.log(john.name); // "John" (found on john object)

// 2. If not found, look on the object's prototype
console.log(john.greet()); // "Hello, I'm John" (found on Person.prototype)

// 3. If not found, continue up the prototype chain
console.log(john.toString()); // "[object Object]" (found on Object.prototype)

// 4. If not found anywhere in the chain, return undefined
console.log(john.nonExistentProperty); // undefined
```

**Inheritance Between "Classes":**

```javascript
// Parent constructor
function Animal(name) {
  this.name = name;
}

// Parent methods
Animal.prototype.eat = function(food) {
  return `${this.name} eats ${food}`;
};

// Child constructor
function Dog(name, breed) {
  // Call parent constructor
  Animal.call(this, name);
  this.breed = breed;
}

// Set up inheritance
Dog.prototype = Object.create(Animal.prototype);
// Fix constructor reference
Dog.prototype.constructor = Dog;

// Add child-specific methods
Dog.prototype.bark = function() {
  return `${this.name} says woof!`;
};

// Override parent method
Dog.prototype.eat = function(food) {
  return `${this.name} the ${this.breed} eagerly eats ${food}`;
};

// Create instance
const rex = new Dog('Rex', 'German Shepherd');

console.log(rex.name);  // "Rex"
console.log(rex.breed); // "German Shepherd"
console.log(rex.bark()); // "Rex says woof!"
console.log(rex.eat('kibble')); // "Rex the German Shepherd eagerly eats kibble"

// Prototype chain
console.log(rex.__proto__ === Dog.prototype); // true
console.log(rex.__proto__.__proto__ === Animal.prototype); // true
```

**Modern Approaches to Prototype Inheritance:**

**1. Class Syntax (ES6+):**

```javascript
// Parent class
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  eat(food) {
    return `${this.name} eats ${food}`;
  }
  
  sleep() {
    return `${this.name} is sleeping`;
  }
}

// Child class
class Dog extends Animal {
  constructor(name, breed) {
    super(name); // Call parent constructor
    this.breed = breed;
  }
  
  bark() {
    return `${this.name} says woof!`;
  }
  
  // Override parent method
  eat(food) {
    return `${this.name} the ${this.breed} eagerly eats ${food}`;
  }
}

const max = new Dog('Max', 'Beagle');
console.log(max.eat('treats')); // "Max the Beagle eagerly eats treats"
console.log(max.sleep());      // "Max is sleeping"
console.log(max.bark());       // "Max says woof!"

// Under the hood, it's still prototype-based
console.log(max.__proto__ === Dog.prototype); // true
console.log(Dog.prototype.__proto__ === Animal.prototype); // true
```

**2. Object.create():**

```javascript
// Base object
const vehicle = {
  type: 'Generic vehicle',
  start() {
    return `${this.type} is starting`;
  },
  stop() {
    return `${this.type} is stopping`;
  }
};

// Create a car object that inherits from vehicle
const car = Object.create(vehicle, {
  type: {
    value: 'Car',
    writable: true,
    enumerable: true
  },
  drive: {
    value: function() {
      return `${this.type} is driving`;
    },
    writable: true,
    enumerable: true
  }
});

console.log(car.type);    // "Car"
console.log(car.start()); // "Car is starting"
console.log(car.drive()); // "Car is driving"

// Create a specific car that inherits from car
const tesla = Object.create(car);
tesla.type = 'Tesla';
tesla.drive = function() {
  return `${this.type} is driving silently`;
};

console.log(tesla.type);    // "Tesla"
console.log(tesla.start()); // "Tesla is starting"
console.log(tesla.drive()); // "Tesla is driving silently"

// Prototype chain
console.log(tesla.__proto__ === car); // true
console.log(car.__proto__ === vehicle); // true
```

**Advanced Prototype Techniques:**

**1. Mixins - Combining Multiple Sources:**

```javascript
// Mixin function
function mixin(target, ...sources) {
  sources.forEach(source => {
    Object.getOwnPropertyNames(source).forEach(prop => {
      if (prop !== 'constructor' && prop !== 'prototype') {
        Object.defineProperty(
          target, 
          prop, 
          Object.getOwnPropertyDescriptor(source, prop)
        );
      }
    });
  });
  return target;
}

// Base constructor
function Vehicle(type) {
  this.type = type;
}

// Mixins
const drivableMixin = {
  drive() {
    return `${this.type} is driving`;
  },
  park() {
    return `${this.type} is parked`;
  }
};

const fuelableMixin = {
  refuel(amount) {
    this.fuel = (this.fuel || 0) + amount;
    return `${this.type} refueled. Current fuel: ${this.fuel}`;
  },
  consumeFuel(amount) {
    if (!this.fuel || this.fuel < amount) {
      return `${this.type} is out of fuel!`;
    }
    this.fuel -= amount;
    return `${this.type} consumed fuel. Remaining: ${this.fuel}`;
  }
};

// Apply mixins to Vehicle.prototype
mixin(Vehicle.prototype, drivableMixin, fuelableMixin);

// Create instance
const sedan = new Vehicle('Sedan');
console.log(sedan.drive());      // "Sedan is driving"
console.log(sedan.refuel(50));   // "Sedan refueled. Current fuel: 50"
console.log(sedan.consumeFuel(20)); // "Sedan consumed fuel. Remaining: 30"
```

**2. Property Descriptors and Getters/Setters:**

```javascript
function Person(name, birthYear) {
  this.name = name;
  this._birthYear = birthYear; // Convention for "private" property
}

// Define age as a getter that calculates from birthYear
Object.defineProperty(Person.prototype, 'age', {
  get: function() {
    return new Date().getFullYear() - this._birthYear;
  },
  enumerable: true
});

// Define fullName as a getter/setter
Object.defineProperty(Person.prototype, 'fullName', {
  get: function() {
    return this.name;
  },
  set: function(value) {
    this.name = value;
  },
  enumerable: true,
  configurable: true
});

const person = new Person('John Doe', 1990);
console.log(person.age); // Current year - 1990

person.fullName = 'Jane Smith';
console.log(person.name); // "Jane Smith"
```

**3. Dynamic Prototype Pattern:**

```javascript
function Car(make, model) {
  this.make = make;
  this.model = model;
  this.speed = 0;
  
  // Initialize prototype only once
  if (typeof this.accelerate !== 'function') {
    Car.prototype.accelerate = function(amount) {
      this.speed += amount;
      return `${this.make} ${this.model} accelerating to ${this.speed} mph`;
    };
    
    Car.prototype.brake = function(amount) {
      this.speed = Math.max(0, this.speed - amount);
      return `${this.make} ${this.model} slowing to ${this.speed} mph`;
    };
  }
}

const car1 = new Car('Toyota', 'Corolla');
const car2 = new Car('Honda', 'Civic');

console.log(car1.accelerate(30)); // "Toyota Corolla accelerating to 30 mph"
console.log(car2.accelerate(20)); // "Honda Civic accelerating to 20 mph"
```

**4. Prototype Pollution Protection:**

```javascript
// Create a safe object with null prototype
const safeObject = Object.create(null);

// No inherited properties or methods
console.log(safeObject.toString); // undefined
console.log(safeObject.constructor); // undefined

// Freeze the Object.prototype to prevent modifications
Object.freeze(Object.prototype);

// Attempt to modify Object.prototype will fail in strict mode
try {
  Object.prototype.malicious = function() { 
    console.log('This is a security risk'); 
  };
} catch (e) {
  console.log('Protected against prototype pollution');
}
```

**Common Pitfalls and Best Practices:**

**1. `this` Context Issues:**

```javascript
function Counter() {
  this.count = 0;
}

Counter.prototype.increment = function() {
  this.count++;
  return this.count;
};

Counter.prototype.incrementLater = function() {
  // Problem: 'this' will be global or undefined in strict mode
  setTimeout(function() {
    this.increment(); // 'this' is not the Counter instance
    console.log(this.count);
  }, 1000);
  
  // Solution 1: Use arrow function
  setTimeout(() => {
    this.increment(); // 'this' is preserved
    console.log(this.count);
  }, 1000);
  
  // Solution 2: Bind 'this'
  const self = this;
  setTimeout(function() {
    self.increment();
    console.log(self.count);
  }, 1000);
};
```

**2. Property Shadowing:**

```javascript
function Parent() {}
Parent.prototype.name = 'Parent';

function Child() {}
Child.prototype = Object.create(Parent.prototype);

const child = new Child();
console.log(child.name); // "Parent"

// Adding a property with the same name to the instance
child.name = 'Child';
console.log(child.name); // "Child" (shadows the prototype property)

// Delete the instance property to reveal the prototype property again
delete child.name;
console.log(child.name); // "Parent"
```

**3. Performance Considerations:**

```javascript
// Inefficient: Creates a new function for each instance
function BadPractice(name) {
  this.name = name;
  
  // Each instance gets its own copy of the method
  this.greet = function() {
    return `Hello, I'm ${this.name}`;
  };
}

// Efficient: Shares methods via prototype
function GoodPractice(name) {
  this.name = name;
}

// All instances share one copy of the method
GoodPractice.prototype.greet = function() {
  return `Hello, I'm ${this.name}`;
};

// Memory usage comparison
const instances = 10000;
const badObjects = Array.from({length: instances}, (_, i) => new BadPractice(`Person ${i}`));
const goodObjects = Array.from({length: instances}, (_, i) => new GoodPractice(`Person ${i}`));
// The bad approach creates 10,000 function objects
// The good approach creates just one function object shared by all instances
```

**Key Takeaways:**

1. JavaScript's inheritance is prototype-based, not class-based
2. Every object has a prototype chain that ends with `Object.prototype` or `null`
3. Properties are looked up along the prototype chain
4. ES6 classes are syntactic sugar over prototype-based inheritance
5. Prototype inheritance is memory-efficient as methods are shared across instances
6. Understanding prototypes is essential for working with JavaScript objects effectively

### Q57: Explain JavaScript modules in depth, including different module systems and best practices.
**Difficulty: Medium**

**Answer:**
JavaScript modules are a way to organize code into reusable, encapsulated units. They help manage dependencies, avoid global namespace pollution, and improve code maintainability. JavaScript has evolved through several module systems over time.

**Historical Evolution of JavaScript Modules:**

**1. Global Variables and Namespaces (Pre-modules Era):**

```javascript
// Global variable approach (problematic)
var userName = 'John';
function formatUser() { /* ... */ }

// Namespace pattern (better but still limited)
var MyApp = {};
MyApp.userName = 'John';
MyApp.formatUser = function() { /* ... */ };
```

**2. Immediately Invoked Function Expressions (IIFE):**

```javascript
// Module pattern using IIFE
var UserModule = (function() {
  // Private variables and functions
  var privateUser = { name: 'John' };
  
  function privateFunction() {
    return privateUser.name;
  }
  
  // Public API
  return {
    getUser: function() {
      return privateFunction();
    },
    setUser: function(name) {
      privateUser.name = name;
    }
  };
})();

// Usage
UserModule.getUser(); // "John"
UserModule.setUser('Alice');
UserModule.getUser(); // "Alice"
// privateUser and privateFunction are not accessible here
```

**3. CommonJS (Used in Node.js):**

```javascript
// math.js
function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}

// Export specific functions
module.exports = {
  add: add,
  subtract: subtract
};

// Alternative syntax
module.exports.multiply = function(a, b) {
  return a * b;
};

// main.js
const math = require('./math');
console.log(math.add(5, 3));      // 8
console.log(math.subtract(10, 4)); // 6

// Destructuring for specific imports
const { multiply } = require('./math');
console.log(multiply(2, 3));       // 6
```

**4. AMD (Asynchronous Module Definition - Used with RequireJS):**

```javascript
// math.js
define([], function() {
  return {
    add: function(a, b) {
      return a + b;
    },
    subtract: function(a, b) {
      return a - b;
    }
  };
});

// main.js
require(['math'], function(math) {
  console.log(math.add(5, 3));      // 8
  console.log(math.subtract(10, 4)); // 6
});
```

**5. UMD (Universal Module Definition):**

```javascript
// Supports both AMD and CommonJS
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define(['dependency'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS
    module.exports = factory(require('dependency'));
  } else {
    // Browser globals
    root.myModule = factory(root.dependency);
  }
}(typeof self !== 'undefined' ? self : this, function(dependency) {
  // Module code goes here
  return {
    // Public API
  };
}));
```

**6. ES Modules (ESM - Modern Standard):**

```javascript
// math.js
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

export const PI = 3.14159;

// Default export
export default function multiply(a, b) {
  return a * b;
}

// main.js
// Named imports
import { add, subtract, PI } from './math.js';
console.log(add(5, 3));       // 8
console.log(subtract(10, 4));  // 6
console.log(PI);              // 3.14159

// Default import
import multiply from './math.js';
console.log(multiply(2, 3));   // 6

// Import all as namespace
import * as math from './math.js';
console.log(math.add(1, 2));   // 3
console.log(math.PI);         // 3.14159
```

**ES Modules Features in Depth:**

**1. Named Exports and Imports:**

```javascript
// utils.js
export const VERSION = '1.0.0';

export function formatDate(date) {
  return new Date(date).toLocaleDateString();
}

export class Logger {
  log(message) {
    console.log(`[LOG]: ${message}`);
  }
}

// app.js
import { VERSION, formatDate, Logger } from './utils.js';

// Rename imports
import { formatDate as formatDateString } from './utils.js';

// Multiple imports with renaming
import { 
  VERSION, 
  formatDate as format, 
  Logger as LogService 
} from './utils.js';
```

**2. Default Exports and Imports:**

```javascript
// user.js
const user = {
  name: 'John',
  role: 'Admin'
};

export default user;

// OR default function
export default function createUser(name, role) {
  return { name, role };
}

// app.js
import user from './user.js';
// OR with any name (for default exports)
import adminUser from './user.js';

// Combining default and named imports
import defaultExport, { namedExport1, namedExport2 } from './module.js';
```

**3. Re-exporting:**

```javascript
// math.js
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;

// utils.js
export const formatNumber = num => num.toFixed(2);

// index.js (aggregating module)
export { add, subtract } from './math.js';
export { formatNumber } from './utils.js';
export { default as User } from './user.js';

// Re-export all
export * from './config.js';

// Re-export with renaming
export { add as sum } from './math.js';
```

**4. Dynamic Imports:**

```javascript
// Static import (evaluated at load time)
import { heavyFunction } from './heavy-module.js';

// Dynamic import (lazy loading)
button.addEventListener('click', async () => {
  try {
    // Module is loaded only when needed
    const { heavyFunction } = await import('./heavy-module.js');
    const result = heavyFunction();
    console.log(result);
  } catch (error) {
    console.error('Failed to load module:', error);
  }
});

// Conditional dynamic import
if (user.isPremium) {
  import('./premium-features.js')
    .then(module => {
      module.enablePremiumFeatures();
    });
}
```

**5. Module Attributes and Import Assertions:**

```javascript
// Import JSON (requires import assertions)
import configData from './config.json' assert { type: 'json' };
console.log(configData.version);

// Import CSS (with appropriate bundler support)
import styles from './styles.css' assert { type: 'css' };
document.adoptedStyleSheets = [styles];
```

**6. Top-level await (ES2022):**

```javascript
// data-service.js
const response = await fetch('https://api.example.com/data');
const data = await response.json();

export { data };

// main.js
import { data } from './data-service.js';
// The import will wait until data-service.js has finished its await operations
console.log(data);
```

**Module Loading and Execution:**

```javascript
// 1. Modules are executed only once, even when imported multiple times
// module.js
console.log('Module initialized');
export const value = Math.random();

// main.js
import { value as value1 } from './module.js'; // Logs "Module initialized"
import { value as value2 } from './module.js'; // No log, module already executed
console.log(value1 === value2); // true, same instance

// 2. Modules are executed in order of the import graph
// a.js
console.log('Module A');
import './b.js';

// b.js
console.log('Module B');
import './c.js';

// c.js
console.log('Module C');

// When importing a.js, logs: "Module C", "Module B", "Module A"
```

**Module Patterns and Best Practices:**

**1. Barrel Files (Index Modules):**

```javascript
// components/Button.js
export const Button = props => { /* ... */ };

// components/Input.js
export const Input = props => { /* ... */ };

// components/index.js (barrel file)
export { Button } from './Button.js';
export { Input } from './Input.js';

// Usage
import { Button, Input } from './components';
```

**2. Facade Pattern:**

```javascript
// api/index.js
import * as userAPI from './user-api.js';
import * as productAPI from './product-api.js';

// Simplified facade
export const getUser = userAPI.getUser;
export const getProduct = productAPI.getProduct;

// Enhanced facade with additional logic
export async function getUserWithProducts(userId) {
  const user = await userAPI.getUser(userId);
  const products = await productAPI.getUserProducts(userId);
  return { ...user, products };
}
```

**3. Service Modules:**

```javascript
// auth-service.js
let currentUser = null;

export function login(username, password) {
  // Authentication logic
  currentUser = { username, role: 'user' };
  return currentUser;
}

export function logout() {
  currentUser = null;
}

export function getCurrentUser() {
  return currentUser;
}

// Usage maintains state between imports
import { login, getCurrentUser } from './auth-service.js';
login('john', 'password123');

// In another file
import { getCurrentUser } from './auth-service.js';
console.log(getCurrentUser()); // { username: 'john', role: 'user' }
```

**4. Factory Pattern:**

```javascript
// logger-factory.js
export function createLogger(namespace) {
  return {
    log: message => console.log(`[${namespace}] ${message}`),
    error: message => console.error(`[${namespace}] ERROR: ${message}`),
    warn: message => console.warn(`[${namespace}] WARNING: ${message}`)
  };
}

// Usage
import { createLogger } from './logger-factory.js';

const userLogger = createLogger('USER');
const apiLogger = createLogger('API');

userLogger.log('User logged in'); // "[USER] User logged in"
apiLogger.error('Request failed'); // "[API] ERROR: Request failed"
```

**5. Dependency Injection Pattern:**

```javascript
// database.js
export class Database {
  query(sql) { /* ... */ }
}

// user-repository.js
export class UserRepository {
  constructor(db) {
    this.db = db;
  }
  
  findUser(id) {
    return this.db.query(`SELECT * FROM users WHERE id = ${id}`);
  }
}

// app.js
import { Database } from './database.js';
import { UserRepository } from './user-repository.js';

const db = new Database();
const userRepo = new UserRepository(db);

const user = userRepo.findUser(123);
```

**Common Issues and Solutions:**

**1. Circular Dependencies:**

```javascript
// a.js
import { b } from './b.js';
export const a = 1;
export function getB() {
  return b;
}

// b.js
import { a, getB } from './a.js';
export const b = 2;
console.log(a); // undefined (a is not initialized yet)
console.log(getB()); // 2 (function called after both modules are evaluated)
```

**Solution:** Restructure modules or move the circular dependency to a third module.

**2. Tree Shaking for Bundle Size Optimization:**

```javascript
// Bad for tree shaking
export default {
  helper1: function() { /* ... */ },
  helper2: function() { /* ... */ }
};

// Good for tree shaking (named exports)
export function helper1() { /* ... */ }
export function helper2() { /* ... */ }

// Usage
import { helper1 } from './helpers.js'; // Only helper1 is included in the bundle
```

**3. Module Side Effects:**

```javascript
// side-effects.js
console.log('This runs on import');
document.body.style.backgroundColor = 'red';

// To mark a module as side-effect free (for bundlers)
/*#__PURE__*/
export function pureFunction() { /* ... */ }
```

**4. Module Initialization:**

```javascript
// Lazy initialization pattern
let instance;

export function getInstance() {
  if (!instance) {
    instance = createExpensiveInstance();
  }
  return instance;
}

function createExpensiveInstance() {
  // Complex initialization
  return { /* ... */ };
}
```

**Browser Support and Deployment:**

**1. Script Tags with Type Module:**

```html
<!-- Modern browsers support ES modules directly -->
<script type="module">
  import { feature } from './module.js';
  feature();
</script>

<!-- Fallback for older browsers -->
<script nomodule src="fallback-bundle.js"></script>
```

**2. Import Maps (Modern Browsers):**

```html
<script type="importmap">
{
  "imports": {
    "lodash": "https://cdn.skypack.dev/lodash",
    "react": "https://cdn.skypack.dev/react",
    "utils/": "/js/utils/"
  }
}
</script>

<script type="module">
  import _ from 'lodash';
  import React from 'react';
  import { formatDate } from 'utils/date.js';
</script>
```

**3. Dynamic Import Polyfill:**

```javascript
// Polyfill for browsers without dynamic import support
function importModule(url) {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.type = 'module';
    script.textContent = `
      import * as module from '${url}';
      window._tempModule = module;
    `;
    
    script.onload = () => {
      resolve(window._tempModule);
      delete window._tempModule;
      document.head.removeChild(script);
    };
    
    script.onerror = reject;
    document.head.appendChild(script);
  });
}

// Usage
importModule('./module.js')
  .then(module => {
    module.doSomething();
  });
```

**Node.js ESM Support:**

```javascript
// package.json
{
  "type": "module" // Treat all .js files as ESM
}

// OR use .mjs extension for ES modules

// Importing CommonJS from ESM
import pkg from 'commonjs-package'; // Default import gets module.exports

// Importing ESM from CommonJS
const { feature } = await import('./esm-module.js');
```

**Key Takeaways:**

1. ES Modules are the standard module system for JavaScript, supported in modern browsers and Node.js
2. They provide better static analysis, tree shaking, and code organization than older module systems
3. Named exports are preferred for better tree shaking and code clarity
4. Dynamic imports enable code splitting and lazy loading for performance optimization
5. Understanding module patterns helps create maintainable, scalable applications
6. Modern tooling (Webpack, Rollup, Vite, etc.) provides excellent support for working with ES Modules

### Q58: Explain JavaScript memory management and garbage collection in depth.
**Difficulty: Hard**

**Answer:**
JavaScript is a high-level language with automatic memory management through garbage collection. Understanding how memory allocation and garbage collection work is crucial for writing efficient, leak-free applications, especially for complex web applications and Node.js servers.

**Memory Allocation in JavaScript:**

**1. Stack Memory:**
- Used for static data like primitive values and references
- Fixed-size, fast access, managed by CPU
- Function calls create new stack frames
- Automatically cleared when functions return

**2. Heap Memory:**
- Used for dynamic data like objects and arrays
- Flexible size, slower access than stack
- Managed by JavaScript engine's garbage collector
- Where memory leaks typically occur

**Memory Lifecycle:**

```javascript
// 1. Allocation
const number = 42;          // Allocates memory for a number on the stack
const string = 'Hello';     // Allocates memory for a string on the stack/heap
const object = {};          // Allocates memory for an object on the heap
const array = [1, 2, 3];    // Allocates memory for an array on the heap

// 2. Use
console.log(number);        // Using the allocated memory
object.property = 'value';  // Using and modifying allocated memory

// 3. Release (automatic via garbage collection)
// When variables go out of scope or references are removed
```

**Garbage Collection Algorithms:**

**1. Reference Counting:**

An early garbage collection algorithm that counts references to objects.

```javascript
let obj = { name: 'Example' }; // Reference count: 1
let reference = obj;        // Reference count: 2
reference = null;           // Reference count: 1
obj = null;                 // Reference count: 0, object eligible for GC
```

Limitation: Cannot handle circular references

```javascript
function createCycle() {
  const obj1 = {};
  const obj2 = {};
  obj1.ref = obj2; // obj1 references obj2
  obj2.ref = obj1; // obj2 references obj1
  
  return 'Cycle created';
}

createCycle(); // Both objects have reference count > 0 despite being unreachable
```

**2. Mark and Sweep Algorithm:**

Modern JavaScript engines use variations of the mark-and-sweep algorithm:

1. The garbage collector identifies a set of "roots" (global objects)
2. It marks all objects reachable from these roots as "in use"
3. It sweeps through memory and removes unmarked objects

```javascript
// Global scope (root)
let user = { name: 'John' };  // Reachable from root, marked as in-use
let admin = user;             // Same object reachable via another reference

user = null;                  // Object still reachable via 'admin'
admin = null;                 // Object no longer reachable, eligible for GC
```

**3. Generational Collection:**

Modern engines like V8 (Chrome, Node.js) use generational garbage collection:

- Objects are divided into "young" (new) and "old" (survived several GC cycles)
- Young generation is collected more frequently ("minor GC")
- Old generation is collected less frequently ("major GC")

**Memory Leaks in JavaScript:**

**1. Accidental Global Variables:**

```javascript
function leakyFunction() {
  leakyVar = 'I am not declared with var/let/const'; // Global variable!
}

// Better:
function betterFunction() {
  'use strict'; // Prevents accidental globals
  let localVar = 'I am properly scoped';
}
```

**2. Forgotten Timers and Callbacks:**

```javascript
// Memory leak: timer references object that's no longer needed
function createLeakyTimer() {
  const largeData = new Array(1000000).fill('data');
  
  setInterval(() => {
    // This references largeData, preventing GC
    console.log('Timer running, data length:', largeData.length);
  }, 1000);
}

// Better: store timer ID and clear when done
function createCleanTimer() {
  const largeData = new Array(1000000).fill('data');
  const timerId = setInterval(() => {
    console.log('Timer running, data length:', largeData.length);
  }, 1000);
  
  // Later when no longer needed:
  clearInterval(timerId);
}
```

**3. Closures Capturing Large Scopes:**

```javascript
function createLargeClosures() {
  const largeData = new Array(1000000).fill('data');
  
  return function() {
    // This closure captures the entire parent scope, including largeData
    return largeData[0];
  };
}

// Better: only capture what's needed
function createEfficientClosures() {
  const largeData = new Array(1000000).fill('data');
  const firstItem = largeData[0]; // Extract only what's needed
  
  return function() {
    return firstItem; // Only captures firstItem, not the entire largeData
  };
}
```

**4. Detached DOM Elements:**

```javascript
// Memory leak: keeping references to removed DOM elements
let detachedNodes = [];

function createDetachedDOM() {
  const div = document.createElement('div');
  document.body.appendChild(div);
  
  // Store reference to the DOM node
  detachedNodes.push(div);
  
  // Remove from DOM but keep in our array
  document.body.removeChild(div);
  // div is detached from DOM but still in memory!
}

// Better: clear references when no longer needed
function cleanupDetachedDOM() {
  detachedNodes = [];
}
```

**5. Event Listeners:**

```javascript
// Memory leak: adding event listeners without removing them
function addLeakyEventListener() {
  const button = document.getElementById('button');
  const largeData = new Array(1000000).fill('data');
  
  button.addEventListener('click', function() {
    // This handler captures largeData
    console.log('Button clicked, data length:', largeData.length);
  });
  // If button is removed from DOM, the handler and largeData still exist in memory
}

// Better: remove event listeners when no longer needed
function addCleanEventListener() {
  const button = document.getElementById('button');
  const largeData = new Array(1000000).fill('data');
  
  const handler = function() {
    console.log('Button clicked, data length:', largeData.length);
  };
  
  button.addEventListener('click', handler);
  
  // Later when no longer needed:
  button.removeEventListener('click', handler);
}
```

**6. WeakMap and WeakSet for Preventing Leaks:**

```javascript
// Using WeakMap to store metadata about objects without preventing GC
function createMetadataTracker() {
  // WeakMap holds references to keys weakly - they can still be garbage collected
  const metadata = new WeakMap();
  
  function addObject(obj, meta) {
    metadata.set(obj, meta);
  }
  
  function getMetadata(obj) {
    return metadata.get(obj);
  }
  
  return { addObject, getMetadata };
}

const tracker = createMetadataTracker();
let user = { name: 'John' };

tracker.addObject(user, { lastAccess: Date.now() });
console.log(tracker.getMetadata(user)); // { lastAccess: timestamp }

user = null; // The user object and its metadata can be garbage collected
```

**Memory Profiling and Debugging:**

**1. Chrome DevTools Memory Profiling:**

```javascript
// Example of code to profile
function createObjects() {
  let result = [];
  for (let i = 0; i < 1000; i++) {
    result.push({ index: i, data: new Array(1000).fill(i) });
  }
  return result;
}

// In Chrome DevTools:
// 1. Open Performance or Memory tab
// 2. Record heap snapshot before
// 3. Run the function
// 4. Record heap snapshot after
// 5. Compare snapshots to find retained objects
const objects = createObjects();
```

**2. Memory Leaks Detection Patterns:**

```javascript
// Pattern: Growing memory usage over time
function detectMemoryLeak() {
  let leak = [];
  
  setInterval(() => {
    leak.push(new Array(1000000).fill('leak'));
    console.log('Memory used:', process.memoryUsage().heapUsed / 1024 / 1024, 'MB');
  }, 1000);
}

// In Node.js, monitor with:
// process.memoryUsage()

// In browser, use Performance Monitor in DevTools
```

**Advanced Garbage Collection Optimization:**

**1. Object Pooling:**

```javascript
// Reuse objects instead of creating new ones
class ObjectPool {
  constructor(createFn, initialSize = 10) {
    this.createFn = createFn;
    this.pool = Array(initialSize).fill().map(() => this.createFn());
  }
  
  get() {
    if (this.pool.length === 0) {
      return this.createFn();
    }
    return this.pool.pop();
  }
  
  release(obj) {
    this.pool.push(obj);
  }
}

// Usage
const vectorPool = new ObjectPool(() => ({ x: 0, y: 0 }));

function processVectors() {
  const v1 = vectorPool.get();
  v1.x = 10;
  v1.y = 20;
  
  // Use v1...
  
  // Return to pool instead of letting GC handle it
  v1.x = 0;
  v1.y = 0;
  vectorPool.release(v1);
}
```

**2. Avoiding Closures for Performance-Critical Code:**

```javascript
// Closure-heavy approach (creates functions for each item)
function processList(items) {
  return items.map(item => {
    return () => item * 2; // Creates a closure for each item
  });
}

// More efficient approach
function processListBetter(items) {
  const results = new Array(items.length);
  for (let i = 0; i < items.length; i++) {
    results[i] = items[i] * 2; // Direct computation, no closures
  }
  return results;
}
```

**3. Handling Large Data Sets:**

```javascript
// Process data in chunks to avoid memory spikes
async function processLargeArray(array, chunkSize = 1000) {
  const results = [];
  
  for (let i = 0; i < array.length; i += chunkSize) {
    const chunk = array.slice(i, i + chunkSize);
    
    // Process chunk
    const chunkResults = chunk.map(item => processItem(item));
    results.push(...chunkResults);
    
    // Allow GC to run and UI to update
    await new Promise(resolve => setTimeout(resolve, 0));
  }
  
  return results;
}

function processItem(item) {
  return item * 2;
}
```

**4. Optimizing String Concatenation:**

```javascript
// Inefficient: creates many intermediate strings
function buildStringBad(items) {
  let result = '';
  for (let i = 0; i < items.length; i++) {
    result += items[i]; // Creates a new string each time
  }
  return result;
}

// Better: uses array join
function buildStringGood(items) {
  return items.join(''); // More efficient
}

// Or for complex cases, use array and join
function buildComplexString(items) {
  const parts = [];
  for (let i = 0; i < items.length; i++) {
    parts.push(processItem(items[i]));
  }
  return parts.join('');
}
```

**5. Handling Memory in Web Workers:**

```javascript
// Offload memory-intensive tasks to Web Workers
function startMemoryIntensiveTask(data) {
  const worker = new Worker('worker.js');
  
  worker.onmessage = function(e) {
    console.log('Task completed with result:', e.data);
    // Terminate worker when done to free memory
    worker.terminate();
  };
  
  worker.postMessage(data);
}

// In worker.js
self.onmessage = function(e) {
  const result = processLargeData(e.data);
  self.postMessage(result);
};

function processLargeData(data) {
  // Memory-intensive processing
  return data.map(x => x * x);
}
```

**Browser-Specific Memory Management:**

**1. Chrome V8 Engine:**
- Uses generational garbage collection with young and old spaces
- Implements incremental marking to reduce GC pauses
- Employs concurrent garbage collection when possible

**2. Firefox SpiderMonkey:**
- Uses incremental garbage collection
- Implements generational collection
- Features compacting garbage collection

**3. Safari JavaScriptCore:**
- Uses multiple collector types for different object types
- Implements concurrent and incremental collection

**Node.js Memory Management:**

```javascript
// Controlling Node.js memory limits
node --max-old-space-size=4096 script.js // Increase heap size to 4GB

// Monitoring memory in Node.js
const memoryUsage = process.memoryUsage();
console.log({
  rss: `${memoryUsage.rss / 1024 / 1024} MB`,      // Resident Set Size - total memory allocated
  heapTotal: `${memoryUsage.heapTotal / 1024 / 1024} MB`, // Total size of allocated heap
  heapUsed: `${memoryUsage.heapUsed / 1024 / 1024} MB`,  // Actual memory used
  external: `${memoryUsage.external / 1024 / 1024} MB`,  // Memory used by C++ objects
});
```

**Best Practices for Memory Management:**

**1. Limit Variable Scope:**

```javascript
// Bad: variables in broader scope than needed
let tempData = null;

function processData(data) {
  tempData = data; // Stored in parent scope
  // Process data...
  return tempData.length;
}

// Good: variables scoped as tightly as possible
function processDataBetter(data) {
  // data is local to this function
  // Process data...
  return data.length;
}
```

**2. Nullify References When Done:**

```javascript
function processLargeData() {
  const largeData = new Array(1000000).fill('data');
  
  // Process data...
  const result = largeData.length;
  
  // Clear reference when done
  largeData = null;
  
  return result;
}
```

**3. Use Appropriate Data Structures:**

```javascript
// Inefficient for frequent lookups
function findInArray(array, id) {
  return array.find(item => item.id === id);
}

// More efficient with Map
function createEfficientLookup(array) {
  const map = new Map();
  for (const item of array) {
    map.set(item.id, item);
  }
  
  return id => map.get(id);
}
```

**4. Avoid Memory-Intensive Closures in Loops:**

```javascript
// Bad: creates a closure for each element
function addHandlersBad(elements) {
  for (let i = 0; i < elements.length; i++) {
    const element = elements[i];
    element.addEventListener('click', function() {
      console.log('Element clicked:', element.textContent);
    });
  }
}

// Better: use event delegation
function addHandlersGood(elements, containerId) {
  const container = document.getElementById(containerId);
  container.addEventListener('click', function(event) {
    if (event.target.matches('.clickable')) {
      console.log('Element clicked:', event.target.textContent);
    }
  });
}
```

**5. Dispose Resources Properly:**

```javascript
// For resources that need explicit cleanup
class ResourceManager {
  constructor() {
    this.resources = new Set();
  }
  
  acquire(resource) {
    this.resources.add(resource);
    return resource;
  }
  
  release(resource) {
    if (resource.dispose) {
      resource.dispose();
    }
    this.resources.delete(resource);
  }
  
  releaseAll() {
    for (const resource of this.resources) {
      if (resource.dispose) {
        resource.dispose();
      }
    }
    this.resources.clear();
  }
}

// Usage
const manager = new ResourceManager();
const resource = manager.acquire(createExpensiveResource());

// When done
manager.release(resource);

// Or release all at once
manager.releaseAll();
```

**Key Takeaways:**

1. JavaScript uses automatic garbage collection to manage memory
2. Modern JavaScript engines use sophisticated algorithms like mark-and-sweep and generational collection
3. Common memory leaks include forgotten callbacks, detached DOM elements, and accidental global variables
4. Tools like Chrome DevTools and Node.js memory profiling help identify memory issues
5. Best practices include limiting variable scope, using appropriate data structures, and properly disposing resources
6. Understanding memory management is crucial for building high-performance, stable JavaScript applications

### Q59: Explain common JavaScript design patterns with examples.
**Difficulty: Medium**

**Answer:**
Design patterns are reusable solutions to common problems in software design. They represent best practices evolved over time by experienced developers. In JavaScript, design patterns help create maintainable, scalable, and robust applications.

**1. Creational Patterns**

**Singleton Pattern:**
Ensures a class has only one instance and provides a global point of access to it.

```javascript
// Classic Singleton
const Singleton = (function() {
  let instance;
  
  function createInstance() {
    const object = new Object("I am the singleton instance");
    return object;
  }
  
  return {
    getInstance: function() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

const instance1 = Singleton.getInstance();
const instance2 = Singleton.getInstance();
console.log(instance1 === instance2); // true

// Modern Singleton using ES modules
// database.js
class Database {
  constructor(data) {
    if (Database.instance) {
      return Database.instance;
    }
    
    this.data = data;
    Database.instance = this;
  }
  
  getData() {
    return this.data;
  }
}

// Usage
const mongo = new Database('MongoDB');
const mysql = new Database('MySQL');

console.log(mongo === mysql); // true
console.log(mongo.getData()); // 'MongoDB' (not 'MySQL')
```

**Factory Pattern:**
Creates objects without specifying the exact class or constructor function to use.

```javascript
// Simple Factory
class UserFactory {
  createUser(type) {
    switch(type) {
      case 'admin':
        return new Admin();
      case 'moderator':
        return new Moderator();
      case 'guest':
        return new Guest();
      default:
        throw new Error(`User type ${type} not recognized.`);
    }
  }
}

class Admin {
  constructor() {
    this.role = 'admin';
    this.permissions = ['read', 'write', 'delete', 'manage-users'];
  }
}

class Moderator {
  constructor() {
    this.role = 'moderator';
    this.permissions = ['read', 'write', 'delete'];
  }
}

class Guest {
  constructor() {
    this.role = 'guest';
    this.permissions = ['read'];
  }
}

// Usage
const factory = new UserFactory();
const admin = factory.createUser('admin');
const guest = factory.createUser('guest');

console.log(admin.permissions); // ['read', 'write', 'delete', 'manage-users']
console.log(guest.permissions); // ['read']
```

**Builder Pattern:**
Separates the construction of complex objects from their representation.

```javascript
class QueryBuilder {
  constructor() {
    this.query = {};
  }
  
  select(fields) {
    this.query.fields = fields;
    return this;
  }
  
  from(table) {
    this.query.table = table;
    return this;
  }
  
  where(conditions) {
    this.query.conditions = conditions;
    return this;
  }
  
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  
  build() {
    return this.query;
  }
}

// Usage
const query = new QueryBuilder()
  .select(['name', 'email'])
  .from('users')
  .where({ status: 'active' })
  .limit(10)
  .build();

console.log(query);
// { fields: ['name', 'email'], table: 'users', conditions: { status: 'active' }, limit: 10 }
```

**Prototype Pattern:**
Creates new objects by cloning existing ones, rather than creating from scratch.

```javascript
// Using Object.create
const vehiclePrototype = {
  init(model) {
    this.model = model;
  },
  getModel() {
    return this.model;
  },
  drive() {
    console.log(`Driving ${this.model}`);
  }
};

function createVehicle(model) {
  const vehicle = Object.create(vehiclePrototype);
  vehicle.init(model);
  return vehicle;
}

// Usage
const car = createVehicle('Tesla');
car.drive(); // "Driving Tesla"

// Using class syntax
class Vehicle {
  constructor(model) {
    this.model = model;
  }
  
  clone() {
    return new Vehicle(this.model);
  }
}

const originalVehicle = new Vehicle('Tesla');
const clonedVehicle = originalVehicle.clone();
```

**2. Structural Patterns**

**Module Pattern:**
Encapsulates private functionality within a closure while exposing a public API.

```javascript
// Classic Module Pattern
const Calculator = (function() {
  // Private variables and functions
  let result = 0;
  
  function add(a, b) {
    return a + b;
  }
  
  function subtract(a, b) {
    return a - b;
  }
  
  // Public API
  return {
    add: function(a, b) {
      result = add(a, b);
      return result;
    },
    subtract: function(a, b) {
      result = subtract(a, b);
      return result;
    },
    getResult: function() {
      return result;
    }
  };
})();

// Usage
console.log(Calculator.add(5, 3));     // 8
console.log(Calculator.subtract(10, 4)); // 6
console.log(Calculator.getResult());     // 6

// Modern Module Pattern using ES modules
// calculator.js
let result = 0;

function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}

export function performAdd(a, b) {
  result = add(a, b);
  return result;
}

export function performSubtract(a, b) {
  result = subtract(a, b);
  return result;
}

export function getResult() {
  return result;
}
```

**Decorator Pattern:**
Dynamically adds behavior to objects without affecting other objects of the same class.

```javascript
// Function decorators
function logExecutionTime(func) {
  return function(...args) {
    const start = performance.now();
    const result = func.apply(this, args);
    const end = performance.now();
    console.log(`Execution time: ${end - start} ms`);
    return result;
  };
}

function memoize(func) {
  const cache = new Map();
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = func.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// Usage
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const fastFibonacci = memoize(fibonacci);
const trackedFibonacci = logExecutionTime(fastFibonacci);

console.log(trackedFibonacci(40)); // Much faster with memoization

// Class decorators
class Coffee {
  cost() {
    return 5;
  }
  
  description() {
    return 'Simple coffee';
  }
}

class MilkDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }
  
  cost() {
    return this.coffee.cost() + 1.5;
  }
  
  description() {
    return `${this.coffee.description()} with milk`;
  }
}

class SugarDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }
  
  cost() {
    return this.coffee.cost() + 0.5;
  }
  
  description() {
    return `${this.coffee.description()} with sugar`;
  }
}

// Usage
let myCoffee = new Coffee();
console.log(myCoffee.description(), myCoffee.cost()); // "Simple coffee 5"

myCoffee = new MilkDecorator(myCoffee);
console.log(myCoffee.description(), myCoffee.cost()); // "Simple coffee with milk 6.5"

myCoffee = new SugarDecorator(myCoffee);
console.log(myCoffee.description(), myCoffee.cost()); // "Simple coffee with milk with sugar 7"
```

**Facade Pattern:**
Provides a simplified interface to a complex subsystem.

```javascript
// Complex subsystems
class AudioAPI {
  constructor() {
    this.volume = 50;
  }
  
  setVolume(percent) {
    this.volume = percent;
    console.log(`Setting volume to ${percent}%`);
  }
  
  initialize() {
    console.log('Audio system initialized');
  }
}

class VideoAPI {
  constructor() {
    this.contrast = 50;
    this.brightness = 50;
  }
  
  setContrast(percent) {
    this.contrast = percent;
    console.log(`Setting contrast to ${percent}%`);
  }
  
  setBrightness(percent) {
    this.brightness = percent;
    console.log(`Setting brightness to ${percent}%`);
  }
  
  initialize() {
    console.log('Video system initialized');
  }
}

class InputAPI {
  constructor() {
    this.sensitivity = 50;
  }
  
  setSensitivity(percent) {
    this.sensitivity = percent;
    console.log(`Setting input sensitivity to ${percent}%`);
  }
  
  initialize() {
    console.log('Input system initialized');
  }
}

// Facade
class MultimediaFacade {
  constructor() {
    this.audio = new AudioAPI();
    this.video = new VideoAPI();
    this.input = new InputAPI();
  }
  
  initialize() {
    this.audio.initialize();
    this.video.initialize();
    this.input.initialize();
    console.log('All systems initialized');
  }
  
  setDefaultSettings() {
    this.audio.setVolume(30);
    this.video.setContrast(60);
    this.video.setBrightness(50);
    this.input.setSensitivity(40);
    console.log('Default settings applied');
  }
  
  setMovieMode() {
    this.audio.setVolume(70);
    this.video.setContrast(80);
    this.video.setBrightness(60);
    this.input.setSensitivity(30);
    console.log('Movie mode enabled');
  }
}

// Usage
const multimedia = new MultimediaFacade();
multimedia.initialize();
multimedia.setMovieMode();
```

**Proxy Pattern:**
Provides a surrogate or placeholder for another object to control access to it.

```javascript
// Target object
class DatabaseAccess {
  getData() {
    return 'Sensitive data from database';
  }
  
  setData(data) {
    console.log(`Data saved: ${data}`);
    return true;
  }
}

// Proxy with access control
class SecureDBProxy {
  constructor(user) {
    this.user = user;
    this.database = new DatabaseAccess();
  }
  
  getData() {
    if (this.user.isAuthenticated && this.user.hasReadAccess) {
      return this.database.getData();
    } else {
      throw new Error('Access denied: read permission required');
    }
  }
  
  setData(data) {
    if (this.user.isAuthenticated && this.user.hasWriteAccess) {
      return this.database.setData(data);
    } else {
      throw new Error('Access denied: write permission required');
    }
  }
}

// Usage
const adminUser = {
  isAuthenticated: true,
  hasReadAccess: true,
  hasWriteAccess: true
};

const guestUser = {
  isAuthenticated: true,
  hasReadAccess: true,
  hasWriteAccess: false
};

const adminProxy = new SecureDBProxy(adminUser);
console.log(adminProxy.getData()); // "Sensitive data from database"
adminProxy.setData('New data'); // "Data saved: New data"

const guestProxy = new SecureDBProxy(guestUser);
console.log(guestProxy.getData()); // "Sensitive data from database"
try {
  guestProxy.setData('Malicious data'); // Error: Access denied
} catch (e) {
  console.log(e.message);
}
```

**3. Behavioral Patterns**

**Observer Pattern:**
Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified.

```javascript
class Observable {
  constructor() {
    this.observers = [];
  }
  
  subscribe(observer) {
    this.observers.push(observer);
    return () => this.unsubscribe(observer); // Return unsubscribe function
  }
  
  unsubscribe(observer) {
    this.observers = this.observers.filter(obs => obs !== observer);
  }
  
  notify(data) {
    this.observers.forEach(observer => observer(data));
  }
}

// Usage
const newsPublisher = new Observable();

function emailSubscriber(data) {
  console.log(`Sending email with news: ${data}`);
}

function webSubscriber(data) {
  console.log(`Updating website with news: ${data}`);
}

// Subscribe
const unsubscribeEmail = newsPublisher.subscribe(emailSubscriber);
newsPublisher.subscribe(webSubscriber);

// Publish news
newsPublisher.notify('Breaking news: JavaScript is awesome!');
// "Sending email with news: Breaking news: JavaScript is awesome!"
// "Updating website with news: Breaking news: JavaScript is awesome!"

// Unsubscribe from email updates
unsubscribeEmail();

// Publish more news
newsPublisher.notify('More news: New JavaScript framework released!');
// Only "Updating website with news: More news: New JavaScript framework released!"
```

**Strategy Pattern:**
Defines a family of algorithms, encapsulates each one, and makes them interchangeable.

```javascript
// Strategies
class RegularPricingStrategy {
  calculatePrice(basePrice) {
    return basePrice;
  }
}

class PremiumPricingStrategy {
  calculatePrice(basePrice) {
    return basePrice * 0.9; // 10% discount
  }
}

class BlackFridayPricingStrategy {
  calculatePrice(basePrice) {
    return basePrice * 0.7; // 30% discount
  }
}

// Context
class ShoppingCart {
  constructor(pricingStrategy) {
    this.pricingStrategy = pricingStrategy;
    this.items = [];
  }
  
  setPricingStrategy(pricingStrategy) {
    this.pricingStrategy = pricingStrategy;
  }
  
  addItem(item) {
    this.items.push(item);
  }
  
  calculateTotal() {
    const basePrice = this.items.reduce((total, item) => total + item.price, 0);
    return this.pricingStrategy.calculatePrice(basePrice);
  }
}

// Usage
const regularCart = new ShoppingCart(new RegularPricingStrategy());
regularCart.addItem({ name: 'Product 1', price: 100 });
regularCart.addItem({ name: 'Product 2', price: 50 });

console.log(regularCart.calculateTotal()); // 150

// Switch to premium pricing
regularCart.setPricingStrategy(new PremiumPricingStrategy());
console.log(regularCart.calculateTotal()); // 135

// Switch to Black Friday pricing
regularCart.setPricingStrategy(new BlackFridayPricingStrategy());
console.log(regularCart.calculateTotal()); // 105
```

**Command Pattern:**
Encapsulates a request as an object, allowing parameterization of clients with different requests, queuing of requests, and logging of operations.

```javascript
// Receiver
class Light {
  turnOn() {
    console.log('Light turned on');
  }
  
  turnOff() {
    console.log('Light turned off');
  }
  
  dim() {
    console.log('Light dimmed');
  }
}

// Commands
class TurnOnCommand {
  constructor(light) {
    this.light = light;
  }
  
  execute() {
    this.light.turnOn();
  }
  
  undo() {
    this.light.turnOff();
  }
}

class TurnOffCommand {
  constructor(light) {
    this.light = light;
  }
  
  execute() {
    this.light.turnOff();
  }
  
  undo() {
    this.light.turnOn();
  }
}

class DimCommand {
  constructor(light) {
    this.light = light;
  }
  
  execute() {
    this.light.dim();
  }
  
  // No simple undo for dim
}

// Invoker
class RemoteControl {
  constructor() {
    this.commands = {};
    this.history = [];
  }
  
  setCommand(button, command) {
    this.commands[button] = command;
  }
  
  pressButton(button) {
    const command = this.commands[button];
    if (command) {
      command.execute();
      this.history.push(command);
    }
  }
  
  undo() {
    const command = this.history.pop();
    if (command && command.undo) {
      command.undo();
    }
  }
}

// Usage
const light = new Light();
const turnOn = new TurnOnCommand(light);
const turnOff = new TurnOffCommand(light);
const dim = new DimCommand(light);

const remote = new RemoteControl();
remote.setCommand('on', turnOn);
remote.setCommand('off', turnOff);
remote.setCommand('dim', dim);

remote.pressButton('on');  // "Light turned on"
remote.pressButton('dim');  // "Light dimmed"
remote.pressButton('off'); // "Light turned off"
remote.undo();            // "Light turned on"
```

**Iterator Pattern:**
Provides a way to access elements of an aggregate object sequentially without exposing its underlying representation.

```javascript
class IterableCollection {
  constructor(items) {
    this.items = items;
  }
  
  // Built-in iterator protocol
  [Symbol.iterator]() {
    let index = 0;
    const items = this.items;
    
    return {
      next() {
        return index < items.length ?
          { value: items[index++], done: false } :
          { done: true };
      }
    };
  }
  
  // Custom iterators
  reverseIterator() {
    let index = this.items.length - 1;
    const items = this.items;
    
    return {
      next() {
        return index >= 0 ?
          { value: items[index--], done: false } :
          { done: true };
      }
    };
  }
  
  skipIterator(skip) {
    let index = 0;
    const items = this.items;
    
    return {
      next() {
        if (index >= items.length) {
          return { done: true };
        }
        const value = items[index];
        index += skip;
        return { value, done: false };
      }
    };
  }
}

// Usage
const collection = new IterableCollection([1, 2, 3, 4, 5]);

// Using built-in iterator
for (const item of collection) {
  console.log(item); // 1, 2, 3, 4, 5
}

// Using custom reverse iterator
const reverseIterator = collection.reverseIterator();
let result = reverseIterator.next();
while (!result.done) {
  console.log(result.value); // 5, 4, 3, 2, 1
  result = reverseIterator.next();
}

// Using custom skip iterator
const skipIterator = collection.skipIterator(2);
result = skipIterator.next();
while (!result.done) {
  console.log(result.value); // 1, 3, 5
  result = skipIterator.next();
}
```

**Mediator Pattern:**
Defines an object that encapsulates how a set of objects interact, promoting loose coupling.

```javascript
class ChatMediator {
  constructor() {
    this.users = [];
  }
  
  addUser(user) {
    this.users.push(user);
  }
  
  sendMessage(message, sender) {
    this.users.forEach(user => {
      // Don't send message back to sender
      if (user !== sender) {
        user.receiveMessage(message, sender);
      }
    });
  }
}

class User {
  constructor(name, mediator) {
    this.name = name;
    this.mediator = mediator;
    mediator.addUser(this);
  }
  
  sendMessage(message) {
    console.log(`${this.name} sends: ${message}`);
    this.mediator.sendMessage(message, this);
  }
  
  receiveMessage(message, sender) {
    console.log(`${this.name} received from ${sender.name}: ${message}`);
  }
}

// Usage
const chatroom = new ChatMediator();

const john = new User('John', chatroom);
const alice = new User('Alice', chatroom);
const bob = new User('Bob', chatroom);

john.sendMessage('Hello everyone!');
// "John sends: Hello everyone!"
// "Alice received from John: Hello everyone!"
// "Bob received from John: Hello everyone!"

alice.sendMessage('Hi John!');
// "Alice sends: Hi John!"
// "John received from Alice: Hi John!"
// "Bob received from Alice: Hi John!"
```

**4. Modern JavaScript Patterns**

**Hooks Pattern (React-inspired):**
Encapsulates stateful logic and side effects in reusable functions.

```javascript
// Simple implementation of React-like hooks
let currentComponent = null;
const components = new Map();

function useState(initialState) {
  const component = currentComponent;
  if (!components.has(component)) {
    components.set(component, { states: [], stateIndex: 0 });
  }
  
  const componentData = components.get(component);
  const { states, stateIndex } = componentData;
  
  if (stateIndex === states.length) {
    states.push(initialState);
  }
  
  const currentState = states[stateIndex];
  const setState = (newState) => {
    states[stateIndex] = newState;
    renderComponent(component);
  };
  
  componentData.stateIndex++;
  return [currentState, setState];
}

function useEffect(callback, dependencies) {
  const component = currentComponent;
  if (!components.has(component)) {
    components.set(component, { effects: [], effectIndex: 0, dependencies: [] });
  }
  
  const componentData = components.get(component);
  const { effects, effectIndex, dependencies: prevDeps } = componentData;
  
  const hasChanged = !prevDeps[effectIndex] || 
    !dependencies || 
    dependencies.some((dep, i) => dep !== prevDeps[effectIndex][i]);
  
  if (hasChanged) {
    // Clean up previous effect
    if (effects[effectIndex]) {
      effects[effectIndex]();
    }
    
    // Schedule new effect
    setTimeout(() => {
      effects[effectIndex] = callback();
    }, 0);
  }
  
  componentData.dependencies[effectIndex] = dependencies;
  componentData.effectIndex++;
}

function renderComponent(component) {
  // Reset indices before rendering
  const componentData = components.get(component);
  if (componentData) {
    componentData.stateIndex = 0;
    componentData.effectIndex = 0;
  }
  
  currentComponent = component;
  component.render();
  currentComponent = null;
}

// Usage
class Counter {
  render() {
    const [count, setCount] = useState(0);
    const [text, setText] = useState('Hello');
    
    useEffect(() => {
      console.log(`Count changed to ${count}`);
      document.title = `Count: ${count}`;
      
      return () => {
        console.log('Cleaning up effect');
      };
    }, [count]);
    
    console.log(`Rendering with count: ${count}, text: ${text}`);
    
    // Simulate click handler
    if (!this.initialized) {
      this.initialized = true;
      setTimeout(() => setCount(count + 1), 1000);
    }
  }
}

const counter = new Counter();
renderComponent(counter);
```

**Composition Pattern:**
Favors object composition over inheritance for code reuse.

```javascript
// Functional mixins
function withLogging(target) {
  return Object.assign({}, target, {
    log(message) {
      console.log(`[${new Date().toISOString()}] ${message}`);
    }
  });
}

function withData(target) {
  return Object.assign({}, target, {
    data: [],
    add(item) {
      this.data.push(item);
    },
    get(index) {
      return this.data[index];
    }
  });
}

function withStorage(target) {
  return Object.assign({}, target, {
    save(key) {
      localStorage.setItem(key, JSON.stringify(this.data));
    },
    load(key) {
      const data = localStorage.getItem(key);
      this.data = data ? JSON.parse(data) : [];
    }
  });
}

// Usage
const baseObject = { name: 'DataManager' };
const dataManager = withStorage(withData(withLogging(baseObject)));

dataManager.log('Initializing data manager'); // "[2023-01-01T00:00:00.000Z] Initializing data manager"
dataManager.add({ id: 1, value: 'Item 1' });
dataManager.add({ id: 2, value: 'Item 2' });
dataManager.save('items');
```

**Middleware Pattern:**
Allows for processing of requests or data through a chain of functions.

```javascript
class MiddlewareChain {
  constructor() {
    this.middlewares = [];
  }
  
  use(middleware) {
    this.middlewares.push(middleware);
    return this; // For chaining
  }
  
  execute(data) {
    let index = 0;
    
    const next = (err) => {
      if (err) {
        return Promise.reject(err);
      }
      
      const middleware = this.middlewares[index++];
      if (!middleware) {
        return Promise.resolve(data);
      }
      
      try {
        return Promise.resolve(middleware(data, next));
      } catch (err) {
        return Promise.reject(err);
      }
    };
    
    return next();
  }
}

// Usage
const chain = new MiddlewareChain();

chain.use(async (data, next) => {
  console.log('Middleware 1: Validating data');
  if (!data.username) {
    throw new Error('Username is required');
  }
  return next();
});

chain.use(async (data, next) => {
  console.log('Middleware 2: Transforming data');
  data.username = data.username.toLowerCase();
  return next();
});

chain.use(async (data, next) => {
  console.log('Middleware 3: Saving data');
  // Simulate database save
  data.id = Date.now();
  return next();
});

// Execute the middleware chain
chain.execute({ username: 'John' })
  .then(result => {
    console.log('Final result:', result);
  })
  .catch(err => {
    console.error('Error:', err.message);
  });

// Logs:
// "Middleware 1: Validating data"
// "Middleware 2: Transforming data"
// "Middleware 3: Saving data"
// "Final result: { username: 'john', id: 1609459200000 }"
```

**Key Takeaways:**

1. Design patterns provide proven solutions to common software design problems
2. Creational patterns like Singleton, Factory, and Builder help manage object creation
3. Structural patterns like Module, Decorator, and Facade organize code and relationships between objects
4. Behavioral patterns like Observer, Strategy, and Command define communication between objects
5. Modern JavaScript patterns like Hooks and Composition leverage the language's functional nature
6. Understanding design patterns helps write more maintainable, scalable, and robust code

### Q60: Explain JavaScript error handling and debugging techniques.
**Difficulty: Medium**

**Answer:**
Error handling and debugging are crucial skills for JavaScript developers. Proper error handling makes applications more robust, while effective debugging techniques help identify and fix issues quickly.

**1. Types of Errors in JavaScript**

**Syntax Errors:**
Occur when the code violates JavaScript's grammar rules. These errors prevent the code from running at all.

```javascript
// Syntax Error examples
function myFunction( {  // Missing closing parenthesis
  console.log('Hello');
}

const value = 'test  // Missing closing quote
```

**Runtime Errors (Exceptions):**
Occur during code execution when something unexpected happens.

```javascript
// Runtime Error examples
const obj = null;
console.log(obj.property);  // TypeError: Cannot read property 'property' of null

function greet() {
  console.log(name);  // ReferenceError: name is not defined
}
greet();
```

**Logical Errors:**
The code runs without throwing errors, but doesn't produce the expected results.

```javascript
// Logical Error example
function calculateArea(radius) {
  return radius * radius;  // Logical error: should be π * radius^2
}

console.log(calculateArea(5));  // Returns 25 instead of ~78.54
```

**Common Error Types:**

- `SyntaxError`: Invalid JavaScript syntax
- `ReferenceError`: Reference to an undefined variable
- `TypeError`: Operation performed on an inappropriate type
- `RangeError`: Numeric value outside of acceptable range
- `URIError`: Incorrect use of URI functions
- `EvalError`: Error with the eval() function
- `AggregateError`: Represents multiple errors wrapped in a single error
- `InternalError`: Error in the JavaScript engine (non-standard)

**2. Error Handling Techniques**

**Try-Catch-Finally:**
The primary mechanism for handling exceptions in JavaScript.

```javascript
try {
  // Code that might throw an error
  const data = JSON.parse(invalidJson);
} catch (error) {
  // Handle the error
  console.error('Failed to parse JSON:', error.message);
} finally {
  // Code that always runs, regardless of whether an error occurred
  console.log('Parsing operation completed');
}
```

**Error Objects:**
Creating and throwing custom errors.

```javascript
// Creating custom error types
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';
    this.code = 'E_VALIDATION';
  }
}

class DatabaseError extends Error {
  constructor(message, query) {
    super(message);
    this.name = 'DatabaseError';
    this.query = query;
  }
}

// Using custom errors
function validateUser(user) {
  if (!user.name) {
    throw new ValidationError('User name is required');
  }
  if (!user.email) {
    throw new ValidationError('User email is required');
  }
}

try {
  validateUser({ name: 'John' });
} catch (error) {
  if (error instanceof ValidationError) {
    console.log('Validation failed:', error.message);
  } else {
    console.error('Unknown error:', error);
  }
}
```

**Error Propagation:**
Allowing errors to bubble up to be handled at a higher level.

```javascript
function processData(data) {
  try {
    validateData(data);  // This might throw an error
    transformData(data); // Only runs if validation succeeds
    return data;
  } catch (error) {
    // Add context to the error and re-throw
    error.context = { processedData: data };
    throw error;
  }
}

function validateData(data) {
  if (!data) {
    throw new Error('Data is required');
  }
  // More validation...
}

try {
  const result = processData(null);
} catch (error) {
  console.error('Processing failed:', error.message, error.context);
}
```

**Async Error Handling:**
Handling errors in asynchronous code.

```javascript
// Using promises
fetchData()
  .then(data => processData(data))
  .catch(error => {
    console.error('Error in data pipeline:', error);
  });

// Using async/await
async function getData() {
  try {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    const data = await response.json();
    return processData(data);
  } catch (error) {
    console.error('Failed to get data:', error);
    // Rethrow or return a default value
    return { error: true, message: error.message };
  }
}
```

**Global Error Handling:**
Catching unhandled errors.

```javascript
// For synchronous errors
window.onerror = function(message, source, lineno, colno, error) {
  console.error('Unhandled error:', { message, source, lineno, colno });
  // Return true to prevent the default browser error handler
  return true;
};

// For unhandled promise rejections
window.addEventListener('unhandledrejection', function(event) {
  console.error('Unhandled promise rejection:', event.reason);
  // Prevent default handling
  event.preventDefault();
});

// For Node.js
process.on('uncaughtException', (error) => {
  console.error('Uncaught exception:', error);
  // Graceful shutdown
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled rejection at:', promise, 'reason:', reason);
  // Don't exit here, just log
});
```

**Advanced Error Handling Patterns:**

```javascript
// Retry pattern
async function fetchWithRetry(url, options = {}, retries = 3, backoff = 300) {
  try {
    return await fetch(url, options);
  } catch (error) {
    if (retries <= 0) throw error;
    
    await new Promise(resolve => setTimeout(resolve, backoff));
    return fetchWithRetry(url, options, retries - 1, backoff * 2);
  }
}

// Circuit breaker pattern
class CircuitBreaker {
  constructor(fn, options = {}) {
    this.fn = fn;
    this.failureCount = 0;
    this.resetTimeout = options.resetTimeout || 10000;
    this.failureThreshold = options.failureThreshold || 5;
    this.state = 'CLOSED';
    this.nextAttempt = Date.now();
  }
  
  async exec(...args) {
    if (this.state === 'OPEN') {
      if (Date.now() > this.nextAttempt) {
        this.state = 'HALF-OPEN';
      } else {
        throw new Error('Circuit is OPEN');
      }
    }
    
    try {
      const result = await this.fn(...args);
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failureCount++;
    if (this.failureCount >= this.failureThreshold || this.state === 'HALF-OPEN') {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.resetTimeout;
    }
  }
}

// Usage
const breaker = new CircuitBreaker(fetchData, { failureThreshold: 3 });
try {
  const result = await breaker.exec('https://api.example.com/data');
} catch (error) {
  console.error('Operation failed:', error);
}
```

**3. Debugging Techniques**

**Console Methods:**
Using the console API for debugging.

```javascript
// Basic logging
console.log('Simple message');
console.info('Informational message');
console.warn('Warning message');
console.error('Error message');

// Structured data
console.table([{ name: 'John', age: 30 }, { name: 'Alice', age: 25 }]);

// Grouping related logs
console.group('User Details');
console.log('Name: John');
console.log('Role: Admin');
console.groupEnd();

// Timing operations
console.time('Array processing');
const arr = Array(1000000).fill(0).map((_, i) => i);
console.timeEnd('Array processing');

// Conditional logging
console.assert(1 === 2, 'This will show because the assertion failed');

// Stack traces
console.trace('Tracing function calls');
```

**Debugger Statement:**
Pausing execution for debugging.

```javascript
function complexCalculation(data) {
  let result = 0;
  for (let i = 0; i < data.length; i++) {
    if (data[i] < 0) {
      debugger; // Execution will pause here when DevTools is open
      // Inspect variables, call stack, etc.
    }
    result += processItem(data[i]);
  }
  return result;
}
```

**Browser DevTools:**
Leveraging browser debugging tools.

- **Breakpoints**: Set breakpoints to pause execution at specific lines
- **Watch expressions**: Monitor values of variables or expressions
- **Call stack**: Examine the function call hierarchy
- **Step through code**: Execute code line by line
- **DOM breakpoints**: Pause when DOM elements change
- **XHR/fetch breakpoints**: Pause when network requests occur
- **Exception breakpoints**: Pause when exceptions are thrown

**Source Maps:**
Debugging minified or transpiled code.

```javascript
// webpack.config.js example
module.exports = {
  mode: 'development',
  devtool: 'source-map',  // Generates source maps
  // ... other configuration
};
```

**Logging Utilities:**
Using structured logging for better debugging.

```javascript
// Simple logging utility
const Logger = {
  level: 'info',  // 'debug', 'info', 'warn', 'error'
  levels: { debug: 0, info: 1, warn: 2, error: 3 },
  
  debug(message, ...args) {
    if (this.levels[this.level] <= this.levels.debug) {
      console.debug(`[DEBUG] ${message}`, ...args);
    }
  },
  
  info(message, ...args) {
    if (this.levels[this.level] <= this.levels.info) {
      console.info(`[INFO] ${message}`, ...args);
    }
  },
  
  warn(message, ...args) {
    if (this.levels[this.level] <= this.levels.warn) {
      console.warn(`[WARN] ${message}`, ...args);
    }
  },
  
  error(message, ...args) {
    if (this.levels[this.level] <= this.levels.error) {
      console.error(`[ERROR] ${message}`, ...args);
    }
  }
};

// Usage
Logger.level = 'debug';  // Set log level
Logger.debug('Detailed debug info', { user: 'john' });
Logger.info('Operation completed');
Logger.warn('Resource usage high');
Logger.error('Operation failed', new Error('Database connection failed'));
```

**Performance Debugging:**
Identifying performance issues.

```javascript
// Using Performance API
performance.mark('start-process');

// Some time-consuming operation
for (let i = 0; i < 1000000; i++) {
  // Complex operation
}

performance.mark('end-process');
performance.measure('process-time', 'start-process', 'end-process');

const measurements = performance.getEntriesByType('measure');
console.log(measurements);

// Using Chrome DevTools Performance panel
// 1. Open DevTools > Performance tab
// 2. Click Record
// 3. Perform the actions you want to analyze
// 4. Stop recording and analyze the results
```

**4. Best Practices**

**Fail Fast:**
Detect and report errors as early as possible.

```javascript
function processUserData(user) {
  // Validate inputs early
  if (!user) throw new Error('User data is required');
  if (!user.id) throw new Error('User ID is required');
  if (!user.name) throw new Error('User name is required');
  
  // Process data only after validation
  return {
    displayName: user.name.toUpperCase(),
    initials: user.name.split(' ').map(n => n[0]).join(''),
    id: user.id
  };
}
```

**Graceful Degradation:**
Handle errors in a way that allows the application to continue functioning.

```javascript
async function loadUserProfile(userId) {
  try {
    const user = await fetchUser(userId);
    return user;
  } catch (error) {
    console.error('Failed to load user profile:', error);
    // Return a default user profile instead of crashing
    return {
      id: userId,
      name: 'Unknown User',
      avatar: '/images/default-avatar.png',
      isDefaultProfile: true
    };
  }
}
```

**Structured Error Handling:**
Organize error handling in a consistent way.

```javascript
// Error handling service
class ErrorService {
  constructor() {
    this.handlers = {
      network: error => this.handleNetworkError(error),
      validation: error => this.handleValidationError(error),
      auth: error => this.handleAuthError(error),
      default: error => this.handleUnknownError(error)
    };
  }
  
  handleError(error) {
    const handler = this.handlers[error.type] || this.handlers.default;
    return handler(error);
  }
  
  handleNetworkError(error) {
    console.error('Network error:', error);
    // Show offline message, retry mechanism, etc.
  }
  
  handleValidationError(error) {
    console.error('Validation error:', error);
    // Show field-specific error messages
  }
  
  handleAuthError(error) {
    console.error('Auth error:', error);
    // Redirect to login page
  }
  
  handleUnknownError(error) {
    console.error('Unknown error:', error);
    // Show generic error message
  }
}

// Usage
const errorService = new ErrorService();

try {
  // Some operation
} catch (error) {
  errorService.handleError({ ...error, type: 'network' });
}
```

**Monitoring and Logging:**
Implement proper error tracking in production.

```javascript
// Simple error tracking service
class ErrorTracker {
  constructor(apiKey, options = {}) {
    this.apiKey = apiKey;
    this.endpoint = options.endpoint || 'https://error-tracking.example.com/api/errors';
    this.appVersion = options.appVersion || '1.0.0';
    this.environment = options.environment || 'production';
    
    // Set up global error handlers
    this.setupGlobalHandlers();
  }
  
  setupGlobalHandlers() {
    window.onerror = (message, source, lineno, colno, error) => {
      this.trackError(error || { message, source, lineno, colno });
      return false; // Let default handler run
    };
    
    window.addEventListener('unhandledrejection', event => {
      this.trackError(event.reason || { message: 'Unhandled Promise rejection' });
    });
  }
  
  trackError(error) {
    const errorData = {
      message: error.message || 'Unknown error',
      stack: error.stack,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      appVersion: this.appVersion,
      environment: this.environment,
      url: window.location.href,
      // Additional context
      userId: this.userId,
      sessionId: this.sessionId
    };
    
    // Send error to tracking service
    fetch(this.endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`
      },
      body: JSON.stringify(errorData),
      // Use keepalive to ensure the request completes even if the page unloads
      keepalive: true
    }).catch(err => {
      // Fallback if the error tracking service is down
      console.error('Failed to send error to tracking service:', err);
    });
  }
  
  setUser(userId) {
    this.userId = userId;
  }
  
  setSession(sessionId) {
    this.sessionId = sessionId;
  }
}

// Usage
const errorTracker = new ErrorTracker('your-api-key', {
  environment: process.env.NODE_ENV,
  appVersion: '2.1.3'
});

// Set user and session when available
errorTracker.setUser('user-123');
errorTracker.setSession('session-456');

// Manually track an error
try {
  riskyOperation();
} catch (error) {
  errorTracker.trackError(error);
}
```

**Key Takeaways:**

1. Understand the different types of errors in JavaScript and how to handle them
2. Use try-catch blocks to gracefully handle exceptions
3. Create custom error types for better error classification
4. Implement proper error handling for asynchronous code
5. Use browser DevTools and debugging techniques to identify issues
6. Implement structured logging and monitoring for production applications
7. Follow best practices like failing fast and graceful degradation
8. Use advanced patterns like retry and circuit breaker for robust applications

## JavaScript Performance and Security

### Q61: Explain JavaScript performance optimization techniques.
**Difficulty: Hard**

**Answer:**
Optimizing JavaScript performance is crucial for creating responsive web applications and efficient server-side code. Understanding how JavaScript engines work and applying the right optimization techniques can significantly improve application speed and resource usage.

**1. Understanding JavaScript Performance**

**JavaScript Engine Basics:**
Modern JavaScript engines (like V8, SpiderMonkey, and JavaScriptCore) use Just-In-Time (JIT) compilation to convert JavaScript into optimized machine code.

```javascript
// JavaScript engines optimize code that follows predictable patterns
// This function is likely to be optimized well
function optimizedSum(a, b) {
  return a + b;  // Consistent types lead to optimized machine code
}

// This function may be less optimized due to type inconsistency
function lessOptimizedSum(a, b) {
  if (typeof a === 'string') {
    return a + String(b);  // Type changes cause deoptimization
  }
  return a + b;
}
```

**Key Performance Metrics:**

- **Execution time**: How long operations take to complete
- **Memory usage**: How much memory the application consumes
- **Rendering performance**: How smoothly the UI updates
- **Load time**: How quickly the application becomes interactive
- **Responsiveness**: How the application responds to user input

**2. Code Execution Optimization**

**Avoid Premature Optimization:**
Focus on measuring performance before optimizing.

```javascript
// Use the Performance API to measure execution time
function measurePerformance(fn, ...args) {
  const label = fn.name || 'Anonymous Function';
  performance.mark(`${label}-start`);
  const result = fn(...args);
  performance.mark(`${label}-end`);
  performance.measure(label, `${label}-start`, `${label}-end`);
  console.log(`${label} took ${performance.getEntriesByName(label)[0].duration.toFixed(2)}ms`);
  return result;
}

// Usage
const result = measurePerformance(expensiveOperation, data);
```

**Optimize Loops:**
Make loops more efficient.

```javascript
// Less efficient loop
function inefficientSum(arr) {
  let sum = 0;
  for (let i = 0; i < arr.length; i++) {  // Length checked each iteration
    sum += arr[i];
  }
  return sum;
}

// More efficient loop
function efficientSum(arr) {
  let sum = 0;
  const len = arr.length;  // Cache the length
  for (let i = 0; i < len; i++) {
    sum += arr[i];
  }
  return sum;
}

// Even more modern and often faster
function modernSum(arr) {
  return arr.reduce((sum, val) => sum + val, 0);
}
```

**Minimize DOM Operations:**
DOM manipulation is expensive.

```javascript
// Inefficient - causes multiple reflows
function inefficientDOMUpdate(items) {
  const list = document.getElementById('myList');
  items.forEach(item => {
    list.innerHTML += `<li>${item}</li>`;  // Causes reflow on each iteration
  });
}

// More efficient - batches DOM updates
function efficientDOMUpdate(items) {
  const list = document.getElementById('myList');
  const fragment = document.createDocumentFragment();
  
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    fragment.appendChild(li);
  });
  
  list.appendChild(fragment);  // Single reflow and repaint
}
```

**Use Web Workers for CPU-Intensive Tasks:**
Move heavy computation off the main thread.

```javascript
// main.js
const worker = new Worker('worker.js');

worker.onmessage = function(e) {
  console.log('Result from worker:', e.data);
};

function processDataInBackground(data) {
  worker.postMessage(data);
}

// worker.js
self.onmessage = function(e) {
  const result = performExpensiveCalculation(e.data);
  self.postMessage(result);
};

function performExpensiveCalculation(data) {
  // CPU-intensive work here
  return processedData;
}
```

**Debounce and Throttle:**
Limit the rate of function execution.

```javascript
// Debounce - execute after a period of inactivity
function debounce(fn, delay) {
  let timer;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

// Throttle - execute at most once per specified period
function throttle(fn, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

// Usage
const debouncedSearch = debounce(searchAPI, 300);
const throttledScroll = throttle(handleScroll, 100);

inputElement.addEventListener('input', debouncedSearch);
window.addEventListener('scroll', throttledScroll);
```

**Memoization:**
Cache function results for repeated calls with the same inputs.

```javascript
function memoize(fn) {
  const cache = new Map();
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// Usage
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFibonacci = memoize(fibonacci);

console.time('Non-memoized');
fibonacci(40);  // Very slow
console.timeEnd('Non-memoized');

console.time('Memoized');
memoizedFibonacci(40);  // Much faster
console.timeEnd('Memoized');
```

**3. Memory Optimization**

**Avoid Memory Leaks:**
Prevent common causes of memory leaks.

```javascript
// Memory leak - forgotten event listener
function setupEventHandlers() {
  const button = document.getElementById('myButton');
  const data = loadLargeData();  // Imagine this is a large object
  
  button.addEventListener('click', function() {
    console.log(data);  // Captures 'data' in closure
  });
}

// Fixed version - remove event listener when done
function setupEventHandlersFixed() {
  const button = document.getElementById('myButton');
  const data = loadLargeData();
  
  const clickHandler = function() {
    console.log(data);
  };
  
  button.addEventListener('click', clickHandler);
  
  // Clean up when no longer needed
  return function cleanup() {
    button.removeEventListener('click', clickHandler);
  };
}

// Memory leak - circular references
function createCircularReference() {
  const parent = {};
  const child = {};
  
  parent.child = child;
  child.parent = parent;  // Creates a circular reference
  
  return parent;
}

// Fixed version - use WeakMap for parent references
function createNonCircularReference() {
  const parentToChild = new WeakMap();
  const childToParent = new WeakMap();
  
  const parent = {};
  const child = {};
  
  parentToChild.set(parent, child);
  childToParent.set(child, parent);
  
  return {
    getChild: () => parentToChild.get(parent),
    getParent: () => childToParent.get(child)
  };
}
```

**Object Pooling:**
Reuse objects instead of creating new ones.

```javascript
class ParticlePool {
  constructor(size) {
    this.pool = [];
    this.size = size;
    this.createParticles();
  }
  
  createParticles() {
    for (let i = 0; i < this.size; i++) {
      this.pool.push({
        x: 0,
        y: 0,
        velocity: { x: 0, y: 0 },
        active: false
      });
    }
  }
  
  getParticle() {
    for (let i = 0; i < this.size; i++) {
      if (!this.pool[i].active) {
        this.pool[i].active = true;
        return this.pool[i];
      }
    }
    return null;  // No free particles
  }
  
  releaseParticle(particle) {
    particle.active = false;
    // Reset other properties as needed
    particle.x = 0;
    particle.y = 0;
    particle.velocity.x = 0;
    particle.velocity.y = 0;
  }
}

// Usage
const particleSystem = new ParticlePool(1000);

function createExplosion(x, y) {
  for (let i = 0; i < 50; i++) {
    const particle = particleSystem.getParticle();
    if (particle) {
      particle.x = x;
      particle.y = y;
      particle.velocity.x = Math.random() * 10 - 5;
      particle.velocity.y = Math.random() * 10 - 5;
    }
  }
}

function updateParticles() {
  for (let i = 0; i < particleSystem.size; i++) {
    const particle = particleSystem.pool[i];
    if (particle.active) {
      // Update particle position
      particle.x += particle.velocity.x;
      particle.y += particle.velocity.y;
      
      // Check if particle should be deactivated
      if (/* some condition */) {
        particleSystem.releaseParticle(particle);
      }
    }
  }
}
```

**Use Appropriate Data Structures:**
Choose the right data structure for the task.

```javascript
// Inefficient for frequent lookups
function findUserInArray(users, id) {
  return users.find(user => user.id === id);  // O(n) time complexity
}

// More efficient for frequent lookups
function findUserInMap(usersMap, id) {
  return usersMap.get(id);  // O(1) time complexity
}

// Usage
const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
  // ... thousands more users
];

// Create a map for efficient lookups
const usersMap = new Map(users.map(user => [user.id, user]));

console.time('Array lookup');
findUserInArray(users, 9999);  // Slower
console.timeEnd('Array lookup');

console.time('Map lookup');
findUserInMap(usersMap, 9999);  // Much faster
console.timeEnd('Map lookup');
```

**4. Rendering Performance**

**Optimize Critical Rendering Path:**
Minimize render-blocking resources.

```html
<!-- Inefficient - render-blocking CSS -->
<link rel="stylesheet" href="styles.css">

<!-- More efficient - non-render-blocking CSS -->
<link rel="stylesheet" href="critical.css"> <!-- Only critical styles -->
<link rel="stylesheet" href="non-critical.css" media="print" onload="this.media='all'">

<!-- Inefficient - render-blocking JavaScript -->
<script src="app.js"></script>

<!-- More efficient - deferred JavaScript -->
<script src="app.js" defer></script>
```

**Use requestAnimationFrame:**
Synchronize animations with the browser's refresh rate.

```javascript
// Inefficient animation
function inefficientAnimation() {
  let position = 0;
  const element = document.getElementById('animated');
  
  function animate() {
    position += 5;
    element.style.transform = `translateX(${position}px)`;
    
    if (position < 1000) {
      setTimeout(animate, 16);  // Approximately 60fps, but not synced with browser
    }
  }
  
  animate();
}

// Efficient animation
function efficientAnimation() {
  let position = 0;
  const element = document.getElementById('animated');
  
  function animate() {
    position += 5;
    element.style.transform = `translateX(${position}px)`;
    
    if (position < 1000) {
      requestAnimationFrame(animate);  // Synced with browser's refresh rate
    }
  }
  
  requestAnimationFrame(animate);
}
```

**Virtualize Long Lists:**
Only render visible items in long lists.

```javascript
class VirtualList {
  constructor(container, itemHeight, totalItems, renderItem) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.totalItems = totalItems;
    this.renderItem = renderItem;
    this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2; // +2 for buffer
    this.scrollTop = 0;
    this.startIndex = 0;
    this.endIndex = this.visibleItems - 1;
    
    this.setupContainer();
    this.render();
    this.attachEvents();
  }
  
  setupContainer() {
    this.container.style.position = 'relative';
    this.container.style.overflow = 'auto';
    this.content = document.createElement('div');
    this.content.style.height = `${this.totalItems * this.itemHeight}px`;
    this.container.appendChild(this.content);
  }
  
  attachEvents() {
    this.container.addEventListener('scroll', () => {
      this.scrollTop = this.container.scrollTop;
      this.render();
    });
  }
  
  render() {
    this.startIndex = Math.floor(this.scrollTop / this.itemHeight);
    this.endIndex = Math.min(this.startIndex + this.visibleItems, this.totalItems - 1);
    
    // Clear previous content
    this.content.innerHTML = '';
    
    for (let i = this.startIndex; i <= this.endIndex; i++) {
      const item = this.renderItem(i);
      item.style.position = 'absolute';
      item.style.top = `${i * this.itemHeight}px`;
      item.style.height = `${this.itemHeight}px`;
      item.style.width = '100%';
      this.content.appendChild(item);
    }
  }
}

// Usage
const container = document.getElementById('list-container');
const virtualList = new VirtualList(
  container,
  50, // Item height in pixels
  10000, // Total number of items
  (index) => {
    const item = document.createElement('div');
    item.textContent = `Item ${index}`;
    item.className = 'list-item';
    return item;
  }
);
```

**5. Network Optimization**

**Bundle and Minify:**
Reduce the size of JavaScript files.

```javascript
// webpack.config.js example
const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  // ... other config
  optimization: {
    minimize: true,
    minimizer: [new TerserPlugin({
      terserOptions: {
        compress: {
          drop_console: true,
        },
      },
    })],
    splitChunks: {
      chunks: 'all',
      maxInitialRequests: Infinity,
      minSize: 0,
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name(module) {
            const packageName = module.context.match(/[\\/]node_modules[\\/](.+?)([\\/]|$)/)[1];
            return `npm.${packageName.replace('@', '')}`;
          },
        },
      },
    },
  },
};
```

**Lazy Loading:**
Load JavaScript only when needed.

```javascript
// Modern ES modules with dynamic imports
const button = document.getElementById('load-module');

button.addEventListener('click', async () => {
  try {
    // Load the module only when the button is clicked
    const { default: Module } = await import('./heavy-module.js');
    const instance = new Module();
    instance.initialize();
  } catch (error) {
    console.error('Failed to load module:', error);
  }
});
```

**Caching:**
Implement effective caching strategies.

```javascript
// Service Worker caching example
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('v1').then((cache) => {
      return cache.addAll([
        '/',
        '/index.html',
        '/styles.css',
        '/app.js',
        '/api-data.json'
      ]);
    })
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      // Cache hit - return the response from the cached version
      if (response) {
        return response;
      }
      
      // Not in cache - fetch from network
      return fetch(event.request).then((networkResponse) => {
        // Don't cache if response is not valid
        if (!networkResponse || networkResponse.status !== 200 || networkResponse.type !== 'basic') {
          return networkResponse;
        }
        
        // Clone the response
        const responseToCache = networkResponse.clone();
        
        caches.open('v1').then((cache) => {
          cache.put(event.request, responseToCache);
        });
        
        return networkResponse;
      });
    })
  );
});
```

**6. Advanced Optimization Techniques**

**Avoid Layout Thrashing:**
Batch DOM reads and writes to prevent forced reflows.

```javascript
// Inefficient - causes layout thrashing
function inefficientResizing() {
  const boxes = document.querySelectorAll('.box');
  
  boxes.forEach(box => {
    const width = box.offsetWidth;  // Read
    box.style.height = width + 'px';  // Write - forces reflow
    const height = box.offsetHeight;  // Read - forces another reflow
    box.style.fontSize = height / 10 + 'px';  // Write - forces reflow again
  });
}

// Efficient - batches reads and writes
function efficientResizing() {
  const boxes = document.querySelectorAll('.box');
  const dimensions = [];
  
  // Batch all reads
  boxes.forEach(box => {
    dimensions.push({
      width: box.offsetWidth,
      element: box
    });
  });
  
  // Batch all writes
  dimensions.forEach(dim => {
    dim.element.style.height = dim.width + 'px';
    dim.element.style.fontSize = dim.width / 10 + 'px';
  });
}
```

**Use Web Assembly for Performance-Critical Code:**
Execute high-performance code in the browser.

```javascript
// main.js
async function initWasm() {
  try {
    const response = await fetch('fibonacci.wasm');
    const buffer = await response.arrayBuffer();
    const wasmModule = await WebAssembly.instantiate(buffer);
    const { fibonacci } = wasmModule.instance.exports;
    
    // Compare performance
    console.time('JS Fibonacci');
    jsFibonacci(40);
    console.timeEnd('JS Fibonacci');
    
    console.time('WASM Fibonacci');
    fibonacci(40);
    console.timeEnd('WASM Fibonacci');
  } catch (error) {
    console.error('Failed to load WASM module:', error);
  }
}

function jsFibonacci(n) {
  if (n <= 1) return n;
  return jsFibonacci(n - 1) + jsFibonacci(n - 2);
}

initWasm();
```

**Optimize for Modern JavaScript Engines:**
Leverage engine optimizations.

```javascript
// Helping V8 optimize your code

// 1. Use consistent types
function sum(a, b) {
  // Always use with same types (e.g., both numbers)
  return a + b;
}

// 2. Avoid array holes
const goodArray = [1, 2, 3, 4, 5];  // Dense array, optimized
const badArray = [];
badArray[0] = 1;
badArray[10] = 10;  // Sparse array, less optimized

// 3. Initialize object properties in constructor
class OptimizedClass {
  constructor() {
    this.x = 0;  // Initialize all properties
    this.y = 0;
    this.name = '';
  }
}

// 4. Use typed arrays for numeric data
const floatData = new Float64Array(1000);  // More efficient for numeric operations
for (let i = 0; i < floatData.length; i++) {
  floatData[i] = Math.random();
}

// 5. Avoid modifying object structure after creation
const person = { name: 'John', age: 30 };
// Good: modify existing properties
person.age = 31;
// Bad: add new properties later
person.address = '123 Main St';  // Can cause deoptimization
```

**7. Measuring and Monitoring Performance**

**Use Performance API:**
Measure real-world performance.

```javascript
// Measure page load performance
window.addEventListener('load', () => {
  // Get performance metrics
  const perfData = window.performance.timing;
  const pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
  const domReadyTime = perfData.domComplete - perfData.domLoading;
  
  console.log(`Page load time: ${pageLoadTime}ms`);
  console.log(`DOM ready time: ${domReadyTime}ms`);
  
  // Report to analytics
  reportPerformanceMetrics({
    pageLoad: pageLoadTime,
    domReady: domReadyTime,
    ttfb: perfData.responseStart - perfData.navigationStart,
    domInteractive: perfData.domInteractive - perfData.navigationStart
  });
});

// Measure custom operations
function measureOperation(name, operation, ...args) {
  performance.mark(`${name}-start`);
  const result = operation(...args);
  performance.mark(`${name}-end`);
  performance.measure(name, `${name}-start`, `${name}-end`);
  
  const duration = performance.getEntriesByName(name)[0].duration;
  console.log(`${name} took ${duration.toFixed(2)}ms`);
  
  return result;
}
```

**Lighthouse and WebPageTest:**
Use tools to analyze performance.

```javascript
// Example of fixing issues identified by Lighthouse

// 1. Eliminate render-blocking resources
document.addEventListener('DOMContentLoaded', () => {
  // Load non-critical CSS
  const link = document.createElement('link');
  link.rel = 'stylesheet';
  link.href = 'non-critical.css';
  document.head.appendChild(link);
});

// 2. Properly size images
function loadOptimizedImages() {
  const images = document.querySelectorAll('img[data-src]');
  images.forEach(img => {
    const width = img.clientWidth;
    const src = img.dataset.src.replace('{width}', width);
    img.src = src;
  });
}

// 3. Defer offscreen images (lazy loading)
const lazyImages = document.querySelectorAll('img.lazy');
const lazyImageObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      img.classList.remove('lazy');
      lazyImageObserver.unobserve(img);
    }
  });
});

lazyImages.forEach(img => lazyImageObserver.observe(img));
```

**8. Best Practices**

**Avoid Micro-Optimizations:**
Focus on significant performance bottlenecks.

```javascript
// Don't waste time on micro-optimizations like this
function microOptimization() {
  // Negligible difference between these approaches
  let i = 0;
  i++;  // vs i = i + 1 vs i += 1
  
  // This kind of optimization rarely matters
  const len = someArray.length;
  for (let j = 0; j < len; j++) {  // vs for (let j = 0; j < someArray.length; j++)
    // ...
  }
}

// Instead, focus on algorithmic improvements
function significantOptimization(data) {
  // Changing from O(n²) to O(n log n) algorithm
  // This can make a huge difference for large datasets
  
  // Before: Bubble sort O(n²)
  // After: Quick sort O(n log n)
  return data.sort((a, b) => a - b);
}
```

**Profile Before Optimizing:**
Identify actual bottlenecks.

```javascript
// Use Chrome DevTools Performance panel
console.profile('Expensive Operation');
tryToOptimizeThis();
console.profileEnd('Expensive Operation');

// Use console.time for quick measurements
console.time('Operation A');
operationA();
console.timeEnd('Operation A');

console.time('Operation B');
operationB();
console.timeEnd('Operation B');
```

**Key Takeaways:**

1. Understand how JavaScript engines optimize code and avoid patterns that cause deoptimization
2. Measure performance before and after optimization to ensure improvements
3. Optimize loops, minimize DOM operations, and use appropriate data structures
4. Use techniques like debouncing, throttling, and memoization to improve responsiveness
5. Prevent memory leaks by managing event listeners and avoiding circular references
6. Optimize rendering with techniques like virtualization and requestAnimationFrame
7. Implement network optimizations through bundling, minification, and lazy loading
8. Focus on significant algorithmic improvements rather than micro-optimizations

### Q62: What are JavaScript security best practices and common vulnerabilities?
**Difficulty: Hard**

**Answer:**
JavaScript security is critical for protecting web applications from various attacks. Understanding common vulnerabilities and implementing security best practices helps create more secure applications.

**1. Common JavaScript Vulnerabilities**

**Cross-Site Scripting (XSS):**
XSS attacks occur when attackers inject malicious scripts into web pages viewed by other users.

```javascript
// Vulnerable code - directly inserting user input into the DOM
function displayComment(comment) {
  const commentSection = document.getElementById('comments');
  commentSection.innerHTML += `<div class="comment">${comment}</div>`; // Dangerous!
}

// Safer approach - sanitizing input
function displayCommentSafely(comment) {
  const commentSection = document.getElementById('comments');
  const div = document.createElement('div');
  div.className = 'comment';
  div.textContent = comment; // Automatically escapes HTML
  commentSection.appendChild(div);
}
```

**Cross-Site Request Forgery (CSRF):**
CSRF attacks trick users into performing unwanted actions on a site they're authenticated to.

```javascript
// Vulnerable form without CSRF protection
<form action="/transfer-funds" method="POST">
  <input type="hidden" name="to" value="account123">
  <input type="text" name="amount">
  <button type="submit">Transfer</button>
</form>

// Protected form with CSRF token
<form action="/transfer-funds" method="POST">
  <input type="hidden" name="csrf_token" value="randomGeneratedToken123">
  <input type="hidden" name="to" value="account123">
  <input type="text" name="amount">
  <button type="submit">Transfer</button>
</form>

// Server-side validation
function handleTransfer(req, res) {
  if (req.body.csrf_token !== req.session.csrf_token) {
    return res.status(403).send('Invalid CSRF token');
  }
  // Process the transfer
}
```

**Prototype Pollution:**
Prototype pollution occurs when attackers manipulate JavaScript object prototypes.

```javascript
// Vulnerable deep merge function
function deepMerge(target, source) {
  for (const key in source) {
    if (source[key] && typeof source[key] === 'object') {
      if (!target[key]) target[key] = {};
      deepMerge(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
  return target;
}

// Attack payload
const payload = JSON.parse('{"__proto__": {"isAdmin": true}}');
const userConfig = {};

// This pollutes Object.prototype
deepMerge(userConfig, payload);

// Now all objects have isAdmin=true
console.log({}.isAdmin); // true - security breach!

// Safer deep merge function
function safeDeepMerge(target, source) {
  for (const key in source) {
    // Prevent prototype pollution
    if (key === '__proto__' || key === 'constructor') continue;
    
    if (source[key] && typeof source[key] === 'object') {
      if (!target[key]) target[key] = {};
      safeDeepMerge(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
  return target;
}
```

**Insecure Direct Object References (IDOR):**
IDOR vulnerabilities allow attackers to access unauthorized resources by manipulating references.

```javascript
// Vulnerable API endpoint
app.get('/api/user/:id/data', (req, res) => {
  const userId = req.params.id;
  // No authorization check!
  database.getUserData(userId)
    .then(data => res.json(data));
});

// Secure API endpoint with authorization
app.get('/api/user/:id/data', (req, res) => {
  const userId = req.params.id;
  const currentUserId = req.session.userId;
  
  // Verify the user is authorized to access this data
  if (userId !== currentUserId && !isAdmin(req.session.role)) {
    return res.status(403).json({ error: 'Unauthorized access' });
  }
  
  database.getUserData(userId)
    .then(data => res.json(data));
});
```

**2. Input Validation and Sanitization**

**Client-Side Validation:**
Implement client-side validation for better user experience, but never rely on it for security.

```javascript
// Basic client-side validation
function validateForm() {
  const email = document.getElementById('email').value;
  const password = document.getElementById('password').value;
  let isValid = true;
  
  // Email validation
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    document.getElementById('email-error').textContent = 'Please enter a valid email';
    isValid = false;
  } else {
    document.getElementById('email-error').textContent = '';
  }
  
  // Password validation
  if (password.length < 8) {
    document.getElementById('password-error').textContent = 'Password must be at least 8 characters';
    isValid = false;
  } else {
    document.getElementById('password-error').textContent = '';
  }
  
  return isValid;
}
```

**Server-Side Validation:**
Always implement thorough server-side validation.

```javascript
// Server-side validation example (Node.js/Express)
const { body, validationResult } = require('express-validator');

app.post('/register',
  // Validation rules
  [
    body('email').isEmail().normalizeEmail(),
    body('password').isLength({ min: 8 }),
    body('name').trim().escape().isLength({ min: 2 })
  ],
  // Handle request after validation
  (req, res) => {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    
    // Process valid data
    createUser(req.body);
    res.status(201).json({ message: 'User created successfully' });
  }
);
```

**Content Security Policy (CSP):**
Implement CSP to prevent XSS and other code injection attacks.

```html
<!-- CSP in HTML meta tag -->
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://trusted-cdn.com; style-src 'self' https://trusted-cdn.com; img-src 'self' https://trusted-images.com data:;">
```

```javascript
// CSP in HTTP header (Node.js/Express)
app.use((req, res, next) => {
  res.setHeader(
    'Content-Security-Policy',
    "default-src 'self'; " +
    "script-src 'self' https://trusted-cdn.com; " +
    "style-src 'self' https://trusted-cdn.com; " +
    "img-src 'self' https://trusted-images.com data:;"
  );
  next();
});
```

**3. Authentication and Authorization**

**Secure Authentication:**
Implement secure authentication practices.

```javascript
// JWT-based authentication example
const jwt = require('jsonwebtoken');

// Login endpoint
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  
  try {
    // Verify credentials (simplified)
    const user = await db.findUser(username);
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    const passwordValid = await bcrypt.compare(password, user.passwordHash);
    if (!passwordValid) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Generate JWT token
    const token = jwt.sign(
      { id: user.id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );
    
    // Set HTTP-only cookie
    res.cookie('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 3600000 // 1 hour
    });
    
    res.json({ message: 'Login successful' });
  } catch (error) {
    res.status(500).json({ error: 'Server error' });
  }
});

// Authentication middleware
function authenticate(req, res, next) {
  const token = req.cookies.token;
  
  if (!token) {
    return res.status(401).json({ error: 'Authentication required' });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid or expired token' });
  }
}

// Protected route
app.get('/api/profile', authenticate, (req, res) => {
  // Access is granted only to authenticated users
  res.json({ user: req.user });
});
```

**Role-Based Access Control (RBAC):**
Implement RBAC for fine-grained authorization.

```javascript
// RBAC middleware
function checkRole(roles) {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    
    next();
  };
}

// Admin-only route
app.get('/api/admin/users', authenticate, checkRole(['admin']), (req, res) => {
  // Only admins can access this endpoint
  getAllUsers().then(users => res.json(users));
});

// Route accessible to both admins and managers
app.get('/api/reports', authenticate, checkRole(['admin', 'manager']), (req, res) => {
  getReports().then(reports => res.json(reports));
});
```

**4. Secure Data Storage and Transmission**

**Secure Cookies:**
Set secure flags on cookies containing sensitive information.

```javascript
// Setting secure cookies
res.cookie('sessionId', sessionId, {
  httpOnly: true,     // Prevents JavaScript access
  secure: true,       // Requires HTTPS
  sameSite: 'strict', // Prevents CSRF
  maxAge: 3600000     // 1 hour expiration
});
```

**HTTPS:**
Always use HTTPS for data transmission.

```javascript
// Redirect HTTP to HTTPS (Express.js)
app.use((req, res, next) => {
  if (process.env.NODE_ENV === 'production' && !req.secure) {
    return res.redirect(`https://${req.headers.host}${req.url}`);
  }
  next();
});
```

**Sensitive Data Handling:**
Never store sensitive data in client-side storage.

```javascript
// Bad practice - storing sensitive data in localStorage
localStorage.setItem('userToken', token);  // Vulnerable to XSS

// Better approach - using HttpOnly cookies (server-side)
res.cookie('token', token, { httpOnly: true, secure: true });

// For non-sensitive data that needs client-side access
sessionStorage.setItem('userPreferences', JSON.stringify(preferences));
```

**5. Third-Party Code and Dependencies**

**Subresource Integrity (SRI):**
Use SRI to ensure third-party resources haven't been tampered with.

```html
<!-- Using SRI for external scripts -->
<script 
  src="https://cdn.example.com/library.js" 
  integrity="sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC" 
  crossorigin="anonymous">
</script>
```

**Dependency Management:**
Regularly update and audit dependencies.

```bash
# NPM commands for dependency management
npm audit                # Check for vulnerabilities
npm audit fix            # Automatically fix issues
npm update               # Update dependencies
npm install package@latest  # Update specific package
```

**6. API Security**

**Rate Limiting:**
Implement rate limiting to prevent abuse.

```javascript
// Rate limiting with Express.js
const rateLimit = require('express-rate-limit');

const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later'
});

// Apply rate limiting to all API routes
app.use('/api/', apiLimiter);

// More strict rate limiting for authentication routes
const authLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 5, // 5 attempts per hour
  message: 'Too many login attempts, please try again later'
});

app.use('/api/login', authLimiter);
```

**CORS Configuration:**
Configure CORS properly to restrict access to your API.

```javascript
// Basic CORS setup (Express.js)
const cors = require('cors');

// Allow all origins (not recommended for production)
app.use(cors());

// Restrictive CORS configuration
const corsOptions = {
  origin: ['https://trusted-app.com', 'https://admin.trusted-app.com'],
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true,
  maxAge: 86400 // Cache preflight requests for 24 hours
};

app.use(cors(corsOptions));
```

**7. Client-Side Security**

**Preventing DOM-Based Vulnerabilities:**
Avoid unsafe DOM manipulation.

```javascript
// Unsafe use of location.hash
function displayHashContent() {
  const hash = location.hash.substring(1);
  document.getElementById('content').innerHTML = decodeURIComponent(hash); // Dangerous!
}

// Safer approach
function displayHashContentSafely() {
  const hash = location.hash.substring(1);
  document.getElementById('content').textContent = decodeURIComponent(hash);
}
```

**Preventing Clickjacking:**
Use X-Frame-Options or CSP frame-ancestors.

```javascript
// Server-side header (Express.js)
app.use((req, res, next) => {
  res.setHeader('X-Frame-Options', 'DENY');
  // Or use CSP
  res.setHeader('Content-Security-Policy', "frame-ancestors 'none'");
  next();
});
```

**8. Security Testing and Monitoring**

**Regular Security Audits:**
Conduct regular security audits and penetration testing.

```javascript
// Example security testing script using OWASP ZAP API
async function runSecurityScan() {
  const zapApi = require('zaproxy');
  const options = {
    apiKey: process.env.ZAP_API_KEY,
    proxy: {
      host: 'localhost',
      port: 8080
    }
  };
  
  const zap = new zapApi(options);
  
  // Start a scan
  try {
    console.log('Starting security scan...');
    await zap.spider.scan({
      url: 'https://your-application.com',
      maxChildren: 10
    });
    
    // Wait for spider to complete
    let status;
    do {
      await new Promise(resolve => setTimeout(resolve, 5000));
      status = await zap.spider.status();
      console.log(`Spider progress: ${status}%`);
    } while (status < 100);
    
    // Run active scan
    const scanId = await zap.ascan.scan({
      url: 'https://your-application.com'
    });
    
    // Wait for active scan to complete
    let scanStatus;
    do {
      await new Promise(resolve => setTimeout(resolve, 10000));
      scanStatus = await zap.ascan.status(scanId);
      console.log(`Active scan progress: ${scanStatus}%`);
    } while (scanStatus < 100);
    
    // Get alerts
    const alerts = await zap.core.alerts();
    console.log('Security scan completed');
    console.log(`Found ${alerts.length} potential vulnerabilities`);
    
    // Generate report
    const report = await zap.core.htmlreport();
    require('fs').writeFileSync('security-report.html', report);
  } catch (error) {
    console.error('Security scan failed:', error);
  }
}
```

**Logging and Monitoring:**
Implement comprehensive logging and monitoring.

```javascript
// Logging security events (Node.js)
const winston = require('winston');

// Create a security logger
const securityLogger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  defaultMeta: { service: 'security-service' },
  transports: [
    new winston.transports.File({ filename: 'security.log' }),
    new winston.transports.Console()
  ]
});

// Log security events
function logSecurityEvent(event) {
  securityLogger.info({
    event: event.type,
    user: event.userId || 'anonymous',
    ip: event.ip,
    details: event.details,
    timestamp: new Date().toISOString()
  });
  
  // For critical events, send alerts
  if (event.severity === 'critical') {
    sendSecurityAlert(event);
  }
}

// Example usage
app.post('/login', (req, res) => {
  const { username, password } = req.body;
  
  authenticateUser(username, password)
    .then(user => {
      // Log successful login
      logSecurityEvent({
        type: 'login_success',
        userId: user.id,
        ip: req.ip,
        details: { username }
      });
      
      // Create session
      // ...
    })
    .catch(error => {
      // Log failed login attempt
      logSecurityEvent({
        type: 'login_failure',
        ip: req.ip,
        details: { username, reason: error.message },
        severity: isRepeatedFailure(username, req.ip) ? 'critical' : 'warning'
      });
      
      res.status(401).json({ error: 'Authentication failed' });
    });
});
```

**Key Takeaways:**

1. Always validate and sanitize user input on both client and server sides
2. Implement proper authentication and authorization mechanisms
3. Use Content Security Policy (CSP) to prevent XSS attacks
4. Protect against CSRF attacks with tokens and SameSite cookies
5. Secure cookies with HttpOnly, Secure, and SameSite flags
6. Regularly update and audit dependencies for vulnerabilities
7. Implement proper CORS configuration to restrict API access
8. Use HTTPS for all data transmission
9. Never store sensitive data in client-side storage
10. Conduct regular security testing and implement comprehensive logging

### Q63: Explain JavaScript testing strategies and frameworks.
**Difficulty: Medium**

**Answer:**
Testing is a critical part of JavaScript development that ensures code quality, prevents regressions, and facilitates maintenance. A comprehensive testing strategy typically involves multiple testing types and frameworks.

**1. Types of JavaScript Tests**

**Unit Tests:**
Test individual functions, methods, or components in isolation.

```javascript
// Function to test
function sum(a, b) {
  return a + b;
}

// Jest unit test
test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});

// Mocha/Chai unit test
describe('sum function', () => {
  it('should add two numbers correctly', () => {
    chai.expect(sum(1, 2)).to.equal(3);
  });
});
```

**Integration Tests:**
Test how multiple units work together.

```javascript
// Components to test
class UserService {
  constructor(database) {
    this.database = database;
  }
  
  async getUserById(id) {
    return this.database.findUser(id);
  }
}

class UserController {
  constructor(userService) {
    this.userService = userService;
  }
  
  async getUser(req, res) {
    try {
      const user = await this.userService.getUserById(req.params.id);
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }
      return res.json(user);
    } catch (error) {
      return res.status(500).json({ error: 'Server error' });
    }
  }
}

// Jest integration test
describe('UserController', () => {
  test('getUser returns user when found', async () => {
    // Mock dependencies
    const mockDatabase = {
      findUser: jest.fn().mockResolvedValue({ id: '123', name: 'John' })
    };
    const userService = new UserService(mockDatabase);
    const userController = new UserController(userService);
    
    // Mock Express req/res objects
    const req = { params: { id: '123' } };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn()
    };
    
    // Execute method under test
    await userController.getUser(req, res);
    
    // Assertions
    expect(mockDatabase.findUser).toHaveBeenCalledWith('123');
    expect(res.json).toHaveBeenCalledWith({ id: '123', name: 'John' });
    expect(res.status).not.toHaveBeenCalled();
  });
  
  test('getUser returns 404 when user not found', async () => {
    // Mock dependencies
    const mockDatabase = {
      findUser: jest.fn().mockResolvedValue(null)
    };
    const userService = new UserService(mockDatabase);
    const userController = new UserController(userService);
    
    // Mock Express req/res objects
    const req = { params: { id: '999' } };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn()
    };
    
    // Execute method under test
    await userController.getUser(req, res);
    
    // Assertions
    expect(mockDatabase.findUser).toHaveBeenCalledWith('999');
    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({ error: 'User not found' });
  });
});
```

**End-to-End (E2E) Tests:**
Test the entire application flow from start to finish.

```javascript
// Cypress E2E test
describe('Login Flow', () => {
  beforeEach(() => {
    cy.visit('/login');
  });
  
  it('should login successfully with valid credentials', () => {
    cy.get('input[name=email]').type('user@example.com');
    cy.get('input[name=password]').type('validPassword123');
    cy.get('button[type=submit]').click();
    
    // Verify redirect to dashboard
    cy.url().should('include', '/dashboard');
    cy.get('.welcome-message').should('contain', 'Welcome, User');
  });
  
  it('should show error with invalid credentials', () => {
    cy.get('input[name=email]').type('user@example.com');
    cy.get('input[name=password]').type('wrongPassword');
    cy.get('button[type=submit]').click();
    
    // Verify error message
    cy.get('.error-message').should('be.visible');
    cy.get('.error-message').should('contain', 'Invalid credentials');
    cy.url().should('include', '/login');
  });
});
```

**Component Tests:**
Test UI components in isolation (particularly relevant for frameworks like React, Vue, or Angular).

```javascript
// React component to test
function Counter() {
  const [count, setCount] = React.useState(0);
  
  return (
    <div>
      <p data-testid="count-value">{count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

// React Testing Library test
import { render, screen, fireEvent } from '@testing-library/react';

test('counter increments when button is clicked', () => {
  render(<Counter />);
  
  // Initial state
  expect(screen.getByTestId('count-value')).toHaveTextContent('0');
  
  // Click the button
  fireEvent.click(screen.getByText('Increment'));
  
  // Updated state
  expect(screen.getByTestId('count-value')).toHaveTextContent('1');
});
```

**2. Popular Testing Frameworks**

**Jest:**
A comprehensive testing framework with built-in assertion library, mocking capabilities, and code coverage.

```javascript
// Jest test with mocking
test('fetchUserData calls the API and processes the response', async () => {
  // Mock fetch API
  global.fetch = jest.fn().mockResolvedValue({
    json: jest.fn().mockResolvedValue({ id: 1, name: 'John Doe' })
  });
  
  const userData = await fetchUserData(1);
  
  // Verify fetch was called correctly
  expect(fetch).toHaveBeenCalledWith('https://api.example.com/users/1');
  
  // Verify the returned data
  expect(userData).toEqual({ id: 1, name: 'John Doe' });
});

// Jest snapshot testing
test('Button component renders correctly', () => {
  const { container } = render(<Button label="Click me" primary />);
  expect(container).toMatchSnapshot();
});
```

**Mocha:**
A flexible testing framework that can be paired with assertion libraries like Chai.

```javascript
// Mocha test with Chai assertions
describe('User API', function() {
  describe('GET /users/:id', function() {
    it('should return user when valid ID is provided', async function() {
      const response = await request(app).get('/users/123');
      
      expect(response.status).to.equal(200);
      expect(response.body).to.be.an('object');
      expect(response.body).to.have.property('id', '123');
    });
    
    it('should return 404 when user is not found', async function() {
      const response = await request(app).get('/users/999');
      
      expect(response.status).to.equal(404);
      expect(response.body).to.have.property('error');
    });
  });
});
```

**Jasmine:**
A behavior-driven development framework with built-in assertion and mocking capabilities.

```javascript
// Jasmine test
describe('Calculator', function() {
  let calculator;
  
  beforeEach(function() {
    calculator = new Calculator();
  });
  
  describe('add method', function() {
    it('should add two numbers correctly', function() {
      expect(calculator.add(2, 3)).toBe(5);
    });
    
    it('should handle negative numbers', function() {
      expect(calculator.add(-1, -3)).toBe(-4);
    });
  });
  
  describe('divide method', function() {
    it('should divide two numbers correctly', function() {
      expect(calculator.divide(6, 2)).toBe(3);
    });
    
    it('should throw an error when dividing by zero', function() {
      expect(function() {
        calculator.divide(5, 0);
      }).toThrowError('Cannot divide by zero');
    });
  });
});
```

**Cypress:**
A modern end-to-end testing framework focused on web applications.

```javascript
// Cypress test for a shopping cart
describe('Shopping Cart', () => {
  beforeEach(() => {
    // Set up initial state
    cy.visit('/products');
  });
  
  it('should add items to cart', () => {
    // Add first product to cart
    cy.get('.product-card').first().within(() => {
      cy.get('.product-title').invoke('text').as('firstProductTitle');
      cy.get('button').contains('Add to Cart').click();
    });
    
    // Verify cart indicator updated
    cy.get('.cart-count').should('contain', '1');
    
    // Go to cart page
    cy.get('.cart-icon').click();
    cy.url().should('include', '/cart');
    
    // Verify product is in cart
    cy.get('@firstProductTitle').then((title) => {
      cy.get('.cart-item').should('contain', title);
    });
  });
  
  it('should update quantity and total price', () => {
    // Add product to cart
    cy.get('.product-card').first().find('button').contains('Add to Cart').click();
    cy.get('.cart-icon').click();
    
    // Get initial price
    cy.get('.item-price').invoke('text').as('unitPrice');
    cy.get('.total-price').invoke('text').as('initialTotal');
    
    // Increase quantity
    cy.get('.quantity-input').clear().type('3');
    cy.get('.update-button').click();
    
    // Verify total updated correctly
    cy.get('@unitPrice').then((unitPrice) => {
      const price = parseFloat(unitPrice.replace('$', ''));
      const expectedTotal = (price * 3).toFixed(2);
      
      cy.get('.total-price').should('contain', `$${expectedTotal}`);
    });
  });
});
```

**Testing Library:**
A family of packages for testing UI components with a focus on user behavior.

```javascript
// React Testing Library example
import { render, screen, fireEvent } from '@testing-library/react';
import UserForm from './UserForm';

test('submitting the form calls onSubmit with user data', () => {
  // Mock submit handler
  const handleSubmit = jest.fn();
  
  // Render component
  render(<UserForm onSubmit={handleSubmit} />);
  
  // Fill out the form
  fireEvent.change(screen.getByLabelText(/name/i), {
    target: { value: 'John Doe' }
  });
  
  fireEvent.change(screen.getByLabelText(/email/i), {
    target: { value: 'john@example.com' }
  });
  
  // Submit the form
  fireEvent.click(screen.getByRole('button', { name: /submit/i }));
  
  // Verify form submission
  expect(handleSubmit).toHaveBeenCalledTimes(1);
  expect(handleSubmit).toHaveBeenCalledWith({
    name: 'John Doe',
    email: 'john@example.com'
  });
});
```

**3. Test-Driven Development (TDD)**

TDD is a development methodology where tests are written before the implementation code.

```javascript
// TDD example with Jest

// Step 1: Write a failing test
test('validatePassword should reject passwords shorter than 8 characters', () => {
  expect(validatePassword('short')).toBe(false);
});

// Step 2: Implement the minimal code to pass the test
function validatePassword(password) {
  return password.length >= 8;
}

// Step 3: Write more tests
test('validatePassword should reject passwords without uppercase letters', () => {
  expect(validatePassword('alllowercase123')).toBe(false);
});

// Step 4: Update implementation to pass all tests
function validatePassword(password) {
  if (password.length < 8) return false;
  if (!/[A-Z]/.test(password)) return false;
  return true;
}

// Step 5: Continue with more tests
test('validatePassword should reject passwords without numbers', () => {
  expect(validatePassword('NoNumbers')).toBe(false);
});

// Step 6: Update implementation again
function validatePassword(password) {
  if (password.length < 8) return false;
  if (!/[A-Z]/.test(password)) return false;
  if (!/[0-9]/.test(password)) return false;
  return true;
}

// Step 7: Add a positive test case
test('validatePassword should accept passwords meeting all criteria', () => {
  expect(validatePassword('ValidPass123')).toBe(true);
});
```

**4. Mocking and Stubbing**

Mocking allows you to isolate the code being tested by replacing dependencies with controlled implementations.

```javascript
// Function that uses an external API
async function getUserData(userId) {
  const response = await fetch(`https://api.example.com/users/${userId}`);
  if (!response.ok) {
    throw new Error('Failed to fetch user data');
  }
  return response.json();
}

// Component that uses the function
async function displayUserProfile(userId) {
  try {
    const userData = await getUserData(userId);
    document.getElementById('user-name').textContent = userData.name;
    document.getElementById('user-email').textContent = userData.email;
  } catch (error) {
    document.getElementById('error-message').textContent = error.message;
  }
}

// Jest test with mocking
describe('displayUserProfile', () => {
  // Setup and teardown
  beforeEach(() => {
    document.body.innerHTML = `
      <div id="user-profile">
        <h2 id="user-name"></h2>
        <p id="user-email"></p>
        <p id="error-message"></p>
      </div>
    `;
  });
  
  afterEach(() => {
    jest.resetAllMocks();
  });
  
  test('displays user data when API call succeeds', async () => {
    // Mock the getUserData function
    const mockUserData = { name: 'John Doe', email: 'john@example.com' };
    jest.spyOn(window, 'getUserData').mockResolvedValue(mockUserData);
    
    // Call the function
    await displayUserProfile('123');
    
    // Verify the DOM was updated correctly
    expect(document.getElementById('user-name').textContent).toBe('John Doe');
    expect(document.getElementById('user-email').textContent).toBe('john@example.com');
    expect(document.getElementById('error-message').textContent).toBe('');
    
    // Verify the mock was called correctly
    expect(window.getUserData).toHaveBeenCalledWith('123');
  });
  
  test('displays error message when API call fails', async () => {
    // Mock the getUserData function to throw an error
    jest.spyOn(window, 'getUserData').mockRejectedValue(new Error('API error'));
    
    // Call the function
    await displayUserProfile('123');
    
    // Verify the error message was displayed
    expect(document.getElementById('error-message').textContent).toBe('API error');
    expect(document.getElementById('user-name').textContent).toBe('');
    expect(document.getElementById('user-email').textContent).toBe('');
  });
});
```

**5. Code Coverage**

Code coverage measures how much of your code is executed during tests.

```javascript
// Jest configuration for code coverage (in package.json)
{
  "jest": {
    "collectCoverage": true,
    "coverageReporters": ["text", "lcov"],
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}

// Running tests with coverage
// $ jest --coverage
```

**6. Testing Asynchronous Code**

Testing asynchronous JavaScript code requires special handling.

```javascript
// Function to test
async function fetchData(id) {
  const response = await fetch(`https://api.example.com/data/${id}`);
  const data = await response.json();
  return data.processed;
}

// Jest test for async function
test('fetchData returns processed data', async () => {
  // Mock fetch
  global.fetch = jest.fn().mockResolvedValue({
    json: jest.fn().mockResolvedValue({ processed: 'test-data' })
  });
  
  const result = await fetchData('123');
  expect(result).toBe('test-data');
});

// Testing promises with .then/.catch
test('fetchData handles errors', () => {
  // Mock fetch to reject
  global.fetch = jest.fn().mockRejectedValue(new Error('Network error'));
  
  return fetchData('123')
    .catch(error => {
      expect(error.message).toBe('Network error');
    });
});

// Testing with async/await and try/catch
test('fetchData handles errors with async/await', async () => {
  // Mock fetch to reject
  global.fetch = jest.fn().mockRejectedValue(new Error('Network error'));
  
  try {
    await fetchData('123');
    // If we reach here, the test should fail
    expect(true).toBe(false); // This line should not be reached
  } catch (error) {
    expect(error.message).toBe('Network error');
  }
});
```

**7. Best Practices for JavaScript Testing**

**Write Testable Code:**
Structure your code to be easily testable.

```javascript
// Hard to test
function hardToTest() {
  const data = fetch('https://api.example.com/data').then(res => res.json());
  document.getElementById('result').innerHTML = processData(data);
}

// More testable version
function fetchData(url) {
  return fetch(url).then(res => res.json());
}

function processData(data) {
  // Process the data
  return processedResult;
}

function updateUI(element, content) {
  element.innerHTML = content;
}

async function main() {
  try {
    const data = await fetchData('https://api.example.com/data');
    const processed = processData(data);
    updateUI(document.getElementById('result'), processed);
  } catch (error) {
    console.error('Failed:', error);
  }
}
```

**Arrange-Act-Assert Pattern:**
Structure tests in a clear, consistent way.

```javascript
test('user registration with valid data', async () => {
  // Arrange
  const userData = {
    username: 'newuser',
    email: 'newuser@example.com',
    password: 'Password123'
  };
  const mockDb = new MockDatabase();
  const userService = new UserService(mockDb);
  
  // Act
  const result = await userService.registerUser(userData);
  
  // Assert
  expect(result.success).toBe(true);
  expect(result.userId).toBeDefined();
  expect(mockDb.users).toHaveLength(1);
  expect(mockDb.users[0].username).toBe('newuser');
  // Password should be hashed, not stored as plaintext
  expect(mockDb.users[0].password).not.toBe('Password123');
});
```

**Test Isolation:**
Ensure tests don't depend on each other.

```javascript
// Bad practice - tests depend on each other
let createdUserId;

test('creates a user', async () => {
  const response = await request(app)
    .post('/users')
    .send({ name: 'Test User' });
  
  expect(response.status).toBe(201);
  createdUserId = response.body.id; // This will be used by the next test
});

test('retrieves the created user', async () => {
  const response = await request(app).get(`/users/${createdUserId}`);
  expect(response.status).toBe(200);
  expect(response.body.name).toBe('Test User');
});

// Better practice - tests are independent
test('creates a user', async () => {
  const response = await request(app)
    .post('/users')
    .send({ name: 'Test User' });
  
  expect(response.status).toBe(201);
  expect(response.body.id).toBeDefined();
});

test('retrieves a user by id', async () => {
  // Setup - create a user first
  const createResponse = await request(app)
    .post('/users')
    .send({ name: 'Another User' });
  
  const userId = createResponse.body.id;
  
  // Test retrieving the user
  const getResponse = await request(app).get(`/users/${userId}`);
  expect(getResponse.status).toBe(200);
  expect(getResponse.body.name).toBe('Another User');
});
```

**Key Takeaways:**

1. Use a combination of unit, integration, and end-to-end tests for comprehensive coverage
2. Choose testing frameworks and tools that match your project's needs
3. Implement Test-Driven Development (TDD) for better code quality
4. Use mocking to isolate the code being tested from external dependencies
5. Monitor code coverage to identify untested parts of your codebase
6. Write tests for asynchronous code using async/await or promise handling
7. Structure your code to be testable by following principles like dependency injection
8. Follow the Arrange-Act-Assert pattern for clear, consistent tests
9. Ensure test isolation to prevent tests from affecting each other
10. Automate testing in your CI/CD pipeline for continuous quality assurance

## Web APIs and Browser Integration

### Q64: Explain the most important Web APIs and browser interactions in JavaScript.
**Difficulty: Medium**

**Answer:**
Web APIs (Application Programming Interfaces) are interfaces provided by browsers that allow JavaScript to interact with the browser environment and perform various operations. Understanding these APIs is crucial for effective web development.

**1. DOM (Document Object Model) API**

The DOM API allows JavaScript to access and manipulate the structure, content, and styles of HTML documents.

```javascript
// Selecting elements
const element = document.getElementById('myId');
const elements = document.querySelectorAll('.myClass');

// Modifying content
element.textContent = 'New text content';
element.innerHTML = '<strong>HTML content</strong>';

// Creating and appending elements
const newElement = document.createElement('div');
newElement.className = 'new-element';
newElement.textContent = 'Dynamically created element';
document.body.appendChild(newElement);

// Removing elements
const elementToRemove = document.querySelector('.remove-me');
elementToRemove.parentNode.removeChild(elementToRemove);
// Or with newer API
elementToRemove.remove();

// Modifying attributes
element.setAttribute('data-custom', 'value');
const attrValue = element.getAttribute('data-custom');
element.removeAttribute('data-custom');

// Working with classes
element.classList.add('active');
element.classList.remove('inactive');
element.classList.toggle('visible');
const hasClass = element.classList.contains('active');

// Modifying styles
element.style.color = 'red';
element.style.backgroundColor = '#f0f0f0';
element.style.display = 'flex';
```

**2. Fetch API**

The Fetch API provides a modern interface for making HTTP requests, replacing the older XMLHttpRequest.

```javascript
// Basic GET request
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log('Data received:', data))
  .catch(error => console.error('Fetch error:', error));

// POST request with JSON data
fetch('https://api.example.com/submit', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token123'
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  })
})
.then(response => response.json())
.then(data => console.log('Success:', data))
.catch(error => console.error('Error:', error));

// Using async/await with Fetch
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Fetch error:', error);
    throw error;
  }
}

// Fetch with AbortController (for cancellation)
const controller = new AbortController();
const signal = controller.signal;

fetch('https://api.example.com/large-data', { signal })
  .then(response => response.json())
  .then(data => console.log('Data:', data))
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('Fetch aborted');
    } else {
      console.error('Fetch error:', error);
    }
  });

// Abort the fetch after 5 seconds
setTimeout(() => controller.abort(), 5000);
```

**3. Web Storage API**

The Web Storage API provides mechanisms for storing data in the browser.

```javascript
// LocalStorage (persists until explicitly cleared)
localStorage.setItem('username', 'JohnDoe');
const username = localStorage.getItem('username');
localStorage.removeItem('username');
localStorage.clear(); // Clear all items

// SessionStorage (persists for the session)
sessionStorage.setItem('sessionId', '12345');
const sessionId = sessionStorage.getItem('sessionId');
sessionStorage.removeItem('sessionId');
sessionStorage.clear();

// Storage event (triggered when storage changes in another tab/window)
window.addEventListener('storage', (event) => {
  console.log('Storage changed in another window/tab');
  console.log('Key:', event.key);
  console.log('Old value:', event.oldValue);
  console.log('New value:', event.newValue);
  console.log('Storage area:', event.storageArea); // localStorage or sessionStorage
});

// Working with complex objects
const user = {
  id: 1,
  name: 'John Doe',
  preferences: {
    theme: 'dark',
    notifications: true
  }
};

// Storing objects (must be serialized)
localStorage.setItem('user', JSON.stringify(user));

// Retrieving objects (must be parsed)
const storedUser = JSON.parse(localStorage.getItem('user'));
```

**4. Geolocation API**

The Geolocation API allows JavaScript to access the user's geographical location.

```javascript
// Check if geolocation is supported
if ('geolocation' in navigator) {
  // Get current position
  navigator.geolocation.getCurrentPosition(
    // Success callback
    (position) => {
      const latitude = position.coords.latitude;
      const longitude = position.coords.longitude;
      const accuracy = position.coords.accuracy;
      
      console.log(`Latitude: ${latitude}, Longitude: ${longitude}`);
      console.log(`Accuracy: ${accuracy} meters`);
      
      // Use coordinates (e.g., with a mapping API)
      displayMap(latitude, longitude);
    },
    // Error callback
    (error) => {
      switch(error.code) {
        case error.PERMISSION_DENIED:
          console.error('User denied geolocation permission');
          break;
        case error.POSITION_UNAVAILABLE:
          console.error('Location information unavailable');
          break;
        case error.TIMEOUT:
          console.error('Request timed out');
          break;
        case error.UNKNOWN_ERROR:
          console.error('Unknown error occurred');
          break;
      }
    },
    // Options
    {
      enableHighAccuracy: true, // Use GPS if available
      timeout: 5000,           // Time to wait for response (ms)
      maximumAge: 0            // Don't use cached position
    }
  );
  
  // Watch position (continuous updates)
  const watchId = navigator.geolocation.watchPosition(
    (position) => {
      console.log(`Updated position: ${position.coords.latitude}, ${position.coords.longitude}`);
    },
    (error) => console.error('Error watching position:', error),
    { enableHighAccuracy: true }
  );
  
  // Stop watching
  // navigator.geolocation.clearWatch(watchId);
} else {
  console.error('Geolocation is not supported by this browser');
}
```

**5. History API**

The History API allows manipulation of the browser history and URL without full page reloads.

```javascript
// Navigate to a new URL without page reload
function navigateTo(path) {
  // Update URL
  history.pushState({ page: path }, '', path);
  // Update content
  loadContent(path);
}

// Replace current history entry
history.replaceState({ page: 'home' }, '', '/home');

// Handle back/forward navigation
window.addEventListener('popstate', (event) => {
  if (event.state) {
    loadContent(event.state.page);
  }
});

// Example navigation implementation
document.querySelectorAll('nav a').forEach(link => {
  link.addEventListener('click', (e) => {
    e.preventDefault();
    const path = link.getAttribute('href');
    navigateTo(path);
  });
});

// Example content loader
async function loadContent(path) {
  try {
    const response = await fetch(`/api/content${path}`);
    const data = await response.json();
    document.getElementById('content').innerHTML = data.html;
    document.title = data.title;
  } catch (error) {
    console.error('Error loading content:', error);
  }
}
```

**6. Web Workers API**

Web Workers allow JavaScript to run in background threads, preventing UI blocking during intensive operations.

```javascript
// Main thread code
if (window.Worker) {
  // Create a new worker
  const worker = new Worker('worker.js');
  
  // Send message to worker
  worker.postMessage({
    command: 'process',
    data: [1, 2, 3, 4, 5]
  });
  
  // Receive message from worker
  worker.onmessage = function(event) {
    console.log('Result from worker:', event.data);
    document.getElementById('result').textContent = event.data.result;
  };
  
  // Handle errors
  worker.onerror = function(error) {
    console.error('Worker error:', error.message);
  };
  
  // Terminate worker when done
  function stopWorker() {
    worker.terminate();
    console.log('Worker terminated');
  }
} else {
  console.error('Web Workers are not supported in this browser');
}

// worker.js (separate file)
// Self refers to the worker's global scope
self.onmessage = function(event) {
  const { command, data } = event.data;
  
  if (command === 'process') {
    // Simulate intensive processing
    let result = 0;
    
    // CPU-intensive operation that won't block the UI
    for (let i = 0; i < 1000000000; i++) {
      result += i;
    }
    
    // Process the data
    const processedData = data.map(x => x * x);
    
    // Send result back to main thread
    self.postMessage({
      result: result,
      processedData: processedData
    });
  }
};
```

**7. IndexedDB API**

IndexedDB is a low-level API for client-side storage of significant amounts of structured data.

```javascript
// Open a database
const request = indexedDB.open('MyDatabase', 1);
let db;

// Handle database upgrade (called when version changes)
request.onupgradeneeded = function(event) {
  db = event.target.result;
  
  // Create an object store (similar to a table)
  const objectStore = db.createObjectStore('users', { keyPath: 'id' });
  
  // Create indexes
  objectStore.createIndex('name', 'name', { unique: false });
  objectStore.createIndex('email', 'email', { unique: true });
  
  console.log('Database setup complete');
};

// Handle successful database open
request.onsuccess = function(event) {
  db = event.target.result;
  console.log('Database opened successfully');
};

// Handle errors
request.onerror = function(event) {
  console.error('Database error:', event.target.error);
};

// Add data
function addUser(user) {
  const transaction = db.transaction(['users'], 'readwrite');
  const objectStore = transaction.objectStore('users');
  const request = objectStore.add(user);
  
  request.onsuccess = function() {
    console.log('User added to database');
  };
  
  request.onerror = function(event) {
    console.error('Error adding user:', event.target.error);
  };
}

// Get data
function getUserById(id) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['users'], 'readonly');
    const objectStore = transaction.objectStore('users');
    const request = objectStore.get(id);
    
    request.onsuccess = function(event) {
      if (event.target.result) {
        resolve(event.target.result);
      } else {
        reject(new Error('User not found'));
      }
    };
    
    request.onerror = function(event) {
      reject(event.target.error);
    };
  });
}

// Update data
function updateUser(user) {
  const transaction = db.transaction(['users'], 'readwrite');
  const objectStore = transaction.objectStore('users');
  const request = objectStore.put(user); // Updates if exists, adds if doesn't
  
  request.onsuccess = function() {
    console.log('User updated');
  };
}

// Delete data
function deleteUser(id) {
  const transaction = db.transaction(['users'], 'readwrite');
  const objectStore = transaction.objectStore('users');
  const request = objectStore.delete(id);
  
  request.onsuccess = function() {
    console.log('User deleted');
  };
}

// Query with index
function getUsersByName(name) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['users'], 'readonly');
    const objectStore = transaction.objectStore('users');
    const index = objectStore.index('name');
    const request = index.getAll(name);
    
    request.onsuccess = function(event) {
      resolve(event.target.result);
    };
    
    request.onerror = function(event) {
      reject(event.target.error);
    };
  });
}
```

**8. Intersection Observer API**

The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with its parent or the viewport.

```javascript
// Create an intersection observer
const observer = new IntersectionObserver(
  (entries, observer) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        console.log('Element is now visible:', entry.target);
        
        // Example: Lazy load an image
        if (entry.target.dataset.src) {
          entry.target.src = entry.target.dataset.src;
          entry.target.removeAttribute('data-src');
          observer.unobserve(entry.target); // Stop observing once loaded
        }
      } else {
        console.log('Element is no longer visible:', entry.target);
      }
    });
  },
  {
    root: null, // Use viewport as root
    rootMargin: '0px', // No margin
    threshold: 0.1 // Trigger when 10% of the element is visible
  }
);

// Start observing elements
document.querySelectorAll('.lazy-image').forEach(img => {
  observer.observe(img);
});

// Example: Infinite scroll implementation
function setupInfiniteScroll() {
  const loadingIndicator = document.getElementById('loading');
  
  const infiniteObserver = new IntersectionObserver(
    async (entries) => {
      if (entries[0].isIntersecting) {
        // Show loading indicator
        loadingIndicator.style.display = 'block';
        
        try {
          // Load more content
          await loadMoreContent();
        } catch (error) {
          console.error('Error loading more content:', error);
        } finally {
          // Hide loading indicator
          loadingIndicator.style.display = 'none';
        }
      }
    },
    { threshold: 1.0 }
  );
  
  infiniteObserver.observe(loadingIndicator);
}

async function loadMoreContent() {
  // Fetch more items
  const response = await fetch(`/api/items?page=${currentPage}`);
  const data = await response.json();
  
  // Append items to the DOM
  const container = document.getElementById('items-container');
  data.items.forEach(item => {
    const element = createItemElement(item);
    container.appendChild(element);
  });
  
  currentPage++;
  
  // Stop if no more items
  if (data.isLastPage) {
    infiniteObserver.disconnect();
  }
}
```

**9. Notification API**

The Notification API allows web pages to display system notifications to the user.

```javascript
// Check if browser supports notifications
if ('Notification' in window) {
  // Request permission
  async function requestNotificationPermission() {
    try {
      const permission = await Notification.requestPermission();
      return permission;
    } catch (error) {
      console.error('Error requesting notification permission:', error);
      return 'denied';
    }
  }
  
  // Show notification
  function showNotification(title, options = {}) {
    if (Notification.permission === 'granted') {
      const notification = new Notification(title, {
        body: options.body || '',
        icon: options.icon || '/path/to/icon.png',
        badge: options.badge,
        image: options.image,
        tag: options.tag, // Group similar notifications
        data: options.data,
        requireInteraction: options.requireInteraction || false,
        renotify: options.renotify || false,
        silent: options.silent || false,
        actions: options.actions || []
      });
      
      // Handle notification events
      notification.onclick = function(event) {
        console.log('Notification clicked', event);
        window.focus();
        notification.close();
      };
      
      notification.onclose = function() {
        console.log('Notification closed');
      };
      
      notification.onerror = function(error) {
        console.error('Notification error:', error);
      };
      
      return notification;
    } else {
      console.warn('Notification permission not granted');
      return null;
    }
  }
  
  // Example usage
  async function notifyUser(message) {
    // Request permission if needed
    if (Notification.permission !== 'granted' && Notification.permission !== 'denied') {
      const permission = await requestNotificationPermission();
      if (permission !== 'granted') {
        console.log('Notification permission denied');
        return;
      }
    }
    
    // Show notification
    if (Notification.permission === 'granted') {
      showNotification('New Message', {
        body: message,
        icon: '/images/message-icon.png',
        tag: 'message',
        requireInteraction: true
      });
    }
  }
} else {
  console.warn('This browser does not support notifications');
}
```

**10. Canvas API**

The Canvas API provides a means for drawing graphics via JavaScript and HTML.

```javascript
// Get the canvas element
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');

// Set canvas dimensions
canvas.width = 800;
canvas.height = 600;

// Basic drawing
function drawBasicShapes() {
  // Rectangle
  ctx.fillStyle = 'blue';
  ctx.fillRect(10, 10, 100, 80); // x, y, width, height
  
  // Stroke rectangle
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 3;
  ctx.strokeRect(150, 10, 100, 80);
  
  // Line
  ctx.beginPath();
  ctx.moveTo(300, 10);
  ctx.lineTo(400, 90);
  ctx.stroke();
  
  // Circle
  ctx.beginPath();
  ctx.arc(500, 50, 40, 0, Math.PI * 2); // x, y, radius, startAngle, endAngle
  ctx.fillStyle = 'green';
  ctx.fill();
  
  // Text
  ctx.font = '24px Arial';
  ctx.fillStyle = 'black';
  ctx.fillText('Hello Canvas', 50, 150);
}

// Path drawing
function drawComplexPath() {
  ctx.beginPath();
  ctx.moveTo(50, 200);
  ctx.lineTo(150, 250);
  ctx.lineTo(50, 300);
  ctx.lineTo(150, 350);
  ctx.closePath(); // Connects back to the start
  
  ctx.fillStyle = 'purple';
  ctx.fill();
  ctx.strokeStyle = 'orange';
  ctx.lineWidth = 2;
  ctx.stroke();
}

// Gradients
function drawGradients() {
  // Linear gradient
  const linearGradient = ctx.createLinearGradient(200, 200, 400, 300);
  linearGradient.addColorStop(0, 'red');
  linearGradient.addColorStop(0.5, 'yellow');
  linearGradient.addColorStop(1, 'blue');
  
  ctx.fillStyle = linearGradient;
  ctx.fillRect(200, 200, 200, 100);
  
  // Radial gradient
  const radialGradient = ctx.createRadialGradient(500, 250, 10, 500, 250, 70);
  radialGradient.addColorStop(0, 'white');
  radialGradient.addColorStop(1, 'darkblue');
  
  ctx.fillStyle = radialGradient;
  ctx.beginPath();
  ctx.arc(500, 250, 70, 0, Math.PI * 2);
  ctx.fill();
}

// Images
function drawImage() {
  const img = new Image();
  img.src = 'image.jpg';
  
  img.onload = function() {
    // Draw the entire image
    ctx.drawImage(img, 50, 400, 200, 150); // x, y, width, height
    
    // Draw a portion of the image
    // ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
    ctx.drawImage(img, 100, 100, 200, 200, 300, 400, 150, 150);
  };
}

// Animation
let x = 0;
function animate() {
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw moving rectangle
  ctx.fillStyle = 'red';
  ctx.fillRect(x, 500, 50, 50);
  
  // Update position
  x += 2;
  if (x > canvas.width) {
    x = -50;
  }
  
  // Request next frame
  requestAnimationFrame(animate);
}

// Call drawing functions
drawBasicShapes();
drawComplexPath();
drawGradients();
drawImage();
animate();
```

**Key Takeaways:**

1. The DOM API is fundamental for manipulating HTML document structure and content
2. The Fetch API provides a modern way to make HTTP requests with Promises
3. Web Storage (localStorage/sessionStorage) offers simple key-value storage in the browser
4. The Geolocation API enables access to the user's geographical location
5. The History API allows manipulation of browser history without page reloads
6. Web Workers enable running JavaScript in background threads for performance
7. IndexedDB provides a robust client-side database for storing structured data
8. The Intersection Observer API enables efficient detection of element visibility
9. The Notification API allows web applications to display system notifications
10. The Canvas API provides powerful 2D drawing capabilities for graphics and animations

### Q65: Explain functional programming concepts in JavaScript.
**Difficulty: Hard**

**Answer:**
Functional programming (FP) is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. JavaScript supports many functional programming concepts, making it a versatile language for this paradigm.

**1. Core Principles of Functional Programming**

**Pure Functions:**
Functions that always return the same output for the same input and have no side effects.

```javascript
// Impure function (has side effects)
let counter = 0;
function incrementCounter() {
  counter++; // Side effect: modifies external state
  return counter;
}

// Pure function
function add(a, b) {
  return a + b; // Always returns the same output for the same input
}

// Pure function that creates a new array instead of modifying the original
function addItem(array, item) {
  return [...array, item]; // Returns a new array
}

// Impure function that modifies the original array
function addItemImpure(array, item) {
  array.push(item); // Side effect: modifies the input array
  return array;
}
```

**Immutability:**
Once created, data cannot be changed. Instead, new data structures are created from existing ones.

```javascript
// Mutable approach
const mutableArray = [1, 2, 3];
mutableArray.push(4); // Modifies the original array

// Immutable approach
const immutableArray = [1, 2, 3];
const newArray = [...immutableArray, 4]; // Creates a new array

// Immutable object updates
const user = { name: 'John', age: 30 };

// Mutable update
user.age = 31; // Modifies the original object

// Immutable update
const updatedUser = { ...user, age: 31 }; // Creates a new object

// Deep immutable update
const deepUser = {
  name: 'John',
  address: {
    city: 'New York',
    zip: '10001'
  }
};

const updatedDeepUser = {
  ...deepUser,
  address: {
    ...deepUser.address,
    zip: '10002'
  }
};
```

**First-Class and Higher-Order Functions:**
Functions can be assigned to variables, passed as arguments, and returned from other functions.

```javascript
// Assigning function to a variable
const greet = function(name) {
  return `Hello, ${name}!`;
};

// Passing function as an argument
function executeFunction(fn, value) {
  return fn(value);
}

const result = executeFunction(greet, 'Alice'); // 'Hello, Alice!'

// Returning a function
function multiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

const double = multiplier(2);
const triple = multiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

**Function Composition:**
Combining multiple functions to create a new function.

```javascript
// Basic function composition
function compose(f, g) {
  return function(x) {
    return f(g(x));
  };
}

const addOne = x => x + 1;
const double = x => x * 2;

const addOneThenDouble = compose(double, addOne);
const doubleThenAddOne = compose(addOne, double);

console.log(addOneThenDouble(3)); // (3 + 1) * 2 = 8
console.log(doubleThenAddOne(3)); // (3 * 2) + 1 = 7

// Multiple function composition
function composeMultiple(...fns) {
  return fns.reduce((f, g) => (...args) => f(g(...args)));
}

const addTwo = x => x + 2;
const square = x => x * x;

const addTwoThenSquareThenDouble = composeMultiple(
  double,
  square,
  addTwo
);

console.log(addTwoThenSquareThenDouble(3)); // ((3 + 2)² * 2) = 50
```

**2. Functional Programming Techniques in JavaScript**

**Map, Filter, and Reduce:**
Core functional operations for transforming data.

```javascript
const numbers = [1, 2, 3, 4, 5];

// Map: Transform each element
const doubled = numbers.map(n => n * 2);
// [2, 4, 6, 8, 10]

// Filter: Keep elements that satisfy a condition
const evens = numbers.filter(n => n % 2 === 0);
// [2, 4]

// Reduce: Accumulate values
const sum = numbers.reduce((acc, n) => acc + n, 0);
// 15

// Combining map, filter, and reduce
const sumOfSquaresOfEvens = numbers
  .filter(n => n % 2 === 0)
  .map(n => n * n)
  .reduce((acc, n) => acc + n, 0);
// 2² + 4² = 4 + 16 = 20

// Custom implementations
function map(array, fn) {
  return array.reduce((acc, item) => [...acc, fn(item)], []);
}

function filter(array, predicate) {
  return array.reduce((acc, item) => 
    predicate(item) ? [...acc, item] : acc, []);
}
```

**Currying:**
Transforming a function with multiple arguments into a sequence of functions, each taking a single argument.

```javascript
// Regular function
function add(a, b, c) {
  return a + b + c;
}

// Curried version
function curriedAdd(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

console.log(curriedAdd(1)(2)(3)); // 6

// Arrow function syntax for currying
const curriedAddArrow = a => b => c => a + b + c;

// Partial application
const addFive = curriedAddArrow(5);
const addFiveAndTen = addFive(10);
console.log(addFiveAndTen(15)); // 30

// Generic curry function
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function(...args2) {
        return curried.apply(this, args.concat(args2));
      };
    }
  };
}

const curriedSum = curry((a, b, c) => a + b + c);
console.log(curriedSum(1)(2)(3)); // 6
console.log(curriedSum(1, 2)(3)); // 6
console.log(curriedSum(1)(2, 3)); // 6
console.log(curriedSum(1, 2, 3)); // 6
```

**Partial Application:**
Fixing a number of arguments to a function, producing another function of smaller arity.

```javascript
function partial(fn, ...presetArgs) {
  return function(...laterArgs) {
    return fn(...presetArgs, ...laterArgs);
  };
}

function greet(greeting, name) {
  return `${greeting}, ${name}!`;
}

const sayHello = partial(greet, 'Hello');
console.log(sayHello('John')); // 'Hello, John!'

const sayHiToJohn = partial(greet, 'Hi', 'John');
console.log(sayHiToJohn()); // 'Hi, John!'

// Partial application with placeholders
function partialWithPlaceholders(fn, ...presetArgs) {
  const PLACEHOLDER = Symbol('placeholder');
  
  return function(...laterArgs) {
    const args = presetArgs.map(arg => 
      arg === PLACEHOLDER ? laterArgs.shift() : arg
    ).concat(laterArgs);
    
    return fn(...args);
  };
}

const _ = PLACEHOLDER;
const formatGreeting = partialWithPlaceholders(
  (greeting, name, punctuation) => `${greeting}, ${name}${punctuation}`,
  'Hello',
  _,
  '!'
);

console.log(formatGreeting('Alice')); // 'Hello, Alice!'
```

**Function Memoization:**
Caching the results of expensive function calls to improve performance.

```javascript
function memoize(fn) {
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      console.log('Returning from cache');
      return cache.get(key);
    }
    
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// Expensive function
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// Memoized version
const memoizedFibonacci = memoize(function(n) {
  if (n <= 1) return n;
  return memoizedFibonacci(n - 1) + memoizedFibonacci(n - 2);
});

console.time('Regular');
console.log(fibonacci(35)); // Very slow
console.timeEnd('Regular');

console.time('Memoized');
console.log(memoizedFibonacci(35)); // Much faster
console.timeEnd('Memoized');
```

**Point-Free Style:**
Writing functions without explicitly mentioning the arguments they operate on.

```javascript
// Regular style
const numbers = [1, 2, 3, 4, 5];
const isEven = num => num % 2 === 0;
const evens = numbers.filter(num => isEven(num));

// Point-free style
const evensPointFree = numbers.filter(isEven);

// More complex example
const get = property => object => object[property];
const map = fn => array => array.map(fn);
const filter = predicate => array => array.filter(predicate);

const getName = get('name');
const getAges = map(get('age'));
const adults = filter(age => age >= 18);

const people = [
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 17 },
  { name: 'Charlie', age: 30 }
];

const adultNames = map(getName)(filter(person => person.age >= 18)(people));
// ['Alice', 'Charlie']

// Using compose for cleaner point-free style
const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);
const getAdultNames = compose(
  map(getName),
  filter(person => person.age >= 18)
);

console.log(getAdultNames(people)); // ['Alice', 'Charlie']
```

**3. Functional Data Structures**

**Immutable Lists:**

```javascript
class List {
  constructor(head, tail = null) {
    this.head = head;
    this.tail = tail;
  }
  
  // Add element to the front (non-mutating)
  prepend(value) {
    return new List(value, this);
  }
  
  // Map over the list (non-mutating)
  map(fn) {
    return new List(fn(this.head), this.tail ? this.tail.map(fn) : null);
  }
  
  // Convert to array
  toArray() {
    const result = [this.head];
    let current = this.tail;
    
    while (current) {
      result.push(current.head);
      current = current.tail;
    }
    
    return result;
  }
  
  // Create from array
  static fromArray(array) {
    if (array.length === 0) return null;
    
    let list = new List(array[array.length - 1]);
    for (let i = array.length - 2; i >= 0; i--) {
      list = list.prepend(array[i]);
    }
    
    return list;
  }
}

const list = List.fromArray([1, 2, 3]);
const doubled = list.map(x => x * 2);
console.log(doubled.toArray()); // [2, 4, 6]
console.log(list.toArray()); // Original list unchanged: [1, 2, 3]
```

**4. Functional Libraries in JavaScript**

```javascript
// Examples using Ramda.js
const R = require('ramda');

// Compose functions
const getAdultNames = R.compose(
  R.map(R.prop('name')),
  R.filter(R.propSatisfies(R.gte(R.__, 18), 'age'))
);

const people = [
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 17 },
  { name: 'Charlie', age: 30 }
];

console.log(getAdultNames(people)); // ['Alice', 'Charlie']

// Lens for immutable updates
const user = { name: 'John', address: { city: 'New York', zip: '10001' } };

const addressLens = R.lens(R.prop('address'), R.assoc('address'));
const zipLens = R.lens(R.prop('zip'), R.assoc('zip'));
const addressZipLens = R.compose(addressLens, zipLens);

const updatedUser = R.set(addressZipLens, '10002', user);
console.log(updatedUser);
// { name: 'John', address: { city: 'New York', zip: '10002' } }
```

**5. Practical Applications of Functional Programming**

**State Management:**

```javascript
// Simple immutable state management
function createStore(reducer, initialState) {
  let state = initialState;
  const listeners = [];
  
  function getState() {
    return state;
  }
  
  function dispatch(action) {
    state = reducer(state, action);
    listeners.forEach(listener => listener());
  }
  
  function subscribe(listener) {
    listeners.push(listener);
    return function unsubscribe() {
      const index = listeners.indexOf(listener);
      listeners.splice(index, 1);
    };
  }
  
  // Initialize store
  dispatch({ type: '@@INIT' });
  
  return { getState, dispatch, subscribe };
}

// Example usage
const initialState = { count: 0 };

function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
}

const store = createStore(counterReducer, initialState);

store.subscribe(() => {
  console.log('State updated:', store.getState());
});

store.dispatch({ type: 'INCREMENT' }); // State updated: { count: 1 }
store.dispatch({ type: 'INCREMENT' }); // State updated: { count: 2 }
store.dispatch({ type: 'DECREMENT' }); // State updated: { count: 1 }
```

**Handling Asynchronous Operations:**

```javascript
// Functional approach to async operations
const fetchUserData = userId => 
  fetch(`https://api.example.com/users/${userId}`)
    .then(response => response.json());

const getFullName = user => `${user.firstName} ${user.lastName}`;
const getEmail = user => user.email;

// Composing async operations
const pipe = (...fns) => x => fns.reduce((y, f) => y.then(f), Promise.resolve(x));

const getUserFullName = pipe(
  fetchUserData,
  getFullName
);

getUserFullName('123')
  .then(fullName => console.log(fullName))
  .catch(error => console.error(error));

// More complex example with error handling
const tryCatch = (tryFn, catchFn) => value => 
  Promise.resolve(value)
    .then(tryFn)
    .catch(catchFn);

const logError = error => {
  console.error('Operation failed:', error);
  return null; // Fallback value
};

const safeGetUserFullName = tryCatch(getUserFullName, logError);

safeGetUserFullName('123')
  .then(result => console.log('Result:', result));
```

**6. Benefits and Challenges of Functional Programming**

**Benefits:**

- **Predictability:** Pure functions always produce the same output for the same input
- **Testability:** Pure functions are easier to test since they don't have side effects
- **Concurrency:** Immutable data and pure functions make concurrent programming safer
- **Debugging:** Function composition makes it easier to trace data flow
- **Reusability:** Higher-order functions and composition promote code reuse

**Challenges:**

- **Performance:** Creating new objects instead of mutating can be less efficient
- **Learning Curve:** Functional concepts can be difficult for developers used to imperative programming
- **Interoperability:** Working with non-functional libraries and APIs can be challenging
- **Verbosity:** Some functional patterns can be more verbose than their imperative counterparts

**Key Takeaways:**

1. Pure functions avoid side effects and always return the same output for the same input
2. Immutability prevents unexpected changes to data and makes code more predictable
3. First-class functions enable higher-order functions, currying, and composition
4. Map, filter, and reduce are fundamental operations for functional data transformation
5. Currying and partial application allow for flexible function reuse
6. Function composition enables building complex operations from simple functions
7. Memoization improves performance by caching function results
8. Point-free style can make code more declarative and focused on data flow
9. Functional libraries like Ramda provide comprehensive tools for functional programming
10. Functional programming principles can be applied incrementally to improve code quality

### Q66: Explain JavaScript event handling and event delegation in depth.
**Difficulty: Medium**

**Answer:**
Event handling is a fundamental aspect of JavaScript that allows you to create interactive web applications by responding to user actions and browser events. Event delegation is an advanced pattern that leverages event bubbling to handle events efficiently.

**1. Event Fundamentals**

**Event Types:**
JavaScript supports numerous event types, categorized as follows:

- **Mouse Events:** `click`, `dblclick`, `mousedown`, `mouseup`, `mousemove`, `mouseover`, `mouseout`, `mouseenter`, `mouseleave`
- **Keyboard Events:** `keydown`, `keyup`, `keypress`
- **Form Events:** `submit`, `change`, `focus`, `blur`, `input`
- **Window Events:** `load`, `resize`, `scroll`, `unload`, `beforeunload`
- **Document Events:** `DOMContentLoaded`
- **Touch Events:** `touchstart`, `touchend`, `touchmove`, `touchcancel`
- **Drag Events:** `dragstart`, `drag`, `dragend`, `dragenter`, `dragover`, `dragleave`, `drop`

**Event Object:**
When an event occurs, the browser creates an event object containing information about the event.

```javascript
document.getElementById('myButton').addEventListener('click', function(event) {
  console.log('Event type:', event.type); // 'click'
  console.log('Target element:', event.target); // The button element
  console.log('Current target:', event.currentTarget); // Also the button element
  console.log('Mouse position:', event.clientX, event.clientY); // X and Y coordinates
  
  // Prevent default behavior (e.g., form submission)
  event.preventDefault();
  
  // Stop event propagation
  event.stopPropagation();
});
```

**Common Event Object Properties:**

- `event.type`: The event type (e.g., 'click', 'keydown')
- `event.target`: The element that triggered the event
- `event.currentTarget`: The element that the event listener is attached to
- `event.clientX/clientY`: Mouse coordinates relative to the viewport
- `event.pageX/pageY`: Mouse coordinates relative to the document
- `event.key`: The key value for keyboard events
- `event.code`: The physical key code for keyboard events
- `event.shiftKey`, `event.ctrlKey`, `event.altKey`, `event.metaKey`: Boolean values indicating if modifier keys were pressed

**2. Event Registration Methods**

**Method 1: HTML Attribute (Not Recommended):**

```html
<button onclick="handleClick()">Click me</button>

<script>
function handleClick() {
  console.log('Button clicked!');
}
</script>
```

**Method 2: DOM Property:**

```javascript
const button = document.getElementById('myButton');
button.onclick = function() {
  console.log('Button clicked!');
};

// Limitations: Only one handler per event type
button.onclick = function() {
  console.log('This overwrites the previous handler');
};
```

**Method 3: addEventListener (Recommended):**

```javascript
const button = document.getElementById('myButton');

// Add multiple handlers for the same event
button.addEventListener('click', function() {
  console.log('First handler');
});

button.addEventListener('click', function() {
  console.log('Second handler');
});

// With named function for later removal
function handleClick() {
  console.log('Handler with named function');
}

button.addEventListener('click', handleClick);

// Remove event listener
button.removeEventListener('click', handleClick);

// Options parameter
button.addEventListener('click', handleClick, {
  once: true, // Execute only once
  capture: true, // Use capture phase
  passive: true // Indicates the handler won't call preventDefault()
});
```

**3. Event Propagation**

Event propagation in the DOM occurs in three phases:

**1. Capture Phase:** The event travels from the window down to the target element
**2. Target Phase:** The event reaches the target element
**3. Bubbling Phase:** The event bubbles up from the target element back to the window

```html
<div id="outer">
  <div id="inner">
    <button id="button">Click me</button>
  </div>
</div>

<script>
const outer = document.getElementById('outer');
const inner = document.getElementById('inner');
const button = document.getElementById('button');

// Capture phase (third parameter true)
outer.addEventListener('click', function() {
  console.log('Outer - Capture Phase');
}, true);

inner.addEventListener('click', function() {
  console.log('Inner - Capture Phase');
}, true);

button.addEventListener('click', function() {
  console.log('Button - Capture Phase');
}, true);

// Bubbling phase (default, third parameter false or omitted)
outer.addEventListener('click', function() {
  console.log('Outer - Bubbling Phase');
});

inner.addEventListener('click', function() {
  console.log('Inner - Bubbling Phase');
});

button.addEventListener('click', function() {
  console.log('Button - Bubbling Phase');
});
</script>
```

When the button is clicked, the console output will be:

```
Outer - Capture Phase
Inner - Capture Phase
Button - Capture Phase
Button - Bubbling Phase
Inner - Bubbling Phase
Outer - Bubbling Phase
```

**Stopping Propagation:**

```javascript
button.addEventListener('click', function(event) {
  console.log('Button clicked');
  event.stopPropagation(); // Prevents the event from bubbling up
});

// More aggressive version that also stops other handlers on the same element
button.addEventListener('click', function(event) {
  console.log('This handler runs');
  event.stopImmediatePropagation();
});

button.addEventListener('click', function() {
  console.log('This handler never runs'); // Won't execute
});
```

**4. Event Delegation**

Event delegation is a technique where you attach a single event listener to a parent element to handle events for multiple child elements, including those added dynamically after the initial page load.

**Without Event Delegation:**

```javascript
// Inefficient for many items
const items = document.querySelectorAll('.item');
items.forEach(item => {
  item.addEventListener('click', function() {
    console.log('Item clicked:', this.textContent);
  });
});

// Doesn't work for dynamically added items
const newItem = document.createElement('div');
newItem.className = 'item';
newItem.textContent = 'New Item';
document.getElementById('container').appendChild(newItem);
// The new item won't have a click handler
```

**With Event Delegation:**

```javascript
// Single event listener for all items, including future ones
document.getElementById('container').addEventListener('click', function(event) {
  // Check if the clicked element or any of its parents has the 'item' class
  const item = event.target.closest('.item');
  
  if (item) {
    console.log('Item clicked:', item.textContent);
  }
});

// Now dynamically added items will work too
const newItem = document.createElement('div');
newItem.className = 'item';
newItem.textContent = 'New Item';
document.getElementById('container').appendChild(newItem);
```

**Advanced Event Delegation Pattern:**

```javascript
function delegateEvent(element, eventType, selector, handler) {
  element.addEventListener(eventType, function(event) {
    const targetElement = event.target.closest(selector);
    
    if (targetElement && element.contains(targetElement)) {
      handler.call(targetElement, event);
    }
  });
}

// Usage
delegateEvent(document.body, 'click', '.button', function(event) {
  console.log('Button clicked:', this.textContent);
});

delegateEvent(document.getElementById('menu'), 'click', '.menu-item', function(event) {
  console.log('Menu item clicked:', this.textContent);
});
```

**5. Custom Events**

JavaScript allows you to create and dispatch custom events.

```javascript
// Create a custom event
const customEvent = new CustomEvent('userLoggedIn', {
  detail: { userId: 123, username: 'john_doe' },
  bubbles: true,
  cancelable: true
});

// Listen for the custom event
document.addEventListener('userLoggedIn', function(event) {
  console.log('User logged in:', event.detail.username);
});

// Dispatch the custom event
document.dispatchEvent(customEvent);

// Creating and dispatching in one step
document.dispatchEvent(new CustomEvent('notification', {
  detail: { message: 'Operation completed successfully', type: 'success' }
}));
```

**6. Event Performance Optimization**

**Debouncing Events:**
Limits the rate at which a function can fire by delaying its execution until after a specified amount of time has elapsed since the last time it was invoked.

```javascript
function debounce(func, delay) {
  let timeoutId;
  
  return function(...args) {
    const context = this;
    
    clearTimeout(timeoutId);
    
    timeoutId = setTimeout(() => {
      func.apply(context, args);
    }, delay);
  };
}

// Usage
const expensiveOperation = () => {
  console.log('Performing expensive operation...');
  // Complex calculations or API calls
};

const debouncedOperation = debounce(expensiveOperation, 300);

// Attach to an event that fires rapidly
window.addEventListener('resize', debouncedOperation);

// For search inputs
document.getElementById('search').addEventListener('input', debounce(function(e) {
  console.log('Searching for:', e.target.value);
  // API call or search operation
}, 500));
```

**Throttling Events:**
Ensures a function is called at most once in a specified time period.

```javascript
function throttle(func, limit) {
  let inThrottle;
  
  return function(...args) {
    const context = this;
    
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      
      setTimeout(() => {
        inThrottle = false;
      }, limit);
    }
  };
}

// Usage
const handleMouseMove = throttle(function(e) {
  console.log('Mouse position:', e.clientX, e.clientY);
  // Update UI based on mouse position
}, 100);

document.addEventListener('mousemove', handleMouseMove);
```

**Passive Event Listeners:**
Improves scrolling performance by indicating that a listener will not call preventDefault().

```javascript
// Without passive option - may cause performance issues
document.addEventListener('touchstart', function(e) {
  // Handler code
});

// With passive option - better performance
document.addEventListener('touchstart', function(e) {
  // Handler code (cannot use preventDefault here)
}, { passive: true });

// Feature detection for passive support
let passiveSupported = false;
try {
  const options = {
    get passive() {
      passiveSupported = true;
      return false;
    }
  };
  
  window.addEventListener('test', null, options);
  window.removeEventListener('test', null, options);
} catch (err) {
  passiveSupported = false;
}

// Use passive if supported
document.addEventListener('touchstart', handleTouchStart, 
  passiveSupported ? { passive: true } : false
);
```

**7. Event Handling Best Practices**

**Use Event Delegation:**
Attach event listeners to container elements rather than individual children when appropriate.

**Remove Unused Event Listeners:**
Always remove event listeners when they're no longer needed to prevent memory leaks.

```javascript
function setupEventListeners() {
  const button = document.getElementById('myButton');
  button.addEventListener('click', handleClick);
  
  return function cleanup() {
    button.removeEventListener('click', handleClick);
  };
}

const cleanup = setupEventListeners();

// Later when no longer needed
cleanup();
```

**Avoid Inline Event Handlers:**
Separate JavaScript from HTML for better maintainability.

**Use Named Functions for Event Handlers:**
Makes code more readable and allows for easier removal of event listeners.

```javascript
// Instead of this
element.addEventListener('click', function() {
  // Hard to remove this listener later
});

// Do this
function handleClick() {
  // Handler code
}

element.addEventListener('click', handleClick);
// Can be easily removed later
element.removeEventListener('click', handleClick);
```

**Optimize Event Handlers:**
Use debouncing and throttling for events that fire frequently.

**Use Event Objects Effectively:**
Leverage the information provided by event objects for more dynamic handlers.

```javascript
document.addEventListener('keydown', function(event) {
  // Check for specific keys
  if (event.key === 'Enter') {
    // Handle Enter key
  }
  
  // Check for key combinations
  if (event.ctrlKey && event.key === 's') {
    event.preventDefault(); // Prevent browser's save dialog
    saveDocument(); // Custom save function
  }
});
```

**8. Cross-Browser Event Handling**

Modern browsers have standardized event handling, but for older browsers or complex applications, you might need to handle cross-browser differences.

```javascript
// Cross-browser event listener function
function addEvent(element, eventType, handler) {
  if (element.addEventListener) {
    element.addEventListener(eventType, handler, false);
  } else if (element.attachEvent) {
    // For older IE versions
    element.attachEvent('on' + eventType, function() {
      // Fix the this reference in IE
      return handler.call(element, window.event);
    });
  } else {
    // Fallback
    element['on' + eventType] = handler;
  }
}

// Cross-browser event object normalization
function normalizeEvent(event) {
  event = event || window.event;
  
  // Target
  if (!event.target) {
    event.target = event.srcElement || document;
  }
  
  // preventDefault
  if (!event.preventDefault) {
    event.preventDefault = function() {
      event.returnValue = false;
    };
  }
  
  // stopPropagation
  if (!event.stopPropagation) {
    event.stopPropagation = function() {
      event.cancelBubble = true;
    };
  }
  
  return event;
}

// Usage
addEvent(document.getElementById('myButton'), 'click', function(event) {
  event = normalizeEvent(event);
  console.log('Clicked:', event.target);
  event.preventDefault();
});
```

**Key Takeaways:**

1. Event handling is fundamental to creating interactive web applications
2. Modern event handling should use `addEventListener` rather than HTML attributes or DOM properties
3. Event propagation occurs in three phases: capture, target, and bubbling
4. Event delegation leverages bubbling to efficiently handle events for multiple elements
5. Custom events allow for creating your own event-driven architecture
6. Performance optimization techniques like debouncing and throttling are essential for smooth UIs
7. Proper event cleanup prevents memory leaks in long-running applications
8. The event object provides valuable information about the event context
9. Passive event listeners improve scrolling performance for touch events
10. Cross-browser event handling is less of a concern with modern browsers but may be needed for legacy support

### Q67: Compare and contrast different browser storage mechanisms in JavaScript.
**Difficulty: Medium**

**Answer:**
Modern web applications often need to store data on the client-side for various purposes, such as maintaining user preferences, caching data, or supporting offline functionality. JavaScript provides several storage mechanisms, each with its own characteristics, use cases, and limitations.

**1. Cookies**

**Overview:**
Cookies are small text files stored on the client's computer that are sent to the server with every HTTP request.

**Implementation:**
```javascript
// Setting a cookie
document.cookie = "username=John; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/; secure; samesite=strict";

// Reading all cookies
const allCookies = document.cookie;
console.log(allCookies); // "username=John; theme=dark"

// Parsing cookies
function getCookie(name) {
  const cookieArr = document.cookie.split(";");
  
  for (let i = 0; i < cookieArr.length; i++) {
    const cookiePair = cookieArr[i].split("=");
    const cookieName = cookiePair[0].trim();
    
    if (cookieName === name) {
      return decodeURIComponent(cookiePair[1]);
    }
  }
  
  return null;
}

const username = getCookie("username");
console.log(username); // "John"

// Deleting a cookie (set expiration to past date)
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
```

**Characteristics:**
- **Size Limit:** ~4KB per cookie, typically limited to 20 cookies per domain
- **Expiration:** Can set expiration date or session-based (deleted when browser closes)
- **Scope:** Domain and path specific
- **Accessibility:** Sent with every HTTP request to the server
- **Security:** Can be marked as secure (HTTPS only) and HttpOnly (inaccessible to JavaScript)
- **SameSite:** Can control cross-origin behavior with SameSite attribute

**Use Cases:**
- Session management
- User preferences that need to be accessible on the server
- Tracking and analytics

**2. localStorage**

**Overview:**
localStorage provides persistent storage that doesn't expire and is available across browser sessions.

**Implementation:**
```javascript
// Storing data
localStorage.setItem("username", "John");
localStorage.setItem("preferences", JSON.stringify({
  theme: "dark",
  fontSize: "medium",
  notifications: true
}));

// Reading data
const username = localStorage.getItem("username");
console.log(username); // "John"

const preferences = JSON.parse(localStorage.getItem("preferences"));
console.log(preferences.theme); // "dark"

// Removing specific item
localStorage.removeItem("username");

// Clearing all localStorage data
localStorage.clear();

// Checking if a key exists
if (localStorage.getItem("username") !== null) {
  console.log("Username exists in localStorage");
}

// Getting the number of items
const itemCount = localStorage.length;
console.log(`There are ${itemCount} items in localStorage`);

// Iterating through all items
for (let i = 0; i < localStorage.length; i++) {
  const key = localStorage.key(i);
  const value = localStorage.getItem(key);
  console.log(`${key}: ${value}`);
}
```

**Characteristics:**
- **Size Limit:** ~5-10MB depending on the browser
- **Expiration:** No expiration (persists until explicitly cleared)
- **Scope:** Domain specific (same origin policy)
- **Accessibility:** Synchronous API, available only to JavaScript
- **Storage Type:** Key-value pairs (strings only)

**Use Cases:**
- User preferences and settings
- Shopping cart contents
- Form data persistence
- Cached application data
- Offline application data

**3. sessionStorage**

**Overview:**
sessionStorage is similar to localStorage but limited to the current browser session.

**Implementation:**
```javascript
// The API is identical to localStorage
sessionStorage.setItem("tempData", "This will be gone when the tab closes");

const tempData = sessionStorage.getItem("tempData");
console.log(tempData); // "This will be gone when the tab closes"

sessionStorage.removeItem("tempData");
sessionStorage.clear();
```

**Characteristics:**
- **Size Limit:** ~5-10MB depending on the browser
- **Expiration:** Session-based (cleared when tab/window is closed)
- **Scope:** Limited to the tab/window where it was created
- **Accessibility:** Synchronous API, available only to JavaScript
- **Storage Type:** Key-value pairs (strings only)

**Use Cases:**
- Form data during multi-step processes
- Temporary application state
- Per-tab user settings
- Wizard-like interfaces

**4. IndexedDB**

**Overview:**
IndexedDB is a low-level API for client-side storage of significant amounts of structured data, including files/blobs.

**Implementation:**
```javascript
// Opening a database
const request = indexedDB.open("MyDatabase", 1);

// Handle database creation/upgrade
request.onupgradeneeded = function(event) {
  const db = event.target.result;
  
  // Create an object store with a key path
  const objectStore = db.createObjectStore("users", { keyPath: "id" });
  
  // Create indexes
  objectStore.createIndex("name", "name", { unique: false });
  objectStore.createIndex("email", "email", { unique: true });
};

// Handle successful database open
request.onsuccess = function(event) {
  const db = event.target.result;
  
  // Add data
  function addUser(user) {
    const transaction = db.transaction(["users"], "readwrite");
    const objectStore = transaction.objectStore("users");
    const request = objectStore.add(user);
    
    request.onsuccess = function() {
      console.log("User added to the database");
    };
    
    transaction.oncomplete = function() {
      console.log("Transaction completed");
    };
    
    transaction.onerror = function(event) {
      console.error("Transaction error:", event.target.error);
    };
  }
  
  // Read data
  function getUserById(id) {
    const transaction = db.transaction(["users"], "readonly");
    const objectStore = transaction.objectStore("users");
    const request = objectStore.get(id);
    
    request.onsuccess = function() {
      if (request.result) {
        console.log("User:", request.result);
      } else {
        console.log("User not found");
      }
    };
  }
  
  // Update data
  function updateUser(user) {
    const transaction = db.transaction(["users"], "readwrite");
    const objectStore = transaction.objectStore("users");
    const request = objectStore.put(user);
    
    request.onsuccess = function() {
      console.log("User updated");
    };
  }
  
  // Delete data
  function deleteUser(id) {
    const transaction = db.transaction(["users"], "readwrite");
    const objectStore = transaction.objectStore("users");
    const request = objectStore.delete(id);
    
    request.onsuccess = function() {
      console.log("User deleted");
    };
  }
  
  // Using indexes
  function getUserByEmail(email) {
    const transaction = db.transaction(["users"], "readonly");
    const objectStore = transaction.objectStore("users");
    const index = objectStore.index("email");
    const request = index.get(email);
    
    request.onsuccess = function() {
      if (request.result) {
        console.log("User found by email:", request.result);
      } else {
        console.log("No user with that email");
      }
    };
  }
  
  // Example usage
  addUser({ id: 1, name: "John Doe", email: "john@example.com", age: 30 });
  getUserById(1);
  updateUser({ id: 1, name: "John Doe", email: "john@example.com", age: 31 });
  getUserByEmail("john@example.com");
  // deleteUser(1);
};

// Handle errors
request.onerror = function(event) {
  console.error("Database error:", event.target.error);
};
```

**Characteristics:**
- **Size Limit:** Generally much larger (50MB+ with user permission)
- **Expiration:** No expiration (persists until explicitly deleted)
- **Scope:** Domain specific (same origin policy)
- **Accessibility:** Asynchronous API
- **Storage Type:** Structured data, including objects and binary data
- **Indexing:** Supports indexes for efficient querying
- **Transactions:** Provides transaction support for data integrity

**Use Cases:**
- Offline applications
- Large datasets
- Complex data structures
- File/blob storage
- Applications requiring data indexing and querying

**5. Cache API**

**Overview:**
The Cache API is part of the Service Worker API and provides a way to cache network requests and responses.

**Implementation:**
```javascript
// In a service worker file
self.addEventListener('install', function(event) {
  event.waitUntil(
    caches.open('v1').then(function(cache) {
      return cache.addAll([
        '/',
        '/index.html',
        '/styles.css',
        '/script.js',
        '/images/logo.png'
      ]);
    })
  );
});

self.addEventListener('fetch', function(event) {
  event.respondWith(
    caches.match(event.request).then(function(response) {
      // Cache hit - return response
      if (response) {
        return response;
      }
      
      // Clone the request
      const fetchRequest = event.request.clone();
      
      return fetch(fetchRequest).then(function(response) {
        // Check if valid response
        if (!response || response.status !== 200 || response.type !== 'basic') {
          return response;
        }
        
        // Clone the response
        const responseToCache = response.clone();
        
        caches.open('v1').then(function(cache) {
          cache.put(event.request, responseToCache);
        });
        
        return response;
      });
    })
  );
});

// Managing caches
self.addEventListener('activate', function(event) {
  const cacheWhitelist = ['v2']; // New cache version
  
  event.waitUntil(
    caches.keys().then(function(cacheNames) {
      return Promise.all(
        cacheNames.map(function(cacheName) {
          if (cacheWhitelist.indexOf(cacheName) === -1) {
            // Delete old caches
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
```

**Characteristics:**
- **Size Limit:** Generally large (limited by available disk space)
- **Expiration:** No built-in expiration (managed by service worker code)
- **Scope:** Available across the entire origin
- **Accessibility:** Asynchronous API, primarily used with Service Workers
- **Storage Type:** HTTP requests and responses

**Use Cases:**
- Offline web applications
- Performance optimization
- Progressive Web Apps (PWAs)
- Resource caching

**6. Web SQL (Deprecated)**

**Overview:**
Web SQL provided a SQL database in the browser, but it's deprecated and should not be used for new projects.

**7. File System Access API (Modern)**

**Overview:**
A newer API that provides access to the user's local file system (with permission).

**Implementation:**
```javascript
// Request access to files
async function getFileHandle() {
  try {
    const fileHandle = await window.showOpenFilePicker();
    return fileHandle[0];
  } catch (error) {
    console.error('Error getting file handle:', error);
  }
}

// Read a file
async function readFile(fileHandle) {
  const file = await fileHandle.getFile();
  const contents = await file.text();
  console.log('File contents:', contents);
  return contents;
}

// Write to a file
async function writeFile(fileHandle, contents) {
  const writable = await fileHandle.createWritable();
  await writable.write(contents);
  await writable.close();
  console.log('File written successfully');
}

// Usage
async function accessAndModifyFile() {
  const fileHandle = await getFileHandle();
  const contents = await readFile(fileHandle);
  const modifiedContents = contents + '\nModified by File System Access API';
  await writeFile(fileHandle, modifiedContents);
}

// Check if the API is supported
if ('showOpenFilePicker' in window) {
  console.log('File System Access API is supported');
} else {
  console.log('File System Access API is not supported in this browser');
}
```

**Characteristics:**
- **Size Limit:** Limited by the user's disk space
- **Expiration:** No expiration (actual files on the user's system)
- **Scope:** User-selected files and directories
- **Accessibility:** Requires explicit user permission
- **Storage Type:** Actual files and directories

**Use Cases:**
- Text editors
- Image editors
- File management applications
- Applications that need to read/write local files

**8. Comparison and Selection Guide**

**Storage Size Comparison:**
- Cookies: ~4KB
- localStorage/sessionStorage: ~5-10MB
- IndexedDB: 50MB+ (varies by browser)
- Cache API: Limited by disk space
- File System Access API: Limited by disk space

**Persistence Comparison:**
- Most Persistent: localStorage, IndexedDB, Cache API
- Session-Based: sessionStorage
- Configurable: Cookies (can set expiration)
- User-Controlled: File System Access API

**Selection Criteria:**

**Choose Cookies when:**
- Data needs to be sent to the server with every request
- You need cross-browser compatibility including older browsers
- Small amounts of data (authentication tokens, user preferences)

**Choose localStorage when:**
- You need simple persistent storage
- You're storing user preferences, settings, or UI state
- You need a simple, synchronous API
- Data is relatively small and doesn't require complex querying

**Choose sessionStorage when:**
- Data should be available only for the current session
- You're implementing per-tab functionality
- You're storing temporary form data or wizard progress

**Choose IndexedDB when:**
- You need to store large amounts of structured data
- You need to perform complex queries on the data
- You're building an offline-capable application
- You need to store binary data or files

**Choose Cache API when:**
- You're building a Progressive Web App
- You need to cache network requests and responses
- You want to provide offline functionality

**Choose File System Access API when:**
- You need direct access to files on the user's system
- You're building a file editor or similar application
- You need to read/write large files efficiently

**9. Security Considerations**

**Data Sensitivity:**
- Never store sensitive information (passwords, personal data, etc.) in client-side storage without encryption
- Be aware that users can view and modify client-side storage

**XSS Vulnerabilities:**
- Client-side storage is vulnerable to cross-site scripting (XSS) attacks
- Use Content Security Policy (CSP) to mitigate XSS risks
- Validate and sanitize data before storing and after retrieving

**Storage Quotas:**
- Be prepared to handle quota exceeded errors
- Implement cleanup strategies for old or unused data

**10. Best Practices**

**Versioning:**
```javascript
// Example of versioned localStorage
const APP_VERSION = '1.2.0';
const storageKey = `userPreferences_${APP_VERSION}`;

// When upgrading, migrate old data
function migrateStorage() {
  const oldKey = `userPreferences_1.1.0`;
  const oldData = localStorage.getItem(oldKey);
  
  if (oldData) {
    const parsedData = JSON.parse(oldData);
    // Transform data if needed for the new version
    localStorage.setItem(storageKey, JSON.stringify(parsedData));
    localStorage.removeItem(oldKey); // Clean up old data
  }
}
```

**Error Handling:**
```javascript
function safelyStoreData(key, data) {
  try {
    localStorage.setItem(key, JSON.stringify(data));
    return true;
  } catch (error) {
    if (error.name === 'QuotaExceededError') {
      console.error('Storage quota exceeded. Clearing some space...');
      // Implement cleanup strategy
      return false;
    }
    console.error('Error storing data:', error);
    return false;
  }
}
```

**Abstraction Layer:**
```javascript
// Storage service abstraction
const StorageService = {
  get(key, defaultValue = null) {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue;
    } catch (error) {
      console.error(`Error getting item ${key}:`, error);
      return defaultValue;
    }
  },
  
  set(key, value) {
    try {
      localStorage.setItem(key, JSON.stringify(value));
      return true;
    } catch (error) {
      console.error(`Error setting item ${key}:`, error);
      return false;
    }
  },
  
  remove(key) {
    try {
      localStorage.removeItem(key);
      return true;
    } catch (error) {
      console.error(`Error removing item ${key}:`, error);
      return false;
    }
  },
  
  clear() {
    try {
      localStorage.clear();
      return true;
    } catch (error) {
      console.error('Error clearing storage:', error);
      return false;
    }
  }
};

// Usage
StorageService.set('user', { name: 'John', role: 'admin' });
const user = StorageService.get('user');
```

**Feature Detection:**
```javascript
function getPreferredStorage() {
  if (window.indexedDB) {
    return 'indexedDB';
  } else if (window.localStorage) {
    return 'localStorage';
  } else if (document.cookie) {
    return 'cookies';
  } else {
    return 'memory'; // Fallback to in-memory storage
  }
}

const storageType = getPreferredStorage();
console.log(`Using ${storageType} for storage`);
```

**Key Takeaways:**

1. Cookies are sent with every HTTP request and are useful for server-side interactions
2. localStorage provides simple persistent storage with a synchronous API
3. sessionStorage is similar to localStorage but limited to the current browser session
4. IndexedDB offers large-scale structured data storage with advanced querying capabilities
5. The Cache API is designed for caching network requests in Progressive Web Apps
6. The File System Access API provides direct access to the user's file system
7. Choose the appropriate storage mechanism based on data size, persistence needs, and complexity
8. Implement proper error handling and versioning for robust client-side storage
9. Consider security implications when storing data on the client side
10. Use abstraction layers to make your storage code more maintainable and adaptable

### Q68: Explain Web Workers in JavaScript and how they enable concurrent programming.
**Difficulty: Hard**

**Answer:**
JavaScript is traditionally single-threaded, which means it can only execute one piece of code at a time. This can lead to performance issues when running computationally intensive tasks, as they block the main thread and can cause the UI to become unresponsive. Web Workers provide a solution by allowing JavaScript to run scripts in background threads, separate from the main execution thread.

**1. Introduction to Web Workers**

**Definition:**
Web Workers are a JavaScript API that allows you to run scripts in background threads. The worker thread can perform tasks without interfering with the user interface or other main thread operations.

**Types of Web Workers:**

- **Dedicated Workers**: Used by a single script instance
- **Shared Workers**: Can be shared between multiple scripts or windows
- **Service Workers**: Act as proxy servers that sit between web applications, the browser, and the network

**Browser Support:**
Web Workers are supported in all modern browsers, including mobile browsers.

**2. Basic Usage of Dedicated Workers**

**Creating a Worker:**

```javascript
// main.js - Main thread code
const myWorker = new Worker('worker.js');

// Send data to the worker
myWorker.postMessage({ command: 'start', data: [1, 2, 3, 4, 5] });

// Receive data from the worker
myWorker.onmessage = function(e) {
  console.log('Result received from worker:', e.data);
};

// Handle errors
myWorker.onerror = function(error) {
  console.error('Worker error:', error.message);
};

// Terminate the worker when done
function stopWorker() {
  myWorker.terminate();
  console.log('Worker terminated');
}
```

```javascript
// worker.js - Worker thread code
self.onmessage = function(e) {
  if (e.data.command === 'start') {
    const result = processData(e.data.data);
    self.postMessage(result);
  }
};

function processData(data) {
  // Perform CPU-intensive calculations
  const result = data.map(x => x * x).reduce((sum, val) => sum + val, 0);
  return result;
}

// Handle errors inside the worker
self.onerror = function(error) {
  console.error('Error in worker:', error.message);
};
```

**3. Communication Patterns**

**Basic Message Passing:**

```javascript
// Main thread
myWorker.postMessage({ action: 'calculate', numbers: [1, 2, 3, 4] });

// Worker thread
self.onmessage = function(e) {
  const { action, numbers } = e.data;
  if (action === 'calculate') {
    const sum = numbers.reduce((acc, val) => acc + val, 0);
    self.postMessage({ result: sum });
  }
};
```

**Structured Cloning:**
When you pass data between the main thread and workers, the data is copied, not shared. This process is called structured cloning.

```javascript
// Main thread
const complexObject = {
  name: 'Complex Data',
  data: new Uint8Array(10),
  date: new Date(),
  innerObj: { x: 1, y: 2 }
};

myWorker.postMessage(complexObject); // The entire object is cloned
```

**Transferable Objects:**
For large data, you can use transferable objects to avoid the cloning overhead.

```javascript
// Main thread
const largeBuffer = new ArrayBuffer(1024 * 1024 * 32); // 32MB buffer

// Fill the buffer with data
const view = new Uint8Array(largeBuffer);
for (let i = 0; i < view.length; i++) {
  view[i] = i % 256;
}

// Transfer ownership of the buffer to the worker (zero-copy)
myWorker.postMessage({ buffer: largeBuffer }, [largeBuffer]);

// After transfer, largeBuffer is neutered in the main thread
console.log(largeBuffer.byteLength); // 0
```

**4. Shared Workers**

Shared Workers allow multiple scripts to share the same worker instance.

```javascript
// In multiple scripts or windows
const sharedWorker = new SharedWorker('shared-worker.js');

// Communication happens through a port object
sharedWorker.port.start();
sharedWorker.port.postMessage('Hello from script A');

sharedWorker.port.onmessage = function(e) {
  console.log('Message received from shared worker:', e.data);
};
```

```javascript
// shared-worker.js
const connections = [];

self.onconnect = function(e) {
  const port = e.ports[0];
  connections.push(port);
  
  port.onmessage = function(e) {
    // Broadcast the message to all connected ports
    connections.forEach(function(connection) {
      connection.postMessage('Broadcast: ' + e.data);
    });
  };
  
  port.start();
};
```

**5. Worker Scope and Limitations**

**Available APIs in Workers:**
Workers have access to a subset of JavaScript features:

- `self` (the global scope)
- Standard JavaScript objects (Array, Object, Math, etc.)
- `XMLHttpRequest` and `fetch`
- `setTimeout`/`setInterval`
- `IndexedDB` and `Cache` API
- Web Crypto API

**Unavailable APIs in Workers:**
Workers cannot access:

- The DOM (document, window, parent)
- `alert()`, `confirm()`, `prompt()`
- `localStorage` and `sessionStorage`
- `console` (in some older browsers)

**Example of Using Available APIs:**

```javascript
// worker.js
self.onmessage = async function(e) {
  if (e.data.action === 'fetchData') {
    try {
      // Workers can use fetch
      const response = await fetch('https://api.example.com/data');
      const data = await response.json();
      
      // Workers can use IndexedDB
      const db = await openDatabase();
      await storeInIndexedDB(db, data);
      
      self.postMessage({ status: 'success', data });
    } catch (error) {
      self.postMessage({ status: 'error', message: error.message });
    }
  }
};

function openDatabase() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('WorkerDB', 1);
    
    request.onupgradeneeded = function(e) {
      const db = e.target.result;
      db.createObjectStore('data', { keyPath: 'id' });
    };
    
    request.onsuccess = function(e) {
      resolve(e.target.result);
    };
    
    request.onerror = function(e) {
      reject(e.target.error);
    };
  });
}

function storeInIndexedDB(db, data) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['data'], 'readwrite');
    const store = transaction.objectStore('data');
    
    const request = store.put({ id: 'apiData', value: data });
    
    request.onsuccess = function() {
      resolve();
    };
    
    request.onerror = function(e) {
      reject(e.target.error);
    };
  });
}
```

**6. Importing Scripts in Workers**

Workers can import additional scripts using `importScripts()`.

```javascript
// worker.js
importScripts('helper1.js', 'helper2.js');

self.onmessage = function(e) {
  // Now we can use functions defined in the imported scripts
  const result = helperFunction(e.data);
  self.postMessage(result);
};
```

**7. Module Workers**

Modern browsers support creating workers with ES modules.

```javascript
// main.js
const worker = new Worker('worker.js', { type: 'module' });
```

```javascript
// worker.js (as a module)
import { processData } from './worker-utils.js';

self.onmessage = function(e) {
  const result = processData(e.data);
  self.postMessage(result);
};
```

**8. Error Handling**

**In the Main Thread:**

```javascript
const worker = new Worker('worker.js');

worker.onerror = function(error) {
  console.error('Error in worker:', error.message);
  console.error('In file:', error.filename);
  console.error('At line:', error.lineno);
};

worker.onmessageerror = function(event) {
  console.error('Message error:', event);
};
```

**In the Worker:**

```javascript
self.onerror = function(error) {
  console.error('Worker internal error:', error.message);
};

try {
  // Risky code
  const result = riskyOperation();
  self.postMessage(result);
} catch (error) {
  self.postMessage({ error: error.message });
}
```

**9. Real-World Use Cases**

**Image Processing:**

```javascript
// main.js
const imageWorker = new Worker('image-processor.js');

function processImage(imageData) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  
  imageWorker.postMessage({
    action: 'applyFilter',
    imageData: imgData,
    filter: 'grayscale'
  }, [imgData.data.buffer]); // Transfer the buffer
}

imageWorker.onmessage = function(e) {
  const resultImageData = e.data.imageData;
  // Display the processed image
  ctx.putImageData(resultImageData, 0, 0);
};
```

```javascript
// image-processor.js
self.onmessage = function(e) {
  if (e.data.action === 'applyFilter') {
    const imageData = e.data.imageData;
    const filter = e.data.filter;
    
    switch (filter) {
      case 'grayscale':
        applyGrayscale(imageData);
        break;
      case 'blur':
        applyBlur(imageData);
        break;
      // Other filters
    }
    
    self.postMessage({ imageData }, [imageData.data.buffer]);
  }
};

function applyGrayscale(imageData) {
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
    data[i] = avg;     // Red
    data[i + 1] = avg; // Green
    data[i + 2] = avg; // Blue
    // data[i + 3] is Alpha (unchanged)
  }
}

function applyBlur(imageData) {
  // Blur algorithm implementation
}
```

**Data Processing and Analytics:**

```javascript
// main.js
const analyticsWorker = new Worker('analytics.js');

function processLargeDataset(dataset) {
  analyticsWorker.postMessage({
    action: 'analyze',
    dataset
  });
  
  // UI remains responsive while processing happens in background
  updateUI('Processing data...');
}

analyticsWorker.onmessage = function(e) {
  const results = e.data;
  displayResults(results);
  updateUI('Processing complete');
};
```

**10. Advanced Patterns**

**Worker Pools:**
Managing multiple workers for parallel processing.

```javascript
class WorkerPool {
  constructor(workerScript, numWorkers = navigator.hardwareConcurrency || 4) {
    this.workers = [];
    this.taskQueue = [];
    this.availableWorkers = [];
    
    // Create workers
    for (let i = 0; i < numWorkers; i++) {
      const worker = new Worker(workerScript);
      
      worker.onmessage = (e) => {
        // Get the task that this worker was processing
        const taskId = worker.currentTaskId;
        const task = this.taskQueue.find(t => t.id === taskId);
        
        if (task && task.resolve) {
          task.resolve(e.data);
        }
        
        // Mark worker as available
        worker.currentTaskId = null;
        this.availableWorkers.push(worker);
        
        // Process next task if any
        this.processQueue();
      };
      
      worker.onerror = (error) => {
        const taskId = worker.currentTaskId;
        const task = this.taskQueue.find(t => t.id === taskId);
        
        if (task && task.reject) {
          task.reject(error);
        }
        
        // Mark worker as available despite error
        worker.currentTaskId = null;
        this.availableWorkers.push(worker);
        
        this.processQueue();
      };
      
      worker.currentTaskId = null;
      this.workers.push(worker);
      this.availableWorkers.push(worker);
    }
  }
  
  processQueue() {
    // If we have available workers and pending tasks
    if (this.availableWorkers.length > 0 && this.taskQueue.length > 0) {
      // Find tasks that aren't being processed yet
      const pendingTasks = this.taskQueue.filter(task => !task.processing);
      
      if (pendingTasks.length > 0) {
        const task = pendingTasks[0];
        task.processing = true;
        
        const worker = this.availableWorkers.pop();
        worker.currentTaskId = task.id;
        
        worker.postMessage(task.data);
      }
    }
  }
  
  addTask(data) {
    return new Promise((resolve, reject) => {
      const taskId = Date.now() + Math.random();
      
      this.taskQueue.push({
        id: taskId,
        data,
        resolve,
        reject,
        processing: false
      });
      
      this.processQueue();
    });
  }
  
  terminate() {
    this.workers.forEach(worker => worker.terminate());
    this.workers = [];
    this.availableWorkers = [];
    
    // Reject any pending tasks
    this.taskQueue.forEach(task => {
      if (task.reject && !task.processing) {
        task.reject(new Error('Worker pool terminated'));
      }
    });
    
    this.taskQueue = [];
  }
}

// Usage
const pool = new WorkerPool('worker.js', 4);

// Add tasks to the pool
Promise.all([
  pool.addTask({ action: 'process', data: [1, 2, 3] }),
  pool.addTask({ action: 'process', data: [4, 5, 6] }),
  pool.addTask({ action: 'process', data: [7, 8, 9] }),
  pool.addTask({ action: 'process', data: [10, 11, 12] }),
  pool.addTask({ action: 'process', data: [13, 14, 15] }),
  pool.addTask({ action: 'process', data: [16, 17, 18] })
]).then(results => {
  console.log('All tasks completed:', results);
  pool.terminate();
}).catch(error => {
  console.error('Error in task:', error);
  pool.terminate();
});
```

**Comlink: Simplifying Worker Communication**

Comlink is a library that makes working with Web Workers feel like direct function calls.

```javascript
// main.js
import * as Comlink from 'https://unpkg.com/comlink/dist/esm/comlink.mjs';

async function init() {
  const worker = new Worker('worker.js');
  const api = Comlink.wrap(worker);
  
  // Call worker functions as if they were local
  const result = await api.processData([1, 2, 3, 4]);
  console.log('Result:', result);
  
  // Call worker class methods
  const processor = await new api.DataProcessor();
  const sum = await processor.sum([5, 6, 7, 8]);
  console.log('Sum:', sum);
}

init();
```

```javascript
// worker.js
importScripts('https://unpkg.com/comlink/dist/umd/comlink.js');

// Functions and classes to expose to the main thread
function processData(data) {
  return data.map(x => x * x);
}

class DataProcessor {
  constructor() {
    this.multiplier = 2;
  }
  
  sum(data) {
    return data.reduce((a, b) => a + b, 0);
  }
  
  multiply(data) {
    return data.map(x => x * this.multiplier);
  }
}

// Expose the API to Comlink
Comlink.expose({
  processData,
  DataProcessor
});
```

**11. Service Workers**

Service Workers are a special type of Web Worker that act as a proxy between web applications, the browser, and the network.

```javascript
// Register a service worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/service-worker.js')
    .then(registration => {
      console.log('Service Worker registered with scope:', registration.scope);
    })
    .catch(error => {
      console.error('Service Worker registration failed:', error);
    });
}
```

```javascript
// service-worker.js
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open('v1').then(cache => {
      return cache.addAll([
        '/',
        '/index.html',
        '/styles.css',
        '/app.js',
        '/offline.html'
      ]);
    })
  );
});

self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(response => {
      return response || fetch(event.request).catch(() => {
        return caches.match('/offline.html');
      });
    })
  );
});
```

**12. Performance Considerations**

**When to Use Web Workers:**

- CPU-intensive tasks (calculations, data processing)
- Parsing large JSON or XML files
- Image or video processing
- Complex data analysis or visualization
- Encryption/decryption
- Compression/decompression

**When Not to Use Web Workers:**

- Simple, quick operations
- DOM manipulation (must be done on the main thread)
- Tasks that require frequent communication with the main thread

**Performance Metrics:**

```javascript
// main.js
const iterations = 10000000;

// Without worker (blocks UI)
function calculateWithoutWorker() {
  const startTime = performance.now();
  let result = 0;
  
  for (let i = 0; i < iterations; i++) {
    result += Math.sqrt(i);
  }
  
  const endTime = performance.now();
  console.log(`Main thread calculation: ${endTime - startTime}ms`);
  console.log('Result:', result);
}

// With worker
function calculateWithWorker() {
  const startTime = performance.now();
  const worker = new Worker('calc-worker.js');
  
  worker.postMessage({ iterations });
  
  worker.onmessage = function(e) {
    const endTime = performance.now();
    console.log(`Worker calculation: ${endTime - startTime}ms`);
    console.log('Result:', e.data);
    worker.terminate();
  };
}

// Compare both approaches
document.getElementById('without-worker').addEventListener('click', calculateWithoutWorker);
document.getElementById('with-worker').addEventListener('click', calculateWithWorker);
```

```javascript
// calc-worker.js
self.onmessage = function(e) {
  const { iterations } = e.data;
  let result = 0;
  
  for (let i = 0; i < iterations; i++) {
    result += Math.sqrt(i);
  }
  
  self.postMessage(result);
};
```

**13. Browser Compatibility and Feature Detection**

```javascript
function initializeWorker() {
  if (typeof Worker !== 'undefined') {
    // Web Workers are supported
    try {
      const worker = new Worker('worker.js');
      return worker;
    } catch (e) {
      console.error('Error creating worker:', e);
      return null;
    }
  } else {
    console.log('Web Workers not supported in this browser');
    return null;
  }
}

function initializeSharedWorker() {
  if (typeof SharedWorker !== 'undefined') {
    // Shared Workers are supported
    try {
      const worker = new SharedWorker('shared-worker.js');
      return worker;
    } catch (e) {
      console.error('Error creating shared worker:', e);
      return null;
    }
  } else {
    console.log('Shared Workers not supported in this browser');
    return null;
  }
}

function checkServiceWorkerSupport() {
  if ('serviceWorker' in navigator) {
    return true;
  } else {
    console.log('Service Workers not supported in this browser');
    return false;
  }
}

function checkWorkerModuleSupport() {
  try {
    const worker = new Worker('test-module.js', { type: 'module' });
    worker.terminate();
    return true;
  } catch (e) {
    console.log('Module Workers not supported in this browser');
    return false;
  }
}
```

**14. Security Considerations**

**Same-Origin Policy:**
Workers are subject to the same-origin policy. A worker must be loaded from the same origin as the script that created it, unless CORS headers are properly set.

**Content Security Policy (CSP):**
Workers are affected by CSP directives, particularly `worker-src` and `script-src`.

```html
<!-- Example CSP header that allows workers -->
<meta http-equiv="Content-Security-Policy" content="worker-src 'self' https://trusted-domain.com; script-src 'self'">
```

**Secure Data Handling:**

```javascript
// Avoid sending sensitive data to workers if not necessary
function processUserData(userData) {
  // Only send necessary data to the worker, not the entire user object
  const workerData = {
    id: userData.id,
    preferences: userData.preferences,
    // Don't send sensitive fields like userData.password, userData.paymentInfo, etc.
  };
  
  myWorker.postMessage(workerData);
}
```

**Key Takeaways:**

1. Web Workers enable concurrent JavaScript execution through background threads
2. They help keep the UI responsive during CPU-intensive tasks
3. Communication between the main thread and workers happens through message passing
4. Workers have limited access to browser APIs and cannot directly manipulate the DOM
5. Transferable objects can be used for efficient data transfer without copying
6. Different types of workers (Dedicated, Shared, Service) serve different purposes
7. Worker pools can be implemented for efficient parallel processing
8. Libraries like Comlink can simplify worker communication
9. Workers are subject to same-origin policy and Content Security Policy
10. Feature detection should be used to ensure compatibility across browsers

## Internationalization and Accessibility

### Q69: Explain JavaScript's Internationalization (i18n) features and best practices.
**Difficulty: Medium**

**Answer:**
Internationalization (i18n) is the process of designing and developing applications that can be adapted to different languages and regions. JavaScript provides robust internationalization capabilities through the ECMAScript Internationalization API (Intl) and various libraries. Understanding these features is crucial for building applications that can reach a global audience.

**1. The Intl Object**

The `Intl` object is the namespace for the ECMAScript Internationalization API, which provides language-sensitive string comparison, number formatting, date and time formatting, and more.

**Basic Structure:**
```javascript
Intl.Constructor(locales, options)
```

- `locales`: String or array of strings with language tags (e.g., 'en-US', 'fr', 'zh-Hans-CN')
- `options`: Object with configuration options specific to each constructor

**2. Number Formatting (Intl.NumberFormat)**

**Basic Usage:**
```javascript
const number = 123456.789;

// US English formatting (default in US browsers)
const usFormatter = new Intl.NumberFormat('en-US');
console.log(usFormatter.format(number)); // "123,456.789"

// German formatting
const deFormatter = new Intl.NumberFormat('de-DE');
console.log(deFormatter.format(number)); // "123.456,789"

// Arabic in Egypt formatting
const arEGFormatter = new Intl.NumberFormat('ar-EG');
console.log(arEGFormatter.format(number)); // "١٢٣٬٤٥٦٫٧٨٩"
```

**Advanced Options:**
```javascript
// Currency formatting
const eurFormatter = new Intl.NumberFormat('de-DE', {
  style: 'currency',
  currency: 'EUR'
});
console.log(eurFormatter.format(number)); // "123.456,79 €"

const jpyFormatter = new Intl.NumberFormat('ja-JP', {
  style: 'currency',
  currency: 'JPY'
});
console.log(jpyFormatter.format(number)); // "￥123,457"

// Percentage formatting
const percentFormatter = new Intl.NumberFormat('en-US', {
  style: 'percent',
  minimumFractionDigits: 1,
  maximumFractionDigits: 2
});
console.log(percentFormatter.format(0.2345)); // "23.5%"

// Unit formatting
const kilometerFormatter = new Intl.NumberFormat('en-US', {
  style: 'unit',
  unit: 'kilometer-per-hour',
  unitDisplay: 'long'
});
console.log(kilometerFormatter.format(50)); // "50 kilometers per hour"

// Notation options
const compactFormatter = new Intl.NumberFormat('en-US', {
  notation: 'compact',
  compactDisplay: 'long'
});
console.log(compactFormatter.format(1000000)); // "1 million"
```

**3. Date and Time Formatting (Intl.DateTimeFormat)**

**Basic Usage:**
```javascript
const date = new Date(Date.UTC(2023, 0, 15, 12, 0, 0));

// US English formatting
const usDateFormatter = new Intl.DateTimeFormat('en-US');
console.log(usDateFormatter.format(date)); // "1/15/2023"

// British English formatting
const gbDateFormatter = new Intl.DateTimeFormat('en-GB');
console.log(gbDateFormatter.format(date)); // "15/01/2023"

// Korean formatting
const koDateFormatter = new Intl.DateTimeFormat('ko-KR');
console.log(koDateFormatter.format(date)); // "2023. 1. 15."
```

**Advanced Options:**
```javascript
// Full date and time
const fullFormatter = new Intl.DateTimeFormat('en-US', {
  dateStyle: 'full',
  timeStyle: 'full',
  timeZone: 'America/New_York'
});
console.log(fullFormatter.format(date)); // "Sunday, January 15, 2023 at 7:00:00 AM Eastern Standard Time"

// Custom format
const customFormatter = new Intl.DateTimeFormat('en-US', {
  weekday: 'long',
  year: 'numeric',
  month: 'long',
  day: 'numeric',
  hour: '2-digit',
  minute: '2-digit',
  timeZone: 'Europe/Paris'
});
console.log(customFormatter.format(date)); // "Sunday, January 15, 2023, 01:00 PM"

// Relative time (e.g., "yesterday", "in 2 days")
const rtf = new Intl.RelativeTimeFormat('en', { numeric: 'auto' });
console.log(rtf.format(-1, 'day')); // "yesterday"
console.log(rtf.format(2, 'day')); // "in 2 days"
console.log(rtf.format(-1, 'week')); // "last week"
```

**4. String Comparison and Sorting (Intl.Collator)**

**Basic Usage:**
```javascript
const names = ['Österreich', 'Andorra', 'Vietnam', 'Zaire', 'España'];

// Default sorting (may not handle special characters correctly)
const defaultSorted = [...names].sort();
console.log(defaultSorted); // ["Andorra", "España", "Vietnam", "Zaire", "Österreich"]

// Using Intl.Collator for language-sensitive sorting
const collator = new Intl.Collator('en');
const intlSorted = [...names].sort((a, b) => collator.compare(a, b));
console.log(intlSorted); // ["Andorra", "España", "Österreich", "Vietnam", "Zaire"]
```

**Advanced Options:**
```javascript
// Case-insensitive sorting
const caseInsensitive = new Intl.Collator('en', { sensitivity: 'base' });
console.log(['a', 'A', 'b', 'B'].sort((a, b) => caseInsensitive.compare(a, b)));
// ["a", "A", "b", "B"]

// Accent-insensitive sorting
const accentInsensitive = new Intl.Collator('en', { sensitivity: 'accent' });
console.log(['á', 'a', 'e', 'é'].sort((a, b) => accentInsensitive.compare(a, b)));
// ["a", "á", "e", "é"]

// Numeric sorting
const withNumbers = ['item1', 'item10', 'item2'];
const numericCollator = new Intl.Collator('en', { numeric: true });
console.log(withNumbers.sort((a, b) => numericCollator.compare(a, b)));
// ["item1", "item2", "item10"]
```

**5. Pluralization and Grammatical Inflection (Intl.PluralRules)**

**Basic Usage:**
```javascript
const pluralRules = new Intl.PluralRules('en-US');

function formatItemCount(count) {
  const rule = pluralRules.select(count);
  switch (rule) {
    case 'one':
      return `${count} item`;
    case 'other':
      return `${count} items`;
  }
}

console.log(formatItemCount(1)); // "1 item"
console.log(formatItemCount(2)); // "2 items"
```

**Advanced Usage with Different Languages:**
```javascript
const arabicPluralRules = new Intl.PluralRules('ar');

function formatArabicItemCount(count) {
  const rule = arabicPluralRules.select(count);
  // Arabic has six plural forms
  switch (rule) {
    case 'zero': return `${count} عنصر (zero)`;
    case 'one': return `${count} عنصر (one)`;
    case 'two': return `${count} عنصران (two)`;
    case 'few': return `${count} عناصر (few)`;
    case 'many': return `${count} عنصرًا (many)`;
    case 'other': return `${count} عنصر (other)`;
  }
}

console.log(formatArabicItemCount(0)); // "0 عنصر (zero)"
console.log(formatArabicItemCount(1)); // "1 عنصر (one)"
console.log(formatArabicItemCount(2)); // "2 عنصران (two)"
console.log(formatArabicItemCount(3)); // "3 عناصر (few)"
console.log(formatArabicItemCount(11)); // "11 عنصرًا (many)"
```

**6. List Formatting (Intl.ListFormat)**

**Basic Usage:**
```javascript
const fruits = ['Apple', 'Orange', 'Banana'];

const listFormatter = new Intl.ListFormat('en', {
  style: 'long',
  type: 'conjunction'
});
console.log(listFormatter.format(fruits)); // "Apple, Orange, and Banana"

const disjunctionFormatter = new Intl.ListFormat('en', {
  style: 'short',
  type: 'disjunction'
});
console.log(disjunctionFormatter.format(fruits)); // "Apple, Orange, or Banana"

const frenchFormatter = new Intl.ListFormat('fr', {
  style: 'long',
  type: 'conjunction'
});
console.log(frenchFormatter.format(fruits)); // "Apple, Orange et Banana"
```

**7. Segment Handling (Intl.Segmenter)**

**Basic Usage:**
```javascript
// Word segmentation
const segmenter = new Intl.Segmenter('en', { granularity: 'word' });
const string = "Hello world! How are you?";
const segments = segmenter.segment(string);

const words = [];
for (const segment of segments) {
  if (segment.isWordLike) {
    words.push(segment.segment);
  }
}
console.log(words); // ["Hello", "world", "How", "are", "you"]

// Sentence segmentation
const sentenceSegmenter = new Intl.Segmenter('en', { granularity: 'sentence' });
const text = "Hello! How are you? I am fine.";
const sentenceSegments = sentenceSegmenter.segment(text);

const sentences = [];
for (const segment of sentenceSegments) {
  sentences.push(segment.segment);
}
console.log(sentences); // ["Hello! ", "How are you? ", "I am fine."]
```

**8. Display Names (Intl.DisplayNames)**

**Basic Usage:**
```javascript
// Language names
const languageNames = new Intl.DisplayNames(['en'], { type: 'language' });
console.log(languageNames.of('fr')); // "French"
console.log(languageNames.of('de')); // "German"
console.log(languageNames.of('zh-Hans')); // "Simplified Chinese"

// Region/country names
const regionNames = new Intl.DisplayNames(['en'], { type: 'region' });
console.log(regionNames.of('US')); // "United States"
console.log(regionNames.of('BR')); // "Brazil"

// Script names
const scriptNames = new Intl.DisplayNames(['en'], { type: 'script' });
console.log(scriptNames.of('Latn')); // "Latin"
console.log(scriptNames.of('Arab')); // "Arabic"

// Currency names
const currencyNames = new Intl.DisplayNames(['en'], { type: 'currency' });
console.log(currencyNames.of('USD')); // "US Dollar"
console.log(currencyNames.of('EUR')); // "Euro"
```

**9. Locale Detection and Negotiation**

**Browser Locale Detection:**
```javascript
// Get user's preferred languages from the browser
const userLanguages = navigator.languages || [navigator.language];
console.log(userLanguages); // e.g., ["en-US", "en"]

// Use the first preferred language for formatting
const formatter = new Intl.DateTimeFormat(userLanguages[0]);
console.log(formatter.format(new Date()));
```

**Locale Negotiation:**
```javascript
// Supported locales in your application
const supportedLocales = ['en-US', 'fr-FR', 'es-ES', 'de-DE'];

// User's preferred locales
const userLocales = navigator.languages || [navigator.language];

// Find the best match
function findBestMatch(userLocales, supportedLocales) {
  // Try to find an exact match
  for (const locale of userLocales) {
    if (supportedLocales.includes(locale)) {
      return locale;
    }
  }
  
  // Try to find a match for the language part
  for (const locale of userLocales) {
    const language = locale.split('-')[0];
    const match = supportedLocales.find(supported => 
      supported.startsWith(language + '-'));
    if (match) {
      return match;
    }
  }
  
  // Default to the first supported locale
  return supportedLocales[0];
}

const bestLocale = findBestMatch(userLocales, supportedLocales);
console.log(`Using locale: ${bestLocale}`);
```

**10. Message Formatting with Libraries**

While the Intl API provides many features, complex message formatting often requires additional libraries like `Intl.MessageFormat` or `format-message`.

**Using format-message:**
```javascript
import formatMessage from 'format-message';

formatMessage.setup({
  locale: 'en',
  translations: {
    en: {
      greeting: 'Hello, {name}!',
      itemCount: '{count, plural, =0{No items} one{# item} other{# items}}',
      updated: '{gender, select, male{He} female{She} other{They}} updated {count, plural, one{# file} other{# files}}'
    },
    fr: {
      greeting: 'Bonjour, {name} !',
      itemCount: '{count, plural, =0{Aucun élément} one{# élément} other{# éléments}}',
      updated: '{gender, select, male{Il a} female{Elle a} other{Ils ont}} mis à jour {count, plural, one{# fichier} other{# fichiers}}'
    }
  }
});

console.log(formatMessage('greeting', { name: 'John' })); // "Hello, John!"
console.log(formatMessage('itemCount', { count: 0 })); // "No items"
console.log(formatMessage('itemCount', { count: 1 })); // "1 item"
console.log(formatMessage('itemCount', { count: 5 })); // "5 items"
console.log(formatMessage('updated', { gender: 'female', count: 3 })); // "She updated 3 files"

// Switch locale
formatMessage.setup({ locale: 'fr' });
console.log(formatMessage('greeting', { name: 'John' })); // "Bonjour, John !"
```

**11. Date-fns with Locales**

```javascript
import { format, formatDistance } from 'date-fns';
import { fr, de, ja } from 'date-fns/locale';

const date = new Date(2023, 0, 15);

// Format with different locales
console.log(format(date, 'PPP', { locale: fr })); // "15 janvier 2023"
console.log(format(date, 'PPP', { locale: de })); // "15. Januar 2023"
console.log(format(date, 'PPP', { locale: ja })); // "2023年1月15日"

// Relative time with different locales
const pastDate = new Date(2023, 0, 10);
console.log(formatDistance(pastDate, date, { locale: fr })); // "il y a 5 jours"
console.log(formatDistance(pastDate, date, { locale: de })); // "vor 5 Tagen"
```

**12. React Internationalization with react-intl**

```jsx
import React from 'react';
import { IntlProvider, FormattedMessage, FormattedNumber, FormattedDate } from 'react-intl';

const messages = {
  en: {
    'app.greeting': 'Welcome, {name}!',
    'app.item_count': 'You have {count, plural, =0{no items} one{# item} other{# items}}.',
    'app.last_login': 'Last login: {lastLogin, date, full}'
  },
  es: {
    'app.greeting': '¡Bienvenido, {name}!',
    'app.item_count': 'Tienes {count, plural, =0{ningún elemento} one{# elemento} other{# elementos}}.',
    'app.last_login': 'Último inicio de sesión: {lastLogin, date, full}'
  }
};

function App() {
  const [locale, setLocale] = React.useState('en');
  
  return (
    <IntlProvider locale={locale} messages={messages[locale]}>
      <div>
        <select value={locale} onChange={e => setLocale(e.target.value)}>
          <option value="en">English</option>
          <option value="es">Español</option>
        </select>
        
        <h1>
          <FormattedMessage id="app.greeting" values={{ name: 'John' }} />
        </h1>
        
        <p>
          <FormattedMessage id="app.item_count" values={{ count: 5 }} />
        </p>
        
        <p>
          <FormattedMessage 
            id="app.last_login" 
            values={{ lastLogin: new Date() }} 
          />
        </p>
        
        <p>
          <FormattedNumber 
            value={1234567.89} 
            style="currency" 
            currency={locale === 'en' ? 'USD' : 'EUR'} 
          />
        </p>
        
        <p>
          <FormattedDate 
            value={new Date()} 
            year="numeric" 
            month="long" 
            day="numeric" 
          />
        </p>
      </div>
    </IntlProvider>
  );
}
```

**13. Vue Internationalization with vue-i18n**

```javascript
import Vue from 'vue';
import VueI18n from 'vue-i18n';

Vue.use(VueI18n);

const i18n = new VueI18n({
  locale: 'en',
  messages: {
    en: {
      greeting: 'Hello, {name}!',
      items: 'You have {count} items | You have {count} item | You have {count} items',
      lastLogin: 'Last login: {date}'
    },
    fr: {
      greeting: 'Bonjour, {name} !',
      items: 'Vous avez {count} éléments | Vous avez {count} élément | Vous avez {count} éléments',
      lastLogin: 'Dernière connexion : {date}'
    }
  },
  numberFormats: {
    en: {
      currency: {
        style: 'currency',
        currency: 'USD'
      }
    },
    fr: {
      currency: {
        style: 'currency',
        currency: 'EUR'
      }
    }
  },
  dateTimeFormats: {
    en: {
      long: {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric'
      }
    },
    fr: {
      long: {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        hour12: false
      }
    }
  }
});

new Vue({
  i18n,
  template: `
    <div>
      <select v-model="$i18n.locale">
        <option value="en">English</option>
        <option value="fr">Français</option>
      </select>
      
      <h1>{{ $t('greeting', { name: 'John' }) }}</h1>
      <p>{{ $tc('items', 5, { count: 5 }) }}</p>
      <p>{{ $t('lastLogin', { date: $d(new Date(), 'long') }) }}</p>
      <p>{{ $n(1234.56, 'currency') }}</p>
    </div>
  `
}).$mount('#app');
```

**14. Angular Internationalization**

**Using Angular's built-in i18n:**

```html
<!-- app.component.html -->
<h1 i18n="@@appTitle">Welcome to My App</h1>
<p i18n="@@itemCount">You have {itemCount, plural, =0 {no items} =1 {one item} other {{{itemCount}} items}}.</p>
<p i18n="@@lastLogin">Last login: {lastLogin, date, medium}</p>
```

**Extracting messages:**
```bash
ng xi18n --output-path src/locale
```

**Translated file (e.g., messages.fr.xlf):**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2">
  <file source-language="en" datatype="plaintext" original="ng2.template">
    <body>
      <trans-unit id="appTitle" datatype="html">
        <source>Welcome to My App</source>
        <target>Bienvenue dans Mon Application</target>
      </trans-unit>
      <trans-unit id="itemCount" datatype="html">
        <source>You have {itemCount, plural, =0 {no items} =1 {one item} other {{{itemCount}} items}}.</source>
        <target>Vous avez {itemCount, plural, =0 {aucun élément} =1 {un élément} other {{{itemCount}} éléments}}.</target>
      </trans-unit>
      <trans-unit id="lastLogin" datatype="html">
        <source>Last login: {lastLogin, date, medium}</source>
        <target>Dernière connexion: {lastLogin, date, medium}</target>
      </trans-unit>
    </body>
  </file>
</xliff>
```

**Building for different locales:**
```bash
ng build --configuration=fr
```

**15. Best Practices for Internationalization**

**1. Separate Text from Code:**
```javascript
// Bad
function showError() {
  alert("An error occurred. Please try again.");
}

// Good
const messages = {
  en: {
    errorMessage: "An error occurred. Please try again."
  },
  fr: {
    errorMessage: "Une erreur s'est produite. Veuillez réessayer."
  }
};

function showError() {
  alert(messages[currentLocale].errorMessage);
}
```

**2. Handle Pluralization Properly:**
```javascript
// Bad
function showItemCount(count) {
  if (count === 1) {
    return `You have ${count} item.`;
  } else {
    return `You have ${count} items.`;
  }
}

// Good
const pluralRules = new Intl.PluralRules(currentLocale);
const itemMessages = {
  en: {
    zero: 'You have no items.',
    one: 'You have 1 item.',
    other: 'You have {0} items.'
  },
  ar: {
    zero: 'ليس لديك أي عناصر.',
    one: 'لديك عنصر واحد.',
    two: 'لديك عنصران.',
    few: 'لديك {0} عناصر.',
    many: 'لديك {0} عنصرًا.',
    other: 'لديك {0} عنصر.'
  }
};

function showItemCount(count) {
  const rule = pluralRules.select(count);
  return itemMessages[currentLocale][rule].replace('{0}', count);
}
```

**3. Consider Text Expansion/Contraction:**
```css
/* Allow for text expansion in UI elements */
.button {
  min-width: 120px; /* Ensure buttons can accommodate longer text */
  padding: 8px 16px;
  white-space: normal; /* Allow text to wrap if needed */
}
```

**4. Handle Right-to-Left (RTL) Languages:**
```html
<!-- Set the document direction based on the language -->
<html lang="ar" dir="rtl">
  <!-- Arabic content -->
</html>
```

```css
/* Use logical properties for RTL support */
.container {
  /* Instead of this */
  margin-left: 10px;
  padding-right: 20px;
  
  /* Use this */
  margin-inline-start: 10px;
  padding-inline-end: 20px;
}
```

**5. Format Dates, Times, and Numbers Using Intl:**
```javascript
function formatDateTime(date, locale) {
  return new Intl.DateTimeFormat(locale, {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric'
  }).format(date);
}

function formatCurrency(amount, locale, currency) {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency: currency
  }).format(amount);
}
```

**6. Implement a Language Switcher:**
```javascript
function setLanguage(locale) {
  // Store the selected locale
  localStorage.setItem('userLocale', locale);
  
  // Update the HTML lang attribute
  document.documentElement.lang = locale;
  
  // Update the HTML dir attribute for RTL languages
  const rtlLanguages = ['ar', 'he', 'fa', 'ur'];
  document.documentElement.dir = rtlLanguages.includes(locale.split('-')[0]) ? 'rtl' : 'ltr';
  
  // Reload translations and update the UI
  loadTranslations(locale).then(updateUI);
}
```

**7. Handle Locale-Specific Formatting in Forms:**
```javascript
// Format and parse dates according to the user's locale
function setupDateInput(inputElement, locale) {
  const formatter = new Intl.DateTimeFormat(locale);
  
  // Format the date when displaying it
  inputElement.addEventListener('blur', () => {
    try {
      const date = new Date(inputElement.value);
      if (!isNaN(date)) {
        inputElement.value = formatter.format(date);
      }
    } catch (e) {
      console.error('Invalid date');
    }
  });
  
  // Parse the formatted date when submitting
  inputElement.form.addEventListener('submit', () => {
    try {
      // This is a simplified example; actual parsing would be more complex
      const parts = formatter.formatToParts(new Date());
      // Use the parts to determine the date format and parse accordingly
    } catch (e) {
      console.error('Error parsing date');
    }
  });
}
```

**8. Test with Pseudo-Localization:**
```javascript
function pseudoLocalize(text) {
  // Simple pseudo-localization: expand text by ~30% and add brackets
  return `[${text.replace(/[A-Za-z]/g, char => {
    // Replace with accented characters
    const accented = 'ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿ';
    const normal = 'AAAAAAAECEEEEIIIIDNOOOOOOUUUUYPBaaaaaaaeceeeeiiiidnoooooouuuuypy';
    const index = normal.indexOf(char);
    return index >= 0 ? accented[index] : char;
  })}]`;
}

// Example usage
const pseudoMessages = {};
Object.keys(messages.en).forEach(key => {
  pseudoMessages[key] = pseudoLocalize(messages.en[key]);
});

// Add pseudo-locale for testing
messages['en-XA'] = pseudoMessages;
```

**9. Implement Fallback Chains:**
```javascript
function getMessage(key, locale) {
  // Try the exact locale
  if (messages[locale] && messages[locale][key]) {
    return messages[locale][key];
  }
  
  // Try the language part only
  const language = locale.split('-')[0];
  if (locale !== language && messages[language] && messages[language][key]) {
    return messages[language][key];
  }
  
  // Fall back to English
  if (messages['en'] && messages['en'][key]) {
    return messages['en'][key];
  }
  
  // Last resort: return the key itself
  console.warn(`Missing translation for key: ${key}`);
  return key;
}
```

**10. Lazy-Load Translations:**
```javascript
const loadedLocales = new Set(['en']); // Default locale is pre-loaded

async function loadLocale(locale) {
  if (loadedLocales.has(locale)) {
    return; // Already loaded
  }
  
  try {
    const response = await fetch(`/locales/${locale}.json`);
    const translations = await response.json();
    
    // Add translations to the messages object
    messages[locale] = translations;
    loadedLocales.add(locale);
    
    console.log(`Loaded translations for ${locale}`);
  } catch (error) {
    console.error(`Failed to load translations for ${locale}:`, error);
  }
}

async function setLanguage(locale) {
  await loadLocale(locale);
  currentLocale = locale;
  updateUI();
}
```

**Key Takeaways:**

1. The `Intl` object provides powerful built-in internationalization capabilities in JavaScript
2. Use `Intl.NumberFormat` for formatting numbers, currencies, and percentages
3. Use `Intl.DateTimeFormat` for formatting dates and times according to locale conventions
4. Use `Intl.Collator` for language-sensitive string comparison and sorting
5. Use `Intl.PluralRules` for handling grammatical pluralization rules across languages
6. Consider specialized libraries for complex message formatting needs
7. Separate translatable text from your code to facilitate localization
8. Handle RTL languages and text expansion/contraction in your UI design
9. Implement proper locale detection and fallback mechanisms
10. Test your internationalized application with various locales and pseudo-localization

### Q70: Explain JavaScript's role in web accessibility (a11y) and best practices for creating accessible web applications.
**Difficulty: Medium**

**Answer:**
Web accessibility (often abbreviated as a11y, where "11" represents the number of letters between 'a' and 'y' in "accessibility") refers to the practice of making websites usable by as many people as possible, including those with disabilities. JavaScript plays a crucial role in implementing accessible web applications, as it can both enhance and hinder accessibility depending on how it's used.

**1. Understanding Web Accessibility**

**Why Accessibility Matters:**
- **Legal requirements**: Many countries have laws requiring digital accessibility (e.g., ADA in the US, EAA in Europe)
- **Larger audience**: Approximately 15% of the world's population lives with some form of disability
- **Better UX for everyone**: Accessibility improvements often benefit all users
- **SEO benefits**: Many accessibility practices improve search engine optimization

**WCAG (Web Content Accessibility Guidelines):**
The industry standard for web accessibility is WCAG, which is organized around four principles (POUR):
- **Perceivable**: Information must be presentable to users in ways they can perceive
- **Operable**: User interface components must be operable
- **Understandable**: Information and operation must be understandable
- **Robust**: Content must be robust enough to be interpreted by a variety of user agents, including assistive technologies

**2. JavaScript's Role in Accessibility**

**Enhancing Accessibility with JavaScript:**

```javascript
// Example: Adding keyboard navigation to a custom dropdown
const dropdown = document.querySelector('.custom-dropdown');
const dropdownToggle = dropdown.querySelector('.dropdown-toggle');
const dropdownMenu = dropdown.querySelector('.dropdown-menu');
const dropdownItems = dropdown.querySelectorAll('.dropdown-item');

// Make dropdown accessible via keyboard
dropdownToggle.addEventListener('keydown', (e) => {
  // Open dropdown on Enter or Space
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    dropdownMenu.classList.toggle('show');
    
    if (dropdownMenu.classList.contains('show')) {
      // Focus the first item when opened
      dropdownItems[0].focus();
    }
  }
});

// Allow navigation between dropdown items
dropdownItems.forEach((item, index) => {
  item.addEventListener('keydown', (e) => {
    let targetItem;
    
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        targetItem = index < dropdownItems.length - 1 ? 
          dropdownItems[index + 1] : dropdownItems[0];
        targetItem.focus();
        break;
        
      case 'ArrowUp':
        e.preventDefault();
        targetItem = index > 0 ? 
          dropdownItems[index - 1] : dropdownItems[dropdownItems.length - 1];
        targetItem.focus();
        break;
        
      case 'Escape':
        e.preventDefault();
        dropdownMenu.classList.remove('show');
        dropdownToggle.focus();
        break;
        
      case 'Enter':
      case ' ':
        e.preventDefault();
        item.click();
        dropdownMenu.classList.remove('show');
        dropdownToggle.focus();
        break;
    }
  });
});

// Close dropdown when focus moves outside
document.addEventListener('click', (e) => {
  if (!dropdown.contains(e.target)) {
    dropdownMenu.classList.remove('show');
  }
});
```

**Common Accessibility Issues with JavaScript:**

1. **Keyboard Traps**: When JavaScript prevents users from navigating away from an element using the keyboard

```javascript
// Bad practice: Keyboard trap
input.addEventListener('keydown', (e) => {
  // This prevents all keyboard navigation
  e.preventDefault();
});

// Good practice: Only prevent default for specific keys when necessary
input.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !isValid(input.value)) {
    e.preventDefault();
    showError('Please enter a valid value');
  }
});
```

2. **Removing Focus Indicators**: Disabling focus outlines without alternatives

```css
/* Bad practice */
:focus {
  outline: none; /* Removes all focus indicators */
}

/* Good practice */
:focus {
  outline: 2px solid #4d90fe;
  outline-offset: 2px;
}

/* Alternative: Custom focus styles */
:focus:not(:focus-visible) {
  outline: none;
}

:focus-visible {
  outline: 2px solid #4d90fe;
  outline-offset: 2px;
}
```

3. **Dynamic Content Changes Without Notification**: When JavaScript updates content without informing screen reader users

```javascript
// Bad practice
function updateResults(data) {
  resultsContainer.innerHTML = renderResults(data);
}

// Good practice
function updateResults(data) {
  resultsContainer.innerHTML = renderResults(data);
  
  // Announce the update to screen readers
  const liveRegion = document.getElementById('results-live-region');
  liveRegion.textContent = `${data.length} results found`;
}

// HTML includes:
// <div id="results-live-region" class="sr-only" aria-live="polite"></div>
```

**3. ARIA (Accessible Rich Internet Applications)**

ARIA is a set of attributes that define ways to make web content and applications more accessible. JavaScript is often used to manage ARIA states and properties.

**Common ARIA Attributes:**

```html
<!-- Example: Accessible modal dialog -->
<div id="modal" 
     role="dialog" 
     aria-labelledby="modal-title" 
     aria-describedby="modal-description"
     aria-modal="true">
  <h2 id="modal-title">Confirmation</h2>
  <p id="modal-description">Are you sure you want to delete this item?</p>
  <button id="confirm-btn">Yes, delete</button>
  <button id="cancel-btn">Cancel</button>
</div>
```

```javascript
// JavaScript to manage the modal's accessibility
const modal = document.getElementById('modal');
const openBtn = document.getElementById('open-modal-btn');
const confirmBtn = document.getElementById('confirm-btn');
const cancelBtn = document.getElementById('cancel-btn');
let previouslyFocusedElement;

function openModal() {
  // Store the element that had focus before opening the modal
  previouslyFocusedElement = document.activeElement;
  
  // Show the modal
  modal.style.display = 'block';
  
  // Set focus to the first focusable element in the modal
  confirmBtn.focus();
  
  // Trap focus inside the modal
  modal.addEventListener('keydown', trapFocus);
}

function closeModal() {
  // Hide the modal
  modal.style.display = 'none';
  
  // Restore focus to the element that had it before the modal was opened
  if (previouslyFocusedElement) {
    previouslyFocusedElement.focus();
  }
  
  // Remove the focus trap
  modal.removeEventListener('keydown', trapFocus);
}

function trapFocus(e) {
  // Get all focusable elements in the modal
  const focusableElements = modal.querySelectorAll(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  );
  const firstElement = focusableElements[0];
  const lastElement = focusableElements[focusableElements.length - 1];
  
  // Handle Tab and Shift+Tab to trap focus
  if (e.key === 'Tab') {
    if (e.shiftKey) {
      // If Shift+Tab and focus is on first element, move to last element
      if (document.activeElement === firstElement) {
        e.preventDefault();
        lastElement.focus();
      }
    } else {
      // If Tab and focus is on last element, move to first element
      if (document.activeElement === lastElement) {
        e.preventDefault();
        firstElement.focus();
      }
    }
  }
  
  // Close modal on Escape key
  if (e.key === 'Escape') {
    closeModal();
  }
}

// Event listeners
openBtn.addEventListener('click', openModal);
confirmBtn.addEventListener('click', () => {
  // Handle confirmation
  closeModal();
});
cancelBtn.addEventListener('click', closeModal);
```

**4. Managing Focus**

Proper focus management is crucial for keyboard accessibility, especially in SPAs (Single Page Applications).

**Focus Management in SPAs:**

```javascript
// Example: Focus management in a React-like SPA router
function navigateTo(route) {
  // Update the UI based on the route
  updateUI(route);
  
  // Set focus to the main content area
  const mainContent = document.getElementById('main-content');
  
  // Set tabindex to make it focusable, focus it, then remove tabindex
  mainContent.setAttribute('tabindex', '-1');
  mainContent.focus();
  mainContent.removeAttribute('tabindex');
  
  // Announce page change to screen readers
  const pageTitle = document.title;
  const announcer = document.getElementById('route-announcer');
  announcer.textContent = `Navigated to ${pageTitle}`;
}

// HTML includes:
// <div id="route-announcer" class="sr-only" aria-live="assertive"></div>
// <main id="main-content">...</main>
```

**Skip Links:**

```html
<!-- Skip link for keyboard users to bypass navigation -->
<a href="#main-content" class="skip-link">Skip to main content</a>

<!-- Navigation menu -->
<nav>...</nav>

<!-- Main content with ID that matches the skip link's href -->
<main id="main-content">...</main>
```

```css
.skip-link {
  position: absolute;
  top: -40px;
  left: 0;
  padding: 8px;
  background-color: #fff;
  z-index: 100;
  transition: top 0.2s;
}

.skip-link:focus {
  top: 0;
}
```

**5. Accessible Forms**

Forms are a common area where JavaScript is used to enhance functionality, and they require special attention for accessibility.

**Form Validation:**

```javascript
const form = document.querySelector('form');
const emailInput = document.getElementById('email');
const emailError = document.getElementById('email-error');

emailInput.addEventListener('input', validateEmail);
form.addEventListener('submit', handleSubmit);

function validateEmail() {
  const email = emailInput.value;
  const isValid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  
  if (!isValid && email !== '') {
    // Set aria-invalid to true
    emailInput.setAttribute('aria-invalid', 'true');
    
    // Update the error message
    emailError.textContent = 'Please enter a valid email address';
    
    // Associate the error message with the input
    emailInput.setAttribute('aria-describedby', 'email-error');
    
    // Make the error visible
    emailError.classList.remove('hidden');
  } else {
    // Reset to valid state
    emailInput.removeAttribute('aria-invalid');
    emailError.classList.add('hidden');
  }
}

function handleSubmit(e) {
  const email = emailInput.value;
  const isValid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  
  if (!isValid) {
    e.preventDefault();
    validateEmail();
    
    // Focus the first invalid field
    emailInput.focus();
    
    // Announce error to screen readers
    const formError = document.getElementById('form-error');
    formError.textContent = 'Form submission failed. Please check the errors above.';
  }
}
```

```html
<form>
  <div>
    <label for="email">Email address</label>
    <input type="email" id="email" name="email" required>
    <div id="email-error" class="error hidden" aria-live="polite"></div>
  </div>
  
  <div id="form-error" class="sr-only" aria-live="assertive"></div>
  
  <button type="submit">Submit</button>
</form>
```

**Custom Form Controls:**

```javascript
// Example: Accessible custom select dropdown
class AccessibleSelect {
  constructor(element) {
    this.element = element;
    this.button = element.querySelector('.select-button');
    this.listbox = element.querySelector('.select-listbox');
    this.options = element.querySelectorAll('.select-option');
    this.selectedIndex = -1;
    
    this.init();
  }
  
  init() {
    // Set initial ARIA attributes
    this.button.setAttribute('aria-haspopup', 'listbox');
    this.button.setAttribute('aria-expanded', 'false');
    this.listbox.setAttribute('role', 'listbox');
    
    // Set up options
    this.options.forEach((option, index) => {
      option.setAttribute('role', 'option');
      option.setAttribute('tabindex', '-1');
      option.id = `option-${index}`;
      
      option.addEventListener('click', () => {
        this.selectOption(index);
        this.closeListbox();
      });
      
      option.addEventListener('keydown', (e) => {
        switch (e.key) {
          case 'Enter':
          case ' ':
            e.preventDefault();
            this.selectOption(index);
            this.closeListbox();
            break;
          case 'Escape':
            this.closeListbox();
            this.button.focus();
            break;
          case 'ArrowUp':
            e.preventDefault();
            this.focusOption(index - 1);
            break;
          case 'ArrowDown':
            e.preventDefault();
            this.focusOption(index + 1);
            break;
          case 'Home':
            e.preventDefault();
            this.focusOption(0);
            break;
          case 'End':
            e.preventDefault();
            this.focusOption(this.options.length - 1);
            break;
        }
      });
    });
    
    // Button events
    this.button.addEventListener('click', () => {
      if (this.listbox.classList.contains('hidden')) {
        this.openListbox();
      } else {
        this.closeListbox();
      }
    });
    
    this.button.addEventListener('keydown', (e) => {
      switch (e.key) {
        case 'Enter':
        case ' ':
        case 'ArrowDown':
          e.preventDefault();
          this.openListbox();
          if (this.selectedIndex >= 0) {
            this.focusOption(this.selectedIndex);
          } else {
            this.focusOption(0);
          }
          break;
        case 'ArrowUp':
          e.preventDefault();
          this.openListbox();
          if (this.selectedIndex >= 0) {
            this.focusOption(this.selectedIndex);
          } else {
            this.focusOption(this.options.length - 1);
          }
          break;
      }
    });
    
    // Close when clicking outside
    document.addEventListener('click', (e) => {
      if (!this.element.contains(e.target)) {
        this.closeListbox();
      }
    });
    
    // Select first option by default if none selected
    if (this.selectedIndex === -1 && this.options.length > 0) {
      this.selectOption(0, false);
    }
  }
  
  openListbox() {
    this.listbox.classList.remove('hidden');
    this.button.setAttribute('aria-expanded', 'true');
  }
  
  closeListbox() {
    this.listbox.classList.add('hidden');
    this.button.setAttribute('aria-expanded', 'false');
  }
  
  focusOption(index) {
    // Ensure index is within bounds
    if (index < 0) {
      index = 0;
    } else if (index >= this.options.length) {
      index = this.options.length - 1;
    }
    
    this.options[index].focus();
  }
  
  selectOption(index, focus = true) {
    // Remove selection from previously selected option
    if (this.selectedIndex >= 0) {
      this.options[this.selectedIndex].setAttribute('aria-selected', 'false');
      this.options[this.selectedIndex].classList.remove('selected');
    }
    
    // Set new selection
    this.selectedIndex = index;
    this.options[index].setAttribute('aria-selected', 'true');
    this.options[index].classList.add('selected');
    
    // Update button text
    this.button.textContent = this.options[index].textContent;
    this.button.setAttribute('aria-activedescendant', `option-${index}`);
    
    // Focus the button if requested
    if (focus) {
      this.button.focus();
    }
    
    // Dispatch change event
    const event = new Event('change');
    this.element.dispatchEvent(event);
  }
}

// Initialize all custom selects
document.querySelectorAll('.custom-select').forEach(select => {
  new AccessibleSelect(select);
});
```

```html
<div class="custom-select">
  <button class="select-button" type="button">Select an option</button>
  <ul class="select-listbox hidden">
    <li class="select-option">Option 1</li>
    <li class="select-option">Option 2</li>
    <li class="select-option">Option 3</li>
  </ul>
</div>
```

**6. Accessible Rich Text Editors**

Rich text editors are complex components that require careful accessibility implementation.

```javascript
// Simplified example of an accessible rich text editor
class AccessibleEditor {
  constructor(container) {
    this.container = container;
    this.toolbar = container.querySelector('.editor-toolbar');
    this.buttons = this.toolbar.querySelectorAll('button');
    this.editorArea = container.querySelector('.editor-content');
    
    this.init();
  }
  
  init() {
    // Make the editor area editable
    this.editorArea.setAttribute('contenteditable', 'true');
    this.editorArea.setAttribute('role', 'textbox');
    this.editorArea.setAttribute('aria-multiline', 'true');
    
    // Set up toolbar buttons
    this.buttons.forEach(button => {
      const action = button.dataset.action;
      const label = button.getAttribute('aria-label') || button.textContent;
      
      button.addEventListener('click', () => {
        this.executeAction(action);
        this.announceAction(label);
      });
    });
    
    // Keyboard shortcuts
    this.editorArea.addEventListener('keydown', (e) => {
      // Example: Ctrl+B for bold
      if (e.ctrlKey && e.key === 'b') {
        e.preventDefault();
        this.executeAction('bold');
        this.announceAction('Bold');
      }
    });
  }
  
  executeAction(action) {
    // Execute the command
    switch (action) {
      case 'bold':
        document.execCommand('bold', false, null);
        break;
      case 'italic':
        document.execCommand('italic', false, null);
        break;
      case 'link':
        const url = prompt('Enter URL:');
        if (url) {
          document.execCommand('createLink', false, url);
        }
        break;
      // Add more actions as needed
    }
    
    // Return focus to the editor
    this.editorArea.focus();
  }
  
  announceAction(action) {
    // Announce the action to screen readers
    const announcer = this.container.querySelector('.editor-announcer');
    announcer.textContent = `${action} applied`;
  }
}

// Initialize the editor
const editorContainer = document.querySelector('.accessible-editor');
const editor = new AccessibleEditor(editorContainer);
```

```html
<div class="accessible-editor">
  <div class="editor-toolbar" role="toolbar" aria-label="Formatting options">
    <button type="button" data-action="bold" aria-label="Bold">
      <i class="icon-bold"></i>
    </button>
    <button type="button" data-action="italic" aria-label="Italic">
      <i class="icon-italic"></i>
    </button>
    <button type="button" data-action="link" aria-label="Insert link">
      <i class="icon-link"></i>
    </button>
  </div>
  
  <div class="editor-content" aria-label="Text editor"></div>
  
  <div class="editor-announcer sr-only" aria-live="polite"></div>
</div>
```

**7. Accessible Drag and Drop**

Drag and drop interfaces need keyboard alternatives for accessibility.

```javascript
// Simplified accessible drag and drop
class AccessibleDragDrop {
  constructor(container) {
    this.container = container;
    this.items = container.querySelectorAll('.draggable-item');
    this.dropzones = container.querySelectorAll('.dropzone');
    this.draggedItem = null;
    this.announcer = container.querySelector('.drag-drop-announcer');
    
    this.init();
  }
  
  init() {
    // Set up draggable items
    this.items.forEach((item, index) => {
      // Make items focusable
      item.setAttribute('tabindex', '0');
      
      // Set ARIA attributes
      item.setAttribute('role', 'button');
      item.setAttribute('aria-grabbed', 'false');
      item.setAttribute('aria-dropeffect', 'move');
      item.setAttribute('aria-describedby', 'drag-instructions');
      
      // Mouse events
      item.addEventListener('dragstart', (e) => {
        this.draggedItem = item;
        item.setAttribute('aria-grabbed', 'true');
        e.dataTransfer.setData('text/plain', index.toString());
        this.announce(`Grabbed ${item.textContent}`);
      });
      
      item.addEventListener('dragend', () => {
        item.setAttribute('aria-grabbed', 'false');
        this.draggedItem = null;
      });
      
      // Keyboard events
      item.addEventListener('keydown', (e) => {
        switch (e.key) {
          case ' ':
          case 'Enter':
            e.preventDefault();
            
            // Toggle selection
            const isGrabbed = item.getAttribute('aria-grabbed') === 'true';
            
            // Deselect any previously selected item
            this.items.forEach(i => {
              i.setAttribute('aria-grabbed', 'false');
            });
            
            if (!isGrabbed) {
              item.setAttribute('aria-grabbed', 'true');
              this.draggedItem = item;
              this.announce(`Grabbed ${item.textContent}. Use arrow keys to move, and Enter to drop.`);
            } else {
              this.draggedItem = null;
              this.announce(`Released ${item.textContent}`);
            }
            break;
            
          case 'ArrowUp':
          case 'ArrowDown':
          case 'ArrowLeft':
          case 'ArrowRight':
            if (this.draggedItem === item) {
              e.preventDefault();
              this.moveWithKeyboard(e.key);
            }
            break;
        }
      });
    });
    
    // Set up dropzones
    this.dropzones.forEach((zone, index) => {
      zone.setAttribute('role', 'region');
      zone.setAttribute('aria-label', `Drop zone ${index + 1}`);
      
      zone.addEventListener('dragover', (e) => {
        e.preventDefault();
        zone.classList.add('dragover');
      });
      
      zone.addEventListener('dragleave', () => {
        zone.classList.remove('dragover');
      });
      
      zone.addEventListener('drop', (e) => {
        e.preventDefault();
        zone.classList.remove('dragover');
        
        if (this.draggedItem) {
          zone.appendChild(this.draggedItem);
          this.announce(`Dropped ${this.draggedItem.textContent} into drop zone ${index + 1}`);
        }
      });
    });
  }
  
  moveWithKeyboard(key) {
    if (!this.draggedItem) return;
    
    // Find the nearest dropzone in the direction of the arrow key
    const itemRect = this.draggedItem.getBoundingClientRect();
    const itemCenter = {
      x: itemRect.left + itemRect.width / 2,
      y: itemRect.top + itemRect.height / 2
    };
    
    let closestZone = null;
    let closestDistance = Infinity;
    
    this.dropzones.forEach((zone, index) => {
      const zoneRect = zone.getBoundingClientRect();
      const zoneCenter = {
        x: zoneRect.left + zoneRect.width / 2,
        y: zoneRect.top + zoneRect.height / 2
      };
      
      // Check if the zone is in the direction of the key press
      let isInDirection = false;
      
      switch (key) {
        case 'ArrowUp':
          isInDirection = zoneCenter.y < itemCenter.y;
          break;
        case 'ArrowDown':
          isInDirection = zoneCenter.y > itemCenter.y;
          break;
        case 'ArrowLeft':
          isInDirection = zoneCenter.x < itemCenter.x;
          break;
        case 'ArrowRight':
          isInDirection = zoneCenter.x > itemCenter.x;
          break;
      }
      
      if (isInDirection) {
        // Calculate distance
        const distance = Math.sqrt(
          Math.pow(zoneCenter.x - itemCenter.x, 2) +
          Math.pow(zoneCenter.y - itemCenter.y, 2)
        );
        
        if (distance < closestDistance) {
          closestDistance = distance;
          closestZone = zone;
        }
      }
    });
    
    // Move the item to the closest zone
    if (closestZone) {
      closestZone.appendChild(this.draggedItem);
      this.announce(`Moved ${this.draggedItem.textContent} to ${closestZone.getAttribute('aria-label')}`);
      this.draggedItem.focus();
    }
  }
  
  announce(message) {
    this.announcer.textContent = message;
  }
}

// Initialize drag and drop
const dragDropContainer = document.querySelector('.drag-drop-container');
const dragDrop = new AccessibleDragDrop(dragDropContainer);
```

```html
<div class="drag-drop-container">
  <p id="drag-instructions" class="sr-only">
    Press Space or Enter to grab or release an item. When grabbed, use arrow keys to move to a drop zone.
  </p>
  
  <div class="items-container">
    <div class="draggable-item" draggable="true">Item 1</div>
    <div class="draggable-item" draggable="true">Item 2</div>
    <div class="draggable-item" draggable="true">Item 3</div>
  </div>
  
  <div class="dropzones-container">
    <div class="dropzone">Zone 1</div>
    <div class="dropzone">Zone 2</div>
  </div>
  
  <div class="drag-drop-announcer sr-only" aria-live="assertive"></div>
</div>
```

**8. Accessible Notifications and Alerts**

Notifications need to be accessible to all users, including those using screen readers.

```javascript
// Accessible notification system
class AccessibleNotifications {
  constructor() {
    this.container = document.getElementById('notifications-container');
    this.liveRegion = document.getElementById('notifications-live');
    this.notificationCount = 0;
  }
  
  notify(message, type = 'info', autoHide = true) {
    const id = `notification-${++this.notificationCount}`;
    
    // Create notification element
    const notification = document.createElement('div');
    notification.id = id;
    notification.className = `notification notification-${type}`;
    notification.setAttribute('role', 'alert'); // For immediate announcement
    
    // Add close button
    const closeButton = document.createElement('button');
    closeButton.className = 'notification-close';
    closeButton.setAttribute('aria-label', 'Dismiss notification');
    closeButton.innerHTML = '&times;';
    closeButton.addEventListener('click', () => this.remove(id));
    
    // Add message
    const messageElement = document.createElement('div');
    messageElement.className = 'notification-message';
    messageElement.textContent = message;
    
    // Assemble notification
    notification.appendChild(messageElement);
    notification.appendChild(closeButton);
    
    // Add to container
    this.container.appendChild(notification);
    
    // Announce to screen readers
    this.liveRegion.textContent = `${type} notification: ${message}`;
    
    // Auto-hide if enabled
    if (autoHide) {
      setTimeout(() => {
        this.remove(id);
      }, 5000);
    }
    
    return id;
  }
  
  remove(id) {
    const notification = document.getElementById(id);
    if (notification) {
      // Add exit animation
      notification.classList.add('notification-hiding');
      
      // Remove after animation
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }
  }
}

// Initialize notifications
const notifications = new AccessibleNotifications();

// Example usage
document.getElementById('show-info').addEventListener('click', () => {
  notifications.notify('Your profile has been updated successfully.', 'info');
});

document.getElementById('show-error').addEventListener('click', () => {
  notifications.notify('An error occurred while saving your data.', 'error', false);
});
```

```html
<div id="notifications-container" class="notifications-container"></div>
<div id="notifications-live" class="sr-only" aria-live="assertive"></div>

<button id="show-info">Show Info Notification</button>
<button id="show-error">Show Error Notification</button>
```

**9. Testing for Accessibility**

JavaScript can be used to implement automated accessibility testing.

```javascript
// Simple accessibility checker
class AccessibilityChecker {
  constructor() {
    this.issues = [];
  }
  
  checkPage() {
    this.issues = [];
    
    this.checkImages();
    this.checkHeadings();
    this.checkForms();
    this.checkARIA();
    this.checkKeyboardFocus();
    
    return this.issues;
  }
  
  addIssue(element, issue, severity) {
    this.issues.push({
      element,
      issue,
      severity
    });
  }
  
  checkImages() {
    const images = document.querySelectorAll('img');
    
    images.forEach(img => {
      if (!img.hasAttribute('alt')) {
        this.addIssue(img, 'Image missing alt attribute', 'error');
      } else if (img.alt === '' && !img.hasAttribute('role') && !img.hasAttribute('aria-label')) {
        // Empty alt is fine for decorative images, but they should have role="presentation"
        this.addIssue(img, 'Decorative image should have role="presentation" or role="none"', 'warning');
      }
    });
  }
  
  checkHeadings() {
    const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    let previousLevel = 0;
    
    headings.forEach(heading => {
      const level = parseInt(heading.tagName.substring(1));
      
      if (level - previousLevel > 1) {
        this.addIssue(heading, `Heading level skipped from h${previousLevel} to h${level}`, 'warning');
      }
      
      previousLevel = level;
    });
    
    // Check for missing main heading
    if (!document.querySelector('h1')) {
      this.addIssue(document.body, 'Page is missing an h1 heading', 'error');
    }
  }
  
  checkForms() {
    const inputs = document.querySelectorAll('input, select, textarea');
    
    inputs.forEach(input => {
      // Skip hidden inputs
      if (input.type === 'hidden') return;
      
      // Check for associated labels
      const id = input.id;
      if (!id) {
        this.addIssue(input, 'Form control missing ID attribute', 'error');
      } else {
        const label = document.querySelector(`label[for="${id}"]`);
        if (!label) {
          // Check for aria-label or aria-labelledby as alternatives
          if (!input.hasAttribute('aria-label') && !input.hasAttribute('aria-labelledby')) {
            this.addIssue(input, 'Form control missing associated label', 'error');
          }
        }
      }
      
      // Check for error handling
      if (input.hasAttribute('aria-invalid') && input.getAttribute('aria-invalid') === 'true') {
        if (!input.hasAttribute('aria-describedby')) {
          this.addIssue(input, 'Invalid form control missing error description', 'error');
        }
      }
    });
  }
  
  checkARIA() {
    // Check for invalid ARIA roles
    const elementsWithRole = document.querySelectorAll('[role]');
    
    elementsWithRole.forEach(element => {
      const role = element.getAttribute('role');
      
      // This is a simplified check - a real checker would have a complete list of valid roles
      const validRoles = [
        'alert', 'alertdialog', 'application', 'article', 'banner', 'button', 'cell',
        'checkbox', 'columnheader', 'combobox', 'complementary', 'contentinfo', 'definition',
        'dialog', 'directory', 'document', 'feed', 'figure', 'form', 'grid', 'gridcell',
        'group', 'heading', 'img', 'link', 'list', 'listbox', 'listitem', 'log', 'main',
        'marquee', 'math', 'menu', 'menubar', 'menuitem', 'menuitemcheckbox', 'menuitemradio',
        'navigation', 'none', 'note', 'option', 'presentation', 'progressbar', 'radio',
        'radiogroup', 'region', 'row', 'rowgroup', 'rowheader', 'scrollbar', 'search',
        'searchbox', 'separator', 'slider', 'spinbutton', 'status', 'switch', 'tab',
        'table', 'tablist', 'tabpanel', 'term', 'textbox', 'timer', 'toolbar',
        'tooltip', 'tree', 'treegrid', 'treeitem'
      ];
      
      if (!validRoles.includes(role)) {
        this.addIssue(element, `Invalid ARIA role: ${role}`, 'error');
      }
      
      // Check for required attributes based on role
      if (role === 'checkbox' || role === 'switch') {
        if (!element.hasAttribute('aria-checked')) {
          this.addIssue(element, `Element with role="${role}" missing required aria-checked attribute`, 'error');
        }
      }
    });
  }
  
  checkKeyboardFocus() {
    // Find elements that might need keyboard focus
    const interactiveElements = document.querySelectorAll('a, button, [role="button"], [tabindex]');
    
    interactiveElements.forEach(element => {
      const computedStyle = window.getComputedStyle(element);
      
      // Check if the element has a focus outline style
      if (computedStyle.outlineStyle === 'none' && computedStyle.outlineWidth === '0px') {
        // Check if there's a focus style defined in CSS (this is a simplified check)
        const hasFocusStyle = document.styleSheets.some(sheet => {
          try {
            const rules = sheet.cssRules || sheet.rules;
            return Array.from(rules).some(rule => {
              return rule.selectorText && 
                     rule.selectorText.includes(':focus') && 
                     rule.selectorText.includes(element.tagName.toLowerCase());
            });
          } catch (e) {
            // CORS might prevent reading some stylesheets
            return false;
          }
        });
        
        if (!hasFocusStyle) {
          this.addIssue(element, 'Interactive element may be missing visible focus indicator', 'warning');
        }
      }
    });
  }
}

// Example usage
const checker = new AccessibilityChecker();
document.getElementById('check-accessibility').addEventListener('click', () => {
  const issues = checker.checkPage();
  console.log('Accessibility issues found:', issues);
  
  // Display issues in the UI
  const resultsContainer = document.getElementById('accessibility-results');
  resultsContainer.innerHTML = '';
  
  if (issues.length === 0) {
    resultsContainer.textContent = 'No accessibility issues found!';
    return;
  }
  
  const list = document.createElement('ul');
  
  issues.forEach(issue => {
    const item = document.createElement('li');
    item.className = `issue-${issue.severity}`;
    
    const elementDesc = document.createElement('code');
    elementDesc.textContent = issue.element.outerHTML.substring(0, 100) + 
      (issue.element.outerHTML.length > 100 ? '...' : '');
    
    item.innerHTML = `<strong>${issue.severity.toUpperCase()}:</strong> ${issue.issue}<br>`;
    item.appendChild(elementDesc);
    
    list.appendChild(item);
  });
  
  resultsContainer.appendChild(list);
});
```

```html
<button id="check-accessibility">Check Page Accessibility</button>
<div id="accessibility-results"></div>
```

**10. Best Practices for JavaScript Accessibility**

**1. Progressive Enhancement:**
```javascript
// Start with basic HTML that works without JavaScript
const tabs = document.querySelector('.tabs');
const tabList = tabs.querySelector('ul');
const tabPanels = tabs.querySelectorAll('.tab-panel');

// Only enhance if the browser supports the required features
if (tabs && tabList && tabPanels.length > 0) {
  // Convert to tabbed interface with JavaScript
  enhanceToTabs();
} else {
  // Leave as is - content remains accessible
  console.log('Tab enhancement not possible, leaving as standard content');
}

function enhanceToTabs() {
  // Enhancement code here
}
```

**2. Semantic HTML First:**
```javascript
// Bad practice: Creating a button from a div
const divButton = document.createElement('div');
divButton.className = 'button';
divButton.textContent = 'Click me';
divButton.addEventListener('click', handleClick);

// Good practice: Using the correct semantic element
const button = document.createElement('button');
button.className = 'button';
button.textContent = 'Click me';
button.addEventListener('click', handleClick);
```

**3. Manage Focus for Dynamic Content:**
```javascript
// When showing new content, manage focus appropriately
function showModal(modalId) {
  const modal = document.getElementById(modalId);
  const focusableElements = modal.querySelectorAll(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  );
  
  // Show the modal
  modal.classList.add('visible');
  
  // Store the element that had focus before opening the modal
  modal.previousFocus = document.activeElement;
  
  // Set focus to the first focusable element in the modal
  if (focusableElements.length > 0) {
    focusableElements[0].focus();
  } else {
    // If no focusable elements, make the modal focusable and focus it
    modal.setAttribute('tabindex', '-1');
    modal.focus();
  }
}

function hideModal(modalId) {
  const modal = document.getElementById(modalId);
  
  // Hide the modal
  modal.classList.remove('visible');
  
  // Restore focus to the element that had it before the modal was opened
  if (modal.previousFocus) {
    modal.previousFocus.focus();
  }
}
```

**4. Use ARIA Attributes Judiciously:**
```javascript
// Only use ARIA when HTML semantics aren't sufficient

// Bad practice: Overusing ARIA
const div = document.createElement('div');
div.setAttribute('role', 'button');
div.setAttribute('tabindex', '0');
div.setAttribute('aria-pressed', 'false');
div.textContent = 'Toggle';

// Good practice: Use the native element
const button = document.createElement('button');
button.textContent = 'Toggle';
button.classList.add('toggle-button');
```

**5. Test with Assistive Technologies:**
```javascript
// Include testing with screen readers in your development process
function runAccessibilityTests() {
  // Automated tests
  const axeCore = new AxeCore();
  axeCore.run(document, (err, results) => {
    if (err) throw err;
    console.log('Accessibility violations:', results.violations);
  });
  
  // Manual test checklist
  console.log('Manual tests to perform:');
  console.log('1. Test with keyboard navigation');
  console.log('2. Test with screen reader (NVDA, JAWS, or VoiceOver)');
  console.log('3. Test with high contrast mode');
  console.log('4. Test with zoom (200%)');
}
```

**Key Takeaways:**

1. JavaScript can both enhance and hinder accessibility, so careful implementation is crucial
2. Follow WCAG guidelines and ARIA best practices when developing interactive components
3. Ensure keyboard accessibility for all interactive elements
4. Manage focus appropriately, especially in SPAs and modal dialogs
5. Use semantic HTML as the foundation before enhancing with JavaScript
6. Implement proper form validation with clear error messages
7. Make custom components (dropdowns, tabs, etc.) fully accessible
8. Use ARIA live regions to announce dynamic content changes
9. Test with actual assistive technologies, not just automated tools
10. Follow progressive enhancement to ensure functionality without JavaScript

## Modern Web Development

### Q71: Explain JavaScript build tools and module bundlers. What are their purposes, and how do they improve modern web development?
**Difficulty: Medium**

**Answer:**
JavaScript build tools and module bundlers are essential components of modern web development workflows. They help developers manage complex applications, optimize code for production, and enhance the development experience. Let's explore what they are, why they're needed, and how they work.

**1. The Need for Build Tools and Bundlers**

Modern web applications face several challenges that build tools and bundlers help solve:

- **Module Management**: Managing dependencies between hundreds of files and third-party packages
- **Code Transformation**: Converting modern JavaScript (ES6+) to browser-compatible code
- **Optimization**: Minifying and compressing code for production
- **Developer Experience**: Providing fast feedback loops during development
- **Asset Management**: Handling non-JavaScript assets like CSS, images, and fonts

**2. Popular Build Tools and Bundlers**

**Webpack**

Webpack is one of the most widely used module bundlers in the JavaScript ecosystem.

```javascript
// webpack.config.js - Basic configuration
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.[contenthash].js'
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      },
      {
        test: /\.(png|svg|jpg|jpeg|gif)$/i,
        type: 'asset/resource'
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html'
    })
  ],
  devServer: {
    static: './dist',
    hot: true
  },
  mode: 'development'
};
```

**Key Features of Webpack:**
- **Code Splitting**: Automatically splits code into manageable chunks
- **Loaders**: Transform files before adding them to the dependency graph
- **Plugins**: Perform a wider range of tasks like optimization and asset management
- **Hot Module Replacement (HMR)**: Updates modules in the browser without a full refresh

**Vite**

Vite is a newer build tool that leverages native ES modules for an extremely fast development experience.

```javascript
// vite.config.js - Basic configuration
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  build: {
    outDir: 'dist',
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom']
        }
      }
    }
  },
  server: {
    port: 3000,
    open: true
  }
});
```

**Key Features of Vite:**
- **Lightning-fast cold start**: Uses native ES modules during development
- **Instant HMR**: Updates are reflected almost immediately
- **Optimized builds**: Uses Rollup for production builds
- **Out-of-the-box support**: Handles TypeScript, JSX, CSS, and more without configuration

**Rollup**

Rollup specializes in creating efficient bundles, particularly for libraries.

```javascript
// rollup.config.js - Basic configuration
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import babel from '@rollup/plugin-babel';
import terser from '@rollup/plugin-terser';

export default {
  input: 'src/main.js',
  output: [
    {
      file: 'dist/bundle.cjs.js',
      format: 'cjs'
    },
    {
      file: 'dist/bundle.esm.js',
      format: 'esm'
    },
    {
      file: 'dist/bundle.umd.js',
      format: 'umd',
      name: 'myLibrary',
      plugins: [terser()]
    }
  ],
  plugins: [
    resolve(),
    commonjs(),
    babel({
      babelHelpers: 'bundled',
      exclude: 'node_modules/**'
    })
  ],
  external: ['react', 'react-dom']
};
```

**Key Features of Rollup:**
- **Tree shaking**: Eliminates unused code for smaller bundles
- **Multiple output formats**: Supports ESM, CommonJS, UMD, and more
- **Simple and focused**: Specializes in bundling, not a complete build system
- **Efficient for libraries**: Creates clean, optimized code for distribution

**Parcel**

Parcel emphasizes zero-configuration bundling.

```bash
# No config file needed! Just run:
npm install parcel
npx parcel src/index.html
```

**Key Features of Parcel:**
- **Zero configuration**: Works out of the box with sensible defaults
- **Fast builds**: Utilizes multicore processing and caching
- **Automatic transforms**: Detects and transforms various file types automatically
- **Built-in development server**: Includes hot reloading

**esbuild**

esbuild is an extremely fast JavaScript bundler written in Go.

```javascript
// esbuild.config.js
const esbuild = require('esbuild');

esbuild.build({
  entryPoints: ['src/index.js'],
  bundle: true,
  minify: true,
  sourcemap: true,
  target: ['chrome58', 'firefox57', 'safari11', 'edge16'],
  outfile: 'dist/bundle.js'
}).catch(() => process.exit(1));
```

**Key Features of esbuild:**
- **Extreme speed**: 10-100x faster than other bundlers
- **Built-in minification**: Fast JavaScript and CSS minification
- **TypeScript and JSX support**: Native support without plugins
- **Simple API**: Straightforward configuration options

**3. Task Runners**

Task runners automate repetitive development tasks beyond just bundling.

**npm scripts**

The simplest form of task running, built into npm.

```json
// package.json
{
  "name": "my-project",
  "scripts": {
    "start": "webpack serve --mode development",
    "build": "webpack --mode production",
    "test": "jest",
    "lint": "eslint src/**/*.js",
    "format": "prettier --write 'src/**/*.{js,jsx,css,html}'"
  }
}
```

**Gulp**

Gulp is a streaming build system that uses code over configuration.

```javascript
// gulpfile.js
const { src, dest, watch, series, parallel } = require('gulp');
const sass = require('gulp-sass')(require('sass'));
const autoprefixer = require('gulp-autoprefixer');
const cssnano = require('gulp-cssnano');
const babel = require('gulp-babel');
const uglify = require('gulp-uglify');
const browserSync = require('browser-sync').create();

// Compile SCSS to CSS, autoprefix, and minify
function styles() {
  return src('./src/scss/**/*.scss')
    .pipe(sass().on('error', sass.logError))
    .pipe(autoprefixer())
    .pipe(cssnano())
    .pipe(dest('./dist/css'))
    .pipe(browserSync.stream());
}

// Transpile and minify JavaScript
function scripts() {
  return src('./src/js/**/*.js')
    .pipe(babel({
      presets: ['@babel/preset-env']
    }))
    .pipe(uglify())
    .pipe(dest('./dist/js'))
    .pipe(browserSync.stream());
}

// Start dev server
function serve() {
  browserSync.init({
    server: './dist'
  });
  
  watch('./src/scss/**/*.scss', styles);
  watch('./src/js/**/*.js', scripts);
  watch('./dist/*.html').on('change', browserSync.reload);
}

// Define complex tasks
const build = series(parallel(styles, scripts));

// Export tasks
exports.build = build;
exports.default = series(build, serve);
```

**4. Transpilers**

Transpilers convert code from one language or version to another.

**Babel**

Babel is the most popular JavaScript transpiler, converting modern JavaScript to backward-compatible versions.

```javascript
// babel.config.js
module.exports = {
  presets: [
    ['@babel/preset-env', {
      targets: '> 0.25%, not dead',
      useBuiltIns: 'usage',
      corejs: 3
    }],
    '@babel/preset-react'
  ],
  plugins: [
    '@babel/plugin-proposal-class-properties',
    '@babel/plugin-transform-runtime'
  ]
};
```

**Example of Babel Transformation:**

```javascript
// Modern JavaScript (input)
const sum = (a, b) => a + b;

class Person {
  name = 'John';
  
  greet = () => {
    return `Hello, ${this.name}!`;
  }
}

// Transpiled output for older browsers
"use strict";

function _defineProperty(obj, key, value) { /* ... */ }

var sum = function sum(a, b) {
  return a + b;
};

var Person = function Person() {
  _defineProperty(this, "name", 'John');

  _defineProperty(this, "greet", function () {
    return "Hello, ".concat(this.name, "!");
  });
};
```

**TypeScript**

TypeScript is a superset of JavaScript that adds static typing.

```typescript
// tsconfig.json
{
  "compilerOptions": {
    "target": "es5",
    "module": "esnext",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "allowSyntheticDefaultImports": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "**/*.spec.ts"]
}
```

**Example of TypeScript Transformation:**

```typescript
// TypeScript (input)
interface User {
  id: number;
  name: string;
  email?: string;
}

function greetUser(user: User): string {
  return `Hello, ${user.name}!`;
}

const user: User = {
  id: 1,
  name: 'Alice'
};

console.log(greetUser(user));

// JavaScript output after compilation
"use strict";
function greetUser(user) {
  return "Hello, ".concat(user.name, "!");
}
var user = {
  id: 1,
  name: 'Alice'
};
console.log(greetUser(user));
```

**5. How Build Tools Work**

**The Build Process:**

1. **Parsing**: Reading source files and creating an Abstract Syntax Tree (AST)
2. **Transformation**: Applying plugins and loaders to transform code
3. **Dependency Resolution**: Identifying and resolving module dependencies
4. **Bundling**: Combining modules into bundles
5. **Code Generation**: Outputting the final transformed and bundled code
6. **Optimization**: Applying minification, tree shaking, and other optimizations

**Module Resolution:**

```javascript
// How bundlers resolve imports
import Button from './components/Button';
import { useState } from 'react';
import styles from './styles.css';
import logo from './assets/logo.png';

// Bundlers need to:
// 1. Find the actual file paths
// 2. Process different file types
// 3. Handle node_modules packages
// 4. Apply appropriate transformations
```

**6. Advanced Features**

**Code Splitting**

Code splitting allows loading parts of an application on demand.

```javascript
// Dynamic import with webpack or other modern bundlers
import React, { lazy, Suspense } from 'react';

// Instead of: import Dashboard from './Dashboard';
const Dashboard = lazy(() => import('./Dashboard'));

function App() {
  return (
    <div>
      <h1>My App</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <Dashboard />
      </Suspense>
    </div>
  );
}
```

**Tree Shaking**

Tree shaking eliminates dead code by only including what's actually used.

```javascript
// utils.js - Only the used functions will be included in the bundle
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

export function multiply(a, b) {
  return a * b;
}

// main.js
import { add } from './utils';

console.log(add(2, 3)); // Only the 'add' function will be included in the bundle
```

**Cache Busting**

Cache busting ensures users get the latest version of your code.

```javascript
// webpack.config.js with cache busting
module.exports = {
  output: {
    filename: '[name].[contenthash].js',
    chunkFilename: '[name].[contenthash].chunk.js'
  }
};

// Output: main.8e9c0a8f5e6b7d4c.js
```

**Source Maps**

Source maps help debug minified code by mapping it back to the original source.

```javascript
// webpack.config.js with source maps
module.exports = {
  devtool: process.env.NODE_ENV === 'production' 
    ? 'source-map' 
    : 'eval-cheap-module-source-map'
};
```

**7. Build Tool Integration with Frameworks**

Modern frameworks often come with integrated build tools.

**Create React App**

```bash
npx create-react-app my-app
```

Create React App uses webpack and Babel under the hood with a pre-configured setup.

**Vue CLI**

```bash
npm install -g @vue/cli
vue create my-app
```

Vue CLI provides a configurable webpack setup with optional features.

**Angular CLI**

```bash
npm install -g @angular/cli
ng new my-app
```

Angular CLI uses webpack with extensive build optimizations.

**Next.js**

```bash
npx create-next-app my-app
```

Next.js includes webpack with server-side rendering capabilities.

**8. Optimizing Build Performance**

**Speeding Up Development Builds:**

```javascript
// webpack.config.js - Development optimizations
module.exports = {
  mode: 'development',
  cache: {
    type: 'filesystem' // Use filesystem caching
  },
  optimization: {
    removeAvailableModules: false,
    removeEmptyChunks: false,
    splitChunks: false
  },
  devtool: 'eval-cheap-module-source-map',
  infrastructureLogging: {
    level: 'warn'
  }
};
```

**Optimizing Production Builds:**

```javascript
// webpack.config.js - Production optimizations
const TerserPlugin = require('terser-webpack-plugin');
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');

module.exports = {
  mode: 'production',
  optimization: {
    minimizer: [
      new TerserPlugin({
        parallel: true,
        terserOptions: {
          compress: {
            drop_console: true
          }
        }
      }),
      new CssMinimizerPlugin()
    ],
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendors: {
          test: /[\\]node_modules[\\]/,
          name: 'vendors',
          chunks: 'all'
        }
      }
    },
    runtimeChunk: 'single'
  }
};
```

**9. Future Trends in Build Tools**

- **Native ESM Support**: Leveraging browser's native module system
- **Rust-based Tools**: Faster compilation with tools like SWC and Turbopack
- **Zero-config**: More intelligent defaults requiring less configuration
- **Build-less Development**: Direct browser execution during development
- **WebAssembly Integration**: Improved performance for complex transformations

**10. Choosing the Right Build Tool**

Considerations when selecting a build tool:

- **Project Size**: Simpler tools for smaller projects, more configurable ones for larger apps
- **Performance Needs**: Build speed vs. output optimization
- **Team Experience**: Learning curve and existing knowledge
- **Framework Requirements**: Some frameworks work better with specific tools
- **Feature Requirements**: Code splitting, HMR, TypeScript support, etc.

**Key Takeaways:**

1. Build tools and bundlers are essential for modern web development, handling tasks like module resolution, code transformation, and optimization
2. Webpack is highly configurable and feature-rich, while newer tools like Vite offer improved development experience
3. Task runners like npm scripts and Gulp automate repetitive development tasks
4. Transpilers like Babel and TypeScript convert modern code to browser-compatible versions
5. Code splitting, tree shaking, and cache busting are important optimization techniques
6. Modern frameworks often include pre-configured build setups
7. The choice of build tool depends on project requirements, team experience, and performance needs
8. The trend is moving toward faster, simpler build tools with better developer experiences
9. Understanding how build tools work helps in troubleshooting and optimizing the build process
10. A well-configured build process significantly improves both development experience and end-user performance

### Q72: Explain Progressive Web Apps (PWAs). How do they work, and what JavaScript technologies enable them?
**Difficulty: Medium**

**Answer:**
Progressive Web Apps (PWAs) represent a modern approach to web application development that combines the best features of web and native applications. They deliver enhanced reliability, performance, and engagement through modern web capabilities.

**1. Core Concepts of Progressive Web Apps**

**Progressive Enhancement**

PWAs follow the principle of progressive enhancement, working for all users regardless of browser choice, with enhanced features for modern browsers.

```javascript
// Feature detection example
if ('serviceWorker' in navigator) {
  // Use service worker functionality
  navigator.serviceWorker.register('/service-worker.js')
    .then(registration => {
      console.log('ServiceWorker registered with scope:', registration.scope);
    })
    .catch(error => {
      console.error('ServiceWorker registration failed:', error);
    });
} else {
  // Fallback for browsers without Service Worker support
  console.log('Service workers are not supported in this browser');
}
```

**Responsive Design**

PWAs adapt to various form factors, from desktop to mobile.

```css
/* Responsive design example */
@media (max-width: 600px) {
  .container {
    flex-direction: column;
  }
}
```

**App-like Experience**

PWAs mimic native app behaviors and interactions.

```javascript
// Example of smooth page transitions
const pageTransition = () => {
  const content = document.querySelector('.page-content');
  content.classList.add('page-transition');
  
  setTimeout(() => {
    content.classList.remove('page-transition');
  }, 300);
};

document.querySelectorAll('nav a').forEach(link => {
  link.addEventListener('click', (e) => {
    e.preventDefault();
    pageTransition();
    // Navigation logic
    setTimeout(() => {
      window.location = link.href;
    }, 300);
  });
});
```

**2. Key Technologies Enabling PWAs**

**Service Workers**

Service Workers are JavaScript files that run separately from the main browser thread, intercepting network requests and caching resources.

```javascript
// service-worker.js - Basic example
const CACHE_NAME = 'my-pwa-cache-v1';
const urlsToCache = [
  '/',
  '/styles/main.css',
  '/scripts/main.js',
  '/images/logo.png'
];

// Installation - Cache core assets
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        console.log('Opened cache');
        return cache.addAll(urlsToCache);
      })
  );
});

// Activation - Clean up old caches
self.addEventListener('activate', event => {
  const cacheWhitelist = [CACHE_NAME];
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheWhitelist.indexOf(cacheName) === -1) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// Fetch - Serve from cache, fall back to network
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // Cache hit - return response
        if (response) {
          return response;
        }
        
        // Clone the request
        const fetchRequest = event.request.clone();
        
        return fetch(fetchRequest).then(response => {
          // Check if valid response
          if (!response || response.status !== 200 || response.type !== 'basic') {
            return response;
          }
          
          // Clone the response
          const responseToCache = response.clone();
          
          caches.open(CACHE_NAME)
            .then(cache => {
              cache.put(event.request, responseToCache);
            });
            
          return response;
        });
      })
  );
});
```

**Web App Manifest**

The Web App Manifest is a JSON file that controls how the app appears when installed on a device.

```json
// manifest.json
{
  "name": "My Progressive Web App",
  "short_name": "MyPWA",
  "description": "A simple Progressive Web App example",
  "start_url": "/index.html",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#2196f3",
  "orientation": "portrait",
  "icons": [
    {
      "src": "/images/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png"
    },
    {
      "src": "/images/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png"
    },
    {
      "src": "/images/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png"
    },
    {
      "src": "/images/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png"
    },
    {
      "src": "/images/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png"
    },
    {
      "src": "/images/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/images/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "/images/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "splash_pages": null
}
```

To link the manifest in your HTML:

```html
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#2196f3">
```

**HTTPS**

PWAs require secure connections. Most PWA features, including Service Workers, only work over HTTPS.

**3. Offline Capabilities**

**Caching Strategies**

Different caching strategies can be implemented depending on the application's needs:

```javascript
// Cache-first strategy
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        return response || fetch(event.request);
      })
  );
});

// Network-first strategy
self.addEventListener('fetch', event => {
  event.respondWith(
    fetch(event.request)
      .catch(() => {
        return caches.match(event.request);
      })
  );
});

// Stale-while-revalidate strategy
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.open(CACHE_NAME).then(cache => {
      return cache.match(event.request).then(response => {
        const fetchPromise = fetch(event.request).then(networkResponse => {
          cache.put(event.request, networkResponse.clone());
          return networkResponse;
        });
        return response || fetchPromise;
      });
    })
  );
});
```

**IndexedDB for Offline Data**

IndexedDB provides a way to store structured data for offline use.

```javascript
// Basic IndexedDB example
const dbPromise = idb.open('my-pwa-db', 1, upgradeDB => {
  upgradeDB.createObjectStore('todos', { keyPath: 'id' });
});

// Add a todo item
function addTodo(todo) {
  return dbPromise.then(db => {
    const tx = db.transaction('todos', 'readwrite');
    tx.objectStore('todos').put(todo);
    return tx.complete;
  });
}

// Get all todo items
function getTodos() {
  return dbPromise.then(db => {
    return db.transaction('todos')
      .objectStore('todos').getAll();
  });
}

// Sync with server when online
window.addEventListener('online', () => {
  getTodos().then(todos => {
    // Filter unsynchronized todos
    const unsynced = todos.filter(todo => !todo.synced);
    
    // Send to server
    Promise.all(unsynced.map(todo => {
      return fetch('/api/todos', {
        method: 'POST',
        body: JSON.stringify(todo),
        headers: { 'Content-Type': 'application/json' }
      })
      .then(() => {
        // Mark as synced
        todo.synced = true;
        return addTodo(todo);
      });
    }))
    .then(() => {
      console.log('All todos synchronized');
    });
  });
});
```

**4. Installation and App-like Experience**

**Add to Home Screen**

Detecting and handling the installation prompt:

```javascript
let deferredPrompt;

window.addEventListener('beforeinstallprompt', (e) => {
  // Prevent Chrome 67 and earlier from automatically showing the prompt
  e.preventDefault();
  // Stash the event so it can be triggered later
  deferredPrompt = e;
  // Update UI to notify the user they can add to home screen
  showInstallPromotion();
});

// Installation button click handler
installButton.addEventListener('click', () => {
  // Hide the app provided install promotion
  hideInstallPromotion();
  // Show the install prompt
  deferredPrompt.prompt();
  // Wait for the user to respond to the prompt
  deferredPrompt.userChoice.then((choiceResult) => {
    if (choiceResult.outcome === 'accepted') {
      console.log('User accepted the install prompt');
    } else {
      console.log('User dismissed the install prompt');
    }
    // Clear the saved prompt since it can't be used again
    deferredPrompt = null;
  });
});

// Listen for successful installation
window.addEventListener('appinstalled', (evt) => {
  console.log('App was installed', evt);
});
```

**5. Push Notifications**

Implementing push notifications in a PWA:

```javascript
// Request notification permission
function requestNotificationPermission() {
  return Notification.requestPermission().then(permission => {
    if (permission !== 'granted') {
      throw new Error('Permission not granted for Notification');
    }
    return true;
  });
}

// Subscribe to push notifications
function subscribeToPushNotifications() {
  return navigator.serviceWorker.ready
    .then(registration => {
      // Check for existing subscription
      return registration.pushManager.getSubscription()
        .then(subscription => {
          if (subscription) {
            return subscription;
          }
          
          // Get the server's public key
          return fetch('/api/vapidPublicKey')
            .then(response => response.text())
            .then(vapidPublicKey => {
              // Convert the key to a Uint8Array
              const convertedVapidKey = urlBase64ToUint8Array(vapidPublicKey);
              
              // Subscribe the user
              return registration.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: convertedVapidKey
              });
            });
        });
    })
    .then(subscription => {
      // Send the subscription to your server
      return fetch('/api/subscribe', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(subscription)
      });
    })
    .then(response => response.json())
    .then(response => {
      console.log('User subscribed:', response);
    });
}

// Handle incoming push messages in the service worker
self.addEventListener('push', event => {
  if (event.data) {
    const data = event.data.json();
    
    const options = {
      body: data.body,
      icon: '/images/notification-icon.png',
      badge: '/images/notification-badge.png',
      vibrate: [100, 50, 100],
      data: {
        url: data.url
      },
      actions: [
        {
          action: 'explore',
          title: 'View Details'
        },
        {
          action: 'close',
          title: 'Close'
        }
      ]
    };
    
    event.waitUntil(
      self.registration.showNotification(data.title, options)
    );
  }
});

// Handle notification clicks
self.addEventListener('notificationclick', event => {
  event.notification.close();
  
  if (event.action === 'explore') {
    const urlToOpen = event.notification.data.url || '/';
    
    event.waitUntil(
      clients.openWindow(urlToOpen)
    );
  }
});
```

**6. Background Sync**

Performing tasks when the user regains connectivity:

```javascript
// Register a sync event from the page
function registerSync() {
  navigator.serviceWorker.ready
    .then(registration => {
      return registration.sync.register('sync-todos');
    })
    .then(() => {
      console.log('Sync registered');
    })
    .catch(err => {
      console.error('Sync registration failed:', err);
    });
}

// Handle the sync event in the service worker
self.addEventListener('sync', event => {
  if (event.tag === 'sync-todos') {
    event.waitUntil(
      // Get all unsynced data from IndexedDB
      getUnsyncedTodos()
        .then(todos => {
          // Send each todo to the server
          return Promise.all(
            todos.map(todo => {
              return fetch('/api/todos', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(todo)
              })
              .then(response => {
                if (response.ok) {
                  // Mark as synced in IndexedDB
                  return markTodoAsSynced(todo.id);
                }
                throw new Error('Failed to sync');
              });
            })
          );
        })
        .catch(err => {
          console.error('Sync failed:', err);
          throw err; // Retry sync later
        })
    );
  }
});
```

**7. Workbox - A PWA Library**

Workbox is a set of libraries that simplifies PWA development:

```javascript
// Using Workbox in a service worker
importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.2.0/workbox-sw.js');

workbox.setConfig({ debug: false });

// Cache page navigations
workbox.routing.registerRoute(
  ({ request }) => request.mode === 'navigate',
  new workbox.strategies.NetworkFirst({
    cacheName: 'pages-cache',
    plugins: [
      new workbox.expiration.ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 30 * 24 * 60 * 60 // 30 days
      })
    ]
  })
);

// Cache CSS, JS, and Web Worker requests with a Stale-While-Revalidate strategy
workbox.routing.registerRoute(
  ({ request }) => 
    request.destination === 'style' ||
    request.destination === 'script' ||
    request.destination === 'worker',
  new workbox.strategies.StaleWhileRevalidate({
    cacheName: 'assets-cache',
    plugins: [
      new workbox.expiration.ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60 // 30 days
      })
    ]
  })
);

// Cache images with a Cache-First strategy
workbox.routing.registerRoute(
  ({ request }) => request.destination === 'image',
  new workbox.strategies.CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new workbox.expiration.ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60 // 30 days
      })
    ]
  })
);

// Cache the Google Fonts stylesheets with a Stale-While-Revalidate strategy
workbox.routing.registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new workbox.strategies.StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets'
  })
);

// Cache the Google Fonts webfont files with a Cache-First strategy for 1 year
workbox.routing.registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new workbox.strategies.CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new workbox.expiration.ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
        maxEntries: 30
      })
    ]
  })
);

// Handle API requests
workbox.routing.registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new workbox.strategies.NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new workbox.expiration.ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 5 * 60 // 5 minutes
      })
    ]
  })
);
```

**8. Lighthouse Auditing**

Lighthouse is a tool for measuring PWA quality:

```javascript
// Example of fixing issues identified by Lighthouse

// 1. Ensure pages are responsive
const viewport = document.createElement('meta');
viewport.name = 'viewport';
viewport.content = 'width=device-width, initial-scale=1';
document.head.appendChild(viewport);

// 2. Ensure all links are crawlable
const links = document.querySelectorAll('a[href="#"]');
links.forEach(link => {
  link.href = link.textContent.toLowerCase().replace(/\s+/g, '-');
});

// 3. Ensure sufficient color contrast
document.querySelectorAll('.low-contrast').forEach(element => {
  element.style.color = '#333333';
  element.style.backgroundColor = '#ffffff';
});

// 4. Add meta description
const metaDescription = document.createElement('meta');
metaDescription.name = 'description';
metaDescription.content = 'A progressive web app example with offline capabilities';
document.head.appendChild(metaDescription);
```

**9. PWA Frameworks and Tools**

**React PWA**

```bash
# Create a React PWA
npx create-react-app my-pwa --template cra-template-pwa
```

**Vue PWA**

```bash
# Create a Vue PWA
vue create my-vue-pwa
# Select PWA plugin during setup
```

**Angular PWA**

```bash
# Add PWA capabilities to an Angular app
ng add @angular/pwa
```

**10. Best Practices for PWA Development**

**Performance Optimization**

```javascript
// Implement lazy loading for images
document.addEventListener('DOMContentLoaded', () => {
  const lazyImages = document.querySelectorAll('img.lazy');
  
  if ('IntersectionObserver' in window) {
    const imageObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          img.src = img.dataset.src;
          img.classList.remove('lazy');
          imageObserver.unobserve(img);
        }
      });
    });
    
    lazyImages.forEach(img => imageObserver.observe(img));
  } else {
    // Fallback for browsers without IntersectionObserver
    // ...
  }
});
```

**Responsive Design**

```css
/* Mobile-first approach */
.container {
  width: 100%;
  padding: 15px;
}

/* Tablet */
@media (min-width: 768px) {
  .container {
    max-width: 720px;
    margin: 0 auto;
  }
}

/* Desktop */
@media (min-width: 1024px) {
  .container {
    max-width: 960px;
  }
}
```

**Accessibility**

```javascript
// Ensure keyboard navigation works
const menuItems = document.querySelectorAll('.menu-item');

menuItems.forEach((item, index) => {
  item.setAttribute('tabindex', '0');
  
  item.addEventListener('keydown', (e) => {
    // Handle Enter or Space to activate item
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      item.click();
    }
    
    // Handle arrow keys for navigation
    if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
      e.preventDefault();
      const nextItem = menuItems[index + 1] || menuItems[0];
      nextItem.focus();
    }
    
    if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
      e.preventDefault();
      const prevItem = menuItems[index - 1] || menuItems[menuItems.length - 1];
      prevItem.focus();
    }
  });
});
```

**Key Takeaways:**

1. Progressive Web Apps combine the best features of web and native applications
2. Service Workers enable offline capabilities, background sync, and push notifications
3. The Web App Manifest allows users to install the PWA to their home screen
4. PWAs require HTTPS for security and to enable key features
5. Different caching strategies can be implemented based on application needs
6. IndexedDB provides a way to store structured data for offline use
7. Push notifications and background sync enhance user engagement
8. Workbox simplifies PWA development with pre-built solutions
9. Lighthouse helps audit and improve PWA quality
10. Modern frameworks like React, Vue, and Angular offer built-in PWA support

### Q73: Compare and contrast popular JavaScript frameworks and libraries. What are their strengths, weaknesses, and best use cases?
**Difficulty: Medium**

**Answer:**
JavaScript frameworks and libraries have revolutionized web development by providing structured approaches to building complex applications. Let's examine the most popular ones, their architectural patterns, strengths, weaknesses, and ideal use cases.

**1. React**

**Core Philosophy**: A JavaScript library for building user interfaces with a component-based architecture.

**Key Features:**

- **Component-Based**: UI is broken down into reusable, self-contained components
- **Virtual DOM**: Efficient rendering through a lightweight copy of the actual DOM
- **JSX**: JavaScript syntax extension that allows HTML-like code in JavaScript
- **Unidirectional Data Flow**: Data flows down from parent to child components

**Basic Example:**

```jsx
// A simple React component
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

export default Counter;
```

**Strengths:**

- **Flexibility**: Not opinionated about architecture beyond the view layer
- **Rich Ecosystem**: Vast library of third-party components and tools
- **Strong Community**: Large community and corporate backing (Facebook/Meta)
- **React Native**: Ability to build native mobile apps with the same paradigms
- **Performance**: Virtual DOM provides efficient updates

**Weaknesses:**

- **Steep Learning Curve**: JSX, state management, and hooks can be challenging for beginners
- **Boilerplate**: Requires additional libraries for routing, state management, etc.
- **Tooling Complexity**: Build configuration can be complex
- **Frequent Updates**: Rapid evolution can lead to maintenance challenges

**Best Use Cases:**

- Single-page applications (SPAs)
- Applications with complex UI interactions
- Projects requiring a flexible, component-based architecture
- Cross-platform development (web and mobile)
- Applications where performance is critical

**2. Vue.js**

**Core Philosophy**: A progressive JavaScript framework for building user interfaces with an incrementally adoptable architecture.

**Key Features:**

- **Template-Based**: HTML templates with Vue-specific directives
- **Reactivity System**: Automatic tracking of dependencies and efficient updates
- **Single-File Components**: Combining template, script, and style in one file
- **Two-way Data Binding**: Simplified form handling with v-model directive

**Basic Example:**

```vue
<!-- Vue Single-File Component -->
<template>
  <div>
    <p>You clicked {{ count }} times</p>
    <button @click="increment">Click me</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      count: 0
    };
  },
  methods: {
    increment() {
      this.count++;
    }
  }
};
</script>

<style scoped>
button {
  padding: 5px 10px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
</style>
```

**Strengths:**

- **Gentle Learning Curve**: Easier for beginners to pick up
- **Flexibility**: Can be used for small parts of a page or full SPAs
- **Comprehensive Documentation**: Well-documented with clear examples
- **Integration**: Easy to integrate with existing projects
- **Balance**: Good balance between performance and development experience

**Weaknesses:**

- **Smaller Ecosystem**: Fewer third-party components compared to React
- **Less Corporate Backing**: Primarily community-driven
- **Mobile Solutions**: Vue Native and other mobile solutions less mature than React Native
- **Job Market**: Fewer job opportunities compared to React and Angular

**Best Use Cases:**

- Projects requiring gradual adoption of a framework
- Applications with clear separation of concerns
- Teams transitioning from traditional web development
- Prototyping and rapid development
- Small to medium-sized applications

**3. Angular**

**Core Philosophy**: A platform and framework for building single-page client applications using HTML and TypeScript.

**Key Features:**

- **Full-Featured Framework**: Complete solution with routing, forms, HTTP client, etc.
- **TypeScript**: Built with and encourages use of TypeScript
- **Dependency Injection**: Built-in DI system for better testability and modularity
- **RxJS Integration**: Reactive programming with Observables
- **Two-way Data Binding**: NgModel directive for form elements

**Basic Example:**

```typescript
// Angular component
import { Component } from '@angular/core';

@Component({
  selector: 'app-counter',
  template: `
    <div>
      <p>You clicked {{ count }} times</p>
      <button (click)="increment()">Click me</button>
    </div>
  `,
  styles: [`
    button {
      padding: 5px 10px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
  `]
})
export class CounterComponent {
  count = 0;
  
  increment() {
    this.count++;
  }
}
```

**Strengths:**

- **Comprehensive**: All-in-one solution with built-in tools
- **Consistency**: Enforces consistent coding patterns
- **Enterprise-Ready**: Built with large applications in mind
- **TypeScript Integration**: Strong typing reduces errors
- **Testing**: Built with testability as a core concern

**Weaknesses:**

- **Steep Learning Curve**: Complex concepts and verbose syntax
- **Performance**: Can be heavier than React or Vue for simple applications
- **Flexibility**: More opinionated, less flexible than React
- **Build Size**: Larger initial bundle size
- **Complexity**: Overkill for smaller projects

**Best Use Cases:**

- Enterprise-level applications
- Large teams requiring consistent architecture
- Complex applications with many features
- Projects benefiting from strong typing and tooling
- Applications requiring long-term maintenance

**4. Svelte**

**Core Philosophy**: A compiler that converts your declarative components into efficient JavaScript that surgically updates the DOM.

**Key Features:**

- **Compile-Time Framework**: Shifts work from runtime to build time
- **No Virtual DOM**: Direct, optimized DOM updates
- **Less Boilerplate**: Minimal syntax for reactive declarations
- **Built-in Transitions**: Easy animation capabilities
- **Truly Reactive**: Reactivity is built into the language

**Basic Example:**

```svelte
<!-- Svelte component -->
<script>
  let count = 0;
  
  function increment() {
    count += 1;
  }
</script>

<div>
  <p>You clicked {count} times</p>
  <button on:click={increment}>Click me</button>
</div>

<style>
  button {
    padding: 5px 10px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
</style>
```

**Strengths:**

- **Performance**: Typically faster than virtual DOM frameworks
- **Bundle Size**: Smaller runtime code
- **Simplicity**: Clean, intuitive syntax
- **Less Boilerplate**: Less code for the same functionality
- **Built-in Features**: Transitions, stores, and more included

**Weaknesses:**

- **Smaller Ecosystem**: Fewer libraries and tools
- **Community Size**: Smaller community than React, Vue, or Angular
- **Maturity**: Less battle-tested in large-scale applications
- **Tooling**: Less mature developer tools
- **Job Market**: Fewer job opportunities

**Best Use Cases:**

- Performance-critical applications
- Projects where bundle size is important
- Applications targeting low-powered devices
- Teams preferring simplicity over extensive features
- Smaller to medium-sized applications

**5. Preact**

**Core Philosophy**: A fast 3kB alternative to React with the same modern API.

**Key Features:**

- **React Compatible**: Same API as React but much smaller
- **Performance Focused**: Fast rendering with a tiny footprint
- **Minimal Abstractions**: Close to the DOM for better performance
- **React Ecosystem**: Compatible with most React libraries

**Basic Example:**

```jsx
// Preact component
import { h, Component } from 'preact';
import { useState } from 'preact/hooks';

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

export default Counter;
```

**Strengths:**

- **Size**: Extremely small bundle size (3kB)
- **Performance**: Fast rendering and updates
- **React Compatibility**: Easy migration from React
- **Mobile-Friendly**: Great for mobile web apps due to size
- **Simplicity**: Simpler internals than React

**Weaknesses:**

- **Feature Set**: Missing some React features
- **Ecosystem**: Smaller ecosystem than React
- **Edge Cases**: Some React libraries may require compatibility layer
- **Documentation**: Less comprehensive documentation
- **Community**: Smaller community than React

**Best Use Cases:**

- Performance-critical applications
- Mobile web applications
- Progressive Web Apps
- Projects where bundle size is critical
- Applications already using React but needing optimization

**6. Ember.js**

**Core Philosophy**: A framework for ambitious web developers that provides a complete solution.

**Key Features:**

- **Convention over Configuration**: Standardized project structure
- **Ember CLI**: Powerful command-line tools
- **Ember Data**: Robust data management layer
- **Stability**: Strong commitment to semantic versioning
- **Glimmer Rendering Engine**: Fast rendering system

**Basic Example:**

```javascript
// Ember component
import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
import { action } from '@ember/object';

export default class CounterComponent extends Component {
  @tracked count = 0;
  
  @action
  increment() {
    this.count++;
  }
}
```

```handlebars
{{!-- counter.hbs template --}}
<div>
  <p>You clicked {{this.count}} times</p>
  <button {{on "click" this.increment}}>Click me</button>
</div>
```

**Strengths:**

- **Conventions**: Clear conventions reduce decision fatigue
- **Stability**: Strong backward compatibility
- **Integrated Tooling**: Comprehensive CLI tools
- **Community**: Friendly, supportive community
- **Testing**: Strong testing culture and tools

**Weaknesses:**

- **Learning Curve**: Steep learning curve for beginners
- **Flexibility**: Less flexible due to conventions
- **Size**: Larger than some alternatives
- **Modern JavaScript**: Slower to adopt some modern JS features
- **Popularity**: Less popular than React, Vue, or Angular

**Best Use Cases:**

- Large, long-lived applications
- Teams valuing conventions and stability
- Applications requiring strong data management
- Projects with complex UIs and workflows
- Teams wanting an all-in-one solution

**7. Alpine.js**

**Core Philosophy**: A rugged, minimal framework for composing JavaScript behavior in your markup.

**Key Features:**

- **Minimal**: Lightweight with a small API surface
- **HTML-Centric**: Behavior defined directly in HTML
- **No Build Step**: Works without a build process
- **jQuery Alternative**: Modern replacement for jQuery
- **Progressive Enhancement**: Enhances existing HTML

**Basic Example:**

```html
<!-- Alpine.js component -->
<div x-data="{ count: 0 }">
  <p>You clicked <span x-text="count"></span> times</p>
  <button x-on:click="count++">Click me</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
```

**Strengths:**

- **Simplicity**: Easy to learn and use
- **No Build Step**: Works directly in the browser
- **Size**: Very small footprint (8kB)
- **Integration**: Easy to add to existing projects
- **Progressive Enhancement**: Works well with server-rendered HTML

**Weaknesses:**

- **Scalability**: Not designed for large applications
- **Structure**: Less structured than full frameworks
- **Tooling**: Limited developer tools
- **Complex State**: Not ideal for complex state management
- **Performance**: Can be less performant for complex UIs

**Best Use Cases:**

- Enhancing server-rendered applications
- Small interactive components
- Projects requiring minimal JavaScript
- Teams transitioning from jQuery
- Applications where simplicity is valued over features

**8. Solid.js**

**Core Philosophy**: A declarative JavaScript library for creating user interfaces with a fine-grained reactivity system.

**Key Features:**

- **Fine-Grained Reactivity**: Updates only what changed without diffing
- **JSX**: Uses JSX like React but with different semantics
- **No Virtual DOM**: Direct DOM updates
- **Signals**: Explicit reactive primitives
- **No Component Re-rendering**: Components render once

**Basic Example:**

```jsx
// Solid.js component
import { createSignal } from 'solid-js';

function Counter() {
  const [count, setCount] = createSignal(0);
  
  return (
    <div>
      <p>You clicked {count()} times</p>
      <button onClick={() => setCount(count() + 1)}>
        Click me
      </button>
    </div>
  );
}

export default Counter;
```

**Strengths:**

- **Performance**: Extremely fast updates
- **Bundle Size**: Small runtime size
- **Reactivity Model**: Explicit and powerful
- **Mental Model**: Clear separation of concerns
- **TypeScript Support**: Built with TypeScript in mind

**Weaknesses:**

- **Ecosystem**: Smaller ecosystem than established frameworks
- **Learning Curve**: Different mental model from React despite similar syntax
- **Community Size**: Smaller community
- **Maturity**: Newer framework with less production history
- **Resources**: Fewer tutorials and examples

**Best Use Cases:**

- Performance-critical applications
- Data-heavy dashboards and visualizations
- Applications requiring fine-grained control over updates
- Projects where bundle size matters
- Teams comfortable with functional reactive programming

**9. State Management Libraries**

**Redux**

```javascript
// Redux example
import { createStore } from 'redux';

// Reducer
function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

// Store
const store = createStore(counterReducer);

// Dispatch actions
store.dispatch({ type: 'INCREMENT' });
console.log(store.getState()); // { count: 1 }
```

**MobX**

```javascript
// MobX example
import { makeAutoObservable } from 'mobx';

class CounterStore {
  count = 0;
  
  constructor() {
    makeAutoObservable(this);
  }
  
  increment() {
    this.count++;
  }
  
  decrement() {
    this.count--;
  }
}

const counterStore = new CounterStore();
counterStore.increment();
console.log(counterStore.count); // 1
```

**Zustand**

```javascript
// Zustand example
import create from 'zustand';

const useCounterStore = create(set => ({
  count: 0,
  increment: () => set(state => ({ count: state.count + 1 })),
  decrement: () => set(state => ({ count: state.count - 1 }))
}));

// In a component
function Counter() {
  const { count, increment } = useCounterStore();
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

**10. Comparison Table**

| Framework/Library | Size (min+gzip) | Learning Curve | Performance | Ecosystem | Best For |
|------------------|----------------|---------------|------------|-----------|----------|
| React            | ~40kB          | Moderate      | Good       | Excellent | Large SPAs, cross-platform |
| Vue.js           | ~33kB          | Low           | Good       | Good      | Progressive enhancement, medium apps |
| Angular          | ~143kB         | High          | Good       | Very Good | Enterprise apps, large teams |
| Svelte           | ~1.8kB         | Low           | Excellent  | Growing   | Performance-critical apps |
| Preact           | ~3kB           | Moderate      | Excellent  | Good      | Size-constrained environments |
| Ember.js         | ~124kB         | High          | Good       | Moderate  | Conventional, long-term projects |
| Alpine.js        | ~8kB           | Very Low      | Moderate   | Small     | Simple interactivity, enhancement |
| Solid.js         | ~7kB           | Moderate      | Excellent  | Growing   | Performance-focused apps |

**11. Framework Selection Criteria**

When choosing a framework or library, consider:

1. **Project Requirements**: Complexity, scale, and specific features needed
2. **Team Experience**: Existing knowledge and learning capacity
3. **Performance Needs**: Critical performance requirements
4. **Development Speed**: Time constraints and productivity needs
5. **Long-term Maintenance**: Community support and longevity
6. **Bundle Size**: Target devices and network conditions
7. **Ecosystem**: Available plugins, components, and tools
8. **Job Market**: Career opportunities and hiring considerations

**12. Micro-Frontends and Framework Interoperability**

```javascript
// Example of module federation with webpack for micro-frontends
// webpack.config.js for a React micro-frontend
const { ModuleFederationPlugin } = require('webpack').container;

module.exports = {
  // ... other webpack config
  plugins: [
    new ModuleFederationPlugin({
      name: 'reactApp',
      filename: 'remoteEntry.js',
      exposes: {
        './Counter': './src/components/Counter',
      },
      shared: ['react', 'react-dom'],
    }),
  ],
};
```

**Key Takeaways:**

1. React excels in flexibility and ecosystem size, making it ideal for complex SPAs and cross-platform development
2. Vue.js offers an excellent balance of simplicity and power, perfect for teams transitioning to modern frameworks
3. Angular provides a comprehensive solution for enterprise applications with strong typing and tooling
4. Svelte and Solid.js represent the new generation of compile-time frameworks with excellent performance characteristics
5. Preact offers React compatibility with a fraction of the size, ideal for performance-critical applications
6. Ember.js emphasizes conventions and stability for long-lived applications
7. Alpine.js provides jQuery-like simplicity for enhancing server-rendered HTML
8. State management approaches vary widely, from centralized (Redux) to reactive (MobX) to hooks-based (Zustand)
9. Framework selection should be based on project requirements, team experience, and specific constraints
10. Modern architecture patterns like micro-frontends allow multiple frameworks to coexist in the same application

## Advanced JavaScript Topics

### Q74: Explain JavaScript memory management and garbage collection. How can you identify and fix memory leaks in JavaScript applications?
**Difficulty: Hard**

**Answer:**
Memory management in JavaScript is largely automatic through the process of garbage collection, but understanding how it works and how to avoid memory leaks is crucial for building performant applications, especially for long-running applications like SPAs.

**1. JavaScript Memory Allocation**

When we create variables, functions, objects, or any data structures in JavaScript, memory is automatically allocated:

```javascript
// Memory is allocated for these variables
let number = 123;                // Primitive value stored on stack
let string = "Hello, world!";    // Primitive value stored on stack
let object = {                   // Reference stored on stack, object on heap
  name: "John",
  age: 30
};
let array = [1, 2, 3, 4, 5];     // Reference stored on stack, array on heap
let function = () => console.log("Hello"); // Function object stored on heap
```

JavaScript uses two main memory locations:

- **Stack**: For primitive values (numbers, strings, booleans, undefined, null, symbols, and BigInt) and references to objects/functions
- **Heap**: For objects, arrays, functions, and other complex data structures

**2. JavaScript Garbage Collection**

JavaScript uses automatic garbage collection to reclaim memory that's no longer needed. The main algorithm used is called "Mark and Sweep":

1. **Mark**: The garbage collector identifies and marks all objects that are still reachable from the root (global object).
2. **Sweep**: It then removes all objects that weren't marked in the first phase.

```javascript
// Example of garbage collection in action
function createObjects() {
  let obj1 = { name: "Object 1" }; // Allocated on heap
  let obj2 = { name: "Object 2" }; // Allocated on heap
  
  return obj1; // obj1 is returned and remains accessible
  // obj2 becomes unreachable after function execution
  // and will be garbage collected
}

let result = createObjects();
console.log(result); // { name: "Object 1" }
// obj2 is no longer accessible and its memory can be reclaimed
```

Modern JavaScript engines like V8 (Chrome, Node.js) use more sophisticated garbage collection algorithms:

- **Generational Collection**: Objects are divided into "young" and "old" generations
- **Incremental Collection**: Dividing the garbage collection work into smaller chunks
- **Concurrent Collection**: Running garbage collection in parallel with the main program

**3. Common Causes of Memory Leaks**

**a. Unintentional Global Variables**

```javascript
// Leak: Missing 'let', 'const', or 'var' creates a global variable
function leakyFunction() {
  leakyVariable = "I am leaking into global scope";
}

// Fix: Declare variables properly
function fixedFunction() {
  'use strict'; // Helps catch undeclared variables
  let safeVariable = "I am properly scoped";
}
```

**b. Forgotten Timers and Callbacks**

```javascript
// Leak: Timer reference keeps the associated data in memory
function startTimer(data) {
  setInterval(() => {
    // This keeps 'data' in memory even if it's not needed elsewhere
    console.log(data);
  }, 1000);
}

// Fix: Store and clear the timer
let timerId;
function startTimerFixed(data) {
  timerId = setInterval(() => {
    console.log(data);
  }, 1000);
}

function stopTimer() {
  clearInterval(timerId);
  // Now the interval callback and its referenced data can be garbage collected
}
```

**c. Closures Retaining References**

```javascript
// Leak: Closure retains reference to largeData
function setupCallback() {
  const largeData = new Array(1000000).fill('X');
  
  document.getElementById('button').addEventListener('click', function() {
    // This callback retains reference to largeData
    console.log('Button clicked, data length:', largeData.length);
  });
}

// Fix: Only keep what you need
function setupCallbackFixed() {
  const largeData = new Array(1000000).fill('X');
  const dataLength = largeData.length; // Extract only what's needed
  
  document.getElementById('button').addEventListener('click', function() {
    // This callback only retains the length value, not the entire array
    console.log('Button clicked, data length:', dataLength);
  });
  
  // largeData can now be garbage collected after function execution
}
```

**d. DOM References Outside the DOM**

```javascript
// Leak: Storing DOM element references
let elements = {
  button: document.getElementById('button'),
  div: document.getElementById('div'),
  span: document.getElementById('span')
};

// If we remove the button from DOM but keep the reference
document.body.removeChild(document.getElementById('button'));
// The button element is still in memory because of our reference in 'elements'

// Fix: Update or delete references when elements are removed
function removeButton() {
  document.body.removeChild(document.getElementById('button'));
  delete elements.button; // Remove the reference
}
```

**e. Circular References**

```javascript
// Leak: Circular references (modern GC can handle these, but they're still problematic)
function createCircularReference() {
  let obj1 = {};
  let obj2 = {};
  
  obj1.ref = obj2;
  obj2.ref = obj1;
  
  return obj1;
}

// Fix: Break the reference when no longer needed
function cleanupCircularReference(obj) {
  obj.ref = null;
}

let obj = createCircularReference();
// When done with the objects
cleanupCircularReference(obj);
obj = null;
```

**f. Event Listeners**

```javascript
// Leak: Adding event listeners without removing them
function addHandlers() {
  document.getElementById('button').addEventListener('click', handleClick);
}

function handleClick() {
  console.log('Button clicked');
}

// If the button is removed but the listener isn't, it can cause a leak

// Fix: Remove event listeners when no longer needed
function removeHandlers() {
  document.getElementById('button').removeEventListener('click', handleClick);
}

// Or use the once option
document.getElementById('button').addEventListener('click', handleClick, { once: true });
```

**4. Identifying Memory Leaks**

**a. Chrome DevTools Memory Panel**

```javascript
// Example workflow for using Chrome DevTools to find memory leaks

// 1. Take a heap snapshot before the suspected leak
// 2. Perform the actions that might cause a leak
// 3. Take another heap snapshot
// 4. Use the comparison view to identify objects that weren't garbage collected

// Example of a function that might leak memory
function potentialLeak() {
  window.leakyData = new Array(1000000).fill('potentially leaky data');
}
```

**b. Performance Monitor**

```javascript
// Monitor memory usage over time to identify growing memory consumption
// In Chrome DevTools:
// 1. Open the Performance tab
// 2. Check "Memory" checkbox
// 3. Click Record
// 4. Perform actions in your app
// 5. Stop recording and analyze the memory graph
```

**c. Heap Size Timeline**

```javascript
// Use Performance.memory API to monitor heap size
function checkMemory() {
  if (window.performance && window.performance.memory) {
    console.log('Total JS heap size:', window.performance.memory.totalJSHeapSize);
    console.log('Used JS heap size:', window.performance.memory.usedJSHeapSize);
  }
}

// Call periodically to monitor memory growth
setInterval(checkMemory, 1000);
```

**5. Memory Leak Prevention Patterns**

**a. Weak References with WeakMap and WeakSet**

```javascript
// Using WeakMap to store references that shouldn't prevent garbage collection
const cache = new WeakMap();

function processUser(user) {
  if (cache.has(user)) {
    return cache.get(user);
  }
  
  const result = expensiveOperation(user);
  cache.set(user, result);
  return result;
}

// When the user object has no other references, both the user object
// and its cached data can be garbage collected
```

**b. Dispose Pattern**

```javascript
// Implementing a dispose pattern for cleanup
class ResourceManager {
  constructor() {
    this.resources = [];
  }
  
  addResource(resource) {
    this.resources.push(resource);
  }
  
  dispose() {
    // Clean up all resources
    this.resources.forEach(resource => {
      resource.close(); // Assuming resources have a close method
    });
    this.resources = [];
  }
}

const manager = new ResourceManager();
// Add resources...

// When done
manager.dispose();
```

**c. Module Pattern for Controlled References**

```javascript
// Using module pattern to control references
const dataModule = (function() {
  let largeData = null;
  
  return {
    initialize: function() {
      largeData = new Array(1000000).fill('X');
    },
    process: function() {
      // Process the data
      console.log('Processing data of length:', largeData.length);
    },
    cleanup: function() {
      largeData = null; // Allow garbage collection
    }
  };
})();

dataModule.initialize();
dataModule.process();
dataModule.cleanup(); // Explicitly release the reference
```

**d. Using AbortController for Fetch Requests**

```javascript
// Cancellable fetch requests to prevent memory leaks
function fetchWithTimeout(url, timeoutMs) {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);
  
  return fetch(url, { signal: controller.signal })
    .then(response => {
      clearTimeout(timeout);
      return response;
    })
    .catch(error => {
      clearTimeout(timeout);
      throw error;
    });
}

// Usage
try {
  const response = await fetchWithTimeout('https://api.example.com/data', 5000);
  const data = await response.json();
  console.log(data);
} catch (error) {
  if (error.name === 'AbortError') {
    console.log('Request timed out');
  } else {
    console.error('Fetch error:', error);
  }
}
```

**6. Memory Management Best Practices**

**a. Limit Variable Scope**

```javascript
// Good: Variables are scoped to where they're needed
function processData(data) {
  // result only exists within this function
  const result = heavyComputation(data);
  return result;
}

// Avoid global state when possible
```

**b. Nullify References When Done**

```javascript
// Explicitly clear references to large objects when no longer needed
function loadData() {
  let largeData = fetchLargeData();
  processData(largeData);
  largeData = null; // Explicitly clear the reference
}
```

**c. Use Object Pooling for Frequent Allocations**

```javascript
// Object pooling for frequently created/destroyed objects
class ObjectPool {
  constructor(createFn, initialSize = 10) {
    this.createFn = createFn;
    this.pool = [];
    
    // Initialize pool
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.createFn());
    }
  }
  
  get() {
    if (this.pool.length > 0) {
      return this.pool.pop();
    }
    return this.createFn();
  }
  
  release(obj) {
    this.pool.push(obj);
  }
}

// Usage
const vectorPool = new ObjectPool(() => ({ x: 0, y: 0 }));

function simulateParticles() {
  const vector = vectorPool.get();
  vector.x = Math.random();
  vector.y = Math.random();
  
  // Use the vector...
  
  // Return to pool when done instead of letting it be garbage collected
  vectorPool.release(vector);
}
```

**d. Debounce DOM Updates**

```javascript
// Debounce functions to prevent excessive memory allocations
function debounce(func, wait) {
  let timeout;
  
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// Usage
const debouncedUpdate = debounce(() => {
  // DOM update that might allocate memory
  document.getElementById('result').innerHTML = calculateResult();
}, 250);

// Attach to an event that fires frequently
window.addEventListener('resize', debouncedUpdate);
```

**e. Use Web Workers for Memory-Intensive Tasks**

```javascript
// Offload memory-intensive operations to Web Workers
// main.js
const worker = new Worker('worker.js');

worker.onmessage = function(event) {
  console.log('Result from worker:', event.data);
};

worker.postMessage({ data: largeDataSet });

// worker.js
self.onmessage = function(event) {
  const result = processLargeData(event.data.data);
  self.postMessage(result);
};

function processLargeData(data) {
  // Memory-intensive operation happens in a separate memory space
  // When done, the worker's memory can be garbage collected
  return data.map(x => x * 2);
}
```

**7. Tools for Memory Profiling**

**a. Chrome DevTools**

- **Memory Panel**: Take heap snapshots and compare them
- **Performance Panel**: Record memory usage over time
- **Allocation Timeline**: See where and when allocations happen

**b. Node.js Memory Profiling**

```javascript
// Using Node.js built-in memory usage functions
const memoryUsage = process.memoryUsage();
console.log(memoryUsage);
/*
{
  rss: 30932992,      // Resident Set Size - total memory allocated
  heapTotal: 7376896, // Total size of the allocated heap
  heapUsed: 4153936,  // Actual memory used during execution
  external: 9059      // Memory used by C++ objects bound to JS
}
*/

// Using the --inspect flag to profile Node.js applications with Chrome DevTools
// Run: node --inspect server.js
// Then open chrome://inspect in Chrome
```

**c. Memory Leak Detection Libraries**

```javascript
// Example with memory-stats.js for real-time monitoring
// Include the library
// <script src="memory-stats.js"></script>

// Initialize and append to DOM
const stats = new MemoryStats();
stats.domElement.style.position = 'fixed';
stats.domElement.style.right = '0px';
stats.domElement.style.bottom = '0px';
document.body.appendChild(stats.domElement);

// Update on each frame
requestAnimationFrame(function rAFloop() {
  stats.update();
  requestAnimationFrame(rAFloop);
});
```

**Key Takeaways:**

1. JavaScript uses automatic garbage collection to manage memory, primarily through the Mark and Sweep algorithm
2. Memory leaks occur when references to objects are unintentionally retained, preventing garbage collection
3. Common causes of memory leaks include global variables, forgotten timers, closures retaining large objects, and DOM references
4. Chrome DevTools provides powerful memory profiling capabilities through heap snapshots and performance monitoring
5. WeakMap and WeakSet allow you to store references that don't prevent garbage collection
6. Implementing proper cleanup patterns like dispose methods and nullifying references helps prevent memory leaks
7. Object pooling can reduce garbage collection pressure for frequently created and destroyed objects
8. Web Workers can isolate memory-intensive operations in a separate memory space
9. Regular memory profiling should be part of the development process for complex applications
10. Understanding memory management is crucial for building performant long-running JavaScript applications

### Q75: Explain JavaScript's concurrency model and event loop. How does JavaScript handle asynchronous operations despite being single-threaded?
**Difficulty: Hard**

**Answer:**
JavaScript's concurrency model is based on an event loop, which enables it to handle asynchronous operations despite being single-threaded. Understanding this model is crucial for writing efficient JavaScript code, especially for applications that deal with I/O operations, timers, and user interactions.

**1. JavaScript's Single-Threaded Nature**

JavaScript is fundamentally single-threaded, meaning it can execute only one operation at a time in a single call stack:

```javascript
// Simple synchronous operations execute one after another
console.log("First");
console.log("Second");
console.log("Third");

// Output will always be:
// First
// Second
// Third
```

This single-threaded execution model makes JavaScript predictable and easier to reason about, but it also presents challenges for operations that take time to complete, such as:

- Network requests
- File I/O operations
- Complex computations
- Timers and intervals

**2. The JavaScript Runtime Environment**

The JavaScript runtime environment consists of several components:

- **Call Stack**: Where function calls are tracked
- **Heap**: Memory allocation happens here
- **Event Queue (or Callback Queue)**: Where callbacks from asynchronous operations wait
- **Event Loop**: Constantly checks if the call stack is empty and moves callbacks from the queue to the stack
- **Web APIs/Node APIs**: Browser or Node.js provided APIs that handle asynchronous operations

**3. The Event Loop Explained**

Here's how the event loop works:

```javascript
// Simplified visualization of the event loop
console.log("Start");

setTimeout(() => {
  console.log("Timeout callback");
}, 0);

Promise.resolve().then(() => {
  console.log("Promise callback");
});

console.log("End");

// Output will be:
// Start
// End
// Promise callback
// Timeout callback
```

The execution sequence:

1. `console.log("Start")` is pushed onto the call stack and executed immediately
2. `setTimeout` is processed, and its callback is sent to the Web APIs environment
3. Even with a delay of 0ms, the callback is placed in the task queue (macrotask queue)
4. `Promise.resolve().then()` is processed, and its callback is placed in the microtask queue
5. `console.log("End")` is pushed onto the call stack and executed immediately
6. The call stack is now empty, so the event loop checks the microtask queue first
7. The Promise callback is moved to the call stack and executed
8. The event loop checks the microtask queue again (it's empty now)
9. The event loop checks the task queue and finds the setTimeout callback
10. The setTimeout callback is moved to the call stack and executed

**4. Macrotasks vs. Microtasks**

The event loop prioritizes tasks in a specific order:

**Microtasks**:
- Promise callbacks (`.then()`, `.catch()`, `.finally()`)
- `queueMicrotask()` callbacks
- `MutationObserver` callbacks

**Macrotasks**:
- `setTimeout` and `setInterval` callbacks
- UI rendering
- Event callbacks
- `postMessage` and `MessageChannel`
- `setImmediate` (in Node.js)

```javascript
// Demonstrating microtask and macrotask queues
console.log("Script start");

setTimeout(() => {
  console.log("setTimeout 1");
}, 0);

queueMicrotask(() => {
  console.log("queueMicrotask 1");
});
\Promise.resolve().then(() => {
  console.log("Promise 1");
  queueMicrotask(() => {
    console.log("queueMicrotask 2");
  });
}).then(() => {
  console.log("Promise 2");
});

setTimeout(() => {
  console.log("setTimeout 2");
}, 0);

console.log("Script end");

// Output will be:
// Script start
// Script end
// queueMicrotask 1
// Promise 1
// queueMicrotask 2
// Promise 2
// setTimeout 1
// setTimeout 2
```

**5. Asynchronous Patterns in JavaScript**

**a. Callbacks**

The traditional way to handle asynchronous operations:

```javascript
// Callback pattern
function fetchData(callback) {
  setTimeout(() => {
    const data = { id: 1, name: "JavaScript" };
    callback(null, data); // null for error (first parameter by convention)
  }, 1000);
}

fetchData((error, data) => {
  if (error) {
    console.error("Error:", error);
    return;
  }
  console.log("Data received:", data);
});

console.log("Fetching data...");

// Output:
// Fetching data...
// (after 1 second) Data received: { id: 1, name: "JavaScript" }
```

**b. Promises**

Promises provide a more structured way to handle asynchronous operations:

```javascript
// Promise pattern
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const data = { id: 1, name: "JavaScript" };
      resolve(data);
      // In case of error: reject(new Error("Failed to fetch data"));
    }, 1000);
  });
}

fetchData()
  .then(data => {
    console.log("Data received:", data);
    return processData(data);
  })
  .then(processedData => {
    console.log("Processed data:", processedData);
  })
  .catch(error => {
    console.error("Error:", error);
  });

console.log("Fetching data...");

function processData(data) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve({ ...data, processed: true });
    }, 500);
  });
}

// Output:
// Fetching data...
// (after 1 second) Data received: { id: 1, name: "JavaScript" }
// (after 1.5 seconds) Processed data: { id: 1, name: "JavaScript", processed: true }
```

**c. Async/Await**

Async/await provides a more synchronous-looking way to write asynchronous code:

```javascript
// Async/await pattern
async function fetchAndProcessData() {
  try {
    console.log("Fetching data...");
    const data = await fetchData(); // fetchData returns a Promise
    console.log("Data received:", data);
    
    const processedData = await processData(data);
    console.log("Processed data:", processedData);
    
    return processedData;
  } catch (error) {
    console.error("Error:", error);
  }
}

// This is still asynchronous, but looks synchronous
fetchAndProcessData().then(result => {
  console.log("Final result:", result);
});

console.log("Started fetching process");

// Output:
// Started fetching process
// Fetching data...
// (after 1 second) Data received: { id: 1, name: "JavaScript" }
// (after 1.5 seconds) Processed data: { id: 1, name: "JavaScript", processed: true }
// (after 1.5 seconds) Final result: { id: 1, name: "JavaScript", processed: true }
```

**6. The Call Stack and Stack Traces**

When functions are called, they are added to the call stack. When an error occurs, the stack trace shows the path of execution:

```javascript
// Call stack demonstration
function firstFunction() {
  secondFunction();
}

function secondFunction() {
  thirdFunction();
}

function thirdFunction() {
  throw new Error("An error occurred!");
}

try {
  firstFunction();
} catch (error) {
  console.log(error.stack);
  // Error: An error occurred!
  //   at thirdFunction
  //   at secondFunction
  //   at firstFunction
  //   at <anonymous>
}
```

However, with asynchronous code, the stack trace can be less helpful because the original call stack is lost when the callback is executed later:

```javascript
// Asynchronous stack trace issue
function asyncOperation() {
  setTimeout(() => {
    throw new Error("Async error!");
  }, 0);
}

try {
  asyncOperation();
} catch (error) {
  // This will never catch the error!
  console.log("Caught:", error);
}

// Output:
// Uncaught Error: Async error!
//   at <anonymous> (line number)
// Notice how the stack trace doesn't include asyncOperation
```

**7. Handling Long-Running Tasks**

Since JavaScript is single-threaded, long-running tasks can block the main thread and make the UI unresponsive. There are several ways to handle this:

**a. Chunking Work with setTimeout**

```javascript
// Breaking up a long task
function processLargeArray(array, chunkSize = 1000) {
  let index = 0;
  
  function processChunk() {
    const chunk = array.slice(index, index + chunkSize);
    
    // Process the current chunk
    chunk.forEach(item => {
      // Do something with item
      console.log(`Processing item ${item}`);
    });
    
    index += chunkSize;
    
    if (index < array.length) {
      // Schedule the next chunk
      setTimeout(processChunk, 0);
    } else {
      console.log("Processing complete!");
    }
  }
  
  processChunk();
}

// Create a large array
const largeArray = Array.from({ length: 10000 }, (_, i) => i);
processLargeArray(largeArray);
```

**b. Using requestAnimationFrame for Visual Updates**

```javascript
// Using requestAnimationFrame for smooth animations
function animateElement(element, duration) {
  const start = performance.now();
  
  function update(currentTime) {
    const elapsed = currentTime - start;
    const progress = Math.min(elapsed / duration, 1);
    
    // Update element style based on progress
    element.style.transform = `translateX(${progress * 100}px)`;
    
    if (progress < 1) {
      // Schedule the next frame
      requestAnimationFrame(update);
    }
  }
  
  requestAnimationFrame(update);
}

const box = document.getElementById("box");
animateElement(box, 1000); // Animate for 1 second
```

**c. Web Workers for CPU-Intensive Tasks**

```javascript
// main.js
const worker = new Worker("worker.js");

worker.onmessage = function(event) {
  console.log("Result from worker:", event.data);
};

worker.postMessage({
  numbers: Array.from({ length: 10000000 }, (_, i) => i)
});

console.log("Worker started, UI remains responsive!");

// worker.js
self.onmessage = function(event) {
  const numbers = event.data.numbers;
  
  // CPU-intensive task: calculate prime numbers
  const primes = numbers.filter(isPrime);
  
  self.postMessage({
    count: primes.length,
    firstTen: primes.slice(0, 10)
  });
};

function isPrime(num) {
  if (num <= 1) return false;
  if (num <= 3) return true;
  if (num % 2 === 0 || num % 3 === 0) return false;
  
  let i = 5;
  while (i * i <= num) {
    if (num % i === 0 || num % (i + 2) === 0) return false;
    i += 6;
  }
  return true;
}
```

**8. Node.js Event Loop vs. Browser Event Loop**

While the core concept is the same, there are some differences between Node.js and browser event loops:

**Browser Event Loop**:
- Managed by the browser
- Handles DOM events, user interactions, and rendering
- Has Web APIs like `setTimeout`, `fetch`, and DOM APIs

**Node.js Event Loop**:
- Managed by libuv library
- Handles file system operations, network I/O, and timers
- Has additional phases (timers, pending callbacks, idle/prepare, poll, check, close callbacks)
- Provides additional APIs like `setImmediate` and `process.nextTick`

```javascript
// Node.js specific event loop example
console.log("Start");

setTimeout(() => {
  console.log("setTimeout");
}, 0);

setImmediate(() => {
  console.log("setImmediate");
});

process.nextTick(() => {
  console.log("nextTick");
});

console.log("End");

// Output will be:
// Start
// End
// nextTick
// setTimeout
// setImmediate
// (Note: setTimeout and setImmediate order can vary depending on system load)
```

**9. Common Pitfalls and Best Practices**

**a. Callback Hell**

```javascript
// Callback hell (anti-pattern)
getUser(userId, function(user) {
  getUserPosts(user.id, function(posts) {
    getPostComments(posts[0].id, function(comments) {
      getCommentAuthor(comments[0].authorId, function(author) {
        // Deeply nested and hard to maintain
        console.log(author);
      }, handleError);
    }, handleError);
  }, handleError);
}, handleError);

// Better with Promises
getUser(userId)
  .then(user => getUserPosts(user.id))
  .then(posts => getPostComments(posts[0].id))
  .then(comments => getCommentAuthor(comments[0].authorId))
  .then(author => console.log(author))
  .catch(handleError);

// Even better with async/await
async function fetchAuthorDetails(userId) {
  try {
    const user = await getUser(userId);
    const posts = await getUserPosts(user.id);
    const comments = await getPostComments(posts[0].id);
    const author = await getCommentAuthor(comments[0].authorId);
    console.log(author);
  } catch (error) {
    handleError(error);
  }
}
```

**b. Forgetting to Handle Promise Rejections**

```javascript
// Missing error handling (anti-pattern)
fetch("https://api.example.com/data")
  .then(response => response.json())
  .then(data => console.log(data));
  // No .catch() to handle errors!

// Proper error handling
fetch("https://api.example.com/data")
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error("Fetch error:", error));
```

**c. Blocking the Main Thread**

```javascript
// Blocking the main thread (anti-pattern)
function calculatePrimes(max) {
  const primes = [];
  for (let i = 2; i <= max; i++) {
    if (isPrime(i)) primes.push(i);
  }
  return primes;
}

// If max is large, this will freeze the UI
const primes = calculatePrimes(10000000);

// Better: Use a Web Worker or chunk the work
const worker = new Worker("primes-worker.js");
worker.onmessage = event => console.log(event.data);
worker.postMessage({ max: 10000000 });
```

**d. Race Conditions**

```javascript
// Potential race condition
let data = null;

fetch("https://api.example.com/data1")
  .then(response => response.json())
  .then(result => {
    data = result; // This might happen after the second fetch completes
  });

fetch("https://api.example.com/data2")
  .then(response => response.json())
  .then(result => {
    data = result; // This might overwrite the first result
  });

// Better: Use Promise.all to handle multiple fetches
Promise.all([
  fetch("https://api.example.com/data1").then(response => response.json()),
  fetch("https://api.example.com/data2").then(response => response.json())
])
.then(([data1, data2]) => {
  // Both results are available here in the correct order
  console.log(data1, data2);
})
.catch(error => console.error("Error:", error));
```

**10. Advanced Patterns**

**a. Custom Promise Implementation**

```javascript
// Simplified Promise implementation to understand the concept
class MyPromise {
  constructor(executor) {
    this.state = "pending";
    this.value = undefined;
    this.reason = undefined;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];
    
    const resolve = value => {
      if (this.state === "pending") {
        this.state = "fulfilled";
        this.value = value;
        this.onFulfilledCallbacks.forEach(callback => callback(this.value));
      }
    };
    
    const reject = reason => {
      if (this.state === "pending") {
        this.state = "rejected";
        this.reason = reason;
        this.onRejectedCallbacks.forEach(callback => callback(this.reason));
      }
    };
    
    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }
  
  then(onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : value => value;
    onRejected = typeof onRejected === "function" ? onRejected : reason => { throw reason; };
    
    const promise2 = new MyPromise((resolve, reject) => {
      if (this.state === "fulfilled") {
        setTimeout(() => {
          try {
            const x = onFulfilled(this.value);
            resolve(x);
          } catch (error) {
            reject(error);
          }
        }, 0);
      }
      
      if (this.state === "rejected") {
        setTimeout(() => {
          try {
            const x = onRejected(this.reason);
            resolve(x);
          } catch (error) {
            reject(error);
          }
        }, 0);
      }
      
      if (this.state === "pending") {
        this.onFulfilledCallbacks.push(value => {
          setTimeout(() => {
            try {
              const x = onFulfilled(value);
              resolve(x);
            } catch (error) {
              reject(error);
            }
          }, 0);
        });
        
        this.onRejectedCallbacks.push(reason => {
          setTimeout(() => {
            try {
              const x = onRejected(reason);
              resolve(x);
            } catch (error) {
              reject(error);
            }
          }, 0);
        });
      }
    });
    
    return promise2;
  }
  
  catch(onRejected) {
    return this.then(null, onRejected);
  }
  
  static resolve(value) {
    return new MyPromise(resolve => resolve(value));
  }
  
  static reject(reason) {
    return new MyPromise((_, reject) => reject(reason));
  }
}

// Usage
const promise = new MyPromise((resolve, reject) => {
  setTimeout(() => {
    resolve("Success!");
  }, 1000);
});

promise
  .then(value => {
    console.log(value); // "Success!"
    return "Next value";
  })
  .then(value => {
    console.log(value); // "Next value"
  })
  .catch(error => {
    console.error(error);
  });
```

**b. Async Iterators and Generators**

```javascript
// Async generator function
async function* fetchPages(baseUrl, maxPages) {
  let page = 1;
  
  while (page <= maxPages) {
    const url = `${baseUrl}?page=${page}`;
    const response = await fetch(url);
    const data = await response.json();
    
    yield data;
    
    if (data.isLastPage || data.items.length === 0) {
      break;
    }
    
    page++;
  }
}

// Using the async generator
(async () => {
  const pageIterator = fetchPages("https://api.example.com/items", 5);
  
  for await (const pageData of pageIterator) {
    console.log(`Received page with ${pageData.items.length} items`);
    // Process each page as it arrives
    processItems(pageData.items);
  }
  
  console.log("All pages processed");
})();

function processItems(items) {
  // Process the items
  items.forEach(item => console.log(`Processing item ${item.id}`));
}
```

**c. Cancellable Promises with AbortController**

```javascript
// Cancellable fetch with AbortController
function fetchWithTimeout(url, options = {}, timeoutMs = 5000) {
  const controller = new AbortController();
  const { signal } = controller;
  
  // Create a timeout that will abort the fetch
  const timeout = setTimeout(() => {
    controller.abort();
  }, timeoutMs);
  
  return fetch(url, { ...options, signal })
    .then(response => {
      clearTimeout(timeout);
      return response;
    })
    .catch(error => {
      clearTimeout(timeout);
      if (error.name === "AbortError") {
        throw new Error(`Request timed out after ${timeoutMs}ms`);
      }
      throw error;
    });
}

// Usage
const fetchButton = document.getElementById("fetchButton");
const cancelButton = document.getElementById("cancelButton");
let controller;

fetchButton.addEventListener("click", async () => {
  try {
    controller = new AbortController();
    const response = await fetch("https://api.example.com/large-data", {
      signal: controller.signal
    });
    const data = await response.json();
    console.log("Data received:", data);
  } catch (error) {
    if (error.name === "AbortError") {
      console.log("Fetch was cancelled");
    } else {
      console.error("Fetch error:", error);
    }
  }
});

cancelButton.addEventListener("click", () => {
  if (controller) {
    controller.abort();
    console.log("Fetch cancelled");
  }
});
```

**Key Takeaways:**

1. JavaScript is single-threaded but can handle asynchronous operations through the event loop
2. The event loop constantly checks if the call stack is empty and moves callbacks from the queue to the stack
3. Microtasks (Promises) have priority over macrotasks (setTimeout, events) in the event loop
4. Callbacks, Promises, and async/await are different patterns for handling asynchronous code
5. Promises provide a more structured approach to asynchronous programming than callbacks
6. Async/await offers a synchronous-looking syntax for asynchronous code, making it more readable
7. Long-running tasks should be broken up or offloaded to Web Workers to avoid blocking the main thread
8. The Node.js event loop has additional phases compared to the browser event loop
9. Common pitfalls include callback hell, unhandled promise rejections, and race conditions
10. Advanced patterns like async generators and AbortController provide more control over asynchronous operations

### Q76: Explain common JavaScript design patterns. How and when would you implement them?
**Difficulty: Hard**

**Answer:**
Design patterns are reusable solutions to common programming problems. In JavaScript, understanding these patterns is crucial for writing maintainable, scalable, and robust code. Let's explore the most important JavaScript design patterns, their implementations, and when to use them.

**1. Creational Patterns**

Creational patterns focus on object creation mechanisms, trying to create objects in a manner suitable to the situation.

**a. Constructor Pattern**

The constructor pattern uses a special constructor function to initialize a newly created object.

```javascript
// Constructor pattern
function User(name, email) {
  this.name = name;
  this.email = email;
  
  this.sayHello = function() {
    return `Hello, my name is ${this.name}`;
  };
}

// Usage
const user1 = new User('John', 'john@example.com');
const user2 = new User('Jane', 'jane@example.com');

console.log(user1.sayHello()); // Hello, my name is John
console.log(user2.sayHello()); // Hello, my name is Jane
```

**When to use**: When you need to create multiple similar objects with the same properties and methods.

**Drawbacks**: Each instance creates its own copy of methods, which can be memory inefficient.

**b. Prototype Pattern**

The prototype pattern is an extension of the constructor pattern that addresses the memory inefficiency issue by sharing methods across all instances.

```javascript
// Prototype pattern
function User(name, email) {
  this.name = name;
  this.email = email;
}

// Methods added to prototype are shared across all instances
User.prototype.sayHello = function() {
  return `Hello, my name is ${this.name}`;
};

User.prototype.getEmail = function() {
  return this.email;
};

// Usage
const user1 = new User('John', 'john@example.com');
const user2 = new User('Jane', 'jane@example.com');

console.log(user1.sayHello()); // Hello, my name is John
console.log(user2.getEmail()); // jane@example.com

// Both instances share the same method implementation
console.log(user1.sayHello === user2.sayHello); // true
```

**When to use**: When you need to create many instances that share methods, to save memory.

**c. Module Pattern**

The module pattern uses closures to create private and public methods and variables, simulating the concept of encapsulation.

```javascript
// Module pattern
const userModule = (function() {
  // Private variables and functions
  let privateVar = 'I am private';
  
  function privateFunction() {
    return 'This is private';
  }
  
  // Public API
  return {
    publicVar: 'I am public',
    
    publicFunction: function() {
      return 'This is public';
    },
    
    // Public function that can access private members
    getData: function() {
      return `${privateVar}, ${privateFunction()}`;
    }
  };
})();

// Usage
console.log(userModule.publicVar); // I am public
console.log(userModule.publicFunction()); // This is public
console.log(userModule.getData()); // I am private, This is private
console.log(userModule.privateVar); // undefined (private)
```

**When to use**: When you need to organize your code with private and public members, preventing external code from accessing internal variables and functions.

**d. Singleton Pattern**

The singleton pattern ensures a class has only one instance and provides a global point of access to it.

```javascript
// Singleton pattern
const Database = (function() {
  let instance;
  
  // Private constructor
  function createInstance() {
    const object = new Object({
      connection: 'MongoDB',
      connect: function() {
        return 'Connected to database';
      },
      query: function(sql) {
        return `Executing query: ${sql}`;
      }
    });
    return object;
  }
  
  return {
    // Public method to get the instance
    getInstance: function() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

// Usage
const db1 = Database.getInstance();
const db2 = Database.getInstance();

console.log(db1 === db2); // true (same instance)
console.log(db1.connect()); // Connected to database
console.log(db2.query('SELECT * FROM users')); // Executing query: SELECT * FROM users
```

**When to use**: When exactly one instance of a class is needed, such as a connection to a database or a configuration manager.

**e. Factory Pattern**

The factory pattern provides an interface for creating objects without specifying their concrete classes.

```javascript
// Factory pattern
class UserFactory {
  createUser(type) {
    let user;
    
    if (type === 'admin') {
      user = new AdminUser();
    } else if (type === 'regular') {
      user = new RegularUser();
    } else if (type === 'guest') {
      user = new GuestUser();
    } else {
      throw new Error('Invalid user type');
    }
    
    user.type = type;
    
    return user;
  }
}

class AdminUser {
  constructor() {
    this.permissions = ['read', 'write', 'delete', 'admin'];
  }
  
  getPermissions() {
    return this.permissions;
  }
}

class RegularUser {
  constructor() {
    this.permissions = ['read', 'write'];
  }
  
  getPermissions() {
    return this.permissions;
  }
}

class GuestUser {
  constructor() {
    this.permissions = ['read'];
  }
  
  getPermissions() {
    return this.permissions;
  }
}

// Usage
const factory = new UserFactory();

const admin = factory.createUser('admin');
const regular = factory.createUser('regular');
const guest = factory.createUser('guest');

console.log(admin.getPermissions()); // ['read', 'write', 'delete', 'admin']
console.log(regular.getPermissions()); // ['read', 'write']
console.log(guest.getPermissions()); // ['read']
```

**When to use**: When your code needs to work with various related classes without specifying their concrete types.

**2. Structural Patterns**

Structural patterns are concerned with how classes and objects are composed to form larger structures.

**a. Decorator Pattern**

The decorator pattern dynamically adds new behaviors to objects without affecting the behavior of other objects from the same class.

```javascript
// Decorator pattern
// Base component
class Coffee {
  getCost() {
    return 5; // Base cost
  }
  
  getDescription() {
    return 'Plain coffee';
  }
}

// Decorator
class MilkDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }
  
  getCost() {
    return this.coffee.getCost() + 1; // Add milk cost
  }
  
  getDescription() {
    return `${this.coffee.getDescription()} with milk`;
  }
}

// Another decorator
class SugarDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }
  
  getCost() {
    return this.coffee.getCost() + 0.5; // Add sugar cost
  }
  
  getDescription() {
    return `${this.coffee.getDescription()} with sugar`;
  }
}

// Usage
let coffee = new Coffee();
console.log(`${coffee.getDescription()}: $${coffee.getCost()}`); // Plain coffee: $5

// Decorate with milk
coffee = new MilkDecorator(coffee);
console.log(`${coffee.getDescription()}: $${coffee.getCost()}`); // Plain coffee with milk: $6

// Decorate with sugar
coffee = new SugarDecorator(coffee);
console.log(`${coffee.getDescription()}: $${coffee.getCost()}`); // Plain coffee with milk with sugar: $6.5
```

**When to use**: When you need to add responsibilities to objects dynamically and transparently, without affecting other objects.

**b. Facade Pattern**

The facade pattern provides a simplified interface to a complex subsystem.

```javascript
// Facade pattern
// Complex subsystem components
class AudioPlayer {
  turnOn() {
    return 'Audio player turned on';
  }
  
  setVolume(level) {
    return `Volume set to ${level}`;
  }
  
  play(track) {
    return `Playing track: ${track}`;
  }
}

class Display {
  turnOn() {
    return 'Display turned on';
  }
  
  setBrightness(level) {
    return `Brightness set to ${level}`;
  }
  
  showMessage(message) {
    return `Displaying message: ${message}`;
  }
}

class PowerSupply {
  turnOn() {
    return 'Power supply turned on';
  }
}

// Facade
class EntertainmentSystemFacade {
  constructor() {
    this.audioPlayer = new AudioPlayer();
    this.display = new Display();
    this.powerSupply = new PowerSupply();
  }
  
  // Simplified interface
  turnOn() {
    const steps = [
      this.powerSupply.turnOn(),
      this.display.turnOn(),
      this.display.setBrightness(80),
      this.audioPlayer.turnOn(),
      this.audioPlayer.setVolume(50),
      this.display.showMessage('Entertainment system ready')
    ];
    
    return steps.join('\n');
  }
  
  playMusic(track) {
    return this.audioPlayer.play(track);
  }
}

// Usage
const system = new EntertainmentSystemFacade();
console.log(system.turnOn());
// Power supply turned on
// Display turned on
// Brightness set to 80
// Audio player turned on
// Volume set to 50
// Displaying message: Entertainment system ready

console.log(system.playMusic('Jazz')); // Playing track: Jazz
```

**When to use**: When you need to provide a simple interface to a complex system, or when there are many dependencies between clients and implementation classes.

**c. Proxy Pattern**

The proxy pattern provides a surrogate or placeholder for another object to control access to it.

```javascript
// Proxy pattern
// Real subject
class ExpensiveResource {
  constructor() {
    this.data = null;
    this.loaded = false;
  }
  
  load() {
    console.log('Loading expensive resource...');
    // Simulate expensive operation
    this.data = { content: 'Valuable data that was expensive to load' };
    this.loaded = true;
    return this.data;
  }
  
  getData() {
    return this.data;
  }
}

// Proxy
class ExpensiveResourceProxy {
  constructor() {
    this.resource = null;
  }
  
  // Lazy initialization
  getData() {
    if (!this.resource) {
      console.log('Creating resource on first access');
      this.resource = new ExpensiveResource();
    }
    
    if (!this.resource.loaded) {
      return this.resource.load();
    } else {
      console.log('Returning cached data');
      return this.resource.getData();
    }
  }
}

// Usage
const proxy = new ExpensiveResourceProxy();

// First access - creates and loads the resource
console.log(proxy.getData());
// Creating resource on first access
// Loading expensive resource...
// { content: 'Valuable data that was expensive to load' }

// Second access - uses cached data
console.log(proxy.getData());
// Returning cached data
// { content: 'Valuable data that was expensive to load' }
```

**When to use**: When you need to control access to an object, especially for lazy initialization, access control, logging, or caching.

**3. Behavioral Patterns**

Behavioral patterns are concerned with algorithms and the assignment of responsibilities between objects.

**a. Observer Pattern**

The observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

```javascript
// Observer pattern
class Subject {
  constructor() {
    this.observers = [];
  }
  
  subscribe(observer) {
    this.observers.push(observer);
  }
  
  unsubscribe(observer) {
    this.observers = this.observers.filter(obs => obs !== observer);
  }
  
  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }
  
  update(data) {
    console.log(`${this.name} received update: ${data}`);
  }
}

// Usage
const subject = new Subject();

const observer1 = new Observer('Observer 1');
const observer2 = new Observer('Observer 2');
const observer3 = new Observer('Observer 3');

subject.subscribe(observer1);
subject.subscribe(observer2);
subject.subscribe(observer3);

subject.notify('First notification');
// Observer 1 received update: First notification
// Observer 2 received update: First notification
// Observer 3 received update: First notification

subject.unsubscribe(observer2);

subject.notify('Second notification');
// Observer 1 received update: Second notification
// Observer 3 received update: Second notification
```

**When to use**: When changes to one object require changing others, and you don't know how many objects need to change. Common in event handling systems.

**b. Strategy Pattern**

The strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable.

```javascript
// Strategy pattern
// Context
class ShippingCalculator {
  constructor(strategy) {
    this.strategy = strategy;
  }
  
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  
  calculate(package) {
    return this.strategy.calculate(package);
  }
}

// Strategies
class FedExStrategy {
  calculate(package) {
    // FedEx specific calculation
    return `FedEx shipping cost: $${(package.weight * 4.5).toFixed(2)}`;
  }
}

class UPSStrategy {
  calculate(package) {
    // UPS specific calculation
    return `UPS shipping cost: $${(package.weight * 3.25 + 10).toFixed(2)}`;
  }
}

class USPSStrategy {
  calculate(package) {
    // USPS specific calculation
    return `USPS shipping cost: $${(package.weight * 2.5 + 5).toFixed(2)}`;
  }
}

// Usage
const package = { weight: 2, destination: 'New York' };

const calculator = new ShippingCalculator(new FedExStrategy());
console.log(calculator.calculate(package)); // FedEx shipping cost: $9.00

calculator.setStrategy(new UPSStrategy());
console.log(calculator.calculate(package)); // UPS shipping cost: $16.50

calculator.setStrategy(new USPSStrategy());
console.log(calculator.calculate(package)); // USPS shipping cost: $10.00
```

**When to use**: When you have multiple algorithms for a specific task and want to switch between them dynamically at runtime.

**c. Command Pattern**

The command pattern encapsulates a request as an object, allowing for parameterization of clients with different requests, queuing of requests, and logging of operations.

```javascript
// Command pattern
// Receiver
class Light {
  turnOn() {
    return 'Light turned on';
  }
  
  turnOff() {
    return 'Light turned off';
  }
}

// Command interface
class Command {
  execute() {}
  undo() {}
}

// Concrete commands
class TurnOnCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }
  
  execute() {
    return this.light.turnOn();
  }
  
  undo() {
    return this.light.turnOff();
  }
}

class TurnOffCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }
  
  execute() {
    return this.light.turnOff();
  }
  
  undo() {
    return this.light.turnOn();
  }
}

// Invoker
class RemoteControl {
  constructor() {
    this.history = [];
  }
  
  pressButton(command) {
    const result = command.execute();
    this.history.push(command);
    return result;
  }
  
  pressUndo() {
    if (this.history.length > 0) {
      const command = this.history.pop();
      return command.undo();
    }
    return 'No commands to undo';
  }
}

// Usage
const light = new Light();
const turnOn = new TurnOnCommand(light);
const turnOff = new TurnOffCommand(light);
const remote = new RemoteControl();

console.log(remote.pressButton(turnOn)); // Light turned on
console.log(remote.pressButton(turnOff)); // Light turned off
console.log(remote.pressUndo()); // Light turned on
console.log(remote.pressUndo()); // Light turned off
```

**When to use**: When you want to parameterize objects with operations, queue operations, support undoable operations, or structure a system around high-level operations.

**d. Iterator Pattern**

The iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

```javascript
// Iterator pattern
class Iterator {
  constructor(collection) {
    this.collection = collection;
    this.index = 0;
  }
  
  hasNext() {
    return this.index < this.collection.length;
  }
  
  next() {
    return this.hasNext() ? this.collection[this.index++] : null;
  }
  
  reset() {
    this.index = 0;
  }
}

class Collection {
  constructor() {
    this.items = [];
  }
  
  addItem(item) {
    this.items.push(item);
  }
  
  getIterator() {
    return new Iterator(this.items);
  }
  
  get length() {
    return this.items.length;
  }
}

// Usage
const collection = new Collection();
collection.addItem('Item 1');
collection.addItem('Item 2');
collection.addItem('Item 3');

const iterator = collection.getIterator();

while (iterator.hasNext()) {
  console.log(iterator.next());
}
// Item 1
// Item 2
// Item 3

iterator.reset();
console.log(iterator.next()); // Item 1
```

**When to use**: When you need to access elements of a collection without exposing its internal structure, or when you want to provide a standard way to iterate over different types of collections.

**e. Mediator Pattern**

The mediator pattern defines an object that encapsulates how a set of objects interact, promoting loose coupling by keeping objects from referring to each other explicitly.

```javascript
// Mediator pattern
// Mediator
class ChatRoom {
  constructor() {
    this.users = {};
  }
  
  register(user) {
    this.users[user.name] = user;
    user.chatroom = this;
    return `${user.name} registered in the chat room`;
  }
  
  send(message, fromUser, toUser) {
    if (toUser) {
      // Direct message
      return this.users[toUser].receive(message, fromUser);
    } else {
      // Broadcast message
      const messages = [];
      for (const key in this.users) {
        if (key !== fromUser) {
          messages.push(this.users[key].receive(message, fromUser));
        }
      }
      return messages;
    }
  }
}

// Colleagues
class User {
  constructor(name) {
    this.name = name;
    this.chatroom = null;
  }
  
  send(message, toUser) {
    return this.chatroom.send(message, this.name, toUser);
  }
  
  receive(message, fromUser) {
    return `${this.name} received from ${fromUser}: ${message}`;
  }
}

// Usage
const chatroom = new ChatRoom();

const john = new User('John');
const jane = new User('Jane');
const bob = new User('Bob');

console.log(chatroom.register(john));
console.log(chatroom.register(jane));
console.log(chatroom.register(bob));

// Direct message
console.log(john.send('Hi Jane!', 'Jane'));
// Jane received from John: Hi Jane!

// Broadcast message
console.log(jane.send('Hello everyone!'));
// ['John received from Jane: Hello everyone!', 'Bob received from Jane: Hello everyone!']
```

**When to use**: When a set of objects communicate in well-defined but complex ways, or when you want to centralize communication between related objects.

**4. Modern JavaScript Design Patterns**

**a. Module Pattern with ES6 Modules**

ES6 introduced native modules, which provide a cleaner way to implement the module pattern.

```javascript
// user.js
// Private variables and functions (not exported)
const privateVar = 'I am private';

function privateFunction() {
  return 'This is private';
}

// Public API (exported)
export const publicVar = 'I am public';

export function publicFunction() {
  return 'This is public';
}

export function getData() {
  return `${privateVar}, ${privateFunction()}`;
}

// main.js
import { publicVar, publicFunction, getData } from './user.js';

console.log(publicVar); // I am public
console.log(publicFunction()); // This is public
console.log(getData()); // I am private, This is private
```

**When to use**: When you need to organize your code into separate modules with clear public interfaces and private implementation details.

**b. Provider Pattern**

The provider pattern is commonly used in modern JavaScript frameworks to make data or functionality available to multiple components.

```javascript
// Provider pattern (React example)
import React, { createContext, useContext, useState } from 'react';

// Create a context
const ThemeContext = createContext();

// Provider component
export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
  };
  
  // Value provided to consumers
  const value = {
    theme,
    toggleTheme
  };
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

// Custom hook for consumers
export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
}

// Usage in a component
function ThemedButton() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <button 
      onClick={toggleTheme}
      style={{ 
        background: theme === 'light' ? '#fff' : '#333',
        color: theme === 'light' ? '#333' : '#fff'
      }}
    >
      Toggle Theme
    </button>
  );
}

// App component
function App() {
  return (
    <ThemeProvider>
      <div>
        <h1>Themed Application</h1>
        <ThemedButton />
      </div>
    </ThemeProvider>
  );
}
```

**When to use**: When you need to share state or functionality across multiple components in a component tree without prop drilling.

**c. Higher-Order Component (HOC) Pattern**

The HOC pattern is a function that takes a component and returns a new component with enhanced functionality.

```javascript
// Higher-Order Component pattern (React example)
import React from 'react';

// Higher-Order Component
function withLogging(WrappedComponent) {
  // Return a new component
  return function WithLoggingComponent(props) {
    console.log(`Component ${WrappedComponent.name} rendered with props:`, props);
    
    // Render the wrapped component with its props
    return <WrappedComponent {...props} />;
  };
}

// Simple component
function UserProfile({ name, email }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>{email}</p>
    </div>
  );
}

// Enhanced component with logging
const UserProfileWithLogging = withLogging(UserProfile);

// Usage
function App() {
  return (
    <div>
      <UserProfileWithLogging 
        name="John Doe" 
        email="john@example.com" 
      />
    </div>
  );
}
```

**When to use**: When you need to reuse component logic across multiple components, especially for cross-cutting concerns like logging, authentication, or data fetching.

**d. Render Props Pattern**

The render props pattern is a technique for sharing code between components using a prop whose value is a function.

```javascript
// Render Props pattern (React example)
import React, { useState } from 'react';

// Component with render prop
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  const handleMouseMove = (event) => {
    setPosition({
      x: event.clientX,
      y: event.clientY
    });
  };
  
  return (
    <div 
      style={{ height: '100vh' }}
      onMouseMove={handleMouseMove}
    >
      {/* Call the render prop function with the state */}
      {render(position)}
    </div>
  );
}

// Usage
function App() {
  return (
    <MouseTracker 
      render={({ x, y }) => (
        <div>
          <h1>Mouse Position</h1>
          <p>X: {x}, Y: {y}</p>
        </div>
      )}
    />
  );
}
```

**When to use**: When you need to share behavior between components while giving the consumer control over what gets rendered.

**e. Hooks Pattern (React)**

Hooks are a pattern introduced in React that allows you to use state and other React features without writing a class.

```javascript
// Custom Hook pattern (React example)
import { useState, useEffect } from 'react';

// Custom hook for fetching data
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        
        const result = await response.json();
        setData(result);
        setError(null);
      } catch (err) {
        setError(err.message);
        setData(null);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [url]);
  
  return { data, loading, error };
}

// Usage in a component
function UserList() {
  const { data, loading, error } = useFetch('https://api.example.com/users');
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <ul>
      {data && data.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

**When to use**: When you need to extract and reuse stateful logic between multiple components without changing their component hierarchy.

**5. Anti-Patterns to Avoid**

**a. Global Variables**

```javascript
// Anti-pattern: Global variables
var userData = { name: 'John' }; // Global variable

function updateUser() {
  userData.name = 'Jane'; // Modifying global state
}

function displayUser() {
  console.log(userData.name); // Depends on global state
}

// Better approach: Pass as parameters
function updateUser(userData) {
  return { ...userData, name: 'Jane' }; // Return new object
}

function displayUser(userData) {
  console.log(userData.name);
}

const user = { name: 'John' };
const updatedUser = updateUser(user);
displayUser(updatedUser);
```

**b. Callback Hell**

```javascript
// Anti-pattern: Callback hell
getUser(userId, function(user) {
  getUserPosts(user.id, function(posts) {
    getPostComments(posts[0].id, function(comments) {
      // Deeply nested and hard to maintain
    });
  });
});

// Better approach: Promises or async/await
async function getUserData(userId) {
  const user = await getUser(userId);
  const posts = await getUserPosts(user.id);
  const comments = await getPostComments(posts[0].id);
  return { user, posts, comments };
}
```

**c. Modifying Prototypes of Built-in Objects**

```javascript
// Anti-pattern: Modifying built-in prototypes
Array.prototype.first = function() {
  return this[0];
};

const arr = [1, 2, 3];
console.log(arr.first()); // 1

// Better approach: Create utility functions or extend with classes
function getFirst(array) {
  return array[0];
}

console.log(getFirst(arr)); // 1
```

**Key Takeaways:**

1. Design patterns provide reusable solutions to common programming problems in JavaScript
2. Creational patterns like Constructor, Factory, and Singleton help manage object creation
3. Structural patterns like Decorator, Facade, and Proxy focus on object composition and relationships
4. Behavioral patterns like Observer, Strategy, and Command deal with object interaction and responsibility
5. Modern JavaScript has introduced new patterns like ES6 Modules, Providers, and Hooks
6. The Module pattern helps organize code with private and public members
7. The Observer pattern is fundamental for event-driven programming in JavaScript
8. The Strategy pattern allows for interchangeable algorithms at runtime
9. Higher-Order Components and Render Props are powerful patterns for component composition in React
10. Understanding when to apply each pattern is as important as knowing how they work

### Q77: What are the common security vulnerabilities in JavaScript applications and how can you prevent them?
**Difficulty: Hard**

**Answer:**
Security is a critical aspect of JavaScript development, especially as applications become more complex and handle sensitive data. Understanding common vulnerabilities and implementing proper security measures is essential for any JavaScript developer. Let's explore the major security concerns and their prevention strategies.

**1. Cross-Site Scripting (XSS)**

XSS attacks occur when malicious scripts are injected into trusted websites and executed in users' browsers.

**Types of XSS:**

- **Reflected XSS**: Malicious script is reflected off a web server, such as in search results or error messages.
- **Stored XSS**: Malicious script is stored on the target server, such as in a database, message forum, or comment field.
- **DOM-based XSS**: Vulnerability exists in client-side code rather than server-side code.

**Example of vulnerable code:**

```javascript
// Vulnerable to XSS
function displayUserInput() {
  const userInput = document.getElementById('userInput').value;
  document.getElementById('output').innerHTML = userInput;
}
```

**Prevention strategies:**

1. **Output Encoding**: Always encode user-generated content before inserting it into the DOM.

```javascript
// Safe approach using textContent instead of innerHTML
function displayUserInput() {
  const userInput = document.getElementById('userInput').value;
  document.getElementById('output').textContent = userInput;
}
```

2. **Content Security Policy (CSP)**: Implement CSP headers to restrict the sources from which scripts can be loaded.

```html
<!-- CSP header in HTML -->
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://trusted-cdn.com">
```

3. **Use DOMPurify**: When you need to allow some HTML, sanitize it with a library like DOMPurify.

```javascript
// Using DOMPurify to sanitize HTML
import DOMPurify from 'dompurify';

function displayUserHTML() {
  const userHTML = document.getElementById('userHTML').value;
  const sanitizedHTML = DOMPurify.sanitize(userHTML);
  document.getElementById('output').innerHTML = sanitizedHTML;
}
```

4. **Use frameworks that automatically escape content**: Modern frameworks like React, Angular, and Vue automatically escape content by default.

```jsx
// React automatically escapes this content
function UserContent({ userInput }) {
  return <div>{userInput}</div>; // Safe by default
}
```

**2. Cross-Site Request Forgery (CSRF)**

CSRF attacks trick users into performing unwanted actions on a site where they're authenticated.

**Example of vulnerability:**

A user is logged into their bank account and visits a malicious site that contains:

```html
<!-- Malicious site content -->
<img src="https://bank.com/transfer?to=attacker&amount=1000" style="display:none">
```

**Prevention strategies:**

1. **CSRF Tokens**: Include unique, unpredictable tokens with each request that requires protection.

```javascript
// Client-side CSRF token handling
async function submitForm() {
  const form = document.getElementById('paymentForm');
  const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
  
  const formData = new FormData(form);
  
  try {
    const response = await fetch('/api/payment', {
      method: 'POST',
      headers: {
        'X-CSRF-Token': csrfToken
      },
      body: formData
    });
    
    // Handle response
  } catch (error) {
    console.error('Error:', error);
  }
}
```

2. **SameSite Cookie Attribute**: Set cookies with the SameSite attribute to prevent them from being sent in cross-site requests.

```javascript
// Server-side code (Node.js example)
res.cookie('sessionId', 'abc123', { 
  httpOnly: true, 
  secure: true,
  sameSite: 'strict' // or 'lax'
});
```

3. **Check Referer and Origin Headers**: Validate that requests come from your own site.

```javascript
// Server-side validation (Node.js example)
app.post('/api/sensitive-action', (req, res) => {
  const referer = req.headers.referer || req.headers.referrer;
  
  if (!referer || !referer.startsWith('https://mywebsite.com')) {
    return res.status(403).json({ error: 'Invalid request origin' });
  }
  
  // Process the request
});
```

**3. Cross-Origin Resource Sharing (CORS) Misconfiguration**

Incorrect CORS settings can expose your API to unauthorized domains.

**Example of vulnerable configuration:**

```javascript
// Server-side CORS configuration (Node.js with Express)
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*'); // Too permissive
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  next();
});
```

**Prevention strategies:**

1. **Restrict allowed origins**: Only allow specific trusted domains.

```javascript
// Better CORS configuration
const cors = require('cors');

app.use(cors({
  origin: ['https://mywebsite.com', 'https://admin.mywebsite.com'],
  methods: ['GET', 'POST'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
}));
```

2. **Use environment-specific configurations**: Different settings for development and production.

```javascript
// Environment-specific CORS
const allowedOrigins = process.env.NODE_ENV === 'production'
  ? ['https://mywebsite.com']
  : ['http://localhost:3000'];

app.use(cors({
  origin: function(origin, callback) {
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  }
}));
```

**4. Injection Attacks**

Injection attacks occur when untrusted data is sent to an interpreter as part of a command or query.

**Example of SQL injection vulnerability:**

```javascript
// Vulnerable code
function getUserData(userId) {
  const query = `SELECT * FROM users WHERE id = '${userId}'`;
  return database.execute(query);
}
```

**Prevention strategies:**

1. **Use Parameterized Queries**: Never concatenate user input directly into queries.

```javascript
// Safe approach with parameterized query
function getUserData(userId) {
  const query = 'SELECT * FROM users WHERE id = ?';
  return database.execute(query, [userId]);
}
```

2. **Use ORMs**: Object-Relational Mapping libraries typically handle parameterization automatically.

```javascript
// Using Sequelize ORM
async function getUserData(userId) {
  return await User.findByPk(userId);
}
```

3. **For NoSQL databases**: Still use parameterized operations.

```javascript
// MongoDB safe query
async function getUserData(userId) {
  return await db.collection('users').findOne({ _id: new ObjectId(userId) });
}
```

**5. Insecure Direct Object References (IDOR)**

IDOR vulnerabilities occur when an application provides direct access to objects based on user-supplied input.

**Example of vulnerable code:**

```javascript
// Vulnerable API endpoint
app.get('/api/documents/:documentId', (req, res) => {
  const documentId = req.params.documentId;
  const document = db.getDocument(documentId);
  res.json(document);
});
```

**Prevention strategies:**

1. **Implement proper authorization checks**: Verify the user has permission to access the requested resource.

```javascript
// Safe approach with authorization
app.get('/api/documents/:documentId', async (req, res) => {
  const documentId = req.params.documentId;
  const userId = req.user.id; // From authentication middleware
  
  // Check if user has access to this document
  const hasAccess = await authorizationService.canAccessDocument(userId, documentId);
  
  if (!hasAccess) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  const document = await db.getDocument(documentId);
  res.json(document);
});
```

2. **Use indirect references**: Map database IDs to temporary, user-specific tokens.

```javascript
// Using indirect references
const userResourceMap = new Map();

// When loading user data
function loadUserResources(userId) {
  const resources = db.getUserResources(userId);
  const referenceMap = {};
  
  resources.forEach(resource => {
    const temporaryRef = generateSecureToken();
    referenceMap[temporaryRef] = resource.id;
  });
  
  userResourceMap.set(userId, referenceMap);
  return Object.keys(referenceMap); // Return only the references to the client
}

// When handling requests
app.get('/api/documents/:reference', (req, res) => {
  const userId = req.user.id;
  const reference = req.params.reference;
  
  const userMap = userResourceMap.get(userId);
  if (!userMap || !userMap[reference]) {
    return res.status(404).json({ error: 'Resource not found' });
  }
  
  const actualDocumentId = userMap[reference];
  const document = db.getDocument(actualDocumentId);
  res.json(document);
});
```

**6. Security Misconfiguration**

Security misconfiguration includes leaving default settings, incomplete configurations, or verbose error messages.

**Examples of security misconfiguration:**

- Exposing detailed error messages to users
- Running outdated software or frameworks
- Leaving default accounts/passwords enabled
- Not setting proper security headers

**Prevention strategies:**

1. **Implement proper error handling**: Don't expose sensitive information in error messages.

```javascript
// Bad error handling
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: err.message, stack: err.stack }); // Exposes too much
});

// Good error handling
app.use((err, req, res, next) => {
  console.error(err.stack); // Log for debugging
  res.status(500).json({ error: 'An internal server error occurred' }); // Generic message to user
});
```

2. **Set security headers**: Implement proper HTTP security headers.

```javascript
// Using Helmet in Express
const helmet = require('helmet');
app.use(helmet());

// Or manually set headers
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
  next();
});
```

3. **Use environment variables for configuration**: Never hardcode sensitive values.

```javascript
// Bad practice
const apiKey = 'abcd1234';

// Good practice
const apiKey = process.env.API_KEY;
if (!apiKey) {
  throw new Error('API key is required');
}
```

**7. Broken Authentication**

Broken authentication includes weaknesses in session management, password handling, and account controls.

**Examples of vulnerable authentication:**

- Weak password policies
- Improper session management
- Missing protection against brute force attacks

**Prevention strategies:**

1. **Implement proper password hashing**: Never store passwords in plain text.

```javascript
// Using bcrypt for password hashing
const bcrypt = require('bcrypt');

async function registerUser(email, password) {
  const saltRounds = 12;
  const hashedPassword = await bcrypt.hash(password, saltRounds);
  
  // Store email and hashedPassword in database
  return db.createUser({ email, password: hashedPassword });
}

async function verifyUser(email, password) {
  const user = await db.findUserByEmail(email);
  if (!user) return false;
  
  return await bcrypt.compare(password, user.password);
}
```

2. **Implement rate limiting**: Prevent brute force attacks.

```javascript
// Using Express Rate Limit
const rateLimit = require('express-rate-limit');

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts per window
  message: 'Too many login attempts, please try again after 15 minutes'
});

app.post('/api/login', loginLimiter, (req, res) => {
  // Login logic
});
```

3. **Use secure session management**: Implement proper session handling.

```javascript
// Using express-session with secure settings
const session = require('express-session');

app.use(session({
  secret: process.env.SESSION_SECRET,
  name: 'sessionId', // Don't use the default name
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production', // HTTPS only in production
    sameSite: 'strict',
    maxAge: 3600000 // 1 hour
  },
  resave: false,
  saveUninitialized: false
}));
```

4. **Implement multi-factor authentication**: Add an extra layer of security.

```javascript
// Simple 2FA verification example
async function verifyLogin(user, password, token) {
  // First verify password
  const passwordValid = await bcrypt.compare(password, user.hashedPassword);
  if (!passwordValid) return false;
  
  // Then verify 2FA token
  const tokenValid = twoFactorService.verifyToken(user.twoFactorSecret, token);
  return tokenValid;
}
```

**8. Using Vulnerable Dependencies**

Using outdated or vulnerable libraries can expose your application to known security issues.

**Prevention strategies:**

1. **Regularly audit dependencies**: Use tools to check for vulnerabilities.

```bash
# Using npm audit
npm audit

# Fix vulnerabilities
npm audit fix
```

2. **Set up automated security scanning**: Integrate security scanning into your CI/CD pipeline.

```javascript
// Example GitHub workflow for dependency scanning
// .github/workflows/security.yml
name: Security Scan

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 0' # Weekly scan

jobs:
  security:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Run npm audit
      run: npm audit --audit-level=high
```

3. **Use lock files**: Ensure consistent dependency versions.

```bash
# Generate or update package-lock.json
npm install

# Or for yarn.lock
yarn install
```

**9. Client-Side Storage Security**

Insecure handling of data in client-side storage (localStorage, sessionStorage, cookies) can expose sensitive information.

**Examples of vulnerable storage:**

```javascript
// Storing sensitive data in localStorage (vulnerable)
localStorage.setItem('authToken', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...');
localStorage.setItem('userDetails', JSON.stringify({
  name: 'John Doe',
  email: 'john@example.com',
  creditCard: '1234-5678-9012-3456' // Never store this!
}));
```

**Prevention strategies:**

1. **Minimize sensitive data in client storage**: Only store what's absolutely necessary.

```javascript
// Store minimal information
sessionStorage.setItem('userDisplayName', 'John D.'); // OK for UI personalization
```

2. **Use HttpOnly and Secure cookies for sensitive data**: These can't be accessed by JavaScript.

```javascript
// Server-side (Node.js example)
res.cookie('authToken', token, {
  httpOnly: true, // Not accessible via JavaScript
  secure: true,   // HTTPS only
  sameSite: 'strict',
  maxAge: 3600000 // 1 hour
});
```

3. **Encrypt sensitive data if client-side storage is necessary**:

```javascript
// Using the Web Crypto API for client-side encryption
async function encryptData(data, password) {
  const encoder = new TextEncoder();
  const salt = crypto.getRandomValues(new Uint8Array(16));
  
  // Derive key from password
  const keyMaterial = await crypto.subtle.importKey(
    'raw',
    encoder.encode(password),
    { name: 'PBKDF2' },
    false,
    ['deriveBits', 'deriveKey']
  );
  
  const key = await crypto.subtle.deriveKey(
    {
      name: 'PBKDF2',
      salt,
      iterations: 100000,
      hash: 'SHA-256'
    },
    keyMaterial,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
  
  // Encrypt
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const encryptedContent = await crypto.subtle.encrypt(
    {
      name: 'AES-GCM',
      iv
    },
    key,
    encoder.encode(JSON.stringify(data))
  );
  
  // Return everything needed for decryption
  return {
    salt: Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join(''),
    iv: Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join(''),
    encryptedData: Array.from(new Uint8Array(encryptedContent))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('')
  };
}

// Usage
async function storeEncryptedData() {
  const sensitiveData = { userId: 123, accessLevel: 'admin' };
  const masterPassword = 'user-specific-key'; // Could be derived from user password
  
  const encrypted = await encryptData(sensitiveData, masterPassword);
  localStorage.setItem('encryptedData', JSON.stringify(encrypted));
}
```

**10. Insecure Randomness**

Using predictable random values for security-critical operations can lead to vulnerabilities.

**Example of vulnerable code:**

```javascript
// Insecure random token generation
function generateToken() {
  return Math.random().toString(36).substring(2); // Not cryptographically secure
}
```

**Prevention strategies:**

1. **Use cryptographically secure random number generation**:

```javascript
// Secure random token generation in the browser
function generateSecureToken(length = 32) {
  const array = new Uint8Array(length);
  crypto.getRandomValues(array);
  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
}

// In Node.js
const crypto = require('crypto');

function generateSecureToken(length = 32) {
  return crypto.randomBytes(length).toString('hex');
}
```

**Key Takeaways:**

1. Cross-Site Scripting (XSS) can be prevented by properly encoding output and using Content Security Policy
2. Cross-Site Request Forgery (CSRF) attacks can be mitigated with tokens and SameSite cookies
3. Always use parameterized queries to prevent SQL and NoSQL injection attacks
4. Implement proper authorization checks to prevent Insecure Direct Object References
5. Set appropriate security headers and handle errors without exposing sensitive information
6. Never store passwords in plain text; use strong hashing algorithms like bcrypt
7. Implement rate limiting to prevent brute force attacks
8. Regularly audit and update dependencies to avoid known vulnerabilities
9. Be cautious with client-side storage and never store sensitive data in localStorage
10. Use cryptographically secure random number generation for security-critical operations

### Q78: What are the most effective JavaScript performance optimization techniques?
**Difficulty: Hard**

**Answer:**
Performance optimization is crucial for creating responsive and efficient JavaScript applications. As applications grow in complexity, understanding how to optimize your code becomes increasingly important. Let's explore the most effective techniques for optimizing JavaScript performance.

**1. Code Execution Optimization**

**a) Minimize DOM Operations**

DOM operations are expensive because they trigger reflow and repaint.

```javascript
// Inefficient - causes multiple reflows
for (let i = 0; i < 100; i++) {
  document.getElementById('container').innerHTML += '<div>' + i + '</div>';
}

// Optimized - single reflow
let html = '';
for (let i = 0; i < 100; i++) {
  html += '<div>' + i + '</div>';
}
document.getElementById('container').innerHTML = html;

// Even better - use DocumentFragment
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
  const div = document.createElement('div');
  div.textContent = i;
  fragment.appendChild(div);
}
document.getElementById('container').appendChild(fragment);
```

**b) Use Efficient Selectors**

Selector performance can significantly impact DOM manipulation speed.

```javascript
// Slower
document.querySelectorAll('.my-class'); 

// Faster
document.getElementsByClassName('my-class');

// Fastest (when applicable)
document.getElementById('my-id');
```

**c) Optimize Loops**

Loop optimization can lead to significant performance improvements.

```javascript
// Less efficient
const arr = new Array(1000000);
for (let i = 0; i < arr.length; i++) { // Length checked on each iteration
  arr[i] = i;
}

// More efficient
const arr = new Array(1000000);
for (let i = 0, len = arr.length; i < len; i++) { // Length cached
  arr[i] = i;
}

// Often most efficient for arrays
const arr = new Array(1000000);
arr.forEach((_, i) => {
  arr[i] = i;
});

// For objects
const obj = { a: 1, b: 2, c: 3 };

// Less efficient for large objects
for (let key in obj) {
  if (obj.hasOwnProperty(key)) { // Prototypal check on each iteration
    console.log(key, obj[key]);
  }
}

// More efficient
const keys = Object.keys(obj); // Get keys once
for (let i = 0; i < keys.length; i++) {
  const key = keys[i];
  console.log(key, obj[key]);
}
```

**d) Debounce and Throttle Event Handlers**

Limit the rate at which functions are executed for events that fire rapidly.

```javascript
// Debounce - execute function only after a specified delay of inactivity
function debounce(func, delay) {
  let timeout;
  return function() {
    const context = this;
    const args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), delay);
  };
}

// Usage
const expensiveCalculation = debounce(() => {
  // Calculation that runs only after user stops typing for 300ms
  console.log('Calculating...');
}, 300);

window.addEventListener('resize', debounce(() => {
  // Handle resize, but only once it stops for 250ms
  console.log('Resize ended');
}, 250));

// Throttle - execute function at most once per specified time period
function throttle(func, limit) {
  let inThrottle;
  return function() {
    const context = this;
    const args = arguments;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

// Usage
window.addEventListener('scroll', throttle(() => {
  // Handle scroll, but at most once every 100ms
  console.log('Scroll position:', window.scrollY);
}, 100));
```

**2. Memory Management**

**a) Avoid Memory Leaks**

Common causes of memory leaks include forgotten event listeners and circular references.

```javascript
// Memory leak - event listener not removed
function setupListener() {
  const button = document.getElementById('button');
  button.addEventListener('click', function() {
    // This creates a closure that holds a reference to 'button'
    console.log('Button clicked');
  });
}

// Fixed - remove event listener when no longer needed
function setupListener() {
  const button = document.getElementById('button');
  const handleClick = () => console.log('Button clicked');
  button.addEventListener('click', handleClick);
  
  // Cleanup function
  return function cleanup() {
    button.removeEventListener('click', handleClick);
  };
}

// Usage with cleanup
const cleanup = setupListener();
// Later when component unmounts or element is removed
cleanup();
```

**b) Use Object Pooling for Frequent Creation/Disposal**

Reuse objects instead of creating new ones for better performance.

```javascript
// Object pooling example for particle system
class ParticlePool {
  constructor(size) {
    this.particles = Array(size).fill().map(() => this.createParticle());
    this.index = 0;
  }
  
  createParticle() {
    return { x: 0, y: 0, vx: 0, vy: 0, active: false };
  }
  
  get() {
    // Get next available particle
    if (this.index >= this.particles.length) {
      this.index = 0; // Wrap around if all particles are in use
    }
    
    const particle = this.particles[this.index++];
    particle.active = true;
    return particle;
  }
  
  release(particle) {
    // Reset particle state instead of creating a new one
    particle.x = 0;
    particle.y = 0;
    particle.vx = 0;
    particle.vy = 0;
    particle.active = false;
  }
}

// Usage
const pool = new ParticlePool(1000);

function createExplosion(x, y) {
  for (let i = 0; i < 50; i++) {
    const particle = pool.get();
    particle.x = x;
    particle.y = y;
    particle.vx = Math.random() * 10 - 5;
    particle.vy = Math.random() * 10 - 5;
  }
}

function update() {
  for (const particle of pool.particles) {
    if (!particle.active) continue;
    
    particle.x += particle.vx;
    particle.y += particle.vy;
    
    // If particle is out of bounds, release it back to the pool
    if (particle.x < 0 || particle.x > canvas.width || 
        particle.y < 0 || particle.y > canvas.height) {
      pool.release(particle);
    }
  }
  
  requestAnimationFrame(update);
}
```

**3. Rendering Performance**

**a) Use requestAnimationFrame for Animations**

```javascript
// Inefficient animation
setInterval(() => {
  // Update animation
  updateAnimation();
}, 16); // ~60fps

// Optimized animation with requestAnimationFrame
function animate() {
  // Update animation
  updateAnimation();
  
  // Schedule next frame
  requestAnimationFrame(animate);
}

// Start animation
requestAnimationFrame(animate);
```

**b) Use CSS Transitions/Animations When Possible**

```javascript
// JavaScript animation (can be janky)
function animateWidth() {
  const element = document.getElementById('box');
  let width = 0;
  
  const interval = setInterval(() => {
    width++;
    element.style.width = width + 'px';
    
    if (width >= 300) {
      clearInterval(interval);
    }
  }, 16);
}

// Better: CSS transition
/* CSS
.box {
  width: 0;
  transition: width 0.5s ease;
}
.box.expanded {
  width: 300px;
}
*/

// JavaScript just toggles class
function animateWidth() {
  document.getElementById('box').classList.add('expanded');
}
```

**c) Use Hardware Acceleration**

```css
/* Use transform and opacity for smooth animations */
.animated-element {
  transform: translateZ(0); /* Triggers hardware acceleration */
  will-change: transform, opacity; /* Hints browser about properties that will change */
}
```

**4. Network Optimization**

**a) Bundle and Minify Code**

Use tools like Webpack, Rollup, or Parcel to bundle and minify your JavaScript.

```javascript
// webpack.config.js example
module.exports = {
  mode: 'production', // Enables minification
  entry: './src/index.js',
  output: {
    filename: 'bundle.min.js',
    path: path.resolve(__dirname, 'dist'),
  },
  optimization: {
    minimize: true,
    splitChunks: {
      chunks: 'all', // Split code into smaller chunks
    },
  },
};
```

**b) Implement Code Splitting**

Load only what's needed when it's needed.

```javascript
// Modern JavaScript with dynamic imports
button.addEventListener('click', async () => {
  // Load module only when needed
  const { default: VideoPlayer } = await import('./video-player.js');
  
  // Use the module
  const player = new VideoPlayer();
  player.play();
});
```

**c) Use Service Workers for Caching**

```javascript
// service-worker.js
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('v1').then((cache) => {
      return cache.addAll([
        '/',
        '/index.html',
        '/styles.css',
        '/app.js',
        '/api-data.json',
      ]);
    })
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      // Return cached response or fetch from network
      return response || fetch(event.request);
    })
  );
});
```

**5. Algorithmic Optimization**

**a) Use Efficient Data Structures**

Choose the right data structure for your specific use case.

```javascript
// Inefficient for frequent lookups
const array = ['apple', 'banana', 'orange', 'grape', /* thousands more */];
function hasItem(item) {
  return array.includes(item); // O(n) time complexity
}

// More efficient for lookups
const set = new Set(['apple', 'banana', 'orange', 'grape', /* thousands more */]);
function hasItem(item) {
  return set.has(item); // O(1) time complexity
}

// For key-value pairs
const map = new Map();
map.set('user123', { name: 'John', role: 'admin' });
map.set('user456', { name: 'Jane', role: 'editor' });

// O(1) lookup
const user = map.get('user123');
```

**b) Memoize Expensive Calculations**

```javascript
// Without memoization
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// With memoization
function memoizedFibonacci() {
  const cache = {};
  
  return function fib(n) {
    if (n in cache) {
      return cache[n];
    }
    
    if (n <= 1) {
      return n;
    }
    
    cache[n] = fib(n - 1) + fib(n - 2);
    return cache[n];
  };
}

const fastFib = memoizedFibonacci();
console.time('With memoization');
console.log(fastFib(40));
console.timeEnd('With memoization'); // Much faster
```

**c) Use Web Workers for CPU-Intensive Tasks**

```javascript
// main.js
const worker = new Worker('worker.js');

worker.onmessage = function(event) {
  console.log('Result from worker:', event.data);
};

// Start a heavy calculation
worker.postMessage({
  numbers: Array.from({ length: 10000000 }, (_, i) => i),
});

// UI remains responsive while calculation runs in background

// worker.js
self.onmessage = function(event) {
  const { numbers } = event.data;
  
  // Perform CPU-intensive calculation
  const result = numbers.reduce((sum, num) => {
    // Expensive operation
    return sum + Math.sqrt(num) * Math.sin(num);
  }, 0);
  
  // Send result back to main thread
  self.postMessage(result);
};
```

**6. Modern JavaScript Features for Performance**

**a) Use Modern Array Methods**

```javascript
// Less efficient
const numbers = [1, 2, 3, 4, 5];
let sum = 0;
for (let i = 0; i < numbers.length; i++) {
  sum += numbers[i];
}

// More readable and often optimized by JS engines
const sum = numbers.reduce((acc, num) => acc + num, 0);

// Filtering
const evenNumbers = [];
for (let i = 0; i < numbers.length; i++) {
  if (numbers[i] % 2 === 0) {
    evenNumbers.push(numbers[i]);
  }
}

// More concise and often well-optimized
const evenNumbers = numbers.filter(num => num % 2 === 0);
```

**b) Use TypedArrays for Binary Data**

```javascript
// Regular array - less efficient for binary data
const regularArray = new Array(1000000).fill(0);

// TypedArray - more efficient for binary data
const typedArray = new Uint32Array(1000000); // Already initialized to 0

// Example: Computing sum
console.time('Regular array');
let sum1 = 0;
for (let i = 0; i < regularArray.length; i++) {
  sum1 += regularArray[i];
}
console.timeEnd('Regular array');

console.time('TypedArray');
let sum2 = 0;
for (let i = 0; i < typedArray.length; i++) {
  sum2 += typedArray[i];
}
console.timeEnd('TypedArray'); // Usually faster
```

**7. Measuring and Monitoring Performance**

**a) Use Performance API**

```javascript
// Measure time for specific operations
performance.mark('startCalculation');

// Perform calculation
const result = calculateSomething();

performance.mark('endCalculation');
performance.measure('calculation', 'startCalculation', 'endCalculation');

// Log results
const measurements = performance.getEntriesByType('measure');
console.log(measurements);

// Clear marks and measures
performance.clearMarks();
performance.clearMeasures();
```

**b) Use Chrome DevTools Performance Panel**

```javascript
// Add console.time markers for DevTools analysis
console.time('Full operation');

console.time('Part 1');
// Part 1 code
console.timeEnd('Part 1');

console.time('Part 2');
// Part 2 code
console.timeEnd('Part 2');

console.timeEnd('Full operation');
```

**8. Framework-Specific Optimizations**

**a) React**

```jsx
// Use React.memo for component memoization
const ExpensiveComponent = React.memo(function ExpensiveComponent(props) {
  // Component that only re-renders when props change
  return <div>{/* Complex rendering */}</div>;
});

// Use useCallback to prevent unnecessary re-renders
function ParentComponent() {
  const [count, setCount] = useState(0);
  
  // This function is memoized and only changes when dependencies change
  const handleClick = useCallback(() => {
    console.log('Button clicked');
  }, []); // Empty dependency array means function never changes
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increment: {count}</button>
      <ChildComponent onClick={handleClick} />
    </div>
  );
}

// Use useMemo for expensive calculations
function DataProcessor({ data }) {
  // This calculation only runs when data changes
  const processedData = useMemo(() => {
    return data.map(item => expensiveTransformation(item));
  }, [data]);
  
  return <div>{/* Render using processedData */}</div>;
}
```

**b) Vue.js**

```javascript
// Use v-once for content that never changes
<template>
  <div>
    <h1 v-once>{{ staticTitle }}</h1>
    <p>{{ dynamicContent }}</p>
  </div>
</template>

// Use computed properties instead of methods for values derived from state
export default {
  data() {
    return {
      items: [...],
      filter: 'active'
    };
  },
  computed: {
    // This is cached and only recalculated when dependencies change
    filteredItems() {
      return this.items.filter(item => item.status === this.filter);
    }
  },
  methods: {
    // This runs on every render
    getFilteredItems() {
      return this.items.filter(item => item.status === this.filter);
    }
  }
};
```

**9. Loading Optimization**

**a) Lazy Loading**

```javascript
// Lazy loading images
const lazyImages = document.querySelectorAll('.lazy-image');

const lazyLoadObserver = new IntersectionObserver((entries, observer) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      img.classList.remove('lazy-image');
      observer.unobserve(img);
    }
  });
});

lazyImages.forEach(image => {
  lazyLoadObserver.observe(image);
});
```

**b) Preloading Critical Resources**

```html
<!-- Preload critical JavaScript -->
<link rel="preload" href="/critical.js" as="script">

<!-- Preload critical CSS -->
<link rel="preload" href="/critical.css" as="style">

<!-- Preload critical fonts -->
<link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin>
```

**10. Advanced Techniques**

**a) Use OffscreenCanvas for Complex Canvas Operations**

```javascript
// Create an offscreen canvas
const offscreen = new OffscreenCanvas(256, 256);
const offscreenCtx = offscreen.getContext('2d');

// Perform drawing operations on offscreen canvas
offscreenCtx.fillStyle = 'red';
offscreenCtx.fillRect(0, 0, 256, 256);
// More complex drawing...

// Transfer to visible canvas only when needed
const visibleCanvas = document.getElementById('myCanvas');
const visibleCtx = visibleCanvas.getContext('2d');
visibleCtx.drawImage(offscreen, 0, 0);
```

**b) Use SharedArrayBuffer for Efficient Worker Communication**

```javascript
// main.js (with appropriate headers for security)
const buffer = new SharedArrayBuffer(1024);
const sharedArray = new Uint32Array(buffer);

const worker = new Worker('worker.js');
worker.postMessage({ sharedArray });

// Update values directly
sharedArray[0] = 100;

// worker.js
self.onmessage = function(event) {
  const { sharedArray } = event.data;
  
  // Set up interval to read shared data
  setInterval(() => {
    console.log('Value from main thread:', sharedArray[0]);
  }, 1000);
};
```

**Key Takeaways:**

1. Minimize DOM operations and batch updates to reduce reflow and repaint
2. Use efficient selectors and optimize loops for better performance
3. Implement debounce and throttle techniques for event handlers that fire frequently
4. Prevent memory leaks by properly managing event listeners and references
5. Use object pooling for scenarios with frequent object creation and disposal
6. Leverage requestAnimationFrame for smooth animations instead of setTimeout/setInterval
7. Choose appropriate data structures for your specific use case (Map, Set, TypedArray)
8. Implement memoization for expensive calculations that are called repeatedly
9. Offload CPU-intensive tasks to Web Workers to keep the main thread responsive
10. Measure performance using the Performance API and browser developer tools

### Q79: What are the best practices for testing JavaScript applications?
**Difficulty: Hard**

**Answer:**
Testing is a critical aspect of JavaScript development that ensures code quality, prevents regressions, and facilitates refactoring. A comprehensive testing strategy involves multiple types of tests and tools. Let's explore the best practices for testing JavaScript applications.

**1. Types of Tests**

**a) Unit Tests**

Unit tests verify that individual units of code (typically functions or methods) work as expected in isolation.

```javascript
// Function to test
function sum(a, b) {
  return a + b;
}

// Jest unit test
test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});

// Mocha/Chai unit test
describe('sum function', () => {
  it('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).to.equal(3);
  });
});
```

**b) Integration Tests**

Integration tests verify that multiple units work together correctly.

```javascript
// Components to test
class UserService {
  async getUser(id) {
    // In a real app, this would call an API
    return { id, name: 'Test User' };
  }
}

class UserComponent {
  constructor(userService) {
    this.userService = userService;
  }
  
  async displayUser(id) {
    const user = await this.userService.getUser(id);
    return `User: ${user.name}`;
  }
}

// Jest integration test
test('UserComponent displays user from UserService', async () => {
  // Setup
  const userService = new UserService();
  const userComponent = new UserComponent(userService);
  
  // Test integration between components
  const result = await userComponent.displayUser(1);
  expect(result).toBe('User: Test User');
});
```

**c) End-to-End (E2E) Tests**

E2E tests verify that the entire application works as expected from a user's perspective.

```javascript
// Cypress E2E test
describe('Login Flow', () => {
  it('should login successfully with valid credentials', () => {
    cy.visit('/login');
    
    cy.get('input[name="username"]').type('testuser');
    cy.get('input[name="password"]').type('password123');
    cy.get('button[type="submit"]').click();
    
    // Verify successful login
    cy.url().should('include', '/dashboard');
    cy.get('.welcome-message').should('contain', 'Welcome, Test User');
  });
});

// Playwright E2E test
test('should login successfully with valid credentials', async ({ page }) => {
  await page.goto('/login');
  
  await page.fill('input[name="username"]', 'testuser');
  await page.fill('input[name="password"]', 'password123');
  await page.click('button[type="submit"]');
  
  // Verify successful login
  await expect(page).toHaveURL(/.*dashboard/);
  await expect(page.locator('.welcome-message')).toContainText('Welcome, Test User');
});
```

**2. Testing Frameworks and Tools**

**a) Unit and Integration Testing Frameworks**

- **Jest**: Full-featured testing framework with built-in assertions, mocking, and code coverage.

```javascript
// Jest test with mocking
test('fetchUserData calls the API and returns user data', async () => {
  // Mock fetch API
  global.fetch = jest.fn(() =>
    Promise.resolve({
      json: () => Promise.resolve({ id: 1, name: 'John Doe' }),
    })
  );
  
  const userData = await fetchUserData(1);
  
  // Verify fetch was called correctly
  expect(fetch).toHaveBeenCalledWith('/api/users/1');
  
  // Verify the returned data
  expect(userData).toEqual({ id: 1, name: 'John Doe' });
});
```

- **Mocha**: Flexible testing framework that works with different assertion libraries.

```javascript
// Mocha test with Sinon for mocking
describe('fetchUserData', () => {
  let fetchStub;
  
  beforeEach(() => {
    fetchStub = sinon.stub(global, 'fetch');
    fetchStub.resolves({
      json: sinon.stub().resolves({ id: 1, name: 'John Doe' })
    });
  });
  
  afterEach(() => {
    fetchStub.restore();
  });
  
  it('calls the API and returns user data', async () => {
    const userData = await fetchUserData(1);
    
    // Verify fetch was called correctly
    expect(fetchStub.calledWith('/api/users/1')).to.be.true;
    
    // Verify the returned data
    expect(userData).to.deep.equal({ id: 1, name: 'John Doe' });
  });
});
```

- **Jasmine**: Behavior-driven development framework with built-in assertions and mocking.

```javascript
// Jasmine test
describe('Calculator', () => {
  let calculator;
  
  beforeEach(() => {
    calculator = new Calculator();
  });
  
  it('should add numbers correctly', () => {
    expect(calculator.add(1, 2)).toBe(3);
  });
  
  it('should subtract numbers correctly', () => {
    expect(calculator.subtract(5, 2)).toBe(3);
  });
});
```

**b) E2E Testing Tools**

- **Cypress**: Modern E2E testing framework with real-time reloading and time-travel debugging.

```javascript
// Cypress test for a todo application
describe('Todo App', () => {
  beforeEach(() => {
    cy.visit('/');
  });
  
  it('should add a new todo item', () => {
    const todoText = 'Buy groceries';
    
    cy.get('.new-todo')
      .type(`${todoText}{enter}`);
    
    cy.get('.todo-list li')
      .should('have.length', 1)
      .and('contain', todoText);
  });
  
  it('should mark a todo as completed', () => {
    // Add a todo first
    cy.get('.new-todo').type('Test todo{enter}');
    
    // Mark it as completed
    cy.get('.todo-list li:first .toggle').click();
    
    // Verify it's marked as completed
    cy.get('.todo-list li:first').should('have.class', 'completed');
  });
});
```

- **Playwright**: Modern E2E testing framework by Microsoft with multi-browser support.

```javascript
// Playwright test for a login form
test('login form validation', async ({ page }) => {
  await page.goto('/login');
  
  // Try to submit without entering credentials
  await page.click('button[type="submit"]');
  
  // Check for validation messages
  await expect(page.locator('.username-error')).toBeVisible();
  await expect(page.locator('.username-error')).toHaveText('Username is required');
  
  await expect(page.locator('.password-error')).toBeVisible();
  await expect(page.locator('.password-error')).toHaveText('Password is required');
});
```

- **Selenium WebDriver**: Established E2E testing tool with broad browser support.

```javascript
// Selenium test with WebDriverJS
const { Builder, By, until } = require('selenium-webdriver');

(async function example() {
  let driver = await new Builder().forBrowser('chrome').build();
  
  try {
    await driver.get('https://example.com/login');
    
    await driver.findElement(By.name('username')).sendKeys('testuser');
    await driver.findElement(By.name('password')).sendKeys('password123');
    await driver.findElement(By.css('button[type="submit"]')).click();
    
    // Wait for dashboard to load
    await driver.wait(until.urlContains('dashboard'), 5000);
    
    // Verify welcome message
    const welcomeMessage = await driver.findElement(By.css('.welcome-message')).getText();
    console.assert(welcomeMessage.includes('Welcome, Test User'), 'Welcome message not found');
  } finally {
    await driver.quit();
  }
})();
```

**3. Test-Driven Development (TDD)**

TDD involves writing tests before implementing the actual code.

```javascript
// Step 1: Write a failing test
test('stringCalculator should add numbers from a comma-separated string', () => {
  const calculator = new StringCalculator();
  expect(calculator.add('1,2,3')).toBe(6);
});

// Step 2: Implement the code to make the test pass
class StringCalculator {
  add(numbers) {
    if (!numbers) return 0;
    
    return numbers
      .split(',')
      .map(num => parseInt(num, 10))
      .reduce((sum, num) => sum + num, 0);
  }
}

// Step 3: Refactor if needed while keeping tests passing
```

**4. Mocking and Stubbing**

Mocking and stubbing allow you to isolate the code being tested by replacing dependencies with controlled implementations.

**a) Mocking HTTP Requests**

```javascript
// Using Jest's fetch mock
test('fetchUserData should handle API errors gracefully', async () => {
  // Mock a failed API response
  global.fetch = jest.fn(() =>
    Promise.reject(new Error('Network error'))
  );
  
  // Verify error handling
  await expect(fetchUserData(1)).rejects.toThrow('Failed to fetch user data');
});

// Using Axios mock adapter
const axios = require('axios');
const MockAdapter = require('axios-mock-adapter');

describe('User API', () => {
  let mock;
  
  beforeEach(() => {
    mock = new MockAdapter(axios);
  });
  
  afterEach(() => {
    mock.restore();
  });
  
  it('should fetch user data successfully', async () => {
    const userData = { id: 1, name: 'John Doe' };
    mock.onGet('/api/users/1').reply(200, userData);
    
    const result = await userService.getUser(1);
    expect(result).toEqual(userData);
  });
});
```

**b) Mocking Modules and Dependencies**

```javascript
// Jest automatic mocking
jest.mock('./database');
const database = require('./database');

test('saveUser should call database.save with user data', () => {
  // Setup the mock implementation
  database.save.mockResolvedValue({ success: true });
  
  // Call the function that uses the database
  const userService = require('./userService');
  return userService.saveUser({ name: 'John' }).then(result => {
    // Verify database.save was called correctly
    expect(database.save).toHaveBeenCalledWith({ name: 'John' });
    expect(result.success).toBe(true);
  });
});

// Manual mocking with Sinon
const sinon = require('sinon');
const database = require('./database');

describe('userService', () => {
  let saveStub;
  
  beforeEach(() => {
    saveStub = sinon.stub(database, 'save');
    saveStub.resolves({ success: true });
  });
  
  afterEach(() => {
    saveStub.restore();
  });
  
  it('should call database.save with user data', async () => {
    const userService = require('./userService');
    const result = await userService.saveUser({ name: 'John' });
    
    sinon.assert.calledWith(saveStub, { name: 'John' });
    expect(result.success).to.be.true;
  });
});
```

**5. Testing Asynchronous Code**

JavaScript applications often involve asynchronous operations that require special testing approaches.

```javascript
// Testing Promises with Jest
test('fetchData should resolve with the correct data', () => {
  return fetchData().then(data => {
    expect(data).toEqual({ success: true });
  });
});

// Using async/await with Jest
test('fetchData should resolve with the correct data', async () => {
  const data = await fetchData();
  expect(data).toEqual({ success: true });
});

// Testing rejected Promises
test('fetchData should reject when the API fails', async () => {
  // Mock fetch to simulate failure
  global.fetch = jest.fn(() => Promise.reject(new Error('API error')));
  
  await expect(fetchData()).rejects.toThrow('API error');
});

// Testing with done callback (older style)
test('fetchData should resolve with the correct data', (done) => {
  fetchData().then(data => {
    try {
      expect(data).toEqual({ success: true });
      done();
    } catch (error) {
      done(error);
    }
  });
});
```

**6. Testing React Components**

React components require specialized testing approaches to verify rendering and behavior.

**a) Testing with React Testing Library**

```jsx
// Component to test
function Counter() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <span data-testid="count">{count}</span>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

// Test with React Testing Library
import { render, screen, fireEvent } from '@testing-library/react';

test('counter increments when button is clicked', () => {
  render(<Counter />);
  
  // Initial state check
  expect(screen.getByTestId('count')).toHaveTextContent('0');
  
  // Simulate user interaction
  fireEvent.click(screen.getByText('Increment'));
  
  // Verify the state changed
  expect(screen.getByTestId('count')).toHaveTextContent('1');
});
```

**b) Testing with Enzyme**

```jsx
// Test with Enzyme
import { shallow } from 'enzyme';

test('counter increments when button is clicked', () => {
  const wrapper = shallow(<Counter />);
  
  // Initial state check
  expect(wrapper.find('[data-testid="count"]').text()).toBe('0');
  
  // Simulate user interaction
  wrapper.find('button').simulate('click');
  
  // Verify the state changed
  expect(wrapper.find('[data-testid="count"]').text()).toBe('1');
});
```

**7. Testing Vue Components**

```javascript
// Component to test
const Counter = {
  template: `
    <div>
      <span data-testid="count">{{ count }}</span>
      <button @click="increment">Increment</button>
    </div>
  `,
  data() {
    return { count: 0 };
  },
  methods: {
    increment() {
      this.count += 1;
    }
  }
};

// Test with Vue Test Utils
import { mount } from '@vue/test-utils';

test('counter increments when button is clicked', async () => {
  const wrapper = mount(Counter);
  
  // Initial state check
  expect(wrapper.find('[data-testid="count"]').text()).toBe('0');
  
  // Simulate user interaction
  await wrapper.find('button').trigger('click');
  
  // Verify the state changed
  expect(wrapper.find('[data-testid="count"]').text()).toBe('1');
});
```

**8. Testing Angular Components**

```typescript
// Component to test
@Component({
  selector: 'app-counter',
  template: `
    <div>
      <span data-testid="count">{{ count }}</span>
      <button (click)="increment()">Increment</button>
    </div>
  `
})
class CounterComponent {
  count = 0;
  
  increment() {
    this.count += 1;
  }
}

// Test with Angular Testing Library
import { render, screen, fireEvent } from '@testing-library/angular';

test('counter increments when button is clicked', async () => {
  await render(CounterComponent);
  
  // Initial state check
  expect(screen.getByTestId('count').textContent).toBe('0');
  
  // Simulate user interaction
  fireEvent.click(screen.getByText('Increment'));
  
  // Verify the state changed
  expect(screen.getByTestId('count').textContent).toBe('1');
});

// Test with Angular TestBed
import { ComponentFixture, TestBed } from '@angular/core/testing';

describe('CounterComponent', () => {
  let component: CounterComponent;
  let fixture: ComponentFixture<CounterComponent>;
  
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [CounterComponent]
    }).compileComponents();
    
    fixture = TestBed.createComponent(CounterComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });
  
  it('should increment count when button is clicked', () => {
    // Initial state check
    expect(component.count).toBe(0);
    
    // Get button element and click it
    const button = fixture.nativeElement.querySelector('button');
    button.click();
    fixture.detectChanges();
    
    // Verify the state changed
    expect(component.count).toBe(1);
    expect(fixture.nativeElement.querySelector('[data-testid="count"]').textContent).toBe('1');
  });
});
```

**9. Code Coverage**

Code coverage measures how much of your code is executed during tests.

```bash
# Using Jest for code coverage
jest --coverage

# Using NYC (Istanbul) with Mocha
nyc mocha
```

Example Jest coverage configuration in package.json:

```json
{
  "jest": {
    "collectCoverage": true,
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    },
    "collectCoverageFrom": [
      "src/**/*.{js,jsx}",
      "!**/node_modules/**",
      "!**/vendor/**"
    ]
  }
}
```

**10. Testing Best Practices**

**a) Arrange-Act-Assert (AAA) Pattern**

```javascript
test('user registration should work for valid data', async () => {
  // Arrange - set up the test
  const userData = {
    username: 'testuser',
    email: 'test@example.com',
    password: 'Password123!'
  };
  
  // Act - perform the action being tested
  const result = await userService.register(userData);
  
  // Assert - verify the expected outcome
  expect(result.success).toBe(true);
  expect(result.user.username).toBe(userData.username);
  expect(result.user.email).toBe(userData.email);
  // Password should not be returned
  expect(result.user.password).toBeUndefined();
});
```

**b) Test Isolation**

```javascript
// Bad practice - tests depend on each other
let createdUserId;

test('should create a user', async () => {
  const result = await userService.create({ name: 'Test User' });
  createdUserId = result.id; // Storing for the next test
  expect(result.success).toBe(true);
});

test('should retrieve the created user', async () => {
  // This test depends on the previous test
  const user = await userService.getById(createdUserId);
  expect(user.name).toBe('Test User');
});

// Good practice - tests are isolated
test('should create a user', async () => {
  const result = await userService.create({ name: 'Test User' });
  expect(result.success).toBe(true);
});

test('should retrieve a user by id', async () => {
  // Setup the test data independently
  const createdUser = await userService.create({ name: 'Another User' });
  
  // Test the retrieval
  const user = await userService.getById(createdUser.id);
  expect(user.name).toBe('Another User');
});
```

**c) Testing Error Cases**

```javascript
test('login should fail with invalid credentials', async () => {
  // Test the error case
  await expect(
    authService.login('nonexistent@example.com', 'wrongpassword')
  ).rejects.toThrow('Invalid email or password');
});

test('division function should throw error for division by zero', () => {
  // Test the error case
  expect(() => {
    calculator.divide(10, 0);
  }).toThrow('Cannot divide by zero');
});
```

**d) Snapshot Testing**

```javascript
// React component snapshot test
import renderer from 'react-test-renderer';

test('Button component renders correctly', () => {
  const component = renderer.create(
    <Button label="Click me" onClick={() => {}} />
  );
  
  // Create a snapshot
  const tree = component.toJSON();
  expect(tree).toMatchSnapshot();
});
```

**Key Takeaways:**

1. Implement a testing pyramid with many unit tests, some integration tests, and fewer E2E tests
2. Choose testing frameworks and tools that match your project's needs and team's expertise
3. Use Test-Driven Development (TDD) to improve code quality and test coverage
4. Master mocking and stubbing techniques to isolate the code being tested
5. Learn specific approaches for testing asynchronous code and Promises
6. Use specialized libraries for testing UI components in frameworks like React, Vue, and Angular
7. Monitor code coverage to identify untested parts of your codebase
8. Follow the Arrange-Act-Assert pattern to structure your tests clearly
9. Ensure tests are isolated and don't depend on each other's state
10. Test both success and error cases to ensure robust error handling

### Q80: What are the most effective debugging techniques and tools for JavaScript applications?
**Difficulty: Medium**

**Answer:**
Debugging is an essential skill for JavaScript developers. Effective debugging can significantly reduce development time and improve code quality. Let's explore the most effective debugging techniques and tools for JavaScript applications.

**1. Browser Developer Tools**

**a) Console Methods**

The console object provides various methods for debugging:

```javascript
// Basic logging
console.log('User data:', userData);

// Warning messages
console.warn('Deprecated function called');

// Error messages
console.error('Failed to fetch data');

// Information messages
console.info('Application initialized');

// Tabular data
console.table(usersArray);

// Grouping related logs
console.group('User Authentication');
console.log('Validating credentials...');
console.log('Authentication successful');
console.groupEnd();

// Timing operations
console.time('dataFetch');
// ... some operation
console.timeEnd('dataFetch'); // Outputs: dataFetch: 1234.56ms

// Conditional logging
console.assert(user.age >= 18, 'User is underage');

// Tracing function calls
console.trace();

// Styled console output
console.log('%cHello World', 'color: blue; font-size: 20px');
```

**b) Breakpoints**

Breakpoints allow you to pause code execution and inspect the state:

```javascript
function calculateTotal(items) {
  let total = 0;
  
  for (let i = 0; i < items.length; i++) {
    // Debugger statement - code will pause here when DevTools is open
    debugger;
    total += items[i].price * items[i].quantity;
  }
  
  return total;
}
```

You can also set breakpoints in the browser's DevTools:
- Line breakpoints: Pause at a specific line
- Conditional breakpoints: Pause only when a condition is true
- DOM breakpoints: Pause when the DOM structure changes
- XHR/Fetch breakpoints: Pause when a specific URL is requested
- Event listener breakpoints: Pause when specific events are triggered

**c) Call Stack and Scope**

The call stack shows the execution path that led to the current point in the code. The scope pane shows all variables in the current scope.

**d) Network Panel**

The Network panel helps debug network-related issues:

```javascript
// Making a fetch request that you can inspect in the Network panel
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log('Data received:', data))
  .catch(error => console.error('Fetch error:', error));
```

**e) Performance and Memory Profiling**

Browser DevTools provide performance and memory profiling tools to identify bottlenecks and memory leaks.

```javascript
// Example of a memory leak due to event listeners not being removed
function setupEventHandlers() {
  const button = document.getElementById('myButton');
  
  // This adds a new event listener every time the function is called
  // without removing the old ones
  button.addEventListener('click', () => {
    console.log('Button clicked');
  });
}

// Correct approach
function setupEventHandlersCorrectly() {
  const button = document.getElementById('myButton');
  const handleClick = () => console.log('Button clicked');
  
  // Remove existing listener before adding a new one
  button.removeEventListener('click', handleClick);
  button.addEventListener('click', handleClick);
}
```

**2. Debugging Statements and Techniques**

**a) The `debugger` Statement**

```javascript
function processUserData(user) {
  if (!user) {
    console.error('User data is missing');
    return;
  }
  
  // Add debugger statement to inspect the user object
  debugger;
  
  // Process user data
  const fullName = `${user.firstName} ${user.lastName}`;
  // ...
}
```

**b) Try-Catch Blocks**

```javascript
try {
  // Code that might throw an error
  const data = JSON.parse(jsonString);
  processData(data);
} catch (error) {
  console.error('Error processing data:', error.message);
  // Handle the error gracefully
  showErrorToUser('Failed to process data. Please try again.');
} finally {
  // Code that runs regardless of whether an error occurred
  hideLoadingIndicator();
}
```

**c) Error Objects and Custom Errors**

```javascript
// Creating custom error types
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';
  }
}

class DatabaseError extends Error {
  constructor(message, query) {
    super(message);
    this.name = 'DatabaseError';
    this.query = query;
  }
}

// Using custom errors
function validateUser(user) {
  if (!user.email) {
    throw new ValidationError('Email is required');
  }
  
  if (!user.password || user.password.length < 8) {
    throw new ValidationError('Password must be at least 8 characters');
  }
}

try {
  validateUser({ email: 'user@example.com', password: '123' });
} catch (error) {
  if (error instanceof ValidationError) {
    console.error('Validation failed:', error.message);
  } else {
    console.error('Unknown error:', error);
  }
}
```

**d) Logging Middleware**

```javascript
// Redux middleware for logging actions and state changes
const loggerMiddleware = store => next => action => {
  console.group(action.type);
  console.log('Previous state:', store.getState());
  console.log('Action:', action);
  const result = next(action);
  console.log('Next state:', store.getState());
  console.groupEnd();
  return result;
};

// Express middleware for logging requests
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);
  const start = Date.now();
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`${new Date().toISOString()} - ${req.method} ${req.url} ${res.statusCode} - ${duration}ms`);
  });
  next();
});
```

**3. Source Maps**

Source maps allow you to debug the original source code even when running minified or transpiled code in production.

```javascript
// webpack.config.js example for generating source maps
module.exports = {
  mode: 'development',
  devtool: 'source-map', // or 'eval-source-map' for development
  // ... other webpack configuration
};

// Babel configuration for source maps
{
  "presets": ["@babel/preset-env"],
  "sourceMaps": true
}
```

**4. Specialized Debugging Tools**

**a) React DevTools**

React DevTools is a browser extension for debugging React applications.

```javascript
// Example of a React component that you can inspect with React DevTools
function UserProfile({ user }) {
  const [isEditing, setIsEditing] = useState(false);
  
  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      {isEditing ? (
        <EditForm user={user} onSave={() => setIsEditing(false)} />
      ) : (
        <button onClick={() => setIsEditing(true)}>Edit Profile</button>
      )}
    </div>
  );
}
```

**b) Redux DevTools**

Redux DevTools helps debug Redux state management.

```javascript
// Setting up Redux with DevTools
import { createStore, applyMiddleware, compose } from 'redux';
import rootReducer from './reducers';

const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;

const store = createStore(
  rootReducer,
  composeEnhancers(applyMiddleware(/* your middlewares */))
);
```

**c) Vue DevTools**

Vue DevTools is a browser extension for debugging Vue.js applications.

**d) Angular DevTools**

Angular DevTools helps debug Angular applications.

**5. Node.js Debugging**

**a) Node.js Inspector**

```bash
# Start Node.js with the inspector
node --inspect server.js

# Break on the first line
node --inspect-brk server.js
```

**b) Visual Studio Code Debugging**

VS Code provides integrated debugging for Node.js applications.

```json
// .vscode/launch.json example
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Launch Program",
      "skipFiles": ["<node_internals>/**"],
      "program": "${workspaceFolder}/server.js"
    },
    {
      "type": "chrome",
      "request": "launch",
      "name": "Launch Chrome",
      "url": "http://localhost:3000",
      "webRoot": "${workspaceFolder}/public"
    }
  ]
}
```

**c) Node.js Console Methods**

```javascript
// Printing objects with depth
console.dir(complexObject, { depth: null, colors: true });

// Using util.inspect for better object logging
const util = require('util');
console.log(util.inspect(complexObject, { depth: null, colors: true }));

// Debug module for conditional logging
const debug = require('debug')('app:server');
debug('Server starting on port %d', 3000);
```

**6. Remote Debugging**

**a) Remote Chrome Debugging**

```bash
# Start Chrome with remote debugging enabled
google-chrome --remote-debugging-port=9222
```

**b) Mobile Device Debugging**

Use browser DevTools to debug web applications running on mobile devices:

- Chrome: chrome://inspect/#devices
- Safari: Connect iOS device and use Safari's Developer menu

**7. Automated Error Tracking**

**a) Error Monitoring Services**

```javascript
// Example using Sentry for error tracking
import * as Sentry from '@sentry/browser';

Sentry.init({
  dsn: 'https://examplePublicKey@o0.ingest.sentry.io/0',
  integrations: [new Integrations.BrowserTracing()],
  tracesSampleRate: 1.0,
});

try {
  riskyOperation();
} catch (error) {
  Sentry.captureException(error);
  // Also show error to user
  showErrorMessage(error.message);
}
```

**b) Custom Error Handling**

```javascript
// Global error handler for uncaught exceptions in browser
window.addEventListener('error', (event) => {
  console.error('Uncaught error:', event.error);
  // Send to analytics or error tracking service
  sendErrorToAnalytics({
    message: event.error.message,
    stack: event.error.stack,
    url: window.location.href,
    timestamp: new Date().toISOString()
  });
  // Prevent default browser error handling
  event.preventDefault();
});

// Handling unhandled promise rejections
window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event.reason);
  // Send to analytics or error tracking service
  sendErrorToAnalytics({
    message: event.reason.message || 'Unhandled promise rejection',
    stack: event.reason.stack,
    url: window.location.href,
    timestamp: new Date().toISOString()
  });
});
```

**8. Advanced Debugging Techniques**

**a) Proxy Objects for Debugging**

```javascript
// Using Proxy to monitor property access
function createDebuggableObject(obj, name = 'object') {
  return new Proxy(obj, {
    get(target, prop) {
      const value = target[prop];
      console.log(`${name}.${prop} accessed, value:`, value);
      return value;
    },
    set(target, prop, value) {
      console.log(`${name}.${prop} changed from ${target[prop]} to ${value}`);
      target[prop] = value;
      return true;
    }
  });
}

const user = createDebuggableObject({ name: 'John', age: 30 }, 'user');
user.name; // logs: user.name accessed, value: John
user.age = 31; // logs: user.age changed from 30 to 31
```

**b) Monkey Patching for Debugging**

```javascript
// Temporarily overriding a method for debugging
const originalFetch = window.fetch;
window.fetch = function(...args) {
  console.log('fetch called with:', args);
  return originalFetch.apply(this, args)
    .then(response => {
      console.log('fetch response:', response);
      return response;
    })
    .catch(error => {
      console.error('fetch error:', error);
      throw error;
    });
};

// Don't forget to restore the original when done
// window.fetch = originalFetch;
```

**c) Conditional Breakpoints with Console**

You can combine conditional breakpoints with console logging in browser DevTools:

```javascript
// In the conditional breakpoint expression field, add:
false && console.log('Loop index:', i, 'Current item:', items[i])
```

This won't pause execution but will log the values when the breakpoint condition is evaluated.

**9. Testing and Debugging**

**a) Unit Tests as Debugging Tools**

```javascript
// Writing a test to reproduce and debug an issue
test('calculateTotal handles empty items array', () => {
  // This test reproduces the bug
  const result = calculateTotal([]);
  expect(result).toBe(0); // This will fail if there's a bug
});

// Fix the bug in the implementation
function calculateTotal(items) {
  if (!items || items.length === 0) {
    return 0; // Fix: handle empty array
  }
  
  return items.reduce((total, item) => {
    return total + (item.price * item.quantity);
  }, 0);
}
```

**b) Debugging Tests**

```bash
# Running Jest with Node inspector
node --inspect-brk node_modules/.bin/jest --runInBand
```

**10. Debugging Best Practices**

**a) Reproduce the Issue**

Create a minimal, reproducible example of the issue.

**b) Divide and Conquer**

Use binary search to narrow down the source of the problem.

**c) Rubber Duck Debugging**

Explain the problem line by line to an inanimate object (or a colleague).

**d) Read the Error Message**

Error messages often contain valuable information about what went wrong and where.

**e) Check Recent Changes**

Review recent code changes that might have introduced the bug.

**f) Use Version Control**

Use git bisect to find which commit introduced a bug.

```bash
# Start the bisect process
git bisect start

# Mark the current version as bad
git bisect bad

# Mark a known good version
git bisect good v1.0.0

# Git will checkout different commits
# After testing each commit, mark it as good or bad
git bisect good  # or git bisect bad

# When finished, reset to the original state
git bisect reset
```

**g) Document Bugs and Solutions**

Keep a debugging journal to document bugs and their solutions for future reference.

**Key Takeaways:**

1. Master browser DevTools for efficient debugging (Console, Breakpoints, Network panel)
2. Use strategic console logging with different methods (log, warn, error, table, time)
3. Implement try-catch blocks with custom error types for better error handling
4. Set up source maps to debug minified and transpiled code effectively
5. Leverage framework-specific tools like React DevTools and Redux DevTools
6. Use Node.js debugging tools for server-side JavaScript debugging
7. Implement automated error tracking for production applications
8. Apply advanced techniques like Proxy objects and monkey patching for complex issues
9. Write tests to reproduce and verify bug fixes
10. Follow debugging best practices: reproduce, divide and conquer, read error messages carefully

## Functional Programming and Modern JavaScript

### Q81: How does functional programming work in JavaScript, and what are its key concepts?
**Difficulty: Hard**

**Answer:**
Functional programming (FP) is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. JavaScript, being a multi-paradigm language, supports functional programming concepts, which have become increasingly popular in modern JavaScript development. Let's explore the key concepts of functional programming in JavaScript.

**1. First-Class Functions**

In JavaScript, functions are first-class citizens, meaning they can be:
- Assigned to variables
- Passed as arguments to other functions
- Returned from other functions
- Stored in data structures

```javascript
// Assigning a function to a variable
const greet = function(name) {
  return `Hello, ${name}!`;
};

// Passing a function as an argument
function executeFunction(fn, value) {
  return fn(value);
}
const greeting = executeFunction(greet, 'Alice'); // 'Hello, Alice!'

// Returning a function from another function
function createMultiplier(factor) {
  return function(number) {
    return number * factor;
  };
}
const double = createMultiplier(2);
const result = double(5); // 10

// Storing functions in data structures
const functionArray = [
  x => x + 1,
  x => x * 2,
  x => x ** 2
];
const computeAll = x => functionArray.map(fn => fn(x));
computeAll(3); // [4, 6, 9]
```

**2. Pure Functions**

Pure functions are functions that:
- Given the same input, always return the same output
- Have no side effects (don't modify external state)
- Don't rely on external state

```javascript
// Pure function
function add(a, b) {
  return a + b;
}

// Impure function (relies on external state)
let counter = 0;
function incrementCounter() {
  counter++; // Side effect: modifies external state
  return counter;
}

// Impure function (has side effects)
function addToArray(arr, item) {
  arr.push(item); // Side effect: modifies the input array
  return arr;
}

// Pure alternative to addToArray
function pureAddToArray(arr, item) {
  return [...arr, item]; // Returns a new array without modifying the original
}
```

**3. Immutability**

Immutability means not changing data once it's created. Instead of modifying existing data, you create new copies with the desired changes.

```javascript
// Mutable approach (avoid in FP)
const numbers = [1, 2, 3];
numbers.push(4); // Modifies the original array

// Immutable approach (preferred in FP)
const originalNumbers = [1, 2, 3];
const newNumbers = [...originalNumbers, 4]; // Creates a new array

// Immutable object updates
const user = { name: 'John', age: 30 };

// Bad: Mutating the object
user.age = 31;

// Good: Creating a new object
const updatedUser = { ...user, age: 31 };

// Using Object.freeze for enforcing immutability
const frozenUser = Object.freeze({ name: 'Alice', age: 25 });
// The following will fail in strict mode or be silently ignored
// frozenUser.age = 26;
```

**4. Higher-Order Functions**

Higher-order functions are functions that take other functions as arguments and/or return functions.

```javascript
// Higher-order function that takes a function as an argument
function map(array, transformFn) {
  const result = [];
  for (let i = 0; i < array.length; i++) {
    result.push(transformFn(array[i]));
  }
  return result;
}

const numbers = [1, 2, 3, 4];
const doubled = map(numbers, x => x * 2); // [2, 4, 6, 8]

// Higher-order function that returns a function (currying)
function multiply(a) {
  return function(b) {
    return a * b;
  };
}

const triple = multiply(3);
triple(4); // 12

// Using built-in higher-order functions
const numbers = [1, 2, 3, 4, 5];

// map: Transform each element
const squared = numbers.map(x => x ** 2); // [1, 4, 9, 16, 25]

// filter: Keep elements that pass a test
const evens = numbers.filter(x => x % 2 === 0); // [2, 4]

// reduce: Accumulate values
const sum = numbers.reduce((acc, x) => acc + x, 0); // 15
```

**5. Function Composition**

Function composition is the process of combining two or more functions to create a new function.

```javascript
// Basic function composition
const add5 = x => x + 5;
const multiply2 = x => x * 2;

// Manual composition
const add5ThenMultiply2 = x => multiply2(add5(x));
add5ThenMultiply2(3); // (3 + 5) * 2 = 16

// Creating a compose utility
function compose(...fns) {
  return function(x) {
    return fns.reduceRight((acc, fn) => fn(acc), x);
  };
}

const add5AndMultiply2 = compose(multiply2, add5);
add5AndMultiply2(3); // 16

// Creating a pipe utility (left-to-right composition)
function pipe(...fns) {
  return function(x) {
    return fns.reduce((acc, fn) => fn(acc), x);
  };
}

const multiply2ThenAdd5 = pipe(multiply2, add5);
multiply2ThenAdd5(3); // (3 * 2) + 5 = 11
```

**6. Recursion**

Recursion is a technique where a function calls itself to solve a problem.

```javascript
// Factorial using recursion
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}

factorial(5); // 120

// Fibonacci sequence using recursion
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

fibonacci(6); // 8

// Tail-recursive factorial (more efficient)
function factorialTail(n, accumulator = 1) {
  if (n <= 1) return accumulator;
  return factorialTail(n - 1, n * accumulator);
}

factorialTail(5); // 120
```

**7. Currying**

Currying is the technique of converting a function that takes multiple arguments into a sequence of functions that each take a single argument.

```javascript
// Regular function with multiple arguments
function add(a, b, c) {
  return a + b + c;
}

// Curried version
function curriedAdd(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

curriedAdd(1)(2)(3); // 6

// Using arrow functions for more concise syntax
const arrowCurriedAdd = a => b => c => a + b + c;
arrowCurriedAdd(1)(2)(3); // 6

// Practical example: Creating specialized functions
const addTax = rate => price => price * (1 + rate);
const addVAT = addTax(0.20); // 20% tax
const addSalesTax = addTax(0.0725); // 7.25% tax

addVAT(100); // 120
addSalesTax(100); // 107.25
```

**8. Partial Application**

Partial application is the process of fixing a number of arguments to a function, producing another function of smaller arity.

```javascript
// Using bind for partial application
function greet(greeting, name) {
  return `${greeting}, ${name}!`;
}

const sayHello = greet.bind(null, 'Hello');
sayHello('John'); // 'Hello, John!'

// Custom partial application helper
function partial(fn, ...args) {
  return function(...moreArgs) {
    return fn(...args, ...moreArgs);
  };
}

const multiply = (a, b, c) => a * b * c;
const multiplyBy5And10 = partial(multiply, 5, 10);
multiplyBy5And10(3); // 5 * 10 * 3 = 150
```

**9. Point-Free Style (Tacit Programming)**

Point-free style is a coding style where function definitions do not explicitly identify the arguments used. This style usually employs function composition and currying.

```javascript
// Regular style (points to arguments)
const numbers = [1, 2, 3, 4, 5];
const isEven = x => x % 2 === 0;
const evenNumbers = numbers.filter(x => isEven(x));

// Point-free style (doesn't mention arguments)
const evenNumbersPointFree = numbers.filter(isEven);

// Another example with composition
const users = [
  { name: 'John', age: 25 },
  { name: 'Jane', age: 30 }
];

// Regular style
const getNames = users => users.map(user => user.name);

// Point-free style with a utility
const prop = key => obj => obj[key];
const getNamesPointFree = users => users.map(prop('name'));
```

**10. Functors and Monads**

Functors and monads are containers for values that provide a standardized way to apply operations to those values.

**a) Functors**

A functor is an object that has a map method which preserves the structure of the object while transforming its contents.

```javascript
// Array as a functor
const numbers = [1, 2, 3];
const doubled = numbers.map(x => x * 2); // [2, 4, 6]

// Creating a simple functor
class Box {
  constructor(value) {
    this.value = value;
  }
  
  map(fn) {
    return new Box(fn(this.value));
  }
  
  toString() {
    return `Box(${this.value})`;
  }
}

const box = new Box(5);
const boxDoubled = box.map(x => x * 2); // Box(10)
```

**b) Monads**

A monad is a functor with additional methods like flatMap (chain) that help in sequencing operations.

```javascript
// Creating a simple monad (Maybe monad for handling null/undefined)
class Maybe {
  constructor(value) {
    this.value = value;
  }
  
  static of(value) {
    return new Maybe(value);
  }
  
  isNothing() {
    return this.value === null || this.value === undefined;
  }
  
  map(fn) {
    return this.isNothing() ? this : Maybe.of(fn(this.value));
  }
  
  flatMap(fn) {
    return this.isNothing() ? this : fn(this.value);
  }
  
  getOrElse(defaultValue) {
    return this.isNothing() ? defaultValue : this.value;
  }
  
  toString() {
    return this.isNothing() ? 'Maybe(Nothing)' : `Maybe(${this.value})`;
  }
}

// Using Maybe to safely access nested properties
const user = { name: 'John', address: { street: 'Main St' } };
const noAddress = { name: 'Jane' };

function getStreet(user) {
  return Maybe.of(user)
    .map(u => u.address)
    .map(a => a.street)
    .getOrElse('No street found');
}

getStreet(user); // 'Main St'
getStreet(noAddress); // 'No street found'
```

**11. Functional Libraries in JavaScript**

Several libraries help implement functional programming in JavaScript:

```javascript
// Using Ramda
const R = require('ramda');

const numbers = [1, 2, 3, 4, 5];

// Composition with Ramda
const isEven = x => x % 2 === 0;
const double = x => x * 2;
const add1 = x => x + 1;

const transformNumbers = R.pipe(
  R.filter(isEven),
  R.map(double),
  R.map(add1)
);

transformNumbers(numbers); // [5, 9]

// Using Lodash/FP
const _ = require('lodash/fp');

const processUsers = _.flow([
  _.filter(user => user.active),
  _.map(_.pick(['id', 'name'])),
  _.sortBy('name')
]);

processUsers(users);
```

**12. Practical Applications of Functional Programming**

**a) State Management in React with Redux**

```javascript
// Redux reducer (pure function)
function counterReducer(state = 0, action) {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    case 'DECREMENT':
      return state - 1;
    default:
      return state;
  }
}

// Action creators
const increment = () => ({ type: 'INCREMENT' });
const decrement = () => ({ type: 'DECREMENT' });
```

**b) Data Transformation Pipelines**

```javascript
// Processing a list of transactions
const transactions = [
  { id: 1, type: 'debit', amount: 100, category: 'food' },
  { id: 2, type: 'credit', amount: 500, category: 'salary' },
  { id: 3, type: 'debit', amount: 200, category: 'transport' },
  { id: 4, type: 'debit', amount: 50, category: 'food' }
];

// Using a functional approach to analyze transactions
const totalByCategory = transactions
  .filter(t => t.type === 'debit')
  .reduce((acc, t) => {
    acc[t.category] = (acc[t.category] || 0) + t.amount;
    return acc;
  }, {});

// Result: { food: 150, transport: 200 }
```

**13. Benefits of Functional Programming**

- **Predictability**: Pure functions always produce the same output for the same input
- **Testability**: Pure functions are easier to test since they don't have side effects
- **Concurrency**: Immutable data and pure functions make concurrent programming safer
- **Debugging**: With pure functions, bugs are often easier to locate and fix
- **Reusability**: Higher-order functions and composition promote code reuse

**14. Challenges and Limitations**

- **Performance overhead**: Creating new objects instead of mutating existing ones can be less efficient
- **Learning curve**: FP concepts can be challenging for developers used to imperative programming
- **JavaScript limitations**: JavaScript wasn't originally designed for FP, so some patterns can be verbose

**Key Takeaways:**

1. Embrace pure functions that don't have side effects and always return the same output for the same input
2. Use immutability by creating new data structures instead of modifying existing ones
3. Leverage higher-order functions like map, filter, and reduce for data transformations
4. Apply function composition to build complex operations from simple functions
5. Understand currying and partial application for creating specialized functions
6. Use recursion for elegant solutions to problems that involve repeated operations
7. Explore point-free style to make code more declarative and concise
8. Learn about functors and monads for handling operations on contained values
9. Consider functional libraries like Ramda or Lodash/FP for more advanced FP capabilities
10. Apply FP principles pragmatically, combining them with other paradigms when appropriate

### Q82: What is WebAssembly (WASM) and how does it integrate with JavaScript?
**Difficulty: Hard**

**Answer:**
WebAssembly (WASM) is a binary instruction format designed as a portable compilation target for high-performance applications on the web. It's a low-level assembly-like language with a compact binary format that runs with near-native performance and provides languages like C/C++, Rust, and others with a compilation target so they can run on the web.

**1. Core Concepts of WebAssembly**

**a) Key Characteristics**

- **Binary format**: WASM is distributed as compact binary code, not as text
- **Near-native speed**: Executes at performance close to native machine code
- **Memory-safe**: Runs in a sandboxed execution environment
- **Language-agnostic**: Can be generated from multiple programming languages
- **Complements JavaScript**: Designed to work alongside JavaScript, not replace it

**b) WebAssembly Module Structure**

A WebAssembly module consists of:
- Functions (code)
- Tables (references)
- Memory (linear array of bytes)
- Globals (variables)

**2. How WebAssembly Works with JavaScript**

**a) Loading and Instantiating WASM Modules**

```javascript
// Basic WebAssembly loading pattern
async function loadWasmModule() {
  try {
    // Fetch the WASM module as binary data
    const response = await fetch('module.wasm');
    const buffer = await response.arrayBuffer();
    
    // Compile and instantiate the module
    const module = await WebAssembly.compile(buffer);
    const instance = await WebAssembly.instantiate(module);
    
    // Access exported functions
    return instance.exports;
  } catch (error) {
    console.error('Failed to load WASM module:', error);
  }
}

// Using the module
loadWasmModule().then(exports => {
  // Call an exported function
  const result = exports.calculateFibonacci(10);
  console.log('Fibonacci result:', result);
});
```

**b) Streamlined Loading with instantiateStreaming**

```javascript
// More efficient loading with instantiateStreaming
async function loadWasmModuleStreaming() {
  try {
    // Fetch and instantiate in one step
    const { instance } = await WebAssembly.instantiateStreaming(
      fetch('module.wasm')
    );
    
    return instance.exports;
  } catch (error) {
    console.error('Failed to load WASM module:', error);
  }
}
```

**c) Passing JavaScript Functions to WebAssembly (Imports)**

```javascript
// Importing JavaScript functions into WebAssembly
async function loadWasmWithImports() {
  // JavaScript functions to be imported into WASM
  const importObject = {
    env: {
      consoleLog: (value) => console.log('WASM says:', value),
      currentTimeMillis: () => Date.now(),
      // Memory allocation helpers could go here
    }
  };
  
  const { instance } = await WebAssembly.instantiateStreaming(
    fetch('module.wasm'),
    importObject
  );
  
  return instance.exports;
}
```

**3. Memory Management and Data Exchange**

**a) Accessing WebAssembly Memory from JavaScript**

```javascript
async function workWithWasmMemory() {
  const { instance } = await WebAssembly.instantiateStreaming(
    fetch('memory.wasm')
  );
  
  // Get a reference to the WebAssembly memory
  const wasmMemory = instance.exports.memory;
  
  // Create a view into the memory buffer
  const buffer = new Uint8Array(wasmMemory.buffer);
  
  // Call a WASM function that writes to memory
  const offset = instance.exports.writeData();
  
  // Read the data written by the WASM function
  console.log('Data from WASM memory:', buffer.slice(offset, offset + 10));
  
  // Write data from JavaScript to WASM memory
  const inputOffset = 1024; // Some predetermined offset
  for (let i = 0; i < 10; i++) {
    buffer[inputOffset + i] = i * 10;
  }
  
  // Call a WASM function that reads the data we just wrote
  instance.exports.processData(inputOffset, 10);
}
```

**b) Passing Complex Data Structures**

```javascript
async function passComplexData() {
  const { instance } = await WebAssembly.instantiateStreaming(
    fetch('complex-data.wasm')
  );
  
  const { memory, allocateArray, processArray, freeArray } = instance.exports;
  
  // Create a JavaScript array
  const jsArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  
  // Allocate memory in WASM for the array
  const arraySize = jsArray.length;
  const arrayPointer = allocateArray(arraySize);
  
  // Get a view of the memory
  const memoryView = new Int32Array(memory.buffer);
  
  // Copy the JavaScript array to WASM memory
  for (let i = 0; i < arraySize; i++) {
    memoryView[arrayPointer / 4 + i] = jsArray[i]; // Divide by 4 because Int32Array uses 4 bytes per element
  }
  
  // Process the array in WebAssembly
  const sumResult = processArray(arrayPointer, arraySize);
  console.log('Sum calculated in WASM:', sumResult);
  
  // Free the allocated memory when done
  freeArray(arrayPointer);
}
```

**4. Performance Considerations**

**a) When to Use WebAssembly**

- **Computationally intensive tasks**: Image/video processing, physics simulations, cryptography
- **Performance-critical algorithms**: When JavaScript's JIT compilation isn't fast enough
- **Porting existing C/C++/Rust libraries**: Reuse battle-tested code on the web
- **Large applications**: Games, CAD software, scientific visualization

**b) Performance Comparison Example**

```javascript
// Fibonacci calculation in JavaScript
function fibonacciJS(n) {
  if (n <= 1) return n;
  return fibonacciJS(n - 1) + fibonacciJS(n - 2);
}

// Benchmark JavaScript vs WebAssembly
async function runBenchmark() {
  const wasmExports = await loadWasmModule();
  
  const n = 40;
  
  console.time('JavaScript Fibonacci');
  const jsResult = fibonacciJS(n);
  console.timeEnd('JavaScript Fibonacci');
  
  console.time('WebAssembly Fibonacci');
  const wasmResult = wasmExports.fibonacci(n);
  console.timeEnd('WebAssembly Fibonacci');
  
  console.log(`JS Result: ${jsResult}, WASM Result: ${wasmResult}`);
}
```

**5. Creating WebAssembly Modules**

**a) Using Emscripten (C/C++ to WASM)**

Emscripten is a toolchain for compiling C and C++ to WebAssembly.

```c
// simple.c
#include <emscripten.h>

EMSCRIPTEN_KEEPALIVE
int fibonacci(int n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

Compile with:
```bash
emcc simple.c -o simple.js -s WASM=1 -s EXPORTED_FUNCTIONS='["_fibonacci"]' -s EXPORTED_RUNTIME_METHODS='["ccall", "cwrap"]'
```

Using in JavaScript:
```javascript
// After loading simple.js
const fibonacci = Module.cwrap('fibonacci', 'number', ['number']);
const result = fibonacci(10); // 55
```

**b) Using Rust with wasm-bindgen**

```rust
// lib.rs
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn fibonacci(n: u32) -> u32 {
    if n <= 1 {
        return n;
    }
    fibonacci(n - 1) + fibonacci(n - 2)
}

#[wasm_bindgen]
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

Compile with:
```bash
wasm-pack build --target web
```

Using in JavaScript:
```javascript
import init, { fibonacci, add } from './pkg/my_wasm_module.js';

async function run() {
  await init();
  console.log(fibonacci(10)); // 55
  console.log(add(40, 2)); // 42
}

run();
```

**c) Using AssemblyScript (TypeScript-like to WASM)**

```typescript
// assembly/index.ts
export function fibonacci(n: i32): i32 {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

export function add(a: i32, b: i32): i32 {
  return a + b;
}
```

Compile with:
```bash
asc assembly/index.ts -o build/optimized.wasm
```

Using in JavaScript:
```javascript
async function loadAndRun() {
  const imports = {};
  const { instance } = await WebAssembly.instantiateStreaming(
    fetch('build/optimized.wasm'),
    imports
  );
  
  const { fibonacci, add } = instance.exports;
  console.log(fibonacci(10)); // 55
  console.log(add(40, 2)); // 42
}
```

**6. Real-World Applications**

**a) Image Processing with WebAssembly**

```javascript
async function processImage() {
  const wasmModule = await loadWasmModule('image-processing.wasm');
  
  // Get the image data from a canvas
  const canvas = document.getElementById('sourceCanvas');
  const ctx = canvas.getContext('2d');
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  
  // Get a reference to the pixel data
  const pixels = imageData.data;
  
  // Allocate memory in WASM and copy the pixel data
  const { memory, allocateBuffer, applyFilter, freeBuffer } = wasmModule;
  const pixelCount = pixels.length;
  const bufferPointer = allocateBuffer(pixelCount);
  
  // Copy pixels to WASM memory
  const memoryU8 = new Uint8ClampedArray(memory.buffer);
  memoryU8.set(pixels, bufferPointer);
  
  // Apply a filter (e.g., grayscale, blur, etc.)
  applyFilter(bufferPointer, canvas.width, canvas.height);
  
  // Copy the processed pixels back
  const processedPixels = memoryU8.slice(bufferPointer, bufferPointer + pixelCount);
  const newImageData = new ImageData(processedPixels, canvas.width, canvas.height);
  
  // Display the processed image
  const outputCanvas = document.getElementById('outputCanvas');
  const outputCtx = outputCanvas.getContext('2d');
  outputCtx.putImageData(newImageData, 0, 0);
  
  // Free the allocated memory
  freeBuffer(bufferPointer);
}
```

**b) Game Development with WebAssembly**

```javascript
async function initializeGame() {
  // Load the game engine compiled to WebAssembly
  const gameModule = await WebAssembly.instantiateStreaming(
    fetch('game-engine.wasm')
  );
  
  const { 
    initializeEngine, 
    updateGameState, 
    renderFrame,
    handleInput,
    memory
  } = gameModule.instance.exports;
  
  // Initialize the game engine
  const canvasWidth = 800;
  const canvasHeight = 600;
  const canvasPtr = initializeEngine(canvasWidth, canvasHeight);
  
  // Set up the rendering context
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  
  // Set up input handlers
  document.addEventListener('keydown', (event) => {
    handleInput(event.keyCode, 1); // 1 for key down
  });
  
  document.addEventListener('keyup', (event) => {
    handleInput(event.keyCode, 0); // 0 for key up
  });
  
  // Game loop
  function gameLoop(timestamp) {
    // Update game state
    updateGameState(timestamp);
    
    // Render the frame
    renderFrame();
    
    // Copy the frame buffer from WASM memory to canvas
    const frameBuffer = new Uint8ClampedArray(
      memory.buffer, 
      canvasPtr, 
      canvasWidth * canvasHeight * 4
    );
    
    const imageData = new ImageData(frameBuffer, canvasWidth, canvasHeight);
    ctx.putImageData(imageData, 0, 0);
    
    // Continue the game loop
    requestAnimationFrame(gameLoop);
  }
  
  // Start the game loop
  requestAnimationFrame(gameLoop);
}
```

**7. WebAssembly System Interface (WASI)**

WASI is a modular system interface for WebAssembly that provides a way for WASM modules to interact with system resources in a secure, sandboxed way.

```javascript
// Using WASI in a Node.js environment
const fs = require('fs');
const { WASI } = require('wasi');

// Create a new WASI instance
const wasi = new WASI({
  args: ['wasm-module', 'arg1', 'arg2'],
  env: process.env,
  preopens: {
    '/sandbox': '/some/real/path/on/host'
  }
});

// Read the WASM file
const wasmBuffer = fs.readFileSync('./module.wasm');

// Compile and instantiate the WebAssembly module
WebAssembly.compile(wasmBuffer).then(module => {
  // Create imports object with WASI imports
  const importObject = { wasi_snapshot_preview1: wasi.wasiImport };
  
  return WebAssembly.instantiate(module, importObject);
}).then(instance => {
  // Initialize WASI
  wasi.initialize(instance);
  
  // Run the WASM module's main function
  const exitCode = instance.exports._start();
  console.log(`WASM module exited with code ${exitCode}`);
});
```

**8. WebAssembly Threads and Shared Memory**

WebAssembly supports threads via SharedArrayBuffer and Atomics.

```javascript
// Creating a shared memory for WebAssembly threads
async function initThreadedWasm() {
  // Create a shared memory of 16 pages (1MB)
  const memory = new WebAssembly.Memory({ 
    initial: 16, 
    maximum: 100, 
    shared: true 
  });
  
  const importObject = {
    env: {
      memory,
      // Other imports...
    }
  };
  
  // Instantiate the main thread module
  const { instance } = await WebAssembly.instantiateStreaming(
    fetch('threaded-module.wasm'),
    importObject
  );
  
  // Create Web Workers for additional threads
  const workers = [];
  const numWorkers = navigator.hardwareConcurrency - 1 || 3;
  
  for (let i = 0; i < numWorkers; i++) {
    const worker = new Worker('wasm-worker.js');
    
    // Pass the shared memory to the worker
    worker.postMessage({
      memory,
      workerId: i
    });
    
    workers.push(worker);
  }
  
  // Start the computation
  instance.exports.startThreadedComputation(numWorkers);
  
  // Listen for results from workers
  workers.forEach(worker => {
    worker.onmessage = (event) => {
      if (event.data.type === 'result') {
        console.log(`Worker result: ${event.data.result}`);
      }
    };
  });
  
  return { instance, workers };
}

// In wasm-worker.js
self.onmessage = async (event) => {
  const { memory, workerId } = event.data;
  
  const importObject = {
    env: {
      memory,
      // Other imports...
    }
  };
  
  // Instantiate the worker module
  const { instance } = await WebAssembly.instantiateStreaming(
    fetch('threaded-module.wasm'),
    importObject
  );
  
  // Run the worker's computation
  const result = instance.exports.runWorkerTask(workerId);
  
  // Send the result back to the main thread
  self.postMessage({
    type: 'result',
    result
  });
};
```

**9. WebAssembly Garbage Collection (WasmGC)**

WasmGC is an upcoming feature that will add garbage collection support to WebAssembly, making it easier to compile languages like Java, C#, and others to WASM.

```javascript
// This is a future API example (not yet implemented in browsers)
async function loadWasmGCModule() {
  const { instance } = await WebAssembly.instantiateStreaming(
    fetch('gc-module.wasm')
  );
  
  // Create a new object in WASM memory
  const person = instance.exports.Person.new("John", 30);
  
  // Call methods on the object
  console.log(person.getName()); // "John"
  console.log(person.getAge()); // 30
  
  // The object will be garbage collected when no longer referenced
}
```

**10. Debugging WebAssembly**

**a) Using Source Maps**

```javascript
async function loadDebugWasmModule() {
  // Load both the WASM module and its source map
  const [wasmResponse, sourceMapResponse] = await Promise.all([
    fetch('module.wasm'),
    fetch('module.wasm.map')
  ]);
  
  const wasmBuffer = await wasmResponse.arrayBuffer();
  const sourceMapText = await sourceMapResponse.text();
  
  // Register the source map with the browser's debugger
  const wasmModule = await WebAssembly.compile(wasmBuffer);
  
  // This is a conceptual API (actual implementation varies by browser)
  // WebAssembly.setSourceMap(wasmModule, JSON.parse(sourceMapText));
  
  const instance = await WebAssembly.instantiate(wasmModule);
  return instance.exports;
}
```

**b) Using Browser DevTools**

Modern browsers are adding support for debugging WebAssembly:

- Chrome DevTools: Allows stepping through WASM code
- Firefox Developer Tools: Shows WASM disassembly
- WebAssembly Binary Toolkit (WABT): Provides tools for WASM inspection

**11. Future of WebAssembly**

- **Interface Types**: For easier interoperability between WASM and host environments
- **Component Model**: For better modularity and composition of WASM modules
- **Exception Handling**: For standardized error handling across languages
- **Garbage Collection**: For languages with managed memory
- **SIMD (Single Instruction, Multiple Data)**: For vectorized operations
- **Threads**: Enhanced threading support
- **Tail Calls**: For optimizing recursive functions

**Key Takeaways:**

1. WebAssembly is a binary instruction format that enables high-performance code execution in browsers
2. WASM complements JavaScript rather than replacing it, with both working together in web applications
3. WebAssembly modules can be created from languages like C/C++, Rust, and AssemblyScript
4. Memory management requires careful handling when sharing data between JavaScript and WASM
5. WASM excels at computationally intensive tasks like image processing, games, and simulations
6. Tools like Emscripten, wasm-bindgen, and AssemblyScript simplify compiling to WebAssembly
7. WebAssembly System Interface (WASI) extends WASM's capabilities beyond the browser
8. Upcoming features like garbage collection and interface types will make WASM more powerful
9. Performance benefits are most noticeable for CPU-intensive operations, not DOM manipulation
10. Debugging support is improving with source maps and browser DevTools integration

## Internationalization and Accessibility Best Practices

### Q83: How do you implement internationalization (i18n) in JavaScript applications?
**Difficulty: Medium**

**Answer:**
Internationalization (i18n) is the process of designing and developing applications that can be adapted to different languages and regions without engineering changes. Let's explore how to implement internationalization in JavaScript applications.

**1. Core Concepts of Internationalization**

**a) Key Terminology**

- **Internationalization (i18n)**: Designing software to support multiple languages and regions
- **Localization (l10n)**: Adapting software for a specific region or language
- **Locale**: A set of parameters that defines language, region, and formatting preferences (e.g., `en-US`, `fr-FR`, `ja-JP`)
- **Translation**: Converting text from one language to another
- **Pluralization**: Handling grammatical number (singular/plural) forms across languages
- **RTL Support**: Right-to-left text direction support for languages like Arabic and Hebrew

**2. Native JavaScript Internationalization API (Intl)**

The `Intl` object is a namespace for the ECMAScript Internationalization API, which provides language-sensitive string comparison, number formatting, date and time formatting.

**a) Number Formatting**

```javascript
// Basic number formatting
const number = 123456.789;

// US English format (default in US browsers)
const usFormatter = new Intl.NumberFormat('en-US');
console.log(usFormatter.format(number)); // "123,456.789"

// German format
const deFormatter = new Intl.NumberFormat('de-DE');
console.log(deFormatter.format(number)); // "123.456,789"

// Currency formatting
const eurFormatter = new Intl.NumberFormat('de-DE', {
  style: 'currency',
  currency: 'EUR'
});
console.log(eurFormatter.format(number)); // "123.456,79 €"

const jpyFormatter = new Intl.NumberFormat('ja-JP', {
  style: 'currency',
  currency: 'JPY'
});
console.log(jpyFormatter.format(number)); // "¥123,457"

// Percentage formatting
const percentFormatter = new Intl.NumberFormat('en-US', {
  style: 'percent',
  minimumFractionDigits: 1
});
console.log(percentFormatter.format(0.2345)); // "23.5%"
```

**b) Date and Time Formatting**

```javascript
const date = new Date(Date.UTC(2023, 0, 15, 12, 0, 0));

// Different locales
const usDateFormatter = new Intl.DateTimeFormat('en-US');
console.log(usDateFormatter.format(date)); // "1/15/2023"

const ukDateFormatter = new Intl.DateTimeFormat('en-GB');
console.log(ukDateFormatter.format(date)); // "15/01/2023"

const jpDateFormatter = new Intl.DateTimeFormat('ja-JP');
console.log(jpDateFormatter.format(date)); // "2023/1/15"

// Different formats
const longFormatter = new Intl.DateTimeFormat('en-US', {
  weekday: 'long',
  year: 'numeric',
  month: 'long',
  day: 'numeric',
  hour: 'numeric',
  minute: 'numeric',
  timeZone: 'America/New_York'
});
console.log(longFormatter.format(date)); // "Sunday, January 15, 2023, 7:00 AM"

// Relative time formatting
const rtf = new Intl.RelativeTimeFormat('en', { style: 'long' });
console.log(rtf.format(-1, 'day')); // "1 day ago"
console.log(rtf.format(2, 'month')); // "in 2 months"
```

**c) String Comparison and Sorting**

```javascript
// String comparison for different locales
const collator = new Intl.Collator('en');
console.log(collator.compare('a', 'b')); // -1 (a comes before b)
console.log(collator.compare('b', 'a')); // 1 (b comes after a)

// Sorting an array of strings
const fruits = ['apple', 'banana', 'Orange', 'cherry'];

// Default sort (case-sensitive)
console.log([...fruits].sort());
// ['Orange', 'apple', 'banana', 'cherry']

// Case-insensitive sort using Intl.Collator
console.log([...fruits].sort(new Intl.Collator('en', { sensitivity: 'base' }).compare));
// ['apple', 'banana', 'cherry', 'Orange']

// Sorting with special characters
const germanWords = ['Äpfel', 'Apfel', 'Zebra', 'ängstlich'];

// German locale-aware sorting
console.log([...germanWords].sort(new Intl.Collator('de').compare));
// ['Apfel', 'Äpfel', 'ängstlich', 'Zebra']
```

**d) Pluralization with PluralRules**

```javascript
const pr = new Intl.PluralRules('en-US');

console.log(pr.select(0)); // 'other'
console.log(pr.select(1)); // 'one'
console.log(pr.select(2)); // 'other'

// Implementing a simple pluralization function
function getPlural(count, locale) {
  const pluralRules = new Intl.PluralRules(locale);
  const rule = pluralRules.select(count);
  
  const messages = {
    'en-US': {
      'one': 'You have 1 notification',
      'other': `You have ${count} notifications`
    },
    'ru': {
      'one': `У вас ${count} уведомление`,
      'few': `У вас ${count} уведомления`,
      'many': `У вас ${count} уведомлений`,
      'other': `У вас ${count} уведомлений`
    }
  };
  
  return messages[locale][rule];
}

console.log(getPlural(1, 'en-US')); // "You have 1 notification"
console.log(getPlural(5, 'en-US')); // "You have 5 notifications"

console.log(getPlural(1, 'ru')); // "У вас 1 уведомление"
console.log(getPlural(3, 'ru')); // "У вас 3 уведомления"
console.log(getPlural(5, 'ru')); // "У вас 5 уведомлений"
```

**e) List Formatting**

```javascript
const fruits = ['apple', 'banana', 'orange'];

const listFormatter = new Intl.ListFormat('en', { style: 'long', type: 'conjunction' });
console.log(listFormatter.format(fruits)); // "apple, banana, and orange"

const shortListFormatter = new Intl.ListFormat('en', { style: 'short', type: 'disjunction' });
console.log(shortListFormatter.format(fruits)); // "apple, banana, or orange"

const frListFormatter = new Intl.ListFormat('fr', { style: 'long', type: 'conjunction' });
console.log(frListFormatter.format(fruits)); // "apple, banana et orange"
```

**3. Translation Libraries and Frameworks**

**a) Using i18next**

i18next is one of the most popular internationalization frameworks for JavaScript.

```javascript
// Basic i18next setup
import i18next from 'i18next';

i18next.init({
  lng: 'en', // Default language
  resources: {
    en: {
      translation: {
        welcome: 'Welcome to our application',
        greeting: 'Hello, {{name}}!',
        items: 'You have {{count}} item',
        items_plural: 'You have {{count}} items',
        nested: {
          value: 'Nested translation'
        }
      }
    },
    fr: {
      translation: {
        welcome: 'Bienvenue dans notre application',
        greeting: 'Bonjour, {{name}} !',
        items: 'Vous avez {{count}} élément',
        items_plural: 'Vous avez {{count}} éléments',
        nested: {
          value: 'Traduction imbriquée'
        }
      }
    }
  }
});

// Using translations
console.log(i18next.t('welcome')); // "Welcome to our application"
console.log(i18next.t('greeting', { name: 'John' })); // "Hello, John!"
console.log(i18next.t('items', { count: 1 })); // "You have 1 item"
console.log(i18next.t('items', { count: 5 })); // "You have 5 items"
console.log(i18next.t('nested.value')); // "Nested translation"

// Change language
i18next.changeLanguage('fr').then(() => {
  console.log(i18next.t('welcome')); // "Bienvenue dans notre application"
});
```

**b) React Integration with react-i18next**

```jsx
// i18n.js - Configuration file
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

i18n
  .use(initReactI18next)
  .init({
    resources: {
      en: {
        translation: {
          welcome: 'Welcome to our application',
          description: {
            part1: 'This is part one',
            part2: 'This is part two'
          },
          counter: 'You clicked {{count}} time',
          counter_plural: 'You clicked {{count}} times'
        }
      },
      es: {
        translation: {
          welcome: 'Bienvenido a nuestra aplicación',
          description: {
            part1: 'Esta es la primera parte',
            part2: 'Esta es la segunda parte'
          },
          counter: 'Has hecho clic {{count}} vez',
          counter_plural: 'Has hecho clic {{count}} veces'
        }
      }
    },
    lng: 'en',
    fallbackLng: 'en',
    interpolation: {
      escapeValue: false
    }
  });

export default i18n;

// App.jsx
import React, { useState } from 'react';
import { useTranslation } from 'react-i18next';
import './i18n';

function App() {
  const { t, i18n } = useTranslation();
  const [count, setCount] = useState(0);
  
  const changeLanguage = (lng) => {
    i18n.changeLanguage(lng);
  };
  
  return (
    <div>
      <h1>{t('welcome')}</h1>
      <p>{t('description.part1')}</p>
      <p>{t('description.part2')}</p>
      
      <div>
        <button onClick={() => setCount(count + 1)}>
          {t('counter', { count })}
        </button>
      </div>
      
      <div>
        <button onClick={() => changeLanguage('en')}>English</button>
        <button onClick={() => changeLanguage('es')}>Español</button>
      </div>
    </div>
  );
}

export default App;
```

**c) Vue Integration with vue-i18n**

```javascript
// i18n.js
import Vue from 'vue';
import VueI18n from 'vue-i18n';

Vue.use(VueI18n);

const messages = {
  en: {
    welcome: 'Welcome to our application',
    greeting: 'Hello, {name}!',
    items: 'No items | One item | {count} items'
  },
  ja: {
    welcome: 'アプリケーションへようこそ',
    greeting: 'こんにちは、{name}さん！',
    items: 'アイテムがありません | {count}つのアイテム | {count}つのアイテム'
  }
};

const i18n = new VueI18n({
  locale: 'en',
  fallbackLocale: 'en',
  messages
});

export default i18n;

// App.vue
<template>
  <div>
    <h1>{{ $t('welcome') }}</h1>
    <p>{{ $t('greeting', { name: 'Vue' }) }}</p>
    <p>{{ $tc('items', itemCount, { count: itemCount }) }}</p>
    
    <div>
      <button @click="itemCount++">Add Item</button>
      <button @click="itemCount = Math.max(0, itemCount - 1)">Remove Item</button>
    </div>
    
    <div>
      <button @click="$i18n.locale = 'en'">English</button>
      <button @click="$i18n.locale = 'ja'">日本語</button>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      itemCount: 0
    };
  }
};
</script>
```

**d) Angular Integration with @angular/localize**

```typescript
// app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { registerLocaleData } from '@angular/common';
import localeEn from '@angular/common/locales/en';
import localeEs from '@angular/common/locales/es';
import { AppComponent } from './app.component';

// Register locales
registerLocaleData(localeEn, 'en');
registerLocaleData(localeEs, 'es');

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  bootstrap: [AppComponent]
})
export class AppModule {}

// app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: `
    <h1 i18n="@@welcomeMessage">Welcome to our application</h1>
    
    <p i18n>Hello, {{ name }}!</p>
    
    <p>{{ today | date:'fullDate':undefined:locale }}</p>
    <p>{{ price | currency:currency:undefined:locale }}</p>
    
    <div>
      <button (click)="locale = 'en'">English</button>
      <button (click)="locale = 'es'">Español</button>
    </div>
  `
})
export class AppComponent {
  name = 'Angular';
  today = new Date();
  price = 42.99;
  locale = 'en';
  currency = 'USD';
}
```

To extract messages for translation in Angular:

```bash
ng xi18n --output-path src/locale
```

**4. Date and Time Handling with Libraries**

**a) Using Day.js with Internationalization**

```javascript
import dayjs from 'dayjs';
import 'dayjs/locale/fr';
import 'dayjs/locale/ja';
import relativeTime from 'dayjs/plugin/relativeTime';

dayjs.extend(relativeTime);

const date = new Date(2023, 0, 15);

// Format date in different locales
dayjs.locale('en');
console.log(dayjs(date).format('MMMM D, YYYY')); // "January 15, 2023"

dayjs.locale('fr');
console.log(dayjs(date).format('D MMMM YYYY')); // "15 janvier 2023"

dayjs.locale('ja');
console.log(dayjs(date).format('YYYY年M月D日')); // "2023年1月15日"

// Relative time in different locales
dayjs.locale('en');
console.log(dayjs().subtract(1, 'day').fromNow()); // "a day ago"

dayjs.locale('fr');
console.log(dayjs().subtract(1, 'day').fromNow()); // "il y a un jour"
```

**b) Using Luxon for Internationalization**

```javascript
import { DateTime } from 'luxon';

const dt = DateTime.local(2023, 1, 15, 9, 30);

// Format in different locales
console.log(dt.setLocale('en').toLocaleString(DateTime.DATETIME_FULL));
// "January 15, 2023, 9:30 AM"

console.log(dt.setLocale('fr').toLocaleString(DateTime.DATETIME_FULL));
// "15 janvier 2023, 09:30"

console.log(dt.setLocale('ja').toLocaleString(DateTime.DATETIME_FULL));
// "2023年1月15日 9:30"

// Relative time
console.log(dt.setLocale('en').toRelative()); // "in 2 months" (if today is Nov 15)
console.log(dt.setLocale('fr').toRelative()); // "dans 2 mois"
```

**5. Number and Currency Formatting with Libraries**

**a) Using Numeral.js**

```javascript
import numeral from 'numeral';
// For locales
import 'numeral/locales/fr';

const number = 1234.567;

// Default (English) formatting
console.log(numeral(number).format('0,0.00')); // "1,234.57"

// Switch to French locale
numeral.locale('fr');
console.log(numeral(number).format('0,0.00')); // "1 234,57"

// Currency formatting
console.log(numeral(number).format('$0,0.00')); // "€1 234,57" (in French locale)
```

**6. Handling Right-to-Left (RTL) Languages**

**a) CSS Approach**

```html
<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <title>RTL Example</title>
  <style>
    /* Bidirectional text support */
    .container {
      /* Use logical properties instead of physical ones */
      margin-inline-start: 20px; /* Instead of margin-left or margin-right */
      padding-inline-end: 10px; /* Instead of padding-right or padding-left */
      text-align: start; /* Instead of text-align: left */
    }
    
    /* Flip icons if needed */
    .rtl .icon-arrow-right {
      transform: scaleX(-1);
    }
  </style>
</head>
<body>
  <div class="container">
    <p>هذا مثال على النص باللغة العربية</p>
    <span class="icon-arrow-right">→</span>
  </div>
  
  <script>
    // Detect RTL language and add class to body
    document.addEventListener('DOMContentLoaded', () => {
      const isRTL = document.documentElement.dir === 'rtl';
      if (isRTL) {
        document.body.classList.add('rtl');
      }
    });
  </script>
</body>
</html>
```

**b) JavaScript RTL Detection**

```javascript
function isRTL(locale) {
  // List of RTL languages
  const rtlLocales = ['ar', 'he', 'fa', 'ur', 'yi', 'dv', 'ha', 'khw', 'ks', 'ku', 'ps', 'sd', 'ug'];
  
  // Check if the language code (first 2 chars) is in the RTL list
  const lang = locale.split('-')[0].toLowerCase();
  return rtlLocales.includes(lang);
}

function applyRTLStyles(locale) {
  if (isRTL(locale)) {
    document.documentElement.setAttribute('dir', 'rtl');
    document.body.classList.add('rtl');
  } else {
    document.documentElement.setAttribute('dir', 'ltr');
    document.body.classList.remove('rtl');
  }
}

// Usage
applyRTLStyles('ar-EG'); // Apply RTL for Arabic
applyRTLStyles('en-US'); // Apply LTR for English
```

**7. Loading Translations Dynamically**

```javascript
// Dynamic translation loading with i18next and HTTP backend
import i18next from 'i18next';
import HttpBackend from 'i18next-http-backend';
import LanguageDetector from 'i18next-browser-languagedetector';

i18next
  .use(HttpBackend) // Load translations from server
  .use(LanguageDetector) // Detect user language
  .init({
    fallbackLng: 'en',
    ns: ['common', 'home', 'about'], // Namespaces
    defaultNS: 'common',
    backend: {
      loadPath: '/locales/{{lng}}/{{ns}}.json', // Path to translations
    }
  });

// Usage
i18next.loadNamespaces('products').then(() => {
  // Now 'products' namespace is loaded
  console.log(i18next.t('products:title'));
});

// Change language and load its resources
i18next.changeLanguage('de').then(() => {
  console.log(i18next.t('common:welcome'));
});
```

**8. Handling Locale-Specific Formatting**

```javascript
// Helper function for locale-aware formatting
function formatByLocale(value, type, locale, options = {}) {
  switch (type) {
    case 'date':
      return new Intl.DateTimeFormat(locale, options).format(value);
    case 'number':
      return new Intl.NumberFormat(locale, options).format(value);
    case 'currency':
      return new Intl.NumberFormat(locale, {
        style: 'currency',
        currency: options.currency || 'USD',
        ...options
      }).format(value);
    case 'percent':
      return new Intl.NumberFormat(locale, {
        style: 'percent',
        ...options
      }).format(value);
    default:
      return value.toString();
  }
}

// Usage
const userLocale = 'de-DE';
const price = 1234.56;
const date = new Date();

console.log(formatByLocale(price, 'currency', userLocale, { currency: 'EUR' }));
// "1.234,56 €"

console.log(formatByLocale(date, 'date', userLocale, { dateStyle: 'full' }));
// "Montag, 15. Januar 2023"

console.log(formatByLocale(0.1234, 'percent', userLocale));
// "12,34 %"
```

**9. Best Practices for Internationalization**

**a) Separation of Concerns**

```javascript
// Bad: Hardcoded strings
function showWelcome(name) {
  return `Welcome, ${name}! You have 3 new messages.`;
}

// Good: Separated translation and logic
function showWelcome(name, messageCount, t) {
  return t('welcome', { name, count: messageCount });
}

// Usage
const message = showWelcome('John', 3, i18next.t.bind(i18next));
```

**b) Handling Pluralization Correctly**

```javascript
// i18next pluralization example
const resources = {
  en: {
    translation: {
      key_one: 'singular',
      key_other: 'plural',
      complex: '{{count}} item',
      complex_plural: '{{count}} items',
      // Zero form for some languages
      zero_items: 'No items',
      zero_items_one: 'One item',
      zero_items_other: '{{count}} items'
    }
  },
  ar: {
    translation: {
      // Arabic has six plural forms
      key_zero: 'صفر',
      key_one: 'واحد',
      key_two: 'اثنان',
      key_few: 'القليل',
      key_many: 'كثير',
      key_other: 'آخر'
    }
  }
};

// Usage with i18next
i18next.init({ resources, lng: 'en' });

// Basic pluralization
console.log(i18next.t('key', { count: 1 })); // "singular"
console.log(i18next.t('key', { count: 2 })); // "plural"

// With interpolation
console.log(i18next.t('complex', { count: 1 })); // "1 item"
console.log(i18next.t('complex', { count: 5 })); // "5 items"

// Special case for zero
console.log(i18next.t('zero_items', { count: 0 })); // "No items"
console.log(i18next.t('zero_items', { count: 1 })); // "One item"
console.log(i18next.t('zero_items', { count: 5 })); // "5 items"
```

**c) Context-Aware Translations**

```javascript
// i18next context example
const resources = {
  en: {
    translation: {
      friend: 'A friend',
      friend_male: 'A boyfriend',
      friend_female: 'A girlfriend',
      
      // Using contexts
      message_context: 'Message',
      message_email: 'Email',
      message_warning: 'Warning'
    }
  }
};

i18next.init({ resources, lng: 'en' });

// Gender context
console.log(i18next.t('friend')); // "A friend"
console.log(i18next.t('friend', { context: 'male' })); // "A boyfriend"
console.log(i18next.t('friend', { context: 'female' })); // "A girlfriend"

// Other contexts
console.log(i18next.t('message', { context: 'email' })); // "Email"
console.log(i18next.t('message', { context: 'warning' })); // "Warning"
```

**10. Testing Internationalization**

```javascript
// Jest test example for i18next
import i18next from 'i18next';

describe('Internationalization tests', () => {
  beforeAll(() => {
    return i18next.init({
      lng: 'en',
      resources: {
        en: {
          translation: {
            welcome: 'Welcome, {{name}}!',
            items: 'You have {{count}} item',
            items_plural: 'You have {{count}} items'
          }
        },
        fr: {
          translation: {
            welcome: 'Bienvenue, {{name}} !',
            items: 'Vous avez {{count}} élément',
            items_plural: 'Vous avez {{count}} éléments'
          }
        }
      }
    });
  });
  
  test('should translate basic strings', () => {
    expect(i18next.t('welcome', { name: 'John' })).toBe('Welcome, John!');
  });
  
  test('should handle pluralization', () => {
    expect(i18next.t('items', { count: 1 })).toBe('You have 1 item');
    expect(i18next.t('items', { count: 5 })).toBe('You have 5 items');
  });
  
  test('should change language', async () => {
    await i18next.changeLanguage('fr');
    expect(i18next.t('welcome', { name: 'John' })).toBe('Bienvenue, John !');
    expect(i18next.t('items', { count: 1 })).toBe('Vous avez 1 élément');
  });
});
```

**Key Takeaways:**

1. Use the native JavaScript `Intl` API for basic internationalization needs like number, date, and string formatting
2. Implement a robust translation system with libraries like i18next, which handle complex pluralization rules
3. Separate translation strings from application logic to make maintenance easier
4. Consider cultural differences beyond just language, such as date formats, number separators, and currency symbols
5. Support right-to-left (RTL) languages with proper CSS and HTML direction attributes
6. Load translations dynamically to improve initial load performance
7. Use context-aware translations to handle words with multiple meanings based on gender or other contexts
8. Test internationalization features to ensure they work correctly across different languages
9. Implement proper pluralization that accounts for the varying rules across languages
10. Use specialized libraries for complex date/time handling in international contexts

### Q84: What are the best practices for implementing web accessibility in JavaScript applications?
**Difficulty: Medium**

**Answer:**
Web accessibility (often abbreviated as a11y) ensures that websites and web applications are usable by people with disabilities. Let's explore how to implement accessibility best practices in JavaScript applications.

**1. Understanding Web Accessibility**

**a) Core Principles (POUR)**

- **Perceivable**: Information must be presentable in ways all users can perceive
- **Operable**: User interface components must be operable by all users
- **Understandable**: Information and operation must be understandable
- **Robust**: Content must be robust enough to work with current and future technologies

**b) Standards and Guidelines**

- **WCAG (Web Content Accessibility Guidelines)**: The primary standard for web accessibility
- **WAI-ARIA (Web Accessibility Initiative - Accessible Rich Internet Applications)**: Specifications for making dynamic content accessible
- **Section 508**: U.S. federal regulations requiring accessibility for government websites

**2. Semantic HTML as Foundation**

While not strictly JavaScript, proper semantic HTML is the foundation of accessible JavaScript applications:

```javascript
// Bad: Non-semantic elements with JavaScript behavior
const clickHandler = () => alert('Clicked!');

document.getElementById('myDiv').addEventListener('click', clickHandler);

// HTML: <div id="myDiv" style="cursor: pointer;">Click me</div>

// Good: Semantic elements with appropriate roles
const buttonHandler = () => alert('Button clicked!');

document.getElementById('myButton').addEventListener('click', buttonHandler);

// HTML: <button id="myButton" type="button">Click me</button>
```

**3. Managing Focus**

**a) Focus Management in SPAs**

```javascript
// Focus management when loading new content in SPA
function navigateToSection(sectionId) {
  // Update content
  document.getElementById('main-content').innerHTML = getContentForSection(sectionId);
  
  // Set focus to the heading of the new section
  const heading = document.querySelector('#main-content h1');
  
  // Set tabindex to make it focusable
  heading.setAttribute('tabindex', '-1');
  
  // Focus the heading
  heading.focus();
  
  // Announce page change to screen readers
  announcePageChange(`Navigated to ${heading.textContent}`);
}

// Helper function to announce changes to screen readers
function announcePageChange(message) {
  const announcer = document.getElementById('sr-announcer');
  announcer.textContent = message;
}

// HTML: <div id="sr-announcer" class="sr-only" aria-live="polite"></div>
```

**b) Creating Focus Traps for Modals**

```javascript
class FocusTrap {
  constructor(element) {
    this.element = element;
    this.focusableElements = element.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    this.firstFocusable = this.focusableElements[0];
    this.lastFocusable = this.focusableElements[this.focusableElements.length - 1];
    
    this.handleKeyDown = this.handleKeyDown.bind(this);
  }
  
  activate() {
    this.element.addEventListener('keydown', this.handleKeyDown);
    this.firstFocusable.focus();
  }
  
  deactivate() {
    this.element.removeEventListener('keydown', this.handleKeyDown);
  }
  
  handleKeyDown(e) {
    if (e.key !== 'Tab') return;
    
    if (e.shiftKey) { // Shift + Tab
      if (document.activeElement === this.firstFocusable) {
        e.preventDefault();
        this.lastFocusable.focus();
      }
    } else { // Tab
      if (document.activeElement === this.lastFocusable) {
        e.preventDefault();
        this.firstFocusable.focus();
      }
    }
  }
}

// Usage
function openModal() {
  const modal = document.getElementById('accessibleModal');
  modal.style.display = 'block';
  
  // Store the element that had focus before opening the modal
  this.previouslyFocused = document.activeElement;
  
  // Create and activate the focus trap
  const trap = new FocusTrap(modal);
  trap.activate();
  
  // Store the trap for later deactivation
  modal.focusTrap = trap;
}

function closeModal() {
  const modal = document.getElementById('accessibleModal');
  modal.style.display = 'none';
  
  // Deactivate the focus trap
  modal.focusTrap.deactivate();
  
  // Restore focus to the element that had it before the modal opened
  if (this.previouslyFocused) {
    this.previouslyFocused.focus();
  }
}
```

**4. ARIA Attributes and Live Regions**

**a) Dynamic Content Updates**

```javascript
// Updating content with appropriate ARIA live regions
function updateResults(results) {
  const resultsContainer = document.getElementById('searchResults');
  const resultsCount = results.length;
  
  // Update the results
  resultsContainer.innerHTML = '';
  results.forEach(result => {
    const resultItem = document.createElement('li');
    resultItem.textContent = result.title;
    resultsContainer.appendChild(resultItem);
  });
  
  // Update the status for screen readers
  const status = document.getElementById('resultsStatus');
  status.textContent = `${resultsCount} results found`;
}

// HTML:
// <div id="resultsStatus" aria-live="polite" role="status"></div>
// <ul id="searchResults" aria-labelledby="resultsStatus"></ul>
```

**b) Managing ARIA States**

```javascript
// Toggle expanded state for accordion
function toggleAccordion(accordionButton) {
  const expanded = accordionButton.getAttribute('aria-expanded') === 'true';
  const panelId = accordionButton.getAttribute('aria-controls');
  const panel = document.getElementById(panelId);
  
  // Toggle expanded state
  accordionButton.setAttribute('aria-expanded', !expanded);
  
  // Toggle panel visibility
  if (expanded) {
    panel.setAttribute('hidden', '');
  } else {
    panel.removeAttribute('hidden');
  }
}

// HTML:
// <button aria-expanded="false" aria-controls="panel1">Section 1</button>
// <div id="panel1" hidden>Content for section 1</div>
```

**5. Keyboard Accessibility**

**a) Custom Controls**

```javascript
// Implementing keyboard accessibility for a custom dropdown
class AccessibleDropdown {
  constructor(element) {
    this.dropdown = element;
    this.button = element.querySelector('.dropdown-button');
    this.list = element.querySelector('.dropdown-list');
    this.items = element.querySelectorAll('.dropdown-item');
    
    this.isOpen = false;
    this.activeIndex = -1;
    
    this.init();
  }
  
  init() {
    // Set initial ARIA attributes
    this.button.setAttribute('aria-haspopup', 'listbox');
    this.button.setAttribute('aria-expanded', 'false');
    
    this.list.setAttribute('role', 'listbox');
    this.list.setAttribute('tabindex', '-1');
    
    this.items.forEach(item => {
      item.setAttribute('role', 'option');
      item.setAttribute('tabindex', '-1');
    });
    
    // Add event listeners
    this.button.addEventListener('click', () => this.toggleDropdown());
    this.button.addEventListener('keydown', (e) => this.handleButtonKeyDown(e));
    this.list.addEventListener('keydown', (e) => this.handleListKeyDown(e));
    
    this.items.forEach(item => {
      item.addEventListener('click', () => this.selectItem(item));
    });
  }
  
  toggleDropdown() {
    this.isOpen = !this.isOpen;
    this.button.setAttribute('aria-expanded', this.isOpen);
    
    if (this.isOpen) {
      this.list.style.display = 'block';
      this.items[0].focus();
      this.activeIndex = 0;
    } else {
      this.list.style.display = 'none';
      this.activeIndex = -1;
    }
  }
  
  handleButtonKeyDown(e) {
    switch (e.key) {
      case 'ArrowDown':
      case 'Enter':
      case ' ':
        e.preventDefault();
        if (!this.isOpen) {
          this.toggleDropdown();
        }
        break;
      case 'Escape':
        if (this.isOpen) {
          this.toggleDropdown();
        }
        break;
    }
  }
  
  handleListKeyDown(e) {
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        this.activeIndex = Math.min(this.activeIndex + 1, this.items.length - 1);
        this.items[this.activeIndex].focus();
        break;
      case 'ArrowUp':
        e.preventDefault();
        this.activeIndex = Math.max(this.activeIndex - 1, 0);
        this.items[this.activeIndex].focus();
        break;
      case 'Home':
        e.preventDefault();
        this.activeIndex = 0;
        this.items[this.activeIndex].focus();
        break;
      case 'End':
        e.preventDefault();
        this.activeIndex = this.items.length - 1;
        this.items[this.activeIndex].focus();
        break;
      case 'Enter':
      case ' ':
        e.preventDefault();
        this.selectItem(this.items[this.activeIndex]);
        break;
      case 'Escape':
        e.preventDefault();
        this.toggleDropdown();
        this.button.focus();
        break;
    }
  }
  
  selectItem(item) {
    // Update button text with selected item
    this.button.textContent = item.textContent;
    
    // Set selected state
    this.items.forEach(i => {
      i.setAttribute('aria-selected', i === item);
    });
    
    // Close dropdown
    this.toggleDropdown();
    this.button.focus();
    
    // Dispatch change event
    const event = new CustomEvent('change', {
      detail: { value: item.dataset.value }
    });
    this.dropdown.dispatchEvent(event);
  }
}

// Usage
const dropdowns = document.querySelectorAll('.accessible-dropdown');
dropdowns.forEach(dropdown => new AccessibleDropdown(dropdown));
```

**b) Handling Non-Standard Interactions**

```javascript
// Making a drag-and-drop interface keyboard accessible
class AccessibleDragDrop {
  constructor(container) {
    this.container = container;
    this.items = container.querySelectorAll('.draggable-item');
    this.dropzones = container.querySelectorAll('.dropzone');
    
    this.init();
  }
  
  init() {
    // Set up ARIA attributes
    this.items.forEach((item, index) => {
      item.setAttribute('role', 'button');
      item.setAttribute('aria-grabbed', 'false');
      item.setAttribute('tabindex', '0');
      item.setAttribute('aria-describedby', `drag-instructions-${index}`);
      
      // Add hidden instructions for screen readers
      const instructions = document.createElement('span');
      instructions.id = `drag-instructions-${index}`;
      instructions.classList.add('sr-only');
      instructions.textContent = 'Press Space to pick up, use arrow keys to move, and Space to drop';
      item.appendChild(instructions);
      
      // Add event listeners
      item.addEventListener('keydown', (e) => this.handleItemKeyDown(e, item));
    });
    
    this.dropzones.forEach(zone => {
      zone.setAttribute('role', 'region');
      zone.setAttribute('aria-dropeffect', 'move');
    });
  }
  
  handleItemKeyDown(e, item) {
    const isGrabbed = item.getAttribute('aria-grabbed') === 'true';
    
    switch (e.key) {
      case ' ': // Space
        e.preventDefault();
        if (isGrabbed) {
          this.dropItem(item);
        } else {
          this.grabItem(item);
        }
        break;
      case 'ArrowRight':
      case 'ArrowDown':
        e.preventDefault();
        if (isGrabbed) {
          this.moveToNextDropzone(item);
        }
        break;
      case 'ArrowLeft':
      case 'ArrowUp':
        e.preventDefault();
        if (isGrabbed) {
          this.moveToPreviousDropzone(item);
        }
        break;
      case 'Escape':
        if (isGrabbed) {
          this.cancelGrab(item);
        }
        break;
    }
  }
  
  grabItem(item) {
    // Reset all items
    this.items.forEach(i => {
      i.setAttribute('aria-grabbed', 'false');
    });
    
    // Set this item as grabbed
    item.setAttribute('aria-grabbed', 'true');
    
    // Announce to screen readers
    this.announce(`Item ${item.textContent} grabbed. Use arrow keys to move.`);
  }
  
  dropItem(item) {
    const currentZone = this.findCurrentDropzone(item);
    if (currentZone) {
      // Move item to this dropzone
      currentZone.appendChild(item);
      
      // Announce to screen readers
      this.announce(`Item ${item.textContent} dropped in zone ${currentZone.getAttribute('aria-label')}.`);
    }
    
    item.setAttribute('aria-grabbed', 'false');
  }
  
  cancelGrab(item) {
    item.setAttribute('aria-grabbed', 'false');
    this.announce(`Grab cancelled.`);
  }
  
  moveToNextDropzone(item) {
    const currentIndex = this.findDropzoneIndex(item);
    const nextIndex = (currentIndex + 1) % this.dropzones.length;
    this.moveItemToDropzone(item, this.dropzones[nextIndex]);
  }
  
  moveToPreviousDropzone(item) {
    const currentIndex = this.findDropzoneIndex(item);
    const prevIndex = (currentIndex - 1 + this.dropzones.length) % this.dropzones.length;
    this.moveItemToDropzone(item, this.dropzones[prevIndex]);
  }
  
  moveItemToDropzone(item, dropzone) {
    // Visually move the item (without actually moving in DOM yet)
    item.style.outline = '2px solid blue';
    
    // Announce the potential drop location
    this.announce(`Item over ${dropzone.getAttribute('aria-label')}. Press Space to drop.`);
  }
  
  findDropzoneIndex(item) {
    const currentZone = this.findCurrentDropzone(item);
    return Array.from(this.dropzones).indexOf(currentZone);
  }
  
  findCurrentDropzone(item) {
    return item.closest('.dropzone');
  }
  
  announce(message) {
    // Get or create the announcer element
    let announcer = document.getElementById('a11y-announcer');
    if (!announcer) {
      announcer = document.createElement('div');
      announcer.id = 'a11y-announcer';
      announcer.setAttribute('aria-live', 'assertive');
      announcer.setAttribute('class', 'sr-only');
      document.body.appendChild(announcer);
    }
    
    // Set the message
    announcer.textContent = message;
  }
}

// Usage
const dragDropContainers = document.querySelectorAll('.drag-drop-container');
dragDropContainers.forEach(container => new AccessibleDragDrop(container));
```

**6. Screen Reader Considerations**

**a) Hiding Visual Elements from Screen Readers**

```javascript
// Hiding decorative elements from screen readers
function setupDecorativeElements() {
  const decorativeIcons = document.querySelectorAll('.decorative-icon');
  
  decorativeIcons.forEach(icon => {
    // Use aria-hidden for purely decorative elements
    icon.setAttribute('aria-hidden', 'true');
  });
}

// Visually hiding elements but keeping them for screen readers
function createScreenReaderText() {
  const skipLink = document.createElement('a');
  skipLink.href = '#main-content';
  skipLink.textContent = 'Skip to main content';
  skipLink.className = 'sr-only sr-only-focusable';
  
  document.body.insertBefore(skipLink, document.body.firstChild);
}

// CSS:
// .sr-only {
//   position: absolute;
//   width: 1px;
//   height: 1px;
//   padding: 0;
//   margin: -1px;
//   overflow: hidden;
//   clip: rect(0, 0, 0, 0);
//   white-space: nowrap;
//   border: 0;
// }
// 
// .sr-only-focusable:focus {
//   position: static;
//   width: auto;
//   height: auto;
//   overflow: visible;
//   clip: auto;
//   white-space: normal;
// }
```

**b) Accessible Notifications**

```javascript
// Creating accessible toast notifications
class AccessibleNotification {
  constructor() {
    this.createNotificationContainer();
  }
  
  createNotificationContainer() {
    this.container = document.createElement('div');
    this.container.className = 'notification-container';
    this.container.setAttribute('aria-live', 'polite');
    document.body.appendChild(this.container);
  }
  
  notify(message, type = 'info', duration = 5000) {
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.setAttribute('role', 'status');
    
    // Add appropriate icon based on type
    const iconTypes = {
      info: 'ℹ️',
      success: '✅',
      warning: '⚠️',
      error: '❌'
    };
    
    const icon = document.createElement('span');
    icon.className = 'notification-icon';
    icon.setAttribute('aria-hidden', 'true'); // Hide icon from screen readers
    icon.textContent = iconTypes[type] || iconTypes.info;
    
    const text = document.createElement('span');
    text.className = 'notification-text';
    text.textContent = message;
    
    const closeButton = document.createElement('button');
    closeButton.className = 'notification-close';
    closeButton.setAttribute('aria-label', 'Dismiss notification');
    closeButton.textContent = '×';
    closeButton.addEventListener('click', () => this.removeNotification(notification));
    
    notification.appendChild(icon);
    notification.appendChild(text);
    notification.appendChild(closeButton);
    
    this.container.appendChild(notification);
    
    // Auto-remove after duration
    if (duration > 0) {
      setTimeout(() => this.removeNotification(notification), duration);
    }
    
    return notification;
  }
  
  removeNotification(notification) {
    if (notification && notification.parentNode === this.container) {
      this.container.removeChild(notification);
    }
  }
}

// Usage
const notifications = new AccessibleNotification();
notifications.notify('Your profile has been updated successfully', 'success');
```

**7. Accessibility in Modern JavaScript Frameworks**

**a) React Accessibility**

```jsx
// React component with accessibility features
import React, { useState, useRef, useEffect } from 'react';

const AccessibleTabs = ({ tabs }) => {
  const [activeTab, setActiveTab] = useState(0);
  const tabRefs = useRef([]);
  
  // Set up refs array
  useEffect(() => {
    tabRefs.current = tabRefs.current.slice(0, tabs.length);
  }, [tabs]);
  
  const handleTabClick = (index) => {
    setActiveTab(index);
  };
  
  const handleKeyDown = (e, index) => {
    let newIndex;
    
    switch (e.key) {
      case 'ArrowRight':
        newIndex = (index + 1) % tabs.length;
        tabRefs.current[newIndex].focus();
        setActiveTab(newIndex);
        break;
      case 'ArrowLeft':
        newIndex = (index - 1 + tabs.length) % tabs.length;
        tabRefs.current[newIndex].focus();
        setActiveTab(newIndex);
        break;
      case 'Home':
        tabRefs.current[0].focus();
        setActiveTab(0);
        break;
      case 'End':
        newIndex = tabs.length - 1;
        tabRefs.current[newIndex].focus();
        setActiveTab(newIndex);
        break;
      default:
        return;
    }
    
    e.preventDefault();
  };
  
  return (
    <div className="tabs-container">
      <div role="tablist" aria-label="Content tabs">
        {tabs.map((tab, index) => (
          <button
            key={index}
            role="tab"
            id={`tab-${index}`}
            aria-selected={activeTab === index}
            aria-controls={`panel-${index}`}
            tabIndex={activeTab === index ? 0 : -1}
            ref={el => tabRefs.current[index] = el}
            onClick={() => handleTabClick(index)}
            onKeyDown={(e) => handleKeyDown(e, index)}
          >
            {tab.title}
          </button>
        ))}
      </div>
      
      {tabs.map((tab, index) => (
        <div
          key={index}
          role="tabpanel"
          id={`panel-${index}`}
          aria-labelledby={`tab-${index}`}
          hidden={activeTab !== index}
        >
          {tab.content}
        </div>
      ))}
    </div>
  );
};

export default AccessibleTabs;

// Usage
// <AccessibleTabs tabs={[
//   { title: 'Tab 1', content: <p>Content for tab 1</p> },
//   { title: 'Tab 2', content: <p>Content for tab 2</p> },
//   { title: 'Tab 3', content: <p>Content for tab 3</p> }
// ]} />
```

**b) Vue Accessibility**

```vue
<!-- AccessibleDialog.vue -->
<template>
  <div>
    <button
      @click="openDialog"
      :aria-expanded="isOpen ? 'true' : 'false'"
      aria-haspopup="dialog"
    >
      {{ buttonText }}
    </button>
    
    <div
      v-if="isOpen"
      role="dialog"
      aria-modal="true"
      :aria-labelledby="titleId"
      class="dialog-overlay"
      @keydown.esc="closeDialog"
    >
      <div class="dialog-content" ref="dialogContent">
        <header>
          <h2 :id="titleId">{{ title }}</h2>
          <button
            @click="closeDialog"
            aria-label="Close dialog"
            class="close-button"
          >
            ×
          </button>
        </header>
        
        <div class="dialog-body">
          <slot></slot>
        </div>
        
        <footer>
          <slot name="footer">
            <button @click="closeDialog">Close</button>
          </slot>
        </footer>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  props: {
    title: {
      type: String,
      required: true
    },
    buttonText: {
      type: String,
      default: 'Open Dialog'
    }
  },
  
  data() {
    return {
      isOpen: false,
      titleId: `dialog-title-${Math.random().toString(36).substr(2, 9)}`,
      previouslyFocused: null
    };
  },
  
  methods: {
    openDialog() {
      this.isOpen = true;
      this.previouslyFocused = document.activeElement;
      
      // Wait for the DOM to update
      this.$nextTick(() => {
        this.trapFocus();
        this.$refs.dialogContent.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])').focus();
      });
    },
    
    closeDialog() {
      this.isOpen = false;
      
      // Restore focus
      if (this.previouslyFocused) {
        this.previouslyFocused.focus();
      }
    },
    
    trapFocus() {
      const focusableElements = this.$refs.dialogContent.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      
      const firstFocusable = focusableElements[0];
      const lastFocusable = focusableElements[focusableElements.length - 1];
      
      this.$refs.dialogContent.addEventListener('keydown', (e) => {
        if (e.key === 'Tab') {
          if (e.shiftKey) { // Shift + Tab
            if (document.activeElement === firstFocusable) {
              e.preventDefault();
              lastFocusable.focus();
            }
          } else { // Tab
            if (document.activeElement === lastFocusable) {
              e.preventDefault();
              firstFocusable.focus();
            }
          }
        }
      });
    }
  }
};
</script>

<!-- Usage:
<AccessibleDialog title="Important Information">
  <p>This is the dialog content.</p>
  <template #footer>
    <button @click="saveData">Save</button>
    <button @click="$refs.dialog.closeDialog()">Cancel</button>
  </template>
</AccessibleDialog>
-->
```

**c) Angular Accessibility**

```typescript
// accessible-autocomplete.component.ts
import { Component, Input, Output, EventEmitter, OnInit } from '@angular/core';

@Component({
  selector: 'app-accessible-autocomplete',
  template: `
    <div class="autocomplete-container">
      <label [attr.for]="inputId">{{ label }}</label>
      
      <input
        [id]="inputId"
        type="text"
        [attr.aria-autocomplete]="'list'"
        [attr.aria-controls]="listboxId"
        [attr.aria-activedescendant]="activeOption ? 'option-' + activeOption.id : null"
        [attr.aria-expanded]="showSuggestions"
        [value]="inputValue"
        (input)="onInput($event)"
        (keydown)="onKeyDown($event)"
        (blur)="onBlur()"
      />
      
      <ul
        *ngIf="showSuggestions && filteredOptions.length > 0"
        [id]="listboxId"
        role="listbox"
        class="suggestions-list"
      >
        <li
          *ngFor="let option of filteredOptions; let i = index"
          [id]="'option-' + option.id"
          role="option"
          [attr.aria-selected]="i === activeIndex"
          [class.active]="i === activeIndex"
          (mousedown)="selectOption(option)"
          (mouseover)="activeIndex = i"
        >
          {{ option.label }}
        </li>
      </ul>
      
      <div *ngIf="showSuggestions && filteredOptions.length === 0" class="no-results">
        No results found
      </div>
    </div>
  `,
  styles: [`
    .autocomplete-container {
      position: relative;
    }
    
    .suggestions-list {
      position: absolute;
      width: 100%;
      max-height: 200px;
      overflow-y: auto;
      list-style: none;
      padding: 0;
      margin: 0;
      border: 1px solid #ccc;
      z-index: 1;
    }
    
    .suggestions-list li {
      padding: 8px;
      cursor: pointer;
    }
    
    .suggestions-list li.active {
      background-color: #f0f0f0;
    }
    
    .no-results {
      padding: 8px;
      border: 1px solid #ccc;
    }
  `]
})
export class AccessibleAutocompleteComponent implements OnInit {
  @Input() options: Array<{ id: string | number, label: string }>;
  @Input() label: string;
  @Output() optionSelected = new EventEmitter<any>();
  
  inputId: string;
  listboxId: string;
  inputValue: string = '';
  showSuggestions: boolean = false;
  filteredOptions: Array<{ id: string | number, label: string }> = [];
  activeIndex: number = -1;
  activeOption: { id: string | number, label: string } | null = null;
  
  ngOnInit() {
    // Generate unique IDs
    const uniqueId = Math.random().toString(36).substr(2, 9);
    this.inputId = `autocomplete-input-${uniqueId}`;
    this.listboxId = `autocomplete-listbox-${uniqueId}`;
    
    this.filteredOptions = [...this.options];
  }
  
  onInput(event: Event) {
    const target = event.target as HTMLInputElement;
    this.inputValue = target.value;
    
    this.filterOptions();
    this.showSuggestions = true;
    this.activeIndex = -1;
    this.activeOption = null;
  }
  
  filterOptions() {
    const query = this.inputValue.toLowerCase();
    this.filteredOptions = this.options.filter(option =>
      option.label.toLowerCase().includes(query)
    );
  }
  
  onKeyDown(event: KeyboardEvent) {
    switch (event.key) {
      case 'ArrowDown':
        event.preventDefault();
        this.activeIndex = Math.min(this.activeIndex + 1, this.filteredOptions.length - 1);
        if (this.activeIndex === -1 && this.filteredOptions.length > 0) {
          this.activeIndex = 0;
        }
        this.activeOption = this.filteredOptions[this.activeIndex];
        break;
        
      case 'ArrowUp':
        event.preventDefault();
        this.activeIndex = Math.max(this.activeIndex - 1, 0);
        this.activeOption = this.filteredOptions[this.activeIndex];
        break;
        
      case 'Enter':
        if (this.activeIndex >= 0) {
          event.preventDefault();
          this.selectOption(this.filteredOptions[this.activeIndex]);
        }
        break;
        
      case 'Escape':
        this.showSuggestions = false;
        this.activeIndex = -1;
        this.activeOption = null;
        break;
    }
  }
  
  selectOption(option: { id: string | number, label: string }) {
    this.inputValue = option.label;
    this.showSuggestions = false;
    this.optionSelected.emit(option);
  }
  
  onBlur() {
    // Delay hiding suggestions to allow click events to complete
    setTimeout(() => {
      this.showSuggestions = false;
    }, 150);
  }
}

// Usage in template:
// <app-accessible-autocomplete
//   [options]="countries"
//   label="Select a country"
//   (optionSelected)="onCountrySelected($event)">
// </app-accessible-autocomplete>
```

**8. Testing Accessibility**

**a) Automated Testing**

```javascript
// Using axe-core for automated accessibility testing
import { axe } from 'axe-core';

// Basic test function
async function testAccessibility(htmlContent) {
  // Create a container
  const container = document.createElement('div');
  container.innerHTML = htmlContent;
  document.body.appendChild(container);
  
  try {
    // Run axe
    const results = await axe.run(container);
    
    if (results.violations.length > 0) {
      console.error('Accessibility violations found:', results.violations);
      return false;
    }
    
    console.log('No accessibility violations found!');
    return true;
  } finally {
    // Clean up
    document.body.removeChild(container);
  }
}

// Example usage
testAccessibility(`
  <div role="dialog" aria-labelledby="dialog-title">
    <h2 id="dialog-title">Accessible Dialog</h2>
    <p>This is an accessible dialog example.</p>
    <button>Close</button>
  </div>
`);
```

**b) Integration with Testing Frameworks**

```javascript
// Jest + React Testing Library example
import React from 'react';
import { render } from '@testing-library/react';
import { axe, toHaveNoViolations } from 'jest-axe';
import AccessibleTabs from './AccessibleTabs';

expect.extend(toHaveNoViolations);

describe('AccessibleTabs', () => {
  it('should not have accessibility violations', async () => {
    const { container } = render(
      <AccessibleTabs 
        tabs={[
          { title: 'Tab 1', content: <p>Content for tab 1</p> },
          { title: 'Tab 2', content: <p>Content for tab 2</p> }
        ]} 
      />
    );
    
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });
});
```

**9. Common Accessibility Patterns**

**a) Skip Links**

```javascript
// Adding skip links to bypass navigation
function addSkipLinks() {
  const skipLinks = [
    { id: 'main-content', label: 'Skip to main content' },
    { id: 'nav', label: 'Skip to navigation' },
    { id: 'search', label: 'Skip to search' }
  ];
  
  const skipLinksContainer = document.createElement('div');
  skipLinksContainer.className = 'skip-links';
  
  skipLinks.forEach(link => {
    const anchor = document.createElement('a');
    anchor.href = `#${link.id}`;
    anchor.className = 'skip-link';
    anchor.textContent = link.label;
    skipLinksContainer.appendChild(anchor);
  });
  
  document.body.insertBefore(skipLinksContainer, document.body.firstChild);
}

// CSS:
// .skip-links {
//   position: absolute;
//   top: -40px;
//   left: 0;
//   z-index: 1000;
// }
// 
// .skip-link {
//   background: #000;
//   color: #fff;
//   padding: 8px;
//   position: absolute;
//   left: 0;
//   top: 0;
//   transition: top 0.2s;
// }
// 
// .skip-link:focus {
//   top: 40px;
// }
```

**b) Form Validation**

```javascript
// Accessible form validation
class AccessibleForm {
  constructor(formElement) {
    this.form = formElement;
    this.inputs = this.form.querySelectorAll('input, select, textarea');
    this.submitButton = this.form.querySelector('[type="submit"]');
    
    this.errorContainer = document.createElement('div');
    this.errorContainer.className = 'error-summary';
    this.errorContainer.setAttribute('role', 'alert');
    this.errorContainer.setAttribute('aria-live', 'assertive');
    this.errorContainer.style.display = 'none';
    
    this.form.insertBefore(this.errorContainer, this.form.firstChild);
    
    this.init();
  }
  
  init() {
    // Add validation attributes
    this.inputs.forEach(input => {
      if (input.hasAttribute('required')) {
        const label = this.form.querySelector(`label[for="${input.id}"]`);
        if (label) {
          label.innerHTML += ' <span class="required" aria-hidden="true">*</span>';
        }
        
        input.setAttribute('aria-required', 'true');
      }
      
      // Create error message container
      const errorId = `error-${input.id}`;
      const errorElement = document.createElement('div');
      errorElement.id = errorId;
      errorElement.className = 'error-message';
      errorElement.setAttribute('aria-live', 'polite');
      errorElement.style.display = 'none';
      
      input.setAttribute('aria-describedby', errorId);
      input.insertAdjacentElement('afterend', errorElement);
      
      // Add input validation
      input.addEventListener('blur', () => this.validateInput(input));
    });
    
    // Form submission
    this.form.addEventListener('submit', (e) => {
      const isValid = this.validateForm();
      
      if (!isValid) {
        e.preventDefault();
        this.showErrorSummary();
      }
    });
  }
  
  validateInput(input) {
    const errorElement = document.getElementById(`error-${input.id}`);
    let isValid = true;
    let errorMessage = '';
    
    // Clear previous errors
    this.clearInputError(input);
    
    // Check validity
    if (input.hasAttribute('required') && !input.value.trim()) {
      isValid = false;
      errorMessage = `${this.getInputLabel(input)} is required`;
    } else if (input.type === 'email' && input.value && !this.isValidEmail(input.value)) {
      isValid = false;
      errorMessage = 'Please enter a valid email address';
    } else if (input.pattern && input.value && !new RegExp(input.pattern).test(input.value)) {
      isValid = false;
      errorMessage = input.dataset.errorPattern || `Please match the requested format`;
    }
    
    // Show error if invalid
    if (!isValid) {
      input.setAttribute('aria-invalid', 'true');
      errorElement.textContent = errorMessage;
      errorElement.style.display = 'block';
    }
    
    return isValid;
  }
  
  validateForm() {
    let isValid = true;
    
    this.inputs.forEach(input => {
      if (!this.validateInput(input)) {
        isValid = false;
      }
    });
    
    return isValid;
  }
  
  clearInputError(input) {
    const errorElement = document.getElementById(`error-${input.id}`);
    input.removeAttribute('aria-invalid');
    errorElement.textContent = '';
    errorElement.style.display = 'none';
  }
  
  showErrorSummary() {
    // Clear previous summary
    this.errorContainer.innerHTML = '';
    
    // Create heading
    const heading = document.createElement('h2');
    heading.textContent = 'Please fix the following errors:';
    this.errorContainer.appendChild(heading);
    
    // Create error list
    const errorList = document.createElement('ul');
    
    // Find all errors
    const errorMessages = this.form.querySelectorAll('.error-message');
    errorMessages.forEach(error => {
      if (error.textContent) {
        const errorItem = document.createElement('li');
        
        // Create link to the input
        const inputId = error.id.replace('error-', '');
        const errorLink = document.createElement('a');
        errorLink.href = `#${inputId}`;
        errorLink.textContent = error.textContent;
        errorLink.addEventListener('click', () => {
          document.getElementById(inputId).focus();
        });
        
        errorItem.appendChild(errorLink);
        errorList.appendChild(errorItem);
      }
    });
    
    this.errorContainer.appendChild(errorList);
    this.errorContainer.style.display = 'block';
    this.errorContainer.focus();
  }
  
  getInputLabel(input) {
    const label = this.form.querySelector(`label[for="${input.id}"]`);
    return label ? label.textContent.replace('*', '').trim() : input.name;
  }
  
  isValidEmail(email) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }
}

// Usage
const forms = document.querySelectorAll('form');
forms.forEach(form => new AccessibleForm(form));
```

**10. Performance and Accessibility**

```javascript
// Balancing performance and accessibility
class LazyLoadWithA11y {
  constructor(options = {}) {
    this.options = {
      selector: '[data-lazy]',
      rootMargin: '0px',
      threshold: 0.1,
      ...options
    };
    
    this.observer = null;
    this.init();
  }
  
  init() {
    if ('IntersectionObserver' in window) {
      this.observer = new IntersectionObserver(this.onIntersection.bind(this), {
        rootMargin: this.options.rootMargin,
        threshold: this.options.threshold
      });
      
      const elements = document.querySelectorAll(this.options.selector);
      elements.forEach(element => {
        // Add placeholder for screen readers
        if (element.tagName === 'IMG') {
          // Ensure there's an alt text
          if (!element.hasAttribute('alt')) {
            element.setAttribute('alt', element.getAttribute('data-alt') || '');
          }
          
          // Add loading indicator for screen readers
          const loadingText = document.createElement('span');
          loadingText.className = 'sr-only';
          loadingText.setAttribute('aria-live', 'polite');
          loadingText.textContent = 'Image loading';
          element.insertAdjacentElement('afterend', loadingText);
          
          // Store reference to the loading text
          element.loadingText = loadingText;
        }
        
        this.observer.observe(element);
      });
    } else {
      // Fallback for browsers without IntersectionObserver
      this.loadAllElements();
    }
  }
  
  onIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        this.loadElement(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }
  
  loadElement(element) {
    const src = element.getAttribute('data-src');
    const srcset = element.getAttribute('data-srcset');
    
    if (element.tagName === 'IMG') {
      if (src) element.src = src;
      if (srcset) element.srcset = srcset;
      
      element.addEventListener('load', () => {
        element.removeAttribute('data-src');
        element.removeAttribute('data-srcset');
        
        // Update loading text for screen readers
        if (element.loadingText) {
          element.loadingText.textContent = 'Image loaded';
          
          // Remove the loading text after announcement
          setTimeout(() => {
            if (element.loadingText.parentNode) {
              element.loadingText.parentNode.removeChild(element.loadingText);
            }
          }, 2000);
        }
      });
    } else if (element.tagName === 'IFRAME') {
      if (src) element.src = src;
      element.removeAttribute('data-src');
    } else if (element.tagName === 'VIDEO') {
      if (src) element.src = src;
      
      const sources = element.querySelectorAll('source');
      sources.forEach(source => {
        const dataSrc = source.getAttribute('data-src');
        if (dataSrc) source.src = dataSrc;
        source.removeAttribute('data-src');
      });
      
      element.load();
      element.removeAttribute('data-src');
    }
  }
  
  loadAllElements() {
    const elements = document.querySelectorAll(this.options.selector);
    elements.forEach(element => this.loadElement(element));
  }
}

// Usage
const lazyLoader = new LazyLoadWithA11y();
```

**Key Takeaways:**

1. Start with semantic HTML as the foundation for accessible JavaScript applications
2. Manage focus carefully, especially in single-page applications and modal dialogs
3. Use ARIA attributes appropriately to enhance accessibility when native HTML semantics aren't sufficient
4. Ensure keyboard accessibility for all interactive elements, not just mouse interactions
5. Consider screen reader users by providing appropriate text alternatives and announcements
6. Test your applications with automated tools like axe-core and with actual assistive technologies
7. Implement common accessibility patterns like skip links and proper form validation
8. Balance performance optimizations with accessibility requirements
9. Use modern JavaScript frameworks' accessibility features and best practices
10. Remember that accessibility is not just about compliance but about creating inclusive experiences for all users

## Modern Web Development Tools and Frameworks

### Q85: Explain JavaScript build tools and module bundlers. How do they improve development workflow?
**Difficulty: Medium**

**Answer:**
JavaScript build tools and module bundlers are essential components of modern web development workflows. They help developers manage dependencies, optimize code, and prepare applications for production deployment.

**1. Understanding Build Tools and Module Bundlers**

**a) Build Tools**

Build tools automate repetitive tasks in the development workflow, such as:
- Compiling/transpiling code (e.g., TypeScript to JavaScript, ES6+ to ES5)
- Optimizing assets (minification, compression)
- Running tests
- Linting code
- Managing development servers

**b) Module Bundlers**

Module bundlers specifically focus on resolving dependencies between modules and combining them into optimized bundles for the browser:
- They analyze the import/export statements in your code
- They create a dependency graph
- They package related code together into bundles
- They optimize the output for production

**2. Popular Build Tools and Bundlers**

**a) Webpack**

Webpack is the most widely used module bundler that can handle not just JavaScript but also CSS, images, and other assets.

*Basic webpack.config.js:*
```javascript
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.[contenthash].js',
    path: path.resolve(__dirname, 'dist'),
    clean: true
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      },
      {
        test: /\.(png|svg|jpg|jpeg|gif)$/i,
        type: 'asset/resource'
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html'
    })
  ],
  devServer: {
    static: './dist',
    hot: true
  },
  mode: 'development'
};
```

**b) Vite**

Vite is a newer, faster build tool that leverages native ES modules for development and uses Rollup for production builds.

*vite.config.js:*
```javascript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000
  },
  build: {
    outDir: 'dist',
    minify: 'terser',
    sourcemap: true
  }
});
```

**c) Rollup**

Rollup specializes in creating efficient bundles, particularly for libraries, using tree-shaking to eliminate unused code.

*rollup.config.js:*
```javascript
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import babel from '@rollup/plugin-babel';
import terser from '@rollup/plugin-terser';

export default {
  input: 'src/main.js',
  output: [
    {
      file: 'dist/bundle.cjs.js',
      format: 'cjs'
    },
    {
      file: 'dist/bundle.esm.js',
      format: 'es'
    },
    {
      file: 'dist/bundle.umd.js',
      format: 'umd',
      name: 'MyLibrary'
    }
  ],
  plugins: [
    resolve(),
    commonjs(),
    babel({ babelHelpers: 'bundled' }),
    terser()
  ]
};
```

**d) Parcel**

Parcel is a zero-configuration bundler that works out of the box with many file types.

*Using Parcel (no config file needed):*
```bash
# Install Parcel
npm install --save-dev parcel

# Add to package.json
# "scripts": {
#   "dev": "parcel src/index.html",
#   "build": "parcel build src/index.html"
# }
```

**e) esbuild**

esbuild is an extremely fast JavaScript bundler written in Go.

*esbuild.config.js:*
```javascript
require('esbuild').build({
  entryPoints: ['src/index.js'],
  bundle: true,
  minify: true,
  sourcemap: true,
  target: ['chrome58', 'firefox57', 'safari11', 'edge16'],
  outfile: 'dist/bundle.js'
}).catch(() => process.exit(1));
```

**f) Task Runners: npm scripts, Grunt, Gulp**

These tools focus on automating tasks rather than bundling modules.

*package.json with npm scripts:*
```json
{
  "scripts": {
    "start": "webpack serve --open",
    "build": "webpack --mode=production",
    "test": "jest",
    "lint": "eslint src/**/*.js"
  }
}
```

*gulpfile.js:*
```javascript
const { src, dest, watch, series, parallel } = require('gulp');
const sass = require('gulp-sass')(require('sass'));
const autoprefixer = require('gulp-autoprefixer');
const cssnano = require('gulp-cssnano');
const babel = require('gulp-babel');
const terser = require('gulp-terser');
const browsersync = require('browser-sync').create();

// Sass Task
function scssTask() {
  return src('src/scss/**/*.scss')
    .pipe(sass())
    .pipe(autoprefixer())
    .pipe(cssnano())
    .pipe(dest('dist/css'));
}

// JavaScript Task
function jsTask() {
  return src('src/js/**/*.js')
    .pipe(babel({ presets: ['@babel/preset-env'] }))
    .pipe(terser())
    .pipe(dest('dist/js'));
}

// Browsersync
function browserSyncServe(cb) {
  browsersync.init({
    server: {
      baseDir: '.'
    }
  });
  cb();
}

function browserSyncReload(cb) {
  browsersync.reload();
  cb();
}

// Watch Task
function watchTask() {
  watch('*.html', browserSyncReload);
  watch(['src/scss/**/*.scss', 'src/js/**/*.js'], 
    series(scssTask, jsTask, browserSyncReload));
}

// Default Gulp Task
exports.default = series(
  parallel(scssTask, jsTask),
  browserSyncServe,
  watchTask
);
```

**3. Key Features and Benefits**

**a) Module Resolution and Bundling**

```javascript
// Before bundling - separate files with imports/exports
// math.js
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

// app.js
import { add } from './math.js';

console.log(add(2, 3)); // 5

// After bundling - single file with resolved dependencies
// bundle.js (simplified example)
(function() {
  function add(a, b) {
    return a + b;
  }
  
  function subtract(a, b) {
    return a - b;
  }
  
  console.log(add(2, 3)); // 5
})();
```

**b) Code Splitting**

```javascript
// Dynamic import for code splitting
import React, { lazy, Suspense } from 'react';

// These components will be in separate chunks
const Dashboard = lazy(() => import('./Dashboard'));
const Settings = lazy(() => import('./Settings'));
const Profile = lazy(() => import('./Profile'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Router>
        <Route path="/dashboard" component={Dashboard} />
        <Route path="/settings" component={Settings} />
        <Route path="/profile" component={Profile} />
      </Router>
    </Suspense>
  );
}
```

**c) Tree Shaking**

```javascript
// library.js
export function used() {
  return 'This function is used';
}

export function unused() {
  return 'This function is never imported';
}

// app.js
import { used } from './library.js';

console.log(used());

// After tree shaking and bundling
// bundle.js (simplified)
(function() {
  function used() {
    return 'This function is used';
  }
  
  console.log(used());
})();
// Note: The unused function has been eliminated
```

**d) Asset Optimization**

```javascript
// webpack.config.js with optimization
module.exports = {
  // ... other config
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true,
          },
        },
      }),
      new CssMinimizerPlugin(),
    ],
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\\\]/node_modules[\\\\]/,
          name: 'vendors',
          chunks: 'all'
        }
      }
    }
  }
};
```

**e) Development Server with Hot Module Replacement (HMR)**

```javascript
// webpack.config.js with HMR
const webpack = require('webpack');

module.exports = {
  // ... other config
  devServer: {
    static: './dist',
    hot: true,
    port: 3000,
    open: true
  },
  plugins: [
    // ... other plugins
    new webpack.HotModuleReplacementPlugin()
  ]
};

// In your application code
if (module.hot) {
  module.hot.accept('./components/Counter', () => {
    console.log('Counter module updated!');
    // Re-render your application
  });
}
```

**4. Advanced Configurations**

**a) Environment-Specific Builds**

```javascript
// webpack.config.js with environment variables
const webpack = require('webpack');
const { merge } = require('webpack-merge');
const commonConfig = require('./webpack.common.js');

module.exports = (env) => {
  const isProduction = env.production === true;
  const envConfig = isProduction 
    ? require('./webpack.prod.js')
    : require('./webpack.dev.js');
  
  return merge(commonConfig, envConfig, {
    plugins: [
      new webpack.DefinePlugin({
        'process.env.NODE_ENV': JSON.stringify(
          isProduction ? 'production' : 'development'
        ),
        'process.env.API_URL': JSON.stringify(
          isProduction 
            ? 'https://api.example.com' 
            : 'http://localhost:3001'
        )
      })
    ]
  });
};
```

**b) Custom Loaders and Plugins**

```javascript
// Custom webpack loader
module.exports = function(source) {
  // Transform the source code
  const transformed = source.replace(/console\.log\([^)]*\);?/g, '');
  return transformed;
};

// Custom webpack plugin
class MyCustomPlugin {
  constructor(options) {
    this.options = options || {};
  }
  
  apply(compiler) {
    compiler.hooks.emit.tapAsync(
      'MyCustomPlugin',
      (compilation, callback) => {
        // Create a new asset
        compilation.assets['build-info.json'] = {
          source: () => JSON.stringify({
            buildDate: new Date().toISOString(),
            version: process.env.npm_package_version,
            author: this.options.author || 'Unknown'
          }),
          size: () => 42
        };
        
        callback();
      }
    );
  }
}

// Usage in webpack.config.js
module.exports = {
  // ... other config
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: ['babel-loader', './path/to/custom-loader.js']
      }
    ]
  },
  plugins: [
    new MyCustomPlugin({ author: 'Developer Name' })
  ]
};
```

**5. Comparing Build Tools**

| Feature | Webpack | Vite | Rollup | Parcel | esbuild |
|---------|---------|------|--------|--------|--------|
| **Configuration** | Complex | Simple | Moderate | Zero-config | Simple |
| **Build Speed** | Moderate | Very Fast | Fast | Fast | Extremely Fast |
| **Dev Server** | Yes | Yes (native ESM) | With plugin | Yes | With plugin |
| **HMR** | Yes | Yes | With plugin | Yes | Limited |
| **Code Splitting** | Advanced | Yes | Yes | Yes | Basic |
| **Tree Shaking** | Yes | Yes | Advanced | Yes | Yes |
| **TypeScript** | With loader | Native | With plugin | Native | Native |
| **CSS Processing** | With loader | With plugin | With plugin | Native | With plugin |
| **Best For** | Complex apps | Modern apps | Libraries | Quick projects | Performance-critical |

**6. Best Practices**

**a) Optimizing Bundle Size**

```javascript
// webpack.config.js with bundle analysis
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');

module.exports = {
  // ... other config
  plugins: [
    // ... other plugins
    new BundleAnalyzerPlugin({
      analyzerMode: process.env.ANALYZE ? 'server' : 'disabled'
    })
  ]
};

// Implementing dynamic imports for code splitting
import(/* webpackChunkName: "chart" */ './chart').then(module => {
  const createChart = module.default;
  createChart(data);
});
```

**b) Caching Strategies**

```javascript
// webpack.config.js with caching
module.exports = {
  // ... other config
  output: {
    filename: '[name].[contenthash].js',
    path: path.resolve(__dirname, 'dist')
  },
  optimization: {
    moduleIds: 'deterministic',
    runtimeChunk: 'single',
    splitChunks: {
      cacheGroups: {
        vendor: {
          test: /[\\\\]/node_modules[\\\\]/,
          name: 'vendors',
          chunks: 'all'
        }
      }
    }
  }
};
```

**c) Managing Dependencies**

```javascript
// package.json with peer dependencies for a library
{
  "name": "my-component-library",
  "version": "1.0.0",
  "peerDependencies": {
    "react": "^17.0.0 || ^18.0.0",
    "react-dom": "^17.0.0 || ^18.0.0"
  },
  "devDependencies": {
    "react": "^18.0.0",
    "react-dom": "^18.0.0"
  }
}

// webpack.config.js with externals for a library
module.exports = {
  // ... other config
  externals: {
    react: {
      commonjs: 'react',
      commonjs2: 'react',
      amd: 'React',
      root: 'React'
    },
    'react-dom': {
      commonjs: 'react-dom',
      commonjs2: 'react-dom',
      amd: 'ReactDOM',
      root: 'ReactDOM'
    }
  }
};
```

**7. Modern Approaches and Trends**

**a) ESM and Native Modules**

```html
<!-- Using native ESM in the browser -->
<script type="module">
  import { renderApp } from './app.js';
  renderApp();
</script>

<!-- Importing from a CDN -->
<script type="module">
  import React from 'https://cdn.skypack.dev/react';
  import ReactDOM from 'https://cdn.skypack.dev/react-dom';
  
  ReactDOM.render(
    React.createElement('h1', null, 'Hello from ESM!'),
    document.getElementById('root')
  );
</script>
```

**b) Build-less Development**

```javascript
// Using Snowpack for build-less development
// snowpack.config.js
module.exports = {
  mount: {
    public: '/',
    src: '/dist'
  },
  plugins: [
    '@snowpack/plugin-react-refresh',
    '@snowpack/plugin-dotenv'
  ],
  optimize: {
    bundle: true,
    minify: true,
    target: 'es2018'
  }
};
```

**c) WebAssembly Integration**

```javascript
// webpack.config.js with WebAssembly
module.exports = {
  // ... other config
  experiments: {
    asyncWebAssembly: true
  },
  module: {
    rules: [
      {
        test: /\.wasm$/,
        type: 'webassembly/async'
      }
    ]
  }
};

// Using WebAssembly in your code
async function loadWasm() {
  const wasm = await import('./module.wasm');
  const result = wasm.calculate(10, 20);
  console.log(result);
}
```

**Key Takeaways:**

1. Build tools and module bundlers are essential for modern JavaScript development, helping manage dependencies and optimize code
2. Webpack is the most comprehensive bundler with extensive configuration options, while newer tools like Vite offer faster development experiences
3. Key features include module resolution, code splitting, tree shaking, and asset optimization
4. Choose the right tool based on your project needs: complex applications (Webpack), libraries (Rollup), quick projects (Parcel), or performance-critical apps (esbuild)
5. Implement proper caching strategies and code splitting to optimize application performance
6. Modern approaches are moving toward ESM and build-less development for improved developer experience
7. Bundle analysis tools help identify and fix performance issues in your application
8. Environment-specific configurations allow for optimized development and production builds
9. Task runners like npm scripts or Gulp can complement bundlers for additional automation needs
10. The build tools ecosystem continues to evolve toward faster, simpler solutions with better defaults

### Q86: Explain Progressive Web Apps (PWAs) and how to implement them using JavaScript.
**Difficulty: Medium**

**Answer:**
Progressive Web Apps (PWAs) are web applications that use modern web capabilities to deliver app-like experiences to users. They combine the best of web and mobile apps, offering reliability, speed, and engagement.

**1. Core Concepts of PWAs**

**a) Key Characteristics**

- **Progressive:** Work for every user, regardless of browser choice
- **Responsive:** Fit any form factor (desktop, mobile, tablet)
- **Connectivity Independent:** Work offline or with poor network conditions
- **App-like:** Feel like an app with app-style interactions
- **Fresh:** Always up-to-date thanks to service workers
- **Safe:** Served via HTTPS to prevent snooping
- **Discoverable:** Identifiable as "applications" by search engines
- **Re-engageable:** Make re-engagement easy through features like push notifications
- **Installable:** Allow users to add to their home screen without an app store
- **Linkable:** Easily share via URL without complex installation

**b) Core Technologies**

- **Service Workers:** JavaScript files that act as proxies between web applications, the browser, and the network
- **Web App Manifest:** JSON file that provides information about the web application
- **HTTPS:** Required for security and to use service workers
- **Responsive Design:** Ensures the app works across different devices and screen sizes
- **Push Notifications:** Allows re-engagement with timely updates

**2. Implementing a PWA**

**a) Creating a Web App Manifest**

The manifest.json file provides metadata about your application:

```json
{
  "name": "My PWA App",
  "short_name": "PWA",
  "description": "A Progressive Web App example",
  "start_url": "/index.html",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#2196f3",
  "orientation": "portrait-primary",
  "icons": [
    {
      "src": "/images/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png"
    },
    {
      "src": "/images/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png"
    },
    {
      "src": "/images/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png"
    },
    {
      "src": "/images/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png"
    },
    {
      "src": "/images/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png"
    },
    {
      "src": "/images/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/images/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "/images/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "screenshots": [
    {
      "src": "/images/screenshots/screen1.png",
      "sizes": "1280x720",
      "type": "image/png"
    }
  ]
}
```

Link to the manifest in your HTML:

```html
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#2196f3">
<link rel="apple-touch-icon" href="/images/icons/icon-192x192.png">
```

**b) Registering a Service Worker**

Service workers enable offline capabilities, background syncing, and push notifications:

```javascript
// In your main JavaScript file (e.g., app.js)
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then(registration => {
        console.log('Service Worker registered with scope:', registration.scope);
      })
      .catch(error => {
        console.error('Service Worker registration failed:', error);
      });
  });
}
```

**c) Creating a Basic Service Worker**

The service worker file (sw.js) handles caching and offline functionality:

```javascript
// sw.js - Service Worker file

// Cache name (update this when your app content changes)
const CACHE_NAME = 'my-pwa-cache-v1';

// Files to cache
const urlsToCache = [
  '/',
  '/index.html',
  '/styles/main.css',
  '/scripts/app.js',
  '/images/logo.png',
  // Add other assets you want to cache
];

// Install event - cache assets
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        console.log('Cache opened');
        return cache.addAll(urlsToCache);
      })
      .then(() => self.skipWaiting())
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', event => {
  const cacheWhitelist = [CACHE_NAME];
  
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheWhitelist.indexOf(cacheName) === -1) {
            // Delete outdated caches
            return caches.delete(cacheName);
          }
        })
      );
    }).then(() => self.clients.claim())
  );
});

// Fetch event - serve from cache or network
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // Return cached response if found
        if (response) {
          return response;
        }
        
        // Clone the request because it's a one-time use stream
        const fetchRequest = event.request.clone();
        
        // Make network request and cache the response
        return fetch(fetchRequest).then(response => {
          // Check if valid response
          if (!response || response.status !== 200 || response.type !== 'basic') {
            return response;
          }
          
          // Clone the response because it's a one-time use stream
          const responseToCache = response.clone();
          
          caches.open(CACHE_NAME)
            .then(cache => {
              cache.put(event.request, responseToCache);
            });
            
          return response;
        });
      })
      .catch(() => {
        // Fallback for when network is unavailable
        if (event.request.url.indexOf('.html') > -1) {
          return caches.match('/offline.html');
        }
      })
  );
});
```

**3. Advanced PWA Features**

**a) Implementing Offline Page**

```html
<!-- offline.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Offline - My PWA</title>
  <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
  <div class="offline-container">
    <h1>You are offline</h1>
    <p>Please check your internet connection and try again.</p>
  </div>
</body>
</html>
```

**b) Implementing Cache Strategies**

```javascript
// Different caching strategies

// 1. Cache First, Network Fallback (for app shell and static assets)
function cacheFirstStrategy(request) {
  return caches.match(request)
    .then(cacheResponse => {
      return cacheResponse || fetch(request).then(networkResponse => {
        return caches.open(CACHE_NAME).then(cache => {
          cache.put(request, networkResponse.clone());
          return networkResponse;
        });
      });
    });
}

// 2. Network First, Cache Fallback (for API calls and dynamic content)
function networkFirstStrategy(request) {
  return fetch(request)
    .then(networkResponse => {
      const clonedResponse = networkResponse.clone();
      caches.open(CACHE_NAME).then(cache => {
        cache.put(request, clonedResponse);
      });
      return networkResponse;
    })
    .catch(() => {
      return caches.match(request);
    });
}

// 3. Stale While Revalidate (for frequently updated content)
function staleWhileRevalidateStrategy(request) {
  return caches.open(CACHE_NAME).then(cache => {
    return cache.match(request).then(cacheResponse => {
      const fetchPromise = fetch(request).then(networkResponse => {
        cache.put(request, networkResponse.clone());
        return networkResponse;
      });
      return cacheResponse || fetchPromise;
    });
  });
}

// Use different strategies based on request type
self.addEventListener('fetch', event => {
  const url = new URL(event.request.url);
  
  // Static assets - Cache First
  if (event.request.destination === 'style' || 
      event.request.destination === 'script' || 
      event.request.destination === 'image') {
    event.respondWith(cacheFirstStrategy(event.request));
  }
  // API calls - Network First
  else if (url.pathname.startsWith('/api/')) {
    event.respondWith(networkFirstStrategy(event.request));
  }
  // HTML pages - Stale While Revalidate
  else if (event.request.mode === 'navigate') {
    event.respondWith(staleWhileRevalidateStrategy(event.request));
  }
  // Default strategy
  else {
    event.respondWith(cacheFirstStrategy(event.request));
  }
});
```

**c) Implementing Background Sync**

```javascript
// In your app.js
function sendData() {
  const data = {
    message: document.getElementById('message').value,
    timestamp: new Date().getTime()
  };
  
  // Try to send data immediately
  fetch('/api/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(data)
  })
  .catch(() => {
    // If sending fails, store in IndexedDB for later
    saveDataLocally(data)
      .then(() => {
        // Register for background sync if supported
        if ('serviceWorker' in navigator && 'SyncManager' in window) {
          navigator.serviceWorker.ready
            .then(registration => {
              return registration.sync.register('sync-messages');
            })
            .catch(err => console.error('Background sync registration failed:', err));
        }
      });
  });
}

// In your service worker (sw.js)
self.addEventListener('sync', event => {
  if (event.tag === 'sync-messages') {
    event.waitUntil(
      getLocalData()
        .then(dataArray => {
          return Promise.all(dataArray.map(data => {
            return fetch('/api/messages', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(data)
            })
            .then(response => {
              if (response.ok) {
                return removeLocalData(data.id);
              }
              throw new Error('Network response was not ok');
            });
          }));
        })
        .catch(err => console.error('Sync failed:', err))
    );
  }
});
```

**d) Implementing Push Notifications**

```javascript
// In your app.js
function subscribeToPushNotifications() {
  navigator.serviceWorker.ready
    .then(registration => {
      // Check if subscription exists
      return registration.pushManager.getSubscription()
        .then(subscription => {
          if (subscription) {
            return subscription;
          }
          
          // Get server's public key
          return fetch('/api/vapid-public-key')
            .then(response => response.json())
            .then(data => {
              // Convert the key to a Uint8Array
              const convertedVapidKey = urlBase64ToUint8Array(data.publicKey);
              
              // Subscribe the user
              return registration.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: convertedVapidKey
              });
            });
        });
    })
    .then(subscription => {
      // Send the subscription to your server
      return fetch('/api/save-subscription', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(subscription)
      });
    })
    .then(response => {
      if (response.ok) {
        console.log('Subscription saved on server');
      }
    })
    .catch(error => {
      console.error('Error subscribing to push notifications:', error);
    });
}

// Helper function to convert base64 to Uint8Array
function urlBase64ToUint8Array(base64String) {
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding)
    .replace(/-/g, '+')
    .replace(/_/g, '/');
  
  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  
  return outputArray;
}

// In your service worker (sw.js)
self.addEventListener('push', event => {
  let notificationData = {};
  
  try {
    notificationData = event.data.json();
  } catch (e) {
    notificationData = {
      title: 'New Notification',
      body: event.data ? event.data.text() : 'No payload',
      icon: '/images/icons/icon-192x192.png'
    };
  }
  
  event.waitUntil(
    self.registration.showNotification(notificationData.title, {
      body: notificationData.body,
      icon: notificationData.icon,
      badge: '/images/icons/badge-72x72.png',
      data: notificationData.data || {}
    })
  );
});

self.addEventListener('notificationclick', event => {
  event.notification.close();
  
  const urlToOpen = event.notification.data.url || '/';
  
  event.waitUntil(
    clients.matchAll({ type: 'window' })
      .then(clientList => {
        // Check if a window is already open
        for (const client of clientList) {
          if (client.url === urlToOpen && 'focus' in client) {
            return client.focus();
          }
        }
        // If no window is open, open a new one
        if (clients.openWindow) {
          return clients.openWindow(urlToOpen);
        }
      })
  );
});
```

**4. Implementing App Installation**

```javascript
// In your app.js
let deferredPrompt;

// Listen for the beforeinstallprompt event
window.addEventListener('beforeinstallprompt', event => {
  // Prevent Chrome from automatically showing the prompt
  event.preventDefault();
  
  // Stash the event so it can be triggered later
  deferredPrompt = event;
  
  // Show your custom install button
  const installButton = document.getElementById('install-button');
  installButton.style.display = 'block';
  
  installButton.addEventListener('click', () => {
    // Hide the button
    installButton.style.display = 'none';
    
    // Show the prompt
    deferredPrompt.prompt();
    
    // Wait for the user to respond to the prompt
    deferredPrompt.userChoice.then(choiceResult => {
      if (choiceResult.outcome === 'accepted') {
        console.log('User accepted the install prompt');
      } else {
        console.log('User dismissed the install prompt');
      }
      
      // Clear the deferredPrompt variable
      deferredPrompt = null;
    });
  });
});

// Listen for the appinstalled event
window.addEventListener('appinstalled', event => {
  console.log('App was installed', event);
  // You might want to log this event to analytics
});
```

**5. Testing and Auditing PWAs**

**a) Lighthouse Audit**

Lighthouse is an open-source tool from Google that helps improve the quality of web pages. It has audits for performance, accessibility, progressive web apps, SEO, and more.

```javascript
// Example of fixing issues identified by Lighthouse

// 1. Ensure all pages are responsive
const viewport = document.createElement('meta');
viewport.name = 'viewport';
viewport.content = 'width=device-width, initial-scale=1';
document.head.appendChild(viewport);

// 2. Ensure proper contrast for accessibility
document.documentElement.style.setProperty('--text-color', '#333333');
document.documentElement.style.setProperty('--background-color', '#ffffff');

// 3. Add meta description for SEO
const metaDescription = document.createElement('meta');
metaDescription.name = 'description';
metaDescription.content = 'A progressive web app example with offline capabilities';
document.head.appendChild(metaDescription);
```

**b) Workbox Integration**

Workbox is a set of libraries that makes working with service workers easier:

```javascript
// Using Workbox in your service worker
importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.2.0/workbox-sw.js');

if (workbox) {
  console.log('Workbox is loaded');
  
  // Customize cache names
  workbox.core.setCacheNameDetails({
    prefix: 'my-app',
    suffix: 'v1',
    precache: 'precache',
    runtime: 'runtime'
  });
  
  // Precaching
  workbox.precaching.precacheAndRoute([
    { url: '/', revision: '1' },
    { url: '/index.html', revision: '1' },
    { url: '/styles/main.css', revision: '1' },
    { url: '/scripts/app.js', revision: '1' },
    { url: '/offline.html', revision: '1' }
  ]);
  
  // Cache CSS, JS, and Web Worker files with a Cache First strategy
  workbox.routing.registerRoute(
    /\.(?:js|css|mjs|wasm)$/,
    new workbox.strategies.CacheFirst({
      cacheName: 'static-resources',
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 60,
          maxAgeSeconds: 30 * 24 * 60 * 60 // 30 days
        })
      ]
    })
  );
  
  // Cache images with a Cache First strategy
  workbox.routing.registerRoute(
    /\.(?:png|jpg|jpeg|svg|gif|webp)$/,
    new workbox.strategies.CacheFirst({
      cacheName: 'images',
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 60,
          maxAgeSeconds: 30 * 24 * 60 * 60 // 30 days
        })
      ]
    })
  );
  
  // Cache API calls with a Network First strategy
  workbox.routing.registerRoute(
    /\/api\//,
    new workbox.strategies.NetworkFirst({
      cacheName: 'api-responses',
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 50,
          maxAgeSeconds: 5 * 60 // 5 minutes
        })
      ]
    })
  );
  
  // Cache Google Fonts
  workbox.routing.registerRoute(
    /^https:\/\/fonts\.googleapis\.com/,
    new workbox.strategies.StaleWhileRevalidate({
      cacheName: 'google-fonts-stylesheets'
    })
  );
  
  workbox.routing.registerRoute(
    /^https:\/\/fonts\.gstatic\.com/,
    new workbox.strategies.CacheFirst({
      cacheName: 'google-fonts-webfonts',
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 30,
          maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
        }),
        new workbox.cacheableResponse.CacheableResponsePlugin({
          statuses: [0, 200]
        })
      ]
    })
  );
  
  // Fallback to offline page
  workbox.routing.setCatchHandler(({ event }) => {
    if (event.request.destination === 'document') {
      return caches.match('/offline.html');
    }
    return Response.error();
  });
  
} else {
  console.error('Workbox failed to load');
}
```

**6. PWA Best Practices**

**a) Performance Optimization**

```javascript
// Implement lazy loading for images
document.addEventListener('DOMContentLoaded', () => {
  const lazyImages = document.querySelectorAll('img.lazy');
  
  if ('IntersectionObserver' in window) {
    const imageObserver = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const lazyImage = entry.target;
          lazyImage.src = lazyImage.dataset.src;
          if (lazyImage.dataset.srcset) {
            lazyImage.srcset = lazyImage.dataset.srcset;
          }
          lazyImage.classList.remove('lazy');
          imageObserver.unobserve(lazyImage);
        }
      });
    });
    
    lazyImages.forEach(lazyImage => {
      imageObserver.observe(lazyImage);
    });
  } else {
    // Fallback for browsers that don't support IntersectionObserver
    let lazyLoadThrottleTimeout;
    
    function lazyLoad() {
      if (lazyLoadThrottleTimeout) {
        clearTimeout(lazyLoadThrottleTimeout);
      }
      
      lazyLoadThrottleTimeout = setTimeout(() => {
        const scrollTop = window.pageYOffset;
        
        lazyImages.forEach(lazyImage => {
          if (lazyImage.offsetTop < window.innerHeight + scrollTop) {
            lazyImage.src = lazyImage.dataset.src;
            if (lazyImage.dataset.srcset) {
              lazyImage.srcset = lazyImage.dataset.srcset;
            }
            lazyImage.classList.remove('lazy');
          }
        });
        
        if (lazyImages.length === 0) {
          document.removeEventListener('scroll', lazyLoad);
          window.removeEventListener('resize', lazyLoad);
          window.removeEventListener('orientationChange', lazyLoad);
        }
      }, 20);
    }
    
    document.addEventListener('scroll', lazyLoad);
    window.addEventListener('resize', lazyLoad);
    window.addEventListener('orientationChange', lazyLoad);
  }
});
```

**b) Handling Network Changes**

```javascript
// Detect and respond to network changes
function updateNetworkStatus() {
  const networkStatus = document.getElementById('network-status');
  
  if (navigator.onLine) {
    networkStatus.textContent = 'You are online';
    networkStatus.className = 'online';
    
    // Try to sync any pending data
    if ('serviceWorker' in navigator && 'SyncManager' in window) {
      navigator.serviceWorker.ready
        .then(registration => registration.sync.register('sync-data'))
        .catch(err => console.error('Sync registration failed:', err));
    }
  } else {
    networkStatus.textContent = 'You are offline';
    networkStatus.className = 'offline';
  }
}

// Initial status check
updateNetworkStatus();

// Add event listeners for network changes
window.addEventListener('online', updateNetworkStatus);
window.addEventListener('offline', updateNetworkStatus);
```

**c) Handling App Updates**

```javascript
// In your app.js
let refreshing = false;

// Listen for service worker updates
navigator.serviceWorker.addEventListener('controllerchange', () => {
  if (refreshing) return;
  refreshing = true;
  window.location.reload();
});

// Check for service worker updates
function checkForUpdates() {
  navigator.serviceWorker.ready
    .then(registration => {
      registration.update();
    })
    .catch(err => {
      console.error('Error checking for service worker updates:', err);
    });
}

// Check for updates periodically
setInterval(checkForUpdates, 60 * 60 * 1000); // Check every hour

// In your service worker (sw.js)
self.addEventListener('message', event => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// In your app.js - UI to notify users of updates
function showUpdateNotification() {
  const updateNotification = document.getElementById('update-notification');
  const updateButton = document.getElementById('update-button');
  
  updateNotification.style.display = 'block';
  
  updateButton.addEventListener('click', () => {
    updateNotification.style.display = 'none';
    
    // Tell the service worker to skip waiting
    navigator.serviceWorker.ready
      .then(registration => {
        if (registration.waiting) {
          registration.waiting.postMessage({ type: 'SKIP_WAITING' });
        }
      });
  });
}

// Listen for new service workers
navigator.serviceWorker.addEventListener('updatefound', () => {
  const newWorker = navigator.serviceWorker.controller;
  
  if (newWorker) {
    newWorker.addEventListener('statechange', () => {
      if (newWorker.state === 'installed') {
        showUpdateNotification();
      }
    });
  }
});
```

**Key Takeaways:**

1. Progressive Web Apps combine the best features of web and native applications, offering reliability, speed, and engagement
2. Service Workers are the backbone of PWAs, enabling offline functionality, background syncing, and push notifications
3. The Web App Manifest provides metadata that allows users to install the PWA to their home screen
4. Different caching strategies (Cache First, Network First, Stale While Revalidate) should be used for different types of content
5. Background Sync allows data to be sent even when the user goes offline during the operation
6. Push Notifications enable re-engagement with timely updates to bring users back to your application
7. Workbox simplifies service worker implementation with pre-built strategies and patterns
8. Lighthouse helps audit your PWA for compliance with best practices and performance standards
9. Proper handling of network changes and app updates improves the user experience
10. PWAs must be served over HTTPS for security and to enable service worker functionality

### Q87: Compare and contrast popular JavaScript frameworks and libraries. How do you choose the right one for a project?
**Difficulty: Medium**

**Answer:**
JavaScript frameworks and libraries have revolutionized web development by providing structured approaches to building applications. Understanding their differences, strengths, and weaknesses is crucial for making informed decisions for your projects.

**1. Overview of Popular JavaScript Frameworks and Libraries**

**a) React**

React is a library developed by Facebook for building user interfaces, particularly single-page applications.

*Key Features:*
- Virtual DOM for efficient rendering
- Component-based architecture
- JSX syntax
- Unidirectional data flow
- Rich ecosystem with tools like Redux, React Router

*Example:*
```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

export default Counter;
```

**b) Angular**

Angular is a full-featured framework maintained by Google, offering a complete solution for front-end development.

*Key Features:*
- Two-way data binding
- Dependency injection
- TypeScript integration
- Comprehensive built-in features (routing, forms, HTTP client)
- RxJS integration for reactive programming

*Example:*
```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-counter',
  template: `
    <div>
      <p>You clicked {{count}} times</p>
      <button (click)="increment()">Click me</button>
    </div>
  `
})
export class CounterComponent {
  count = 0;
  
  increment() {
    this.count++;
  }
}
```

**c) Vue.js**

Vue is a progressive framework designed to be incrementally adoptable, combining features from both React and Angular.

*Key Features:*
- Gentle learning curve
- Template-based syntax
- Reactive and composable components
- Built-in state management and routing solutions
- Single-file components

*Example:*
```vue
<template>
  <div>
    <p>You clicked {{ count }} times</p>
    <button @click="increment">Click me</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      count: 0
    };
  },
  methods: {
    increment() {
      this.count++;
    }
  }
};
</script>
```

**d) Svelte**

Svelte is a compiler that converts your components into highly efficient imperative code that surgically updates the DOM.

*Key Features:*
- No virtual DOM
- Compile-time framework
- Less boilerplate code
- Built-in animations and transitions
- Truly reactive by design

*Example:*
```svelte
<script>
  let count = 0;
  
  function increment() {
    count += 1;
  }
</script>

<div>
  <p>You clicked {count} times</p>
  <button on:click={increment}>Click me</button>
</div>
```

**e) Ember.js**

Ember is a framework for ambitious web applications with strong conventions and a focus on developer productivity.

*Key Features:*
- Convention over configuration
- Ember CLI for scaffolding
- Built-in testing tools
- Strong community and stability
- Comprehensive routing system

*Example:*
```javascript
import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';

export default class CounterComponent extends Component {
  @tracked count = 0;
  
  increment = () => {
    this.count++;
  }
}
```
```handlebars
{{!-- counter.hbs --}}
<div>
  <p>You clicked {{this.count}} times</p>
  <button {{on "click" this.increment}}>Click me</button>
</div>
```

**f) Preact**

Preact is a fast 3kB alternative to React with the same modern API.

*Key Features:*
- Tiny size (3kB)
- React-compatible API
- Fast performance
- Minimal abstractions

*Example:*
```jsx
import { h, Component } from 'preact';
import { useState } from 'preact/hooks';

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

**g) Alpine.js**

Alpine.js is a minimal framework for composing JavaScript behavior in your markup.

*Key Features:*
- Lightweight (8kB)
- No build step required
- Simple directives in HTML
- Perfect for enhancing existing HTML

*Example:*
```html
<div x-data="{ count: 0 }">
  <p>You clicked <span x-text="count"></span> times</p>
  <button x-on:click="count++">Click me</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
```

**h) Solid.js**

Solid is a declarative JavaScript library for creating user interfaces with a fine-grained reactivity system.

*Key Features:*
- No virtual DOM
- True reactivity with fine-grained updates
- JSX-based but with unique compilation
- Small bundle size
- Excellent performance

*Example:*
```jsx
import { createSignal } from 'solid-js';

function Counter() {
  const [count, setCount] = createSignal(0);
  
  return (
    <div>
      <p>You clicked {count()} times</p>
      <button onClick={() => setCount(count() + 1)}>
        Click me
      </button>
    </div>
  );
}
```

**2. Comparing Frameworks and Libraries**

**a) Performance Comparison**

```javascript
// Performance metrics (simplified example)
const performanceComparison = {
  // Time to interactive (ms) for a medium-sized app
  timeToInteractive: {
    react: 1800,
    angular: 2500,
    vue: 1600,
    svelte: 1200,
    preact: 1400,
    solidjs: 1100
  },
  // Memory usage (MB)
  memoryUsage: {
    react: 7.2,
    angular: 9.1,
    vue: 6.8,
    svelte: 4.9,
    preact: 5.3,
    solidjs: 4.7
  },
  // Bundle size (kB, minified + gzipped)
  bundleSize: {
    react: 42, // + React DOM
    angular: 63,
    vue: 33,
    svelte: 4, // Runtime only
    preact: 10,
    alpinejs: 8,
    solidjs: 7
  }
};
```

**b) Learning Curve**

| Framework/Library | Learning Curve | Why? |
|------------------|----------------|------|
| React | Moderate | JSX, component lifecycle, hooks, state management |
| Angular | Steep | TypeScript, RxJS, modules, decorators, DI system |
| Vue | Gentle | Simple API, clear documentation, gradual learning path |
| Svelte | Gentle | Minimal new syntax, close to vanilla JS/HTML/CSS |
| Ember | Steep | Many conventions to learn, large API surface |
| Preact | Easy (if you know React) | Similar to React but simpler |
| Alpine.js | Very Easy | HTML attributes, minimal JavaScript concepts |
| Solid.js | Moderate | Reactive primitives, JSX, mental model shift |

**c) Community and Ecosystem**

```javascript
// Ecosystem metrics (as of 2023, simplified)
const ecosystemComparison = {
  // GitHub stars (thousands)
  githubStars: {
    react: 200,
    angular: 86,
    vue: 200,
    svelte: 64,
    ember: 22,
    preact: 33,
    alpinejs: 22,
    solidjs: 25
  },
  // npm downloads per week (millions)
  npmDownloads: {
    react: 16,
    angular: 2.3,
    vue: 3.5,
    svelte: 0.4,
    ember: 0.1,
    preact: 0.9,
    alpinejs: 0.2,
    solidjs: 0.1
  },
  // Job listings (relative scale 1-10)
  jobDemand: {
    react: 10,
    angular: 8,
    vue: 6,
    svelte: 3,
    ember: 2,
    preact: 2,
    alpinejs: 1,
    solidjs: 2
  }
};
```

**3. Framework Selection Criteria**

**a) Project Requirements Analysis**

```javascript
// Decision matrix example (score 1-5)
function selectFramework(requirements) {
  const scores = {
    react: 0,
    angular: 0,
    vue: 0,
    svelte: 0,
    ember: 0
  };
  
  // Performance importance
  if (requirements.performance === 'critical') {
    scores.svelte += 5;
    scores.preact += 4;
    scores.react += 3;
    scores.vue += 3;
    scores.angular += 2;
  }
  
  // Team experience
  if (requirements.teamExperience === 'react') {
    scores.react += 5;
    scores.preact += 4;
  } else if (requirements.teamExperience === 'angular') {
    scores.angular += 5;
  }
  
  // Project size
  if (requirements.projectSize === 'large') {
    scores.angular += 5;
    scores.react += 4;
    scores.vue += 4;
    scores.ember += 4;
    scores.svelte += 3;
  } else if (requirements.projectSize === 'small') {
    scores.svelte += 5;
    scores.preact += 5;
    scores.vue += 4;
    scores.react += 3;
    scores.angular += 2;
  }
  
  // Find highest score
  return Object.entries(scores)
    .sort((a, b) => b[1] - a[1])
    .map(entry => entry[0])[0];
}

// Example usage
const recommendation = selectFramework({
  performance: 'critical',
  teamExperience: 'react',
  projectSize: 'small'
});
// Returns: 'preact'
```

**b) Project Type Considerations**

| Project Type | Recommended Frameworks/Libraries | Reasoning |
|--------------|----------------------------------|----------|
| Enterprise SPA | Angular, React | Robust tooling, strong typing support, mature ecosystem |
| Content-focused website | Vue, Svelte, Alpine.js | Lightweight, easy integration with existing content |
| Progressive enhancement | Alpine.js, Stimulus | Minimal JS that enhances HTML |
| Mobile-first app | React Native, Ionic (Angular/React) | Cross-platform capabilities |
| Micro-frontends | React, Vue, Web Components | Isolation, independent deployment |
| Performance-critical app | Svelte, Solid.js, Preact | Minimal overhead, efficient updates |
| Rapid prototyping | Vue, Svelte | Quick setup, less boilerplate |

**4. Framework Integration and Migration**

**a) Incremental Adoption**

```javascript
// React in an existing application
// 1. Add React to a specific part of your app
import React from 'react';
import ReactDOM from 'react-dom';
import NewFeature from './NewFeature';

// Mount React component in existing DOM
document.addEventListener('DOMContentLoaded', () => {
  const container = document.getElementById('new-feature-container');
  if (container) {
    ReactDOM.render(<NewFeature />, container);
  }
});

// 2. Web Components approach (framework agnostic)
class VueCounter extends HTMLElement {
  connectedCallback() {
    const mountPoint = document.createElement('div');
    this.attachShadow({ mode: 'open' }).appendChild(mountPoint);
    
    const { createApp } = Vue;
    const app = createApp({
      data() {
        return { count: 0 };
      },
      template: `
        <button @click="count++">Count: {{ count }}</button>
      `
    });
    
    app.mount(mountPoint);
  }
}

customElements.define('vue-counter', VueCounter);

// Use in any framework or vanilla HTML
// <vue-counter></vue-counter>
```

**b) Migration Strategies**

```javascript
// Migrating from AngularJS to React (example strategy)

// 1. Use ngReact as a bridge
angular.module('myApp', ['react'])
  .directive('reactComponent', function(reactDirective) {
    return reactDirective(MyReactComponent);
  });

// 2. Strangler pattern - gradually replace parts of the app
function migrateModule(moduleName) {
  // 1. Identify the AngularJS module to replace
  const angularModule = document.querySelector(`[ng-controller="${moduleName}"]`);
  
  // 2. Create a React root next to it
  const reactRoot = document.createElement('div');
  reactRoot.id = `react-${moduleName}`;
  angularModule.parentNode.insertBefore(reactRoot, angularModule.nextSibling);
  
  // 3. Render React component
  ReactDOM.render(
    <ReactComponent />,
    document.getElementById(`react-${moduleName}`)
  );
  
  // 4. Once verified working, remove Angular component
  // angularModule.remove();
}
```

**5. Framework-Specific Best Practices**

**a) React Best Practices**

```jsx
// 1. Use functional components with hooks
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    async function fetchUser() {
      setLoading(true);
      try {
        const response = await fetch(`/api/users/${userId}`);
        const data = await response.json();
        setUser(data);
      } catch (error) {
        console.error('Failed to fetch user:', error);
      } finally {
        setLoading(false);
      }
    }
    
    fetchUser();
  }, [userId]);
  
  if (loading) return <Spinner />;
  if (!user) return <Error message="User not found" />;
  
  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}

// 2. Memoize expensive components
import { memo } from 'react';

const ExpensiveComponent = memo(function ExpensiveComponent({ data }) {
  // Complex rendering logic
  return <div>{/* Rendered content */}</div>;
});

// 3. Use context for global state
const ThemeContext = createContext('light');

function App() {
  const [theme, setTheme] = useState('light');
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <MainContent />
    </ThemeContext.Provider>
  );
}
```

**b) Angular Best Practices**

```typescript
// 1. Use OnPush change detection
@Component({
  selector: 'app-user-card',
  template: `<div>{{user.name}}</div>`,
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class UserCardComponent {
  @Input() user: User;
}

// 2. Lazy load modules
const routes: Routes = [
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)
  }
];

// 3. Use services for shared state
@Injectable({
  providedIn: 'root'
})
export class UserService {
  private userSubject = new BehaviorSubject<User | null>(null);
  user$ = this.userSubject.asObservable();
  
  updateUser(user: User) {
    this.userSubject.next(user);
  }
}
```

**c) Vue Best Practices**

```vue
<!-- 1. Use composition API for complex components -->
<script setup>
import { ref, onMounted, computed } from 'vue';

const props = defineProps(['userId']);
const user = ref(null);
const loading = ref(true);

const fullName = computed(() => {
  if (!user.value) return '';
  return `${user.value.firstName} ${user.value.lastName}`;
});

onMounted(async () => {
  try {
    const response = await fetch(`/api/users/${props.userId}`);
    user.value = await response.json();
  } catch (error) {
    console.error('Failed to fetch user:', error);
  } finally {
    loading.value = false;
  }
});
</script>

<!-- 2. Use Pinia for state management -->
<script>
// store/users.js
import { defineStore } from 'pinia';

export const useUserStore = defineStore('users', {
  state: () => ({
    users: [],
    loading: false
  }),
  actions: {
    async fetchUsers() {
      this.loading = true;
      try {
        const response = await fetch('/api/users');
        this.users = await response.json();
      } catch (error) {
        console.error('Failed to fetch users:', error);
      } finally {
        this.loading = false;
      }
    }
  }
});
</script>
```

**6. Future Trends in JavaScript Frameworks**

**a) Server Components**

```jsx
// React Server Components example
// Note: This is a simplified example of the concept

// ServerComponent.js - runs on the server
export default async function ServerComponent({ userId }) {
  // This code only runs on the server
  const userData = await fetch(`http://internal-api/users/${userId}`)
    .then(r => r.json());
  
  // The component is serialized and sent to the client
  return <div>Hello, {userData.name}!</div>;
}

// ClientComponent.js - runs in the browser
'use client';

import { useState } from 'react';

export default function ClientComponent() {
  const [count, setCount] = useState(0);
  
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
```

**b) Islands Architecture**

```javascript
// Islands architecture concept (using Astro as an example)
// ---
// Component islands in a sea of static HTML
// ---

// Page.astro
---
import StaticHeader from '../components/StaticHeader.astro';
import ReactCounter from '../components/ReactCounter.jsx';
import VueSearch from '../components/VueSearch.vue';
---

<html>
  <head>...</head>
  <body>
    <!-- Static content, no JavaScript -->
    <StaticHeader />
    
    <main>
      <p>This is static content...</p>
      
      <!-- Interactive React island -->
      <ReactCounter client:idle />
      
      <!-- Interactive Vue island -->
      <VueSearch client:visible />
      
      <p>More static content...</p>
    </main>
    
    <footer>...</footer>
  </body>
</html>
```

**c) Resumability**

```javascript
// Qwik's resumability concept (simplified example)

// Traditional hydration approach
function TraditionalApp() {
  // When the app loads in the browser, all components
  // need to be re-executed to rebuild the component tree
  const [count, setCount] = useState(0);
  
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}

// Resumable approach (Qwik-like)
function ResumableApp() {
  // State is serialized with the HTML
  // Event listeners are lazy-loaded only when needed
  const count = useSignal(0);
  
  // This function is lazy-loaded only when the button is clicked
  return (
    <button onClick$={() => count.value++}>
      Count: {count.value}
    </button>
  );
}
```

**Key Takeaways:**

1. React excels with its large ecosystem and flexible approach, making it suitable for a wide range of applications
2. Angular provides a comprehensive solution with built-in tools, ideal for large enterprise applications
3. Vue offers an incremental adoption path with a gentle learning curve, balancing simplicity and power
4. Svelte and Solid.js represent the compiler-focused approach, offering excellent performance with minimal runtime code
5. Choose frameworks based on project requirements, team expertise, performance needs, and long-term maintenance
6. Consider the ecosystem maturity, community support, and job market when making framework decisions
7. For large applications, evaluate the framework's state management, routing, and form handling capabilities
8. Newer frameworks often offer better performance but may lack the ecosystem and community support of established ones
9. Framework migration should be incremental, using strategies like the strangler pattern to reduce risk
10. Future trends include server components, islands architecture, and resumability, all aiming to improve performance and developer experience

## Advanced JavaScript Performance and Debugging

### Q88: Explain JavaScript memory management and garbage collection. How do you identify and fix memory leaks?
**Difficulty: Hard**

**Answer:**
Memory management in JavaScript is largely automatic through garbage collection, but understanding how it works is crucial for writing efficient applications and avoiding memory leaks, especially in long-running applications.

**1. JavaScript Memory Allocation**

JavaScript automatically allocates memory when objects are created and frees it when they're no longer needed.

**a) Memory Life Cycle**

```javascript
// 1. Memory Allocation
let user = {                // Memory is allocated for the object
  name: "John",           // Memory is allocated for the string
  age: 30                  // Memory is allocated for the number
};

// 2. Memory Use
console.log(user.name);    // Using the allocated memory
user.age = 31;             // Using and modifying the allocated memory

// 3. Memory Release (when no longer needed)
user = null;               // The object becomes eligible for garbage collection
```

**b) Types of JavaScript Memory**

```javascript
// Stack memory (primitive values)
let a = 10;          // Stored directly in the stack
let b = "hello";     // Primitive string stored in the stack
let c = true;        // Boolean stored in the stack

// Heap memory (reference values)
let obj = {};        // Object stored in the heap
let arr = [];        // Array stored in the heap
let func = () => {}; // Function stored in the heap
```

**2. Garbage Collection Algorithms**

**a) Reference Counting**

An early garbage collection algorithm that has limitations with circular references.

```javascript
// Reference counting example
function createCircularReference() {
  let obj1 = {};
  let obj2 = {};
  
  // Create circular reference
  obj1.ref = obj2;
  obj2.ref = obj1;
  
  return "Function completed";
}

// Call the function
createCircularReference();

// obj1 and obj2 reference each other, but are no longer accessible from code
// Reference counting GC would fail to clean this up (memory leak)
// Modern mark-and-sweep GC will clean this up correctly
```

**b) Mark and Sweep Algorithm**

The standard algorithm used in modern JavaScript engines.

```javascript
// Conceptual representation of mark and sweep
function markAndSweepConcept() {
  // 1. The GC identifies "roots" (global objects)
  let globalRoot = window; // In browser
  
  // 2. The GC "marks" all objects reachable from roots
  // (Simplified representation - this doesn't actually happen in code)
  function markReachable(obj) {
    if (obj.__marked) return; // Already marked
    obj.__marked = true;
    
    // Mark all references from this object
    for (let reference of getReferences(obj)) {
      markReachable(reference);
    }
  }
  
  // 3. The GC "sweeps" (removes) all objects that aren't marked
  // (Again, simplified representation)
  function sweep() {
    for (let obj of allAllocatedObjects) {
      if (!obj.__marked) {
        freeMemory(obj);
      } else {
        obj.__marked = false; // Reset for next cycle
      }
    }
  }
}
```

**c) Generational Collection**

An optimization used in modern JavaScript engines like V8.

```javascript
// Conceptual example of object aging
function generationalGCConcept() {
  // Objects are initially allocated in the "young generation" (nursery)
  let newObject = { data: "fresh" };
  
  // After surviving a few GC cycles, objects are moved to the "old generation"
  // (This happens automatically in the engine, not in actual code)
  
  // Old generation is collected less frequently
  // This improves performance since most objects die young
}
```

**3. Common Causes of Memory Leaks**

**a) Accidental Global Variables**

```javascript
function leakyFunction() {
  // Missing 'let', 'const', or 'var' creates a global variable
  leakyVariable = "I'm leaking memory";
  
  // This is equivalent to:
  window.leakyVariable = "I'm leaking memory";
}

leakyFunction();
// leakyVariable continues to exist even after function execution

// Fix: Always declare variables with let, const, or var
function fixedFunction() {
  const safeVariable = "I'm properly scoped";
}
```

**b) Forgotten Timers and Callbacks**

```javascript
function setupLeakyTimer() {
  const largeData = new Array(10000000).fill('x');
  
  // Timer reference keeps largeData in memory
  setInterval(() => {
    // Do something with largeData
    console.log(largeData.length);
  }, 5000);
}

setupLeakyTimer();
// largeData is never garbage collected as long as the interval is active

// Fix: Store and clear the timer
function setupFixedTimer() {
  const largeData = new Array(10000000).fill('x');
  
  const timerId = setInterval(() => {
    console.log(largeData.length);
  }, 5000);
  
  // Later, when no longer needed:
  // clearInterval(timerId);
  
  return timerId; // Return so it can be cleared externally
}
```

**c) Closures**

```javascript
function createLeak() {
  const largeData = new Array(10000000).fill('x');
  
  return function() {
    // This inner function forms a closure over largeData
    console.log(largeData[0]);
  };
}

const leakyFunction = createLeak();
// largeData remains in memory as long as leakyFunction exists

// Fix: Be mindful of what your closures capture
function createEfficient() {
  const largeData = new Array(10000000).fill('x');
  const firstItem = largeData[0]; // Extract only what's needed
  
  return function() {
    // This closure only captures firstItem, not the entire largeData
    console.log(firstItem);
  };
}
```

**d) Detached DOM Elements**

```javascript
let detachedNodes = [];

function createDetachedDOM() {
  const div = document.createElement('div');
  div.innerHTML = 'Large content with <strong>lots</strong> of nodes';
  
  // Store reference to the detached DOM node
  detachedNodes.push(div);
  
  // The div is not attached to the document
  // but it's still referenced in the detachedNodes array
}

// Fix: Remove references when no longer needed
function cleanup() {
  detachedNodes = [];
}
```

**e) Event Listeners**

```javascript
function addLeakyEventListener() {
  const button = document.getElementById('button');
  const largeData = new Array(10000000).fill('x');
  
  button.addEventListener('click', function() {
    // This handler forms a closure over largeData
    console.log(largeData.length);
  });
  
  // If button is removed from DOM, the event listener still exists
  // and prevents largeData from being garbage collected
}

// Fix: Remove event listeners when no longer needed
function addCleanEventListener() {
  const button = document.getElementById('button');
  const largeData = new Array(10000000).fill('x');
  
  const handler = function() {
    console.log(largeData.length);
  };
  
  button.addEventListener('click', handler);
  
  // Store a function to clean up
  return function cleanup() {
    button.removeEventListener('click', handler);
  };
}
```

**4. Identifying Memory Leaks**

**a) Chrome DevTools Memory Profiler**

```javascript
// Example workflow for using Chrome DevTools to find memory leaks

// 1. Create a function that might leak memory
function potentialLeak() {
  const data = [];
  for (let i = 0; i < 10000; i++) {
    data.push(new Array(10000).fill('x'));
  }
  
  // Store in global scope (leaky)
  window.leakyData = data;
}

// 2. In DevTools:
// - Open Performance tab
// - Start recording
// - Call potentialLeak()
// - Force garbage collection
// - Stop recording
// - Analyze memory usage graph

// 3. In DevTools Memory tab:
// - Take heap snapshot
// - Perform actions
// - Take another snapshot
// - Compare snapshots to find retained objects
```

**b) Heap Snapshots Analysis**

```javascript
// Example of analyzing heap snapshots

// 1. Create a scenario with potential memory issues
let store = [];

function addObjects() {
  for (let i = 0; i < 1000; i++) {
    store.push({
      id: i,
      name: `Item ${i}`,
      data: new Array(10000).fill('x')
    });
  }
}

function removeObjects() {
  // Incorrectly clearing the array
  // This doesn't actually remove all references
  store.length = 0;
}

// 2. In DevTools:
// - Take heap snapshot
// - Call addObjects()
// - Take second snapshot
// - Call removeObjects()
// - Take third snapshot
// - Compare snapshots to identify retained memory
```

**c) Memory Allocation Timeline**

```javascript
// Example of using the allocation timeline

function allocateInLoop() {
  const temporaryArrays = [];
  
  for (let i = 0; i < 100; i++) {
    // Allocate a large array each iteration
    const arr = new Array(1000000).fill('x');
    temporaryArrays.push(arr);
    
    // Do some work with the array
    console.log(arr.length);
    
    // In a real app, we might forget to clean up here
  }
  
  // In DevTools:
  // - Record allocation timeline
  // - Look for growing blue bars (allocations)
  // - Identify objects that aren't being collected
}
```

**5. Fixing Memory Leaks**

**a) Nullifying References**

```javascript
function processLargeData() {
  // Allocate a large array
  const largeData = new Array(10000000).fill('x');
  
  // Process the data
  const result = doSomethingWith(largeData);
  
  // Explicitly nullify the reference when done
  // This helps the GC identify it as eligible for collection sooner
  largeData = null;
  
  return result;
}
```

**b) Using WeakMap and WeakSet**

```javascript
// Using WeakMap to avoid memory leaks

// Problem: Using Map keeps references to key objects
function usingRegularMap() {
  const cache = new Map();
  
  function addToCache(obj, value) {
    cache.set(obj, value);
  }
  
  const user = { id: 123 };
  addToCache(user, 'user data');
  
  // Even if user is no longer referenced elsewhere,
  // the Map keeps a strong reference to it
}

// Solution: WeakMap doesn't prevent garbage collection of keys
function usingWeakMap() {
  const cache = new WeakMap();
  
  function addToCache(obj, value) {
    cache.set(obj, value);
  }
  
  let user = { id: 123 };
  addToCache(user, 'user data');
  
  // If user is no longer referenced elsewhere:
  user = null;
  // The object {id: 123} can be garbage collected
  // and will automatically be removed from the WeakMap
}
```

**c) Proper Event Listener Management**

```javascript
// Component-based cleanup pattern
class Component {
  constructor(element) {
    this.element = element;
    this.listeners = [];
    this.init();
  }
  
  init() {
    // Store references to event handlers
    this.onClick = this.handleClick.bind(this);
    this.onScroll = this.handleScroll.bind(this);
    
    // Add event listeners
    this.element.addEventListener('click', this.onClick);
    window.addEventListener('scroll', this.onScroll);
    
    // Track listeners for cleanup
    this.listeners.push({
      target: this.element,
      type: 'click',
      handler: this.onClick
    });
    this.listeners.push({
      target: window,
      type: 'scroll',
      handler: this.onScroll
    });
  }
  
  handleClick() {
    console.log('Clicked');
  }
  
  handleScroll() {
    console.log('Scrolled');
  }
  
  destroy() {
    // Clean up all event listeners
    this.listeners.forEach(({ target, type, handler }) => {
      target.removeEventListener(type, handler);
    });
    this.listeners = [];
    this.element = null;
  }
}

// Usage
const component = new Component(document.getElementById('my-element'));

// Later, when no longer needed
component.destroy();
```

**d) Avoiding Circular References**

```javascript
// Problematic circular reference
function createCircularStructure() {
  const parent = {
    name: 'parent'
  };
  
  const child = {
    name: 'child',
    parent: parent // Reference to parent
  };
  
  parent.child = child; // Circular reference
  
  return { parent, child };
}

// Better approach: Use weak references or avoid direct circular references
function createBetterStructure() {
  const parent = {
    name: 'parent',
    childId: 'child1' // Reference by ID instead of direct object reference
  };
  
  const child = {
    id: 'child1',
    name: 'child',
    parentId: 'parent1' // Reference by ID
  };
  
  // Store in a manager that handles relationships
  const relationshipManager = {
    objects: {
      'parent1': parent,
      'child1': child
    },
    getParentOf(childId) {
      const child = this.objects[childId];
      return child ? this.objects[child.parentId] : null;
    },
    getChildOf(parentId) {
      const parent = this.objects[parentId];
      return parent ? this.objects[parent.childId] : null;
    }
  };
  
  return relationshipManager;
}
```

**6. Memory Management Best Practices**

**a) Object Pooling for Frequent Allocations**

```javascript
// Object pooling for performance-critical code
class ObjectPool {
  constructor(createFn, initialSize = 10) {
    this.createFn = createFn;
    this.pool = [];
    
    // Pre-fill the pool
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.createFn());
    }
  }
  
  get() {
    // Reuse an existing object or create a new one
    return this.pool.pop() || this.createFn();
  }
  
  release(obj) {
    // Reset the object if needed
    if (obj.reset) obj.reset();
    
    // Return to the pool
    this.pool.push(obj);
  }
}

// Usage example for a game with many particles
const particlePool = new ObjectPool(() => {
  return {
    x: 0,
    y: 0,
    velocity: { x: 0, y: 0 },
    active: false,
    reset() {
      this.x = 0;
      this.y = 0;
      this.velocity.x = 0;
      this.velocity.y = 0;
      this.active = false;
    }
  };
}, 1000);

function createParticleEffect() {
  const particles = [];
  
  // Get particles from the pool instead of creating new ones
  for (let i = 0; i < 100; i++) {
    const particle = particlePool.get();
    particle.x = Math.random() * 100;
    particle.y = Math.random() * 100;
    particle.active = true;
    particles.push(particle);
  }
  
  // Later, return particles to the pool
  particles.forEach(particle => {
    particlePool.release(particle);
  });
}
```

**b) Limiting Closure Scope**

```javascript
// Bad: Capturing unnecessary variables in closure
function createBadClosure() {
  const a = 1;
  const b = 2;
  const largeArray = new Array(10000).fill('x');
  
  return function() {
    // This only uses 'a' but captures all variables in scope
    return a;
  };
}

// Good: Only capture what you need
function createGoodClosure() {
  const a = 1;
  const b = 2;
  const largeArray = new Array(10000).fill('x');
  
  // Only capture 'a'
  const valueToCapture = a;
  
  return function() {
    return valueToCapture;
  };
}
```

**c) Using Generators for Large Data Processing**

```javascript
// Processing large datasets without loading everything into memory
function* chunkProcessor(data, chunkSize) {
  let index = 0;
  
  while (index < data.length) {
    // Process only a chunk at a time
    const chunk = data.slice(index, index + chunkSize);
    yield processChunk(chunk);
    index += chunkSize;
  }
}

function processChunk(chunk) {
  // Process the chunk
  return chunk.map(item => item * 2);
}

// Usage
async function processLargeArray() {
  const largeArray = new Array(1000000).fill(1);
  const results = [];
  
  // Process in chunks of 1000 items
  for (const result of chunkProcessor(largeArray, 1000)) {
    results.push(...result);
    
    // Allow GC to run between chunks
    await new Promise(resolve => setTimeout(resolve, 0));
  }
  
  return results;
}
```

**d) Monitoring Memory Usage**

```javascript
// Using Performance API to monitor memory
function monitorMemory() {
  if (performance.memory) {
    console.log('Total JS heap size:', performance.memory.totalJSHeapSize);
    console.log('Used JS heap size:', performance.memory.usedJSHeapSize);
    console.log('JS heap size limit:', performance.memory.jsHeapSizeLimit);
  }
}

// Set up periodic monitoring
function startMemoryMonitoring(interval = 5000) {
  const memoryUsage = [];
  
  const timerId = setInterval(() => {
    if (performance.memory) {
      memoryUsage.push({
        timestamp: Date.now(),
        used: performance.memory.usedJSHeapSize,
        total: performance.memory.totalJSHeapSize
      });
      
      // Check for potential memory leaks
      const lastFiveReadings = memoryUsage.slice(-5);
      if (lastFiveReadings.length === 5) {
        const allIncreasing = lastFiveReadings.every((reading, i) => {
          return i === 0 || reading.used > lastFiveReadings[i - 1].used;
        });
        
        if (allIncreasing) {
          console.warn('Potential memory leak detected: memory usage consistently increasing');
        }
      }
    }
  }, interval);
  
  return () => clearInterval(timerId); // Return cleanup function
}
```

**Key Takeaways:**

1. JavaScript uses automatic garbage collection, primarily with the mark-and-sweep algorithm
2. Common memory leaks include accidental globals, forgotten timers, closures capturing large objects, and detached DOM elements
3. Chrome DevTools provides powerful memory profiling tools including heap snapshots and allocation timelines
4. WeakMap and WeakSet are useful for caching or storing object references without preventing garbage collection
5. Always remove event listeners when components are destroyed to prevent memory leaks
6. Avoid circular references or use weak references when object relationships are complex
7. Object pooling can improve performance by reducing garbage collection pauses in performance-critical applications
8. Be mindful of closure scope and only capture the variables you need
9. Use generators and chunking to process large datasets without loading everything into memory at once
10. Regularly monitor memory usage to detect leaks early in development

### Q89: Explain JavaScript error handling and debugging strategies. How do you implement robust error handling in production applications?
**Difficulty: Medium**

**Answer:**
Effective error handling and debugging are essential skills for JavaScript developers. A robust error handling strategy improves application reliability, user experience, and makes maintenance easier.

**1. Types of JavaScript Errors**

**a) Built-in Error Types**

```javascript
// SyntaxError: Invalid syntax
try {
  eval('if (true) { console.log("Missing closing brace"');  // Missing closing brace
} catch (error) {
  console.log(error.name);  // SyntaxError
  console.log(error.message);  // Unexpected end of input
}

// ReferenceError: Accessing undefined variables
try {
  console.log(undefinedVariable);
} catch (error) {
  console.log(error.name);  // ReferenceError
  console.log(error.message);  // undefinedVariable is not defined
}

// TypeError: Performing invalid operations
try {
  const num = 123;
  num.toUpperCase();  // Numbers don't have toUpperCase method
} catch (error) {
  console.log(error.name);  // TypeError
  console.log(error.message);  // num.toUpperCase is not a function
}

// RangeError: Value outside allowed range
try {
  const arr = new Array(-1);  // Negative array length
} catch (error) {
  console.log(error.name);  // RangeError
  console.log(error.message);  // Invalid array length
}

// URIError: Invalid URI handling
try {
  decodeURIComponent('%');  // Invalid URI sequence
} catch (error) {
  console.log(error.name);  // URIError
  console.log(error.message);  // URI malformed
}

// EvalError: Error in eval() function (rare in modern JS)
try {
  throw new EvalError('Eval error example');
} catch (error) {
  console.log(error.name);  // EvalError
}
```

**b) Custom Error Types**

```javascript
// Creating custom error types
class ValidationError extends Error {
  constructor(message, field) {
    super(message);
    this.name = 'ValidationError';
    this.field = field;
    
    // Maintain proper stack trace (if supported)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ValidationError);
    }
  }
}

class DatabaseError extends Error {
  constructor(message, query) {
    super(message);
    this.name = 'DatabaseError';
    this.query = query;
    
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, DatabaseError);
    }
  }
}

// Using custom errors
function validateUser(user) {
  if (!user.email) {
    throw new ValidationError('Email is required', 'email');
  }
  
  if (!user.password || user.password.length < 8) {
    throw new ValidationError('Password must be at least 8 characters', 'password');
  }
}

try {
  validateUser({ name: 'John' });
} catch (error) {
  if (error instanceof ValidationError) {
    console.log(`Validation failed for field: ${error.field}`);
    console.log(`Message: ${error.message}`);
  } else {
    console.log('Unknown error:', error);
  }
}
```

**2. Basic Error Handling Techniques**

**a) try-catch-finally**

```javascript
try {
  // Code that might throw an error
  const data = JSON.parse(invalidJson);
  console.log(data);
} catch (error) {
  // Handle the error
  console.error('Failed to parse JSON:', error.message);
} finally {
  // Always executed, regardless of whether an error occurred
  console.log('Cleanup operations');
}
```

**b) Error Bubbling**

```javascript
function parseUserData(jsonString) {
  // This function doesn't handle errors, they bubble up
  const data = JSON.parse(jsonString);
  return data;
}

function processUserData(jsonString) {
  try {
    // If parseUserData throws, the error will bubble up to this try-catch
    const userData = parseUserData(jsonString);
    return userData.name.toUpperCase();
  } catch (error) {
    console.error('Error processing user data:', error.message);
    return null;
  }
}

const result = processUserData('{invalid json}');
```

**c) Conditional Error Handling**

```javascript
function divide(a, b) {
  // Check for potential errors before they happen
  if (typeof a !== 'number' || typeof b !== 'number') {
    throw new TypeError('Both arguments must be numbers');
  }
  
  if (b === 0) {
    throw new Error('Division by zero is not allowed');
  }
  
  return a / b;
}

try {
  console.log(divide(10, 0));
} catch (error) {
  console.error(`Error: ${error.message}`);
}
```

**3. Asynchronous Error Handling**

**a) Promises**

```javascript
// Using Promise catch method
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => {
    console.log('Data:', data);
  })
  .catch(error => {
    console.error('Fetch error:', error.message);
  })
  .finally(() => {
    console.log('Fetch operation completed');
  });

// Promise error handling with multiple catches
fetchUserData(userId)
  .then(userData => processUserData(userData))
  .catch(error => {
    if (error.name === 'NetworkError') {
      console.error('Network issue, retrying...');
      return fetchUserData(userId, { retry: true });
    }
    throw error; // Re-throw if it's not a NetworkError
  })
  .then(data => displayUserData(data))
  .catch(error => {
    console.error('Failed to fetch or process user data:', error);
    displayErrorMessage('Could not load user data');
  });
```

**b) Async/Await**

```javascript
async function fetchAndProcessUser(userId) {
  try {
    const response = await fetch(`https://api.example.com/users/${userId}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    const userData = await response.json();
    return processUserData(userData);
  } catch (error) {
    console.error('Error fetching or processing user:', error);
    throw error; // Re-throw to let caller handle it
  }
}

// Using the async function with try-catch
async function displayUserProfile(userId) {
  try {
    const processedData = await fetchAndProcessUser(userId);
    updateUI(processedData);
  } catch (error) {
    showErrorNotification(`Failed to load user profile: ${error.message}`);
  } finally {
    hideLoadingSpinner();
  }
}
```

**c) Event-based Error Handling**

```javascript
// Global error handling for uncaught promise rejections
window.addEventListener('unhandledrejection', event => {
  console.error('Unhandled promise rejection:', event.reason);
  // Prevent default handling (e.g., logging to console)
  event.preventDefault();
  
  // Log to monitoring service
  logErrorToMonitoringService({
    type: 'unhandledrejection',
    error: event.reason,
    message: event.reason.message || 'Unknown promise rejection'
  });
});

// Global error handling for uncaught exceptions
window.addEventListener('error', event => {
  console.error('Uncaught error:', event.error);
  
  // Log to monitoring service
  logErrorToMonitoringService({
    type: 'uncaughtexception',
    error: event.error,
    message: event.message,
    source: event.filename,
    lineno: event.lineno,
    colno: event.colno
  });
  
  // Prevent default handling
  event.preventDefault();
  
  // Show user-friendly error message
  showErrorDialog('Something went wrong. Our team has been notified.');
});
```

**4. Production Error Handling Strategies**

**a) Centralized Error Handling**

```javascript
// Error handling service
class ErrorHandler {
  constructor(options = {}) {
    this.options = {
      logToConsole: true,
      logToServer: true,
      notifyUser: true,
      ...options
    };
    
    this.setupGlobalHandlers();
  }
  
  setupGlobalHandlers() {
    // Handle uncaught exceptions
    window.addEventListener('error', event => {
      this.handleError({
        type: 'uncaughtException',
        error: event.error,
        source: event.filename,
        line: event.lineno,
        column: event.colno
      });
      
      // Prevent default if configured
      if (this.options.preventDefaultHandling) {
        event.preventDefault();
      }
    });
    
    // Handle unhandled promise rejections
    window.addEventListener('unhandledrejection', event => {
      this.handleError({
        type: 'unhandledRejection',
        error: event.reason,
        promise: event.promise
      });
      
      if (this.options.preventDefaultHandling) {
        event.preventDefault();
      }
    });
  }
  
  handleError(errorInfo) {
    // Extract error details
    const { error, type } = errorInfo;
    const errorDetails = {
      message: error?.message || 'Unknown error',
      stack: error?.stack,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      ...errorInfo
    };
    
    // Log to console if enabled
    if (this.options.logToConsole) {
      console.error(`[${type}]`, error || errorDetails.message);
    }
    
    // Log to server if enabled
    if (this.options.logToServer) {
      this.sendErrorToServer(errorDetails);
    }
    
    // Notify user if enabled
    if (this.options.notifyUser) {
      this.notifyUser(errorDetails);
    }
    
    return errorDetails;
  }
  
  async sendErrorToServer(errorDetails) {
    try {
      const response = await fetch('/api/log-error', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(errorDetails),
        // Use keepalive to ensure the request completes even if page is unloading
        keepalive: true
      });
      
      if (!response.ok) {
        console.error('Failed to send error to server:', response.status);
      }
    } catch (sendError) {
      // Don't throw from error handler
      console.error('Error sending error report:', sendError);
    }
  }
  
  notifyUser(errorDetails) {
    // Implement user notification (toast, modal, etc.)
    const userMessage = this.getUserFriendlyMessage(errorDetails);
    
    // Example implementation with a toast notification
    showToast({
      type: 'error',
      message: userMessage,
      duration: 5000
    });
  }
  
  getUserFriendlyMessage(errorDetails) {
    // Map technical errors to user-friendly messages
    const errorTypeMessages = {
      NetworkError: 'Unable to connect to the server. Please check your internet connection.',
      ValidationError: 'Some information is invalid. Please check your inputs.',
      AuthenticationError: 'Your session has expired. Please log in again.',
      default: 'Something went wrong. Please try again later.'
    };
    
    // Return appropriate message based on error type
    const errorName = errorDetails.error?.name || 'default';
    return errorTypeMessages[errorName] || errorTypeMessages.default;
  }
}

// Initialize the error handler
const errorHandler = new ErrorHandler({
  logToConsole: true,
  logToServer: true,
  notifyUser: true,
  preventDefaultHandling: false
});

// Use it in your application
try {
  riskyOperation();
} catch (error) {
  errorHandler.handleError({ type: 'caught', error });
}
```

**b) Error Boundaries (React Example)**

```jsx
// ErrorBoundary.jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render will show the fallback UI
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // Log the error to an error reporting service
    logErrorToService(error, errorInfo);
    this.setState({ errorInfo });
  }

  render() {
    if (this.state.hasError) {
      // Render fallback UI
      return this.props.fallback ? (
        this.props.fallback(this.state.error, this.state.errorInfo)
      ) : (
        <div className="error-boundary">
          <h2>Something went wrong.</h2>
          <details>
            <summary>Error Details</summary>
            <p>{this.state.error && this.state.error.toString()}</p>
            <p>Component Stack:</p>
            <pre>{this.state.errorInfo && this.state.errorInfo.componentStack}</pre>
          </details>
          <button onClick={() => window.location.reload()}>Reload Page</button>
        </div>
      );
    }

    // If no error, render children normally
    return this.props.children;
  }
}

// Usage
function App() {
  return (
    <div className="app">
      <ErrorBoundary>
        <Header />
      </ErrorBoundary>
      
      <ErrorBoundary>
        <MainContent />
      </ErrorBoundary>
      
      <ErrorBoundary>
        <Footer />
      </ErrorBoundary>
    </div>
  );
}
```

**c) Retry Mechanisms**

```javascript
// Retry utility for async operations
async function retryOperation(operation, { retries = 3, delay = 1000, backoff = 2 } = {}) {
  let lastError;
  
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      // Attempt the operation
      return await operation();
    } catch (error) {
      // Store the error for potential re-throw
      lastError = error;
      
      // If it's the last attempt, don't wait
      if (attempt === retries) break;
      
      // Log the retry
      console.log(`Operation failed, retrying (${attempt + 1}/${retries})...`, error);
      
      // Wait before retrying with exponential backoff
      await new Promise(resolve => setTimeout(resolve, delay * Math.pow(backoff, attempt)));
    }
  }
  
  // If we get here, all retries failed
  throw new Error(`Operation failed after ${retries} retries: ${lastError.message}`);
}

// Usage example
async function fetchUserData(userId) {
  return retryOperation(
    async () => {
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
      return response.json();
    },
    { retries: 3, delay: 1000, backoff: 2 }
  );
}

// Using the retry mechanism
try {
  const userData = await fetchUserData(123);
  console.log('User data:', userData);
} catch (error) {
  console.error('Failed to fetch user data after retries:', error);
  showErrorMessage('Could not load user data. Please try again later.');
}
```

**d) Circuit Breaker Pattern**

```javascript
// Circuit breaker implementation
class CircuitBreaker {
  constructor(operation, options = {}) {
    this.operation = operation;
    
    // Configuration with defaults
    this.options = {
      failureThreshold: 5,     // Number of failures before opening circuit
      resetTimeout: 30000,     // Time in ms before attempting reset (30 seconds)
      monitorTimeout: 10000,   // Time in ms for monitoring window (10 seconds)
      ...options
    };
    
    // Circuit state
    this.state = 'CLOSED';     // CLOSED, OPEN, HALF_OPEN
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.lastAttemptTime = null;
    
    // Bind methods
    this.execute = this.execute.bind(this);
    this.recordSuccess = this.recordSuccess.bind(this);
    this.recordFailure = this.recordFailure.bind(this);
    this.reset = this.reset.bind(this);
  }
  
  async execute(...args) {
    this.lastAttemptTime = Date.now();
    
    // Check circuit state
    if (this.state === 'OPEN') {
      // Check if reset timeout has elapsed
      if (Date.now() - this.lastFailureTime > this.options.resetTimeout) {
        this.state = 'HALF_OPEN';
        console.log('Circuit breaker state: HALF_OPEN');
      } else {
        throw new Error('Circuit is OPEN - operation rejected');
      }
    }
    
    try {
      // Execute the operation
      const result = await this.operation(...args);
      this.recordSuccess();
      return result;
    } catch (error) {
      this.recordFailure();
      throw error;
    }
  }
  
  recordSuccess() {
    if (this.state === 'HALF_OPEN') {
      this.reset();
    }
  }
  
  recordFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    // Check if we should open the circuit
    if (this.state === 'CLOSED' && this.failureCount >= this.options.failureThreshold) {
      this.state = 'OPEN';
      console.log('Circuit breaker state: OPEN');
    } else if (this.state === 'HALF_OPEN') {
      this.state = 'OPEN';
      console.log('Circuit breaker state: OPEN (from HALF_OPEN)');
    }
    
    // Reset failure count if outside monitoring window
    if (Date.now() - this.lastAttemptTime > this.options.monitorTimeout) {
      this.failureCount = 1; // Current failure
    }
  }
  
  reset() {
    this.failureCount = 0;
    this.state = 'CLOSED';
    console.log('Circuit breaker state: CLOSED');
  }
}

// Usage example
const apiCircuitBreaker = new CircuitBreaker(
  async (endpoint) => {
    const response = await fetch(`https://api.example.com/${endpoint}`);
    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
    return response.json();
  },
  { failureThreshold: 3, resetTimeout: 10000 }
);

async function fetchData(endpoint) {
  try {
    return await apiCircuitBreaker.execute(endpoint);
  } catch (error) {
    if (error.message.includes('Circuit is OPEN')) {
      console.log('Service is currently unavailable. Please try again later.');
      return null;
    }
    throw error;
  }
}
```

**5. Debugging Techniques**

**a) Console Methods**

```javascript
// Basic console methods
console.log('Regular log message');
console.info('Informational message');
console.warn('Warning message');
console.error('Error message');

// Grouping related logs
console.group('User Authentication');
console.log('Checking credentials...');
console.log('Validating permissions...');
console.groupEnd();

// Timing operations
console.time('dataFetch');
fetchData().then(() => {
  console.timeEnd('dataFetch'); // Outputs: dataFetch: 1234.56ms
});

// Tabular data
console.table([
  { name: 'John', age: 30, role: 'Developer' },
  { name: 'Jane', age: 28, role: 'Designer' },
  { name: 'Bob', age: 35, role: 'Manager' }
]);

// Conditional logging with console.assert
function validateUser(user) {
  console.assert(user.name, 'User name is required');
  console.assert(user.age >= 18, 'User must be at least 18 years old');
}

// Stack traces
function getStackTrace() {
  console.trace('Trace at this point');
}

function a() { b(); }
function b() { c(); }
function c() { getStackTrace(); }
a(); // Shows call stack: a -> b -> c -> getStackTrace
```

**b) Debugger Statement**

```javascript
function complexCalculation(data) {
  let result = 0;
  
  for (let i = 0; i < data.length; i++) {
    if (data[i] < 0) {
      debugger; // Execution will pause here when DevTools is open
      // Inspect variables, call stack, etc.
    }
    result += processItem(data[i]);
  }
  
  return result;
}
```

**c) Source Maps**

```javascript
// webpack.config.js example for source maps
module.exports = {
  mode: 'development',
  devtool: 'source-map', // Generates separate source map files
  // or 'eval-source-map' for development (inline source maps)
  // other webpack configuration...
};

// .babelrc example for source maps
{
  "presets": ["@babel/preset-env"],
  "sourceMaps": true
}
```

**6. Monitoring and Logging**

**a) Structured Logging**

```javascript
// Structured logging utility
class Logger {
  constructor(options = {}) {
    this.options = {
      level: 'info', // debug, info, warn, error
      includeTimestamp: true,
      service: 'frontend',
      ...options
    };
    
    this.levels = {
      debug: 0,
      info: 1,
      warn: 2,
      error: 3
    };
  }
  
  shouldLog(level) {
    return this.levels[level] >= this.levels[this.options.level];
  }
  
  createLogEntry(level, message, context = {}) {
    const logEntry = {
      level,
      message,
      service: this.options.service,
      ...context
    };
    
    if (this.options.includeTimestamp) {
      logEntry.timestamp = new Date().toISOString();
    }
    
    return logEntry;
  }
  
  log(level, message, context = {}) {
    if (!this.shouldLog(level)) return;
    
    const logEntry = this.createLogEntry(level, message, context);
    
    // Console output
    const consoleMethod = console[level] || console.log;
    consoleMethod(JSON.stringify(logEntry));
    
    // In a real app, you might send logs to a server
    if (level === 'error' || level === 'warn') {
      this.sendToLogServer(logEntry);
    }
    
    return logEntry;
  }
  
  debug(message, context) {
    return this.log('debug', message, context);
  }
  
  info(message, context) {
    return this.log('info', message, context);
  }
  
  warn(message, context) {
    return this.log('warn', message, context);
  }
  
  error(message, context) {
    // For errors, automatically capture stack trace if not provided
    if (context.error && !context.stack) {
      context.stack = context.error.stack;
    }
    return this.log('error', message, context);
  }
  
  sendToLogServer(logEntry) {
    // Implementation to send logs to a server
    // This could use fetch, Beacon API, or a logging service SDK
    fetch('/api/logs', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(logEntry),
      // Use keepalive to ensure the request completes even if page is unloading
      keepalive: true
    }).catch(err => {
      console.error('Failed to send log to server:', err);
    });
  }
}

// Usage
const logger = new Logger({
  level: process.env.NODE_ENV === 'production' ? 'warn' : 'debug',
  service: 'user-dashboard'
});

function processUserData(userData) {
  logger.debug('Processing user data', { userId: userData.id });
  
  try {
    // Process data
    const result = transformUserData(userData);
    logger.info('User data processed successfully', { userId: userData.id });
    return result;
  } catch (error) {
    logger.error('Failed to process user data', {
      userId: userData.id,
      error,
      operation: 'processUserData'
    });
    throw error;
  }
}
```

**b) Error Tracking Services**

```javascript
// Example with a fictional error tracking service
class ErrorTracker {
  constructor(options = {}) {
    this.options = {
      dsn: options.dsn || null,
      environment: options.environment || 'development',
      release: options.release || '1.0.0',
      sampleRate: options.sampleRate || 1.0, // 1.0 = 100% of errors
      maxBreadcrumbs: options.maxBreadcrumbs || 100
    };
    
    this.breadcrumbs = [];
    
    if (!this.options.dsn) {
      console.warn('ErrorTracker initialized without DSN. No errors will be reported.');
      return;
    }
    
    this.setupGlobalHandlers();
  }
  
  setupGlobalHandlers() {
    // Capture unhandled errors
    window.addEventListener('error', event => {
      this.captureException(event.error || new Error(event.message), {
        source: event.filename,
        lineno: event.lineno,
        colno: event.colno
      });
    });
    
    // Capture unhandled promise rejections
    window.addEventListener('unhandledrejection', event => {
      this.captureException(event.reason || new Error('Unhandled Promise rejection'));
    });
    
    // Override console.error to capture errors
    const originalConsoleError = console.error;
    console.error = (...args) => {
      this.addBreadcrumb({
        category: 'console',
        level: 'error',
        message: args.map(arg => String(arg)).join(' ')
      });
      originalConsoleError.apply(console, args);
    };
  }
  
  addBreadcrumb(breadcrumb) {
    const finalBreadcrumb = {
      timestamp: new Date().toISOString(),
      ...breadcrumb
    };
    
    this.breadcrumbs.push(finalBreadcrumb);
    
    // Maintain max breadcrumbs limit
    if (this.breadcrumbs.length > this.options.maxBreadcrumbs) {
      this.breadcrumbs.shift();
    }
  }
  
  captureException(error, extras = {}) {
    // Check sampling rate
    if (Math.random() > this.options.sampleRate) {
      return;
    }
    
    const errorReport = {
      exception: {
        type: error.name,
        value: error.message,
        stacktrace: this.parseStackTrace(error)
      },
      breadcrumbs: this.breadcrumbs,
      tags: {
        environment: this.options.environment,
        release: this.options.release
      },
      user: this.getUserContext(),
      extra: extras,
      timestamp: new Date().toISOString()
    };
    
    this.sendErrorReport(errorReport);
  }
  
  parseStackTrace(error) {
    if (!error.stack) return [];
    
    // Simple stack parser - in a real implementation this would be more robust
    return error.stack
      .split('\n')
      .slice(1) // Remove the error message line
      .map(line => {
        const match = line.match(/^\s*at\s+(.+?)\s+\((.+?):(\d+):(\d+)\)$/);
        if (!match) return { raw: line };
        
        return {
          function: match[1],
          filename: match[2],
          lineno: parseInt(match[3], 10),
          colno: parseInt(match[4], 10)
        };
      });
  }
  
  getUserContext() {
    // In a real app, you'd get actual user info
    return {
      id: localStorage.getItem('userId'),
      username: localStorage.getItem('username'),
      email: localStorage.getItem('userEmail')
    };
  }
  
  sendErrorReport(errorReport) {
    fetch(this.options.dsn, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(errorReport),
      keepalive: true
    }).catch(err => {
      console.error('Failed to send error report:', err);
    });
  }
  
  // Public API
  setUser(user) {
    this.user = user;
  }
  
  setTag(key, value) {
    this.tags = this.tags || {};
    this.tags[key] = value;
  }
  
  setExtra(key, value) {
    this.extras = this.extras || {};
    this.extras[key] = value;
  }
}

// Initialize the error tracker
const errorTracker = new ErrorTracker({
  dsn: 'https://api.errortracking.com/project123/errors',
  environment: process.env.NODE_ENV,
  release: 'v1.2.3'
});

// Usage
try {
  riskyOperation();
} catch (error) {
  errorTracker.captureException(error, {
    operation: 'riskyOperation',
    additionalContext: 'Some helpful context'
  });
}
```

**Key Takeaways:**

1. JavaScript provides built-in error types like SyntaxError, ReferenceError, and TypeError, but you can also create custom error types for domain-specific errors
2. The try-catch-finally pattern is the foundation of error handling in JavaScript, allowing you to gracefully handle exceptions
3. Asynchronous code requires special error handling approaches using Promise chains with .catch() or try-catch blocks with async/await
4. Global error handlers can catch uncaught exceptions and unhandled promise rejections, providing a safety net for your application
5. Centralized error handling improves consistency and makes maintenance easier by consolidating error processing logic
6. Error boundaries in React (and similar patterns in other frameworks) contain errors to specific components, preventing entire app crashes
7. Retry mechanisms and circuit breakers improve resilience by handling transient failures and preventing cascading failures
8. Structured logging with different severity levels helps with debugging and monitoring application health
9. Source maps are essential for debugging minified production code by mapping it back to the original source
10. Error tracking services provide insights into production errors, helping you prioritize fixes and improve application stability

## JavaScript Security and Best Practices

### Q90: Explain JavaScript security best practices. How do you protect web applications from common vulnerabilities?
**Difficulty: Medium-Hard**

**Answer:**
Security is a critical aspect of JavaScript development. As web applications become more complex and handle sensitive data, understanding and implementing security best practices is essential for protecting users and applications from various threats.

**1. Cross-Site Scripting (XSS) Prevention**

XSS attacks occur when attackers inject malicious scripts into web pages viewed by other users.

**a) Content Sanitization**

```javascript
// Unsafe approach - vulnerable to XSS
function displayUserComment(comment) {
  const commentDiv = document.getElementById('user-comment');
  commentDiv.innerHTML = comment; // Dangerous if comment contains malicious code
}

// Safe approach - sanitizing content
function displayUserCommentSafely(comment) {
  const commentDiv = document.getElementById('user-comment');
  
  // Option 1: Use textContent instead of innerHTML
  commentDiv.textContent = comment; // Automatically escapes HTML
  
  // Option 2: Use a library like DOMPurify
  // commentDiv.innerHTML = DOMPurify.sanitize(comment);
}

// Using a sanitization library (DOMPurify)
import DOMPurify from 'dompurify';

function renderUserGeneratedHTML(html) {
  const container = document.getElementById('content-container');
  // Sanitize HTML to remove potentially malicious code while preserving safe HTML
  container.innerHTML = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'ul', 'li'],
    ALLOWED_ATTR: ['href', 'target']
  });
}
```

**b) Context-Specific Output Encoding**

```javascript
// Helper functions for different contexts
const escapeHTML = (str) => {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
};

const escapeJavaScript = (str) => {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/'/g, '\\\'')
    .replace(/"/g, '\\"')
    .replace(/`/g, '\\`')
    .replace(/\//g, '\\/');
};

const escapeAttribute = (str) => {
  return str
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
};

// Usage in different contexts
function renderUserData(userData) {
  // HTML context
  document.getElementById('user-bio').textContent = userData.bio;
  
  // Attribute context
  document.getElementById('user-profile').setAttribute(
    'data-username', 
    escapeAttribute(userData.username)
  );
  
  // JavaScript context
  const userScript = document.createElement('script');
  userScript.textContent = `const userConfig = { name: "${escapeJavaScript(userData.name)}" };`;
  document.head.appendChild(userScript);
}
```

**c) Content Security Policy (CSP)**

```html
<!-- In your HTML file -->
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://trusted-cdn.com; style-src 'self' https://trusted-cdn.com; img-src 'self' https://trusted-images.com data:;">
```

```javascript
// Setting CSP headers in Express.js
const helmet = require('helmet');
const app = express();

app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: ["'self'", 'https://trusted-cdn.com'],
    styleSrc: ["'self'", 'https://trusted-cdn.com'],
    imgSrc: ["'self'", 'https://trusted-images.com', 'data:'],
    connectSrc: ["'self'", 'https://api.example.com'],
    fontSrc: ["'self'", 'https://trusted-fonts.com'],
    objectSrc: ["'none'"],
    mediaSrc: ["'self'"],
    frameSrc: ["'none'"],
    reportUri: '/csp-violation-report'
  }
}));

// Handling CSP violation reports
app.post('/csp-violation-report', (req, res) => {
  console.log('CSP Violation:', req.body);
  // Log to monitoring service
  res.status(204).end();
});
```

**2. Cross-Site Request Forgery (CSRF) Protection**

CSRF attacks trick users into performing unwanted actions on a site they're authenticated to.

**a) Anti-CSRF Tokens**

```javascript
// Server-side (Node.js/Express example)
const express = require('express');
const csrf = require('csurf');
const cookieParser = require('cookie-parser');

const app = express();
app.use(cookieParser());

// Setup CSRF protection
const csrfProtection = csrf({ cookie: true });

// Apply to routes that need protection
app.get('/form', csrfProtection, (req, res) => {
  // Pass the token to the view
  res.render('form', { csrfToken: req.csrfToken() });
});

app.post('/process-form', csrfProtection, (req, res) => {
  // The CSRF token is automatically validated
  // If invalid, it throws an error
  // Process the form...
  res.send('Form processed successfully');
});

// Error handler for CSRF errors
app.use((err, req, res, next) => {
  if (err.code === 'EBADCSRFTOKEN') {
    // Handle CSRF token errors
    res.status(403).send('Form tampered with');
  } else {
    next(err);
  }
});
```

```html
<!-- In your form -->
<form action="/process-form" method="POST">
  <input type="hidden" name="_csrf" value="{{csrfToken}}">
  <!-- other form fields -->
  <button type="submit">Submit</button>
</form>
```

**b) SameSite Cookies**

```javascript
// Setting a cookie with SameSite attribute
document.cookie = 'sessionId=abc123; SameSite=Strict; Secure; HttpOnly';

// In Express.js
app.use(session({
  secret: 'your-secret-key',
  cookie: {
    httpOnly: true,
    secure: true, // Requires HTTPS
    sameSite: 'strict'
  }
}));
```

**3. Secure Authentication and Authorization**

**a) Password Handling**

```javascript
// Server-side password handling (Node.js example)
const bcrypt = require('bcrypt');

async function registerUser(email, password) {
  try {
    // Validate password strength
    if (!isStrongPassword(password)) {
      throw new Error('Password does not meet security requirements');
    }
    
    // Hash the password (never store plaintext passwords)
    const saltRounds = 12;
    const hashedPassword = await bcrypt.hash(password, saltRounds);
    
    // Store user in database with hashed password
    await db.users.insert({
      email,
      password: hashedPassword,
      createdAt: new Date()
    });
    
    return { success: true };
  } catch (error) {
    console.error('Registration error:', error);
    return { success: false, error: error.message };
  }
}

async function authenticateUser(email, password) {
  try {
    // Retrieve user from database
    const user = await db.users.findOne({ email });
    
    if (!user) {
      // Use constant-time comparison to prevent timing attacks
      // Even though no user was found, still perform a comparison
      await bcrypt.compare(password, '$2b$12$invalidhashforcomparison');
      return { success: false, error: 'Invalid credentials' };
    }
    
    // Compare provided password with stored hash
    const passwordMatch = await bcrypt.compare(password, user.password);
    
    if (!passwordMatch) {
      return { success: false, error: 'Invalid credentials' };
    }
    
    // Generate session or token
    const token = generateAuthToken(user);
    
    return { success: true, token };
  } catch (error) {
    console.error('Authentication error:', error);
    return { success: false, error: 'Authentication failed' };
  }
}

// Password strength validation
function isStrongPassword(password) {
  // At least 8 characters, with uppercase, lowercase, number, and special char
  const strongPasswordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*])[A-Za-z\d!@#$%^&*]{8,}$/;
  return strongPasswordRegex.test(password);
}
```

**b) JWT (JSON Web Token) Security**

```javascript
// Server-side JWT handling (Node.js example)
const jwt = require('jsonwebtoken');

// Secret key should be stored in environment variables
const JWT_SECRET = process.env.JWT_SECRET;
const JWT_EXPIRES_IN = '1h'; // Short expiration time

function generateAuthToken(user) {
  // Create payload with minimal sensitive information
  const payload = {
    sub: user.id, // subject (user id)
    email: user.email,
    role: user.role,
    iat: Math.floor(Date.now() / 1000) // issued at time
  };
  
  // Sign the token
  return jwt.sign(payload, JWT_SECRET, {
    expiresIn: JWT_EXPIRES_IN,
    algorithm: 'HS256' // specify the algorithm
  });
}

function verifyAuthToken(token) {
  try {
    const decoded = jwt.verify(token, JWT_SECRET, {
      algorithms: ['HS256'] // restrict to specific algorithm
    });
    return { valid: true, data: decoded };
  } catch (error) {
    console.error('Token verification failed:', error.message);
    return { valid: false, error: error.message };
  }
}

// Middleware to protect routes
function authenticateJWT(req, res, next) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  const token = authHeader.split(' ')[1];
  const result = verifyAuthToken(token);
  
  if (!result.valid) {
    return res.status(401).json({ error: 'Invalid token' });
  }
  
  // Add user data to request object
  req.user = result.data;
  next();
}

// Using the middleware
app.get('/api/protected-resource', authenticateJWT, (req, res) => {
  // Access is granted only if valid token is provided
  res.json({ data: 'Protected data', user: req.user });
});
```

**c) OAuth and Social Login Security**

```javascript
// Using OAuth with a library like Passport.js (Node.js example)
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;

passport.use(new GoogleStrategy({
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: "https://yourdomain.com/auth/google/callback",
    // Verify the callback URL matches exactly what's registered with the provider
    // Use state parameter to prevent CSRF
    state: true
  },
  function(accessToken, refreshToken, profile, cb) {
    // Verify user in your database
    User.findOrCreate({ googleId: profile.id }, function (err, user) {
      return cb(err, user);
    });
  }
));

// Routes for OAuth flow
app.get('/auth/google',
  passport.authenticate('google', { 
    scope: ['profile', 'email'],
    // Request only necessary permissions
    prompt: 'select_account' // Force account selection to prevent automatic login
  }));

app.get('/auth/google/callback', 
  passport.authenticate('google', { failureRedirect: '/login' }),
  function(req, res) {
    // Successful authentication
    // Validate the state parameter to prevent CSRF
    res.redirect('/dashboard');
  });
```

**4. Preventing Injection Attacks**

**a) SQL Injection Prevention**

```javascript
// Using parameterized queries with a library like node-postgres
const { Pool } = require('pg');
const pool = new Pool(/* connection config */);

async function getUserByUsername(username) {
  // Unsafe approach - vulnerable to SQL injection
  // const query = `SELECT * FROM users WHERE username = '${username}'`;
  // const result = await pool.query(query);
  
  // Safe approach - using parameterized query
  const query = 'SELECT * FROM users WHERE username = $1';
  const values = [username];
  const result = await pool.query(query, values);
  
  return result.rows[0];
}

// Using an ORM like Sequelize for added protection
const User = require('./models/user');

async function getUserData(userId) {
  return await User.findByPk(userId, {
    attributes: ['id', 'username', 'email'] // Explicitly select fields
  });
}
```

**b) NoSQL Injection Prevention**

```javascript
// MongoDB example with mongoose
const mongoose = require('mongoose');
const User = mongoose.model('User');

async function findUserByCredentials(username, password) {
  // Unsafe approach - vulnerable to NoSQL injection
  // return await User.findOne({ username: username, password: password });
  
  // Safe approach - validate and sanitize inputs
  if (typeof username !== 'string' || typeof password !== 'string') {
    throw new Error('Invalid input types');
  }
  
  // Use strict equality operator
  return await User.findOne({ 
    username: { $eq: username } 
  }).then(user => {
    if (!user) return null;
    // Verify password using bcrypt or similar
    return verifyPassword(password, user.password) ? user : null;
  });
}
```

**c) Command Injection Prevention**

```javascript
// Node.js child_process example
const { execFile } = require('child_process');
const { promisify } = require('util');
const execFileAsync = promisify(execFile);

async function convertUserFile(filename) {
  // Unsafe approach - vulnerable to command injection
  // const { exec } = require('child_process');
  // return await promisify(exec)(`convert ${filename} output.png`);
  
  // Safe approach - using execFile with separate arguments
  try {
    // Validate filename first
    if (!/^[\w.-]+$/.test(filename)) {
      throw new Error('Invalid filename');
    }
    
    // Use execFile which doesn't invoke a shell
    const { stdout } = await execFileAsync('convert', [filename, 'output.png']);
    return { success: true, output: stdout };
  } catch (error) {
    console.error('File conversion error:', error);
    return { success: false, error: error.message };
  }
}
```

**5. Secure Data Storage and Transmission**

**a) Secure Cookies**

```javascript
// Setting secure cookies
document.cookie = 'sessionId=abc123; Secure; HttpOnly; SameSite=Strict; Path=/; Max-Age=3600';

// In Express.js
app.use(session({
  secret: process.env.SESSION_SECRET,
  cookie: {
    secure: true,           // Requires HTTPS
    httpOnly: true,         // Not accessible via JavaScript
    sameSite: 'strict',     // Only sent for same-site requests
    maxAge: 3600000,        // 1 hour in milliseconds
    path: '/',              // Cookie path
    domain: 'example.com'   // Cookie domain
  },
  resave: false,
  saveUninitialized: false
}));
```

**b) Local Storage Security**

```javascript
// Sensitive data should NOT be stored in localStorage

// Bad practice - storing sensitive data in localStorage
// localStorage.setItem('authToken', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...');
// localStorage.setItem('userDetails', JSON.stringify({name: 'John', ssn: '123-45-6789'}));

// Better approach - store non-sensitive data only
localStorage.setItem('uiPreferences', JSON.stringify({
  theme: 'dark',
  fontSize: 'medium',
  sidebarCollapsed: true
}));

// For sensitive data, use HttpOnly cookies or a more secure approach
// like using a short-lived token in memory during the session

// Example of in-memory token storage
class AuthService {
  constructor() {
    this.token = null;
  }
  
  setToken(token) {
    this.token = token;
  }
  
  getToken() {
    return this.token;
  }
  
  clearToken() {
    this.token = null;
  }
  
  isAuthenticated() {
    return !!this.token;
  }
}

const authService = new AuthService();
export default authService;
```

**c) HTTPS and HSTS**

```javascript
// Node.js HTTPS server example
const https = require('https');
const fs = require('fs');
const express = require('express');
const helmet = require('helmet');

const app = express();

// Use Helmet to set security headers including HSTS
app.use(helmet());

// Set up HSTS with custom configuration
app.use(helmet.hsts({
  maxAge: 31536000, // 1 year in seconds
  includeSubDomains: true,
  preload: true
}));

// SSL/TLS certificate configuration
const options = {
  key: fs.readFileSync('path/to/private-key.pem'),
  cert: fs.readFileSync('path/to/certificate.pem'),
  // Modern, secure cipher configuration
  ciphers: [
    'TLS_AES_256_GCM_SHA384',
    'TLS_CHACHA20_POLY1305_SHA256',
    'TLS_AES_128_GCM_SHA256',
    'ECDHE-RSA-AES256-GCM-SHA384',
    'ECDHE-RSA-AES128-GCM-SHA256'
  ].join(':'),
  // Minimum TLS version
  minVersion: 'TLSv1.2',
  // Prefer server's cipher suite order
  honorCipherOrder: true
};

// Create HTTPS server
https.createServer(options, app).listen(443, () => {
  console.log('HTTPS server running on port 443');
});

// Redirect HTTP to HTTPS
const http = require('http');
http.createServer((req, res) => {
  res.writeHead(301, { 'Location': `https://${req.headers.host}${req.url}` });
  res.end();
}).listen(80);
```

**6. Preventing Client-Side Vulnerabilities**

**a) Subresource Integrity (SRI)**

```html
<!-- Using SRI for external scripts and stylesheets -->
<script src="https://cdn.example.com/library.js" 
        integrity="sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC" 
        crossorigin="anonymous"></script>

<link rel="stylesheet" href="https://cdn.example.com/styles.css" 
      integrity="sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC" 
      crossorigin="anonymous">
```

**b) Iframe Security**

```html
<!-- Secure iframe configuration -->
<iframe src="https://trusted-site.com/widget" 
        sandbox="allow-scripts allow-same-origin" 
        referrerpolicy="no-referrer" 
        title="Trusted Widget"></iframe>
```

```javascript
// Setting frame security headers in Express.js
app.use(helmet.frameguard({ action: 'deny' })); // Prevent being framed
// Or allow only from specific origins
app.use(helmet.frameguard({ action: 'allow-from', domain: 'https://trusted-site.com' }));
```

**c) Preventing Clickjacking**

```javascript
// Setting X-Frame-Options header in Express.js
app.use(helmet.frameguard({ action: 'deny' }));

// Or manually
app.use((req, res, next) => {
  res.setHeader('X-Frame-Options', 'DENY');
  next();
});
```

**7. Secure Coding Practices**

**a) Avoiding Dangerous Functions**

```javascript
// Avoid eval() and similar functions

// Unsafe - using eval
// function calculateFromUserInput(input) {
//   return eval(input); // Dangerous - executes arbitrary code
// }

// Safe alternative - use a proper parser or safer approach
function calculateFromUserInput(input) {
  // Use a math expression evaluator library
  return mathExpressionEvaluator.parse(input).evaluate();
  
  // Or for simple cases, use safer built-in methods
  // return Function('"use strict";return (' + input + ')')();
}

// Avoid innerHTML when possible

// Unsafe - using innerHTML with user input
// function displayMessage(message) {
//   document.querySelector('#message').innerHTML = message;
// }

// Safe alternative - use textContent or create elements properly
function displayMessage(message) {
  document.querySelector('#message').textContent = message;
}

function createRichMessage(messageObj) {
  const container = document.createElement('div');
  
  const title = document.createElement('h3');
  title.textContent = messageObj.title;
  container.appendChild(title);
  
  const body = document.createElement('p');
  body.textContent = messageObj.body;
  container.appendChild(body);
  
  if (messageObj.link) {
    const link = document.createElement('a');
    link.href = sanitizeURL(messageObj.link.url);
    link.textContent = messageObj.link.text;
    link.rel = 'noopener noreferrer';
    link.target = '_blank';
    container.appendChild(link);
  }
  
  return container;
}

// URL sanitization helper
function sanitizeURL(url) {
  // Ensure URL is properly formatted and doesn't use javascript: protocol
  try {
    const parsedURL = new URL(url);
    if (parsedURL.protocol === 'javascript:') {
      return '#'; // Invalid protocol, return safe value
    }
    return parsedURL.toString();
  } catch (e) {
    return '#'; // Invalid URL, return safe value
  }
}
```

**b) Regular Expression Security**

```javascript
// Preventing ReDoS (Regular Expression Denial of Service)

// Vulnerable regex pattern - can cause catastrophic backtracking
// const emailRegex = /^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$/;

// Safer regex pattern with limited backtracking
const safeEmailRegex = /^[^@\s]+@[^@\s]+\.[^@\s]+$/;

function validateEmail(email) {
  // Set a timeout to prevent long-running regex
  const startTime = Date.now();
  const timeoutMs = 100; // 100ms timeout
  
  const isValid = safeEmailRegex.test(email);
  
  if (Date.now() - startTime > timeoutMs) {
    console.warn('Email validation took too long, potential ReDoS attack');
    // Log potential attack
  }
  
  return isValid;
}

// Using a regex validator library with timeout support
function validateWithTimeout(regex, input, timeoutMs = 100) {
  return new Promise((resolve, reject) => {
    // Create a worker to run the regex in a separate thread
    const worker = new Worker(URL.createObjectURL(new Blob([`
      self.onmessage = function(e) {
        const { regex, input } = e.data;
        const result = new RegExp(regex).test(input);
        self.postMessage(result);
      }
    `], { type: 'application/javascript' })));
    
    // Set timeout
    const timeoutId = setTimeout(() => {
      worker.terminate();
      reject(new Error('Regex evaluation timed out'));
    }, timeoutMs);
    
    // Handle result
    worker.onmessage = (e) => {
      clearTimeout(timeoutId);
      worker.terminate();
      resolve(e.data);
    };
    
    // Start the worker
    worker.postMessage({ regex: regex.source, input });
  });
}

// Usage
async function validateUserInput(input) {
  try {
    const isValid = await validateWithTimeout(/^[a-zA-Z0-9]{1,50}$/, input);
    return isValid;
  } catch (error) {
    console.error('Validation error:', error);
    return false; // Consider input invalid if validation times out
  }
}
```

**c) Preventing Prototype Pollution**

```javascript
// Helper to safely merge objects without prototype pollution
function safeObjectMerge(target, source) {
  // Create a new object to avoid modifying the target directly
  const result = { ...target };
  
  // Iterate through source properties
  for (const key in source) {
    // Skip inherited properties
    if (!Object.prototype.hasOwnProperty.call(source, key)) continue;
    
    // Skip __proto__ and constructor to prevent prototype pollution
    if (key === '__proto__' || key === 'constructor') continue;
    
    const value = source[key];
    
    // Handle nested objects recursively
    if (value && typeof value === 'object' && !Array.isArray(value)) {
      // If target has the property and it's an object, merge recursively
      if (result[key] && typeof result[key] === 'object' && !Array.isArray(result[key])) {
        result[key] = safeObjectMerge(result[key], value);
      } else {
        // Otherwise, create a new object
        result[key] = safeObjectMerge({}, value);
      }
    } else {
      // For non-objects, simply copy the value
      result[key] = value;
    }
  }
  
  return result;
}

// Using Object.create(null) for safer objects
function createSafeObject() {
  return Object.create(null); // Creates object with no prototype
}

// Example usage
function processUserConfig(userConfig) {
  // Default configuration
  const defaultConfig = {
    theme: 'light',
    fontSize: 'medium',
    notifications: true
  };
  
  // Safely merge with user configuration
  const finalConfig = safeObjectMerge(defaultConfig, userConfig);
  
  return finalConfig;
}

// Using a library like lodash with security patches
// import _ from 'lodash';
// const finalConfig = _.merge({}, defaultConfig, userConfig);
```

**8. Security Headers and Browser Features**

**a) Setting Security Headers**

```javascript
// Using Helmet in Express.js to set security headers
const express = require('express');
const helmet = require('helmet');
const app = express();

// Apply all default Helmet middleware
app.use(helmet());

// Or configure headers individually
app.use(
  helmet({
    // Content-Security-Policy
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        scriptSrc: ["'self'", 'trusted-cdn.com'],
        // other directives...
      },
    },
    
    // X-XSS-Protection
    xssFilter: true,
    
    // X-Content-Type-Options
    noSniff: true,
    
    // Referrer-Policy
    referrerPolicy: { policy: 'same-origin' },
    
    // Feature-Policy / Permissions-Policy
    permissionsPolicy: {
      features: {
        geolocation: ["'self'"],
        camera: ["'none'"],
        microphone: ["'none'"],
        // other features...
      },
    },
    
    // Strict-Transport-Security (HSTS)
    hsts: {
      maxAge: 31536000,
      includeSubDomains: true,
      preload: true
    },
    
    // X-Frame-Options
    frameguard: { action: 'deny' },
    
    // X-DNS-Prefetch-Control
    dnsPrefetchControl: { allow: false },
    
    // Expect-CT
    expectCt: {
      maxAge: 86400,
      enforce: true
    }
  })
);
```

**b) Feature Policy / Permissions Policy**

```html
<!-- In HTML -->
<meta http-equiv="Permissions-Policy" content="geolocation=(self), camera=(), microphone=()">
```

```javascript
// In Express.js
app.use((req, res, next) => {
  res.setHeader(
    'Permissions-Policy',
    'geolocation=(self), camera=(), microphone=(), payment=(), usb=()'
  );
  next();
});
```

**9. Security Testing and Auditing**

**a) Dependency Scanning**

```javascript
// Using npm audit to check for vulnerabilities
// Run in terminal: npm audit

// Fix vulnerabilities automatically
// npm audit fix

// Using a pre-commit hook to prevent committing with vulnerabilities
// In package.json
{
  "scripts": {
    "precommit": "npm audit --audit-level=high"
  },
  "husky": {
    "hooks": {
      "pre-commit": "npm run precommit"
    }
  }
}
```

**b) Static Analysis Tools**

```javascript
// ESLint security plugin configuration
// .eslintrc.js
module.exports = {
  plugins: ['security'],
  extends: ['plugin:security/recommended'],
  rules: {
    'security/detect-unsafe-regex': 'error',
    'security/detect-buffer-noassert': 'error',
    'security/detect-child-process': 'error',
    'security/detect-disable-mustache-escape': 'error',
    'security/detect-eval-with-expression': 'error',
    'security/detect-no-csrf-before-method-override': 'error',
    'security/detect-non-literal-fs-filename': 'error',
    'security/detect-non-literal-regexp': 'error',
    'security/detect-non-literal-require': 'error',
    'security/detect-object-injection': 'error',
    'security/detect-possible-timing-attacks': 'error',
    'security/detect-pseudoRandomBytes': 'error'
  }
};
```

**c) Security Headers Testing**

```javascript
// Using a testing library to verify security headers
const request = require('supertest');
const app = require('../app');

describe('Security Headers', () => {
  test('should set Content-Security-Policy header', async () => {
    const response = await request(app).get('/');
    expect(response.headers['content-security-policy']).toBeDefined();
  });
  
  test('should set X-XSS-Protection header', async () => {
    const response = await request(app).get('/');
    expect(response.headers['x-xss-protection']).toBe('1; mode=block');
  });
  
  test('should set X-Frame-Options header', async () => {
    const response = await request(app).get('/');
    expect(response.headers['x-frame-options']).toBe('DENY');
  });
  
  test('should set Strict-Transport-Security header', async () => {
    const response = await request(app).get('/');
    expect(response.headers['strict-transport-security']).toContain('max-age=');
  });
});
```

**10. Secure Development Lifecycle**

**a) Security Code Review Checklist**

```javascript
// Example security code review checklist (as comments)

/*
Security Code Review Checklist:

1. Input Validation
   - All user inputs are validated
   - Validation occurs on the server side
   - Input length limits are enforced
   - Input type checking is implemented

2. Output Encoding
   - HTML output is properly escaped
   - JavaScript data is properly escaped
   - SQL queries use parameterized statements
   - JSON output is properly sanitized

3. Authentication & Authorization
   - Password storage uses strong hashing
   - Session management is secure
   - Authorization checks exist on all sensitive operations
   - JWT tokens are properly validated

4. Data Protection
   - Sensitive data is not logged
   - Encryption is used for sensitive data
   - No hardcoded secrets or credentials
   - HTTPS is enforced

5. Error Handling
   - Errors don't reveal sensitive information
   - All exceptions are caught and handled
   - Custom error pages exist

6. Security Headers
   - CSP is properly configured
   - HSTS is enabled
   - X-Content-Type-Options is set
   - X-Frame-Options is set

7. Dependencies
   - All dependencies are up to date
   - No known vulnerabilities in dependencies
   - Minimal permissions for external services

8. Business Logic
   - No race conditions in critical operations
   - Rate limiting is implemented
   - Anti-automation measures exist
*/

// Implementing the checklist in a review tool or script
function securityReview(codebase) {
  const results = {
    inputValidation: checkInputValidation(codebase),
    outputEncoding: checkOutputEncoding(codebase),
    authentication: checkAuthentication(codebase),
    dataProtection: checkDataProtection(codebase),
    errorHandling: checkErrorHandling(codebase),
    securityHeaders: checkSecurityHeaders(codebase),
    dependencies: checkDependencies(codebase),
    businessLogic: checkBusinessLogic(codebase)
  };
  
  return generateReport(results);
}
```

**Key Takeaways:**

1. Always validate and sanitize user input to prevent XSS attacks, using libraries like DOMPurify and context-specific encoding
2. Implement Content Security Policy (CSP) to restrict resource loading and script execution
3. Protect against CSRF attacks using anti-CSRF tokens and SameSite cookies
4. Never store plaintext passwords; use strong hashing algorithms like bcrypt with proper salt
5. Use parameterized queries or ORMs to prevent SQL injection and similar attacks
6. Store sensitive data in HttpOnly, Secure cookies rather than localStorage or sessionStorage
7. Enforce HTTPS with HSTS headers to prevent man-in-the-middle attacks
8. Avoid dangerous functions like eval(), innerHTML, and document.write when handling user input
9. Regularly scan dependencies for vulnerabilities using tools like npm audit
10. Implement proper security headers including CSP, X-XSS-Protection, and X-Frame-Options

### Q91: Explain common JavaScript design patterns. How and when would you implement them?
**Difficulty: Medium-Hard**

**Answer:**
Design patterns are reusable solutions to common problems in software design. They represent best practices evolved over time by experienced developers. In JavaScript, design patterns help create maintainable, scalable, and robust applications.

**1. Creational Patterns**

These patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.

**a) Constructor Pattern**

Uses a special constructor function to create specific types of objects.

```javascript
// ES5 Constructor Pattern
function User(name, email) {
  this.name = name;
  this.email = email;
  this.online = false;
  
  this.login = function() {
    this.online = true;
    console.log(this.name + ' has logged in');
  };
}

const user1 = new User('John', 'john@example.com');
user1.login(); // John has logged in

// ES6 Class (syntactic sugar over constructor pattern)
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
    this.online = false;
  }
  
  login() {
    this.online = true;
    console.log(`${this.name} has logged in`);
  }
}

const user2 = new User('Jane', 'jane@example.com');
user2.login(); // Jane has logged in
```

**When to use:** When you need to create multiple instances of objects with the same properties and methods. It's the foundation of object-oriented programming in JavaScript.

**b) Factory Pattern**

Creates objects without specifying the exact class or constructor to use.

```javascript
// Simple Factory
function createUser(type) {
  const userTypes = {
    admin: AdminUser,
    regular: RegularUser,
    guest: GuestUser
  };
  
  // Select constructor based on type
  const UserType = userTypes[type] || RegularUser;
  
  // Create and return new instance
  return new UserType();
}

function AdminUser() {
  this.permissions = ['read', 'write', 'delete', 'admin'];
  this.role = 'admin';
}

function RegularUser() {
  this.permissions = ['read', 'write'];
  this.role = 'regular';
}

function GuestUser() {
  this.permissions = ['read'];
  this.role = 'guest';
}

// Usage
const admin = createUser('admin');
console.log(admin.permissions); // ['read', 'write', 'delete', 'admin']

const guest = createUser('guest');
console.log(guest.permissions); // ['read']

// Modern Factory with ES6
class UserFactory {
  static createUser(details) {
    const { name, email, role = 'regular' } = details;
    
    // Base user properties
    const user = {
      name,
      email,
      createdAt: new Date(),
      lastLogin: null
    };
    
    // Extend with role-specific properties
    switch (role) {
      case 'admin':
        return {
          ...user,
          permissions: ['read', 'write', 'delete', 'admin'],
          adminSince: new Date()
        };
      case 'guest':
        return {
          ...user,
          permissions: ['read'],
          expiresIn: '24h'
        };
      default:
        return {
          ...user,
          permissions: ['read', 'write']
        };
    }
  }
}

// Usage
const adminUser = UserFactory.createUser({
  name: 'Admin',
  email: 'admin@example.com',
  role: 'admin'
});

console.log(adminUser.permissions); // ['read', 'write', 'delete', 'admin']
```

**When to use:** When creating different objects based on specific conditions, or when you want to create objects without exposing the instantiation logic to the client.

**c) Singleton Pattern**

Ensures a class has only one instance and provides a global point of access to it.

```javascript
// Classic Singleton Pattern
const Database = (function() {
  let instance;
  
  // Private constructor
  function createInstance() {
    const connection = {
      host: 'localhost',
      port: 5432,
      username: 'user'
    };
    
    return {
      query: function(sql) {
        console.log(`Executing query: ${sql}`);
        // Actual query logic would go here
        return [`Result for: ${sql}`];
      },
      connect: function() {
        console.log('Connected to database');
      }
    };
  }
  
  return {
    // Public method to get instance
    getInstance: function() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

// Usage
const db1 = Database.getInstance();
const db2 = Database.getInstance();

console.log(db1 === db2); // true - both variables reference the same instance

// Modern Singleton with ES6
class ConfigManager {
  constructor() {
    if (ConfigManager.instance) {
      return ConfigManager.instance;
    }
    
    // Initialize singleton properties
    this.config = {
      apiUrl: 'https://api.example.com',
      timeout: 5000,
      version: '1.0.0'
    };
    
    // Store instance
    ConfigManager.instance = this;
  }
  
  get(key) {
    return this.config[key];
  }
  
  set(key, value) {
    this.config[key] = value;
  }
}

// Usage
const config1 = new ConfigManager();
const config2 = new ConfigManager();

config1.set('apiUrl', 'https://new-api.example.com');
console.log(config2.get('apiUrl')); // 'https://new-api.example.com'
console.log(config1 === config2); // true - both are the same instance
```

**When to use:** When exactly one instance of a class is needed to coordinate actions across the system, such as configuration managers, connection pools, or caches.

**d) Module Pattern**

Uses closures to create private and public methods and variables.

```javascript
// Classic Module Pattern
const ShoppingCart = (function() {
  // Private variables and methods
  let items = [];
  
  function calculateTotal() {
    return items.reduce((total, item) => total + item.price * item.quantity, 0);
  }
  
  // Public API
  return {
    addItem: function(item) {
      items.push(item);
    },
    removeItem: function(id) {
      items = items.filter(item => item.id !== id);
    },
    getItems: function() {
      // Return a copy to prevent direct manipulation
      return [...items];
    },
    getTotal: function() {
      return calculateTotal();
    }
  };
})();

// Usage
ShoppingCart.addItem({ id: 1, name: 'Book', price: 29.99, quantity: 1 });
ShoppingCart.addItem({ id: 2, name: 'Laptop', price: 999.99, quantity: 1 });

console.log(ShoppingCart.getTotal()); // 1029.98
console.log(ShoppingCart.items); // undefined - private variable

// Modern Module Pattern with ES6
class ShoppingCartModule {
  #items = []; // Private field (ES2022)
  
  #calculateTotal() { // Private method (ES2022)
    return this.#items.reduce((total, item) => total + item.price * item.quantity, 0);
  }
  
  addItem(item) {
    this.#items.push(item);
  }
  
  removeItem(id) {
    this.#items = this.#items.filter(item => item.id !== id);
  }
  
  getItems() {
    return [...this.#items];
  }
  
  getTotal() {
    return this.#calculateTotal();
  }
}

// Usage
const cart = new ShoppingCartModule();
cart.addItem({ id: 1, name: 'Book', price: 29.99, quantity: 1 });
console.log(cart.getTotal()); // 29.99
// console.log(cart.#items); // SyntaxError: Private field '#items' must be declared in an enclosing class
```

**When to use:** When you need to organize related methods and properties while keeping some of them private, creating a clear public API for your module.

**2. Structural Patterns**

These patterns focus on how objects and classes are composed to form larger structures.

**a) Decorator Pattern**

Attaches additional responsibilities to objects dynamically, providing a flexible alternative to subclassing.

```javascript
// Basic component
function Coffee() {
  this.cost = function() {
    return 5;
  };
  this.description = function() {
    return 'Plain coffee';
  };
}

// Decorators
function MilkDecorator(coffee) {
  const cost = coffee.cost();
  const description = coffee.description();
  
  coffee.cost = function() {
    return cost + 1.5;
  };
  
  coffee.description = function() {
    return description + ', milk';
  };
  
  return coffee;
}

function CaramelDecorator(coffee) {
  const cost = coffee.cost();
  const description = coffee.description();
  
  coffee.cost = function() {
    return cost + 2;
  };
  
  coffee.description = function() {
    return description + ', caramel';
  };
  
  return coffee;
}

// Usage
let coffee = new Coffee();
console.log(coffee.description(), coffee.cost()); // Plain coffee 5

coffee = MilkDecorator(coffee);
console.log(coffee.description(), coffee.cost()); // Plain coffee, milk 6.5

coffee = CaramelDecorator(coffee);
console.log(coffee.description(), coffee.cost()); // Plain coffee, milk, caramel 8.5

// Modern Decorator Pattern with ES6
class SimpleCoffee {
  cost() {
    return 5;
  }
  
  description() {
    return 'Plain coffee';
  }
}

// Using composition instead of inheritance
class MilkCoffee {
  constructor(coffee) {
    this.coffee = coffee;
  }
  
  cost() {
    return this.coffee.cost() + 1.5;
  }
  
  description() {
    return `${this.coffee.description()}, milk`;
  }
}

class CaramelCoffee {
  constructor(coffee) {
    this.coffee = coffee;
  }
  
  cost() {
    return this.coffee.cost() + 2;
  }
  
  description() {
    return `${this.coffee.description()}, caramel`;
  }
}

// Usage
let modernCoffee = new SimpleCoffee();
modernCoffee = new MilkCoffee(modernCoffee);
modernCoffee = new CaramelCoffee(modernCoffee);

console.log(modernCoffee.description(), modernCoffee.cost()); // Plain coffee, milk, caramel 8.5

// JavaScript Decorators (Stage 3 proposal)
// @logged decorator example (when supported)
/*
function logged(target, name, descriptor) {
  const original = descriptor.value;
  
  descriptor.value = function(...args) {
    console.log(`Calling ${name} with arguments: ${args}`);
    const result = original.apply(this, args);
    console.log(`Result: ${result}`);
    return result;
  };
  
  return descriptor;
}

class Calculator {
  @logged
  add(a, b) {
    return a + b;
  }
}

const calc = new Calculator();
calc.add(2, 3); // Logs: Calling add with arguments: 2,3 and Result: 5
*/
```

**When to use:** When you need to add responsibilities to objects dynamically and transparently, without affecting other objects, or when extension by subclassing is impractical.

**b) Adapter Pattern**

Allows objects with incompatible interfaces to work together.

```javascript
// Old API
class OldCalculator {
  operate(op, a, b) {
    switch(op) {
      case 'add':
        return a + b;
      case 'sub':
        return a - b;
      default:
        return NaN;
    }
  }
}

// New API
class NewCalculator {
  add(a, b) {
    return a + b;
  }
  
  subtract(a, b) {
    return a - b;
  }
  
  multiply(a, b) {
    return a * b;
  }
  
  divide(a, b) {
    return a / b;
  }
}

// Adapter
class CalculatorAdapter {
  constructor() {
    this.calculator = new NewCalculator();
  }
  
  operate(op, a, b) {
    switch(op) {
      case 'add':
        return this.calculator.add(a, b);
      case 'sub':
        return this.calculator.subtract(a, b);
      case 'mul':
        return this.calculator.multiply(a, b);
      case 'div':
        return this.calculator.divide(a, b);
      default:
        return NaN;
    }
  }
}

// Client code using old interface
function calculateWithOldAPI(calculator) {
  console.log(calculator.operate('add', 10, 5));
  console.log(calculator.operate('sub', 10, 5));
}

// Usage
const oldCalc = new OldCalculator();
calculateWithOldAPI(oldCalc); // 15, 5

const adapter = new CalculatorAdapter();
calculateWithOldAPI(adapter); // 15, 5 (using new calculator with old interface)

// API Adapter Example
class LocalStorageAdapter {
  constructor() {
    this.storage = window.localStorage;
  }
  
  get(key) {
    const value = this.storage.getItem(key);
    return value ? JSON.parse(value) : null;
  }
  
  set(key, value) {
    this.storage.setItem(key, JSON.stringify(value));
  }
  
  remove(key) {
    this.storage.removeItem(key);
  }
  
  clear() {
    this.storage.clear();
  }
}

class IndexedDBAdapter {
  // Implements the same interface but uses IndexedDB
  // ...
}

// Client code can use either adapter with the same interface
function storeUserPreferences(storageAdapter, preferences) {
  storageAdapter.set('userPreferences', preferences);
}
```

**When to use:** When you need to make classes with incompatible interfaces work together, or when you want to create a reusable class that cooperates with classes that don't necessarily have compatible interfaces.

**c) Proxy Pattern**

Provides a surrogate or placeholder for another object to control access to it.

```javascript
// Target object
const bankAccount = {
  balance: 1000,
  withdraw(amount) {
    if (amount > this.balance) {
      console.log('Insufficient funds');
      return false;
    }
    this.balance -= amount;
    console.log(`Withdrew ${amount}, new balance: ${this.balance}`);
    return true;
  },
  deposit(amount) {
    this.balance += amount;
    console.log(`Deposited ${amount}, new balance: ${this.balance}`);
    return true;
  }
};

// Proxy object
const bankAccountProxy = {
  account: bankAccount,
  withdraw(amount) {
    if (amount > 500) {
      console.log('Maximum withdrawal limit is 500');
      return false;
    }
    return this.account.withdraw(amount);
  },
  deposit(amount) {
    if (amount > 5000) {
      console.log('Please visit branch for deposits over 5000');
      return false;
    }
    return this.account.deposit(amount);
  },
  get balance() {
    return this.account.balance;
  }
};

// Usage
console.log(`Initial balance: ${bankAccountProxy.balance}`);
bankAccountProxy.withdraw(200); // Withdrew 200, new balance: 800
bankAccountProxy.withdraw(700); // Maximum withdrawal limit is 500

// Modern Proxy with ES6 Proxy object
const user = {
  firstName: 'John',
  lastName: 'Doe',
  email: 'john@example.com'
};

const userProxy = new Proxy(user, {
  get(target, property) {
    console.log(`Reading property "${property}"`);
    return target[property];
  },
  set(target, property, value) {
    // Validation logic
    if (property === 'email' && !value.includes('@')) {
      console.error('Invalid email format');
      return false;
    }
    
    console.log(`Setting property "${property}" to "${value}"`);
    target[property] = value;
    return true;
  }
});

// Usage
console.log(userProxy.firstName); // Reading property "firstName", John
userProxy.email = 'invalid-email'; // Invalid email format
userProxy.email = 'john.doe@example.com'; // Setting property "email" to "john.doe@example.com"
```

**When to use:** When you need to control access to an object, add logging, implement lazy initialization, or add additional behavior when accessing an object's properties.

**3. Behavioral Patterns**

These patterns focus on communication between objects, how objects operate and interact.

**a) Observer Pattern**

Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

```javascript
// Subject (Observable)
class Newsletter {
  constructor() {
    this.subscribers = [];
  }
  
  subscribe(observer) {
    this.subscribers.push(observer);
  }
  
  unsubscribe(observer) {
    this.subscribers = this.subscribers.filter(subscriber => subscriber !== observer);
  }
  
  notify(message) {
    this.subscribers.forEach(subscriber => subscriber.update(message));
  }
  
  publishNewsletter(content) {
    console.log('Publishing new newsletter...');
    this.notify({ content, date: new Date() });
  }
}

// Observer
class Subscriber {
  constructor(name) {
    this.name = name;
  }
  
  update(message) {
    console.log(`${this.name} received: ${message.content} (${message.date})`);
  }
}

// Usage
const techNewsletter = new Newsletter();

const alice = new Subscriber('Alice');
const bob = new Subscriber('Bob');
const charlie = new Subscriber('Charlie');

techNewsletter.subscribe(alice);
techNewsletter.subscribe(bob);
techNewsletter.subscribe(charlie);

techNewsletter.publishNewsletter('New JavaScript features announced!');
// Alice received: New JavaScript features announced! (...)  
// Bob received: New JavaScript features announced! (...)
// Charlie received: New JavaScript features announced! (...)

techNewsletter.unsubscribe(bob);
techNewsletter.publishNewsletter('TypeScript 5.0 released!');
// Alice received: TypeScript 5.0 released! (...)
// Charlie received: TypeScript 5.0 released! (...)

// Event-based Observer Pattern (common in browser environments)
class EventEmitter {
  constructor() {
    this.events = {};
  }
  
  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
    return () => this.off(event, listener); // Return unsubscribe function
  }
  
  off(event, listener) {
    if (!this.events[event]) return;
    this.events[event] = this.events[event].filter(l => l !== listener);
  }
  
  emit(event, ...args) {
    if (!this.events[event]) return;
    this.events[event].forEach(listener => listener(...args));
  }
  
  once(event, listener) {
    const onceListener = (...args) => {
      listener(...args);
      this.off(event, onceListener);
    };
    return this.on(event, onceListener);
  }
}

// Usage
const userEvents = new EventEmitter();

userEvents.on('login', user => {
  console.log(`${user.name} logged in`);
});

const logoutListener = user => {
  console.log(`${user.name} logged out`);
};

userEvents.on('logout', logoutListener);

userEvents.once('purchase', data => {
  console.log(`${data.user.name} purchased ${data.item} for $${data.price}`);
});

// Trigger events
userEvents.emit('login', { name: 'John', id: 123 }); // John logged in
userEvents.emit('purchase', { user: { name: 'John', id: 123 }, item: 'Book', price: 29.99 }); // John purchased Book for $29.99
userEvents.emit('purchase', { user: { name: 'John', id: 123 }, item: 'Course', price: 99.99 }); // No output - 'once' listener already removed

userEvents.off('logout', logoutListener);
userEvents.emit('logout', { name: 'John', id: 123 }); // No output - listener removed
```

**When to use:** When changes to one object require changing others, and you don't know how many objects need to change, or when an object should be able to notify other objects without making assumptions about those objects.

**b) Strategy Pattern**

Defines a family of algorithms, encapsulates each one, and makes them interchangeable.

```javascript
// Strategy interface (implicit in JavaScript)
// Each strategy must implement a calculate method

// Concrete strategies
class RegularPriceStrategy {
  calculate(amount) {
    return amount;
  }
}

class DiscountPriceStrategy {
  constructor(discountPercentage) {
    this.discountPercentage = discountPercentage;
  }
  
  calculate(amount) {
    return amount * (1 - this.discountPercentage / 100);
  }
}

class SalePriceStrategy {
  constructor(salePercentage) {
    this.salePercentage = salePercentage;
  }
  
  calculate(amount) {
    return amount * (1 - this.salePercentage / 100);
  }
}

// Context
class PriceCalculator {
  constructor(strategy) {
    this.strategy = strategy;
  }
  
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  
  calculatePrice(amount) {
    return this.strategy.calculate(amount);
  }
}

// Usage
const regularPriceStrategy = new RegularPriceStrategy();
const discountPriceStrategy = new DiscountPriceStrategy(10); // 10% discount
const salePriceStrategy = new SalePriceStrategy(25); // 25% sale

const calculator = new PriceCalculator(regularPriceStrategy);

console.log(calculator.calculatePrice(100)); // 100

calculator.setStrategy(discountPriceStrategy);
console.log(calculator.calculatePrice(100)); // 90

calculator.setStrategy(salePriceStrategy);
console.log(calculator.calculatePrice(100)); // 75

// Functional approach to Strategy Pattern
const paymentStrategies = {
  creditCard: (amount) => {
    // Credit card payment processing logic
    console.log(`Processing credit card payment of $${amount}`);
    return { success: true, fee: amount * 0.03 };
  },
  
  paypal: (amount) => {
    // PayPal payment processing logic
    console.log(`Processing PayPal payment of $${amount}`);
    return { success: true, fee: amount * 0.02 + 0.30 };
  },
  
  bankTransfer: (amount) => {
    // Bank transfer payment processing logic
    console.log(`Processing bank transfer payment of $${amount}`);
    return { success: true, fee: 5 };
  }
};

function processPayment(amount, paymentMethod) {
  // Select strategy based on payment method
  const strategy = paymentStrategies[paymentMethod];
  
  if (!strategy) {
    throw new Error(`Payment method ${paymentMethod} not supported`);
  }
  
  return strategy(amount);
}

// Usage
const creditCardResult = processPayment(100, 'creditCard');
console.log(`Fee: $${creditCardResult.fee}`); // Fee: $3

const paypalResult = processPayment(100, 'paypal');
console.log(`Fee: $${paypalResult.fee}`); // Fee: $2.30
```

**When to use:** When you have multiple algorithms for a specific task and you want to switch between them dynamically at runtime, or when you need to isolate the business logic of a class from the implementation details of algorithms that may not be as important in the context of the class.

**c) Command Pattern**

Encapsulates a request as an object, allowing for parameterization of clients with different requests, queuing of requests, and logging of operations.

```javascript
// Receiver
class Light {
  constructor(location) {
    this.location = location;
    this.isOn = false;
  }
  
  turnOn() {
    this.isOn = true;
    console.log(`${this.location} light turned on`);
  }
  
  turnOff() {
    this.isOn = false;
    console.log(`${this.location} light turned off`);
  }
}

// Command interface (implicit in JavaScript)
// Each command must implement execute and undo methods

// Concrete commands
class TurnOnCommand {
  constructor(light) {
    this.light = light;
  }
  
  execute() {
    this.light.turnOn();
  }
  
  undo() {
    this.light.turnOff();
  }
}

class TurnOffCommand {
  constructor(light) {
    this.light = light;
  }
  
  execute() {
    this.light.turnOff();
  }
  
  undo() {
    this.light.turnOn();
  }
}

// Invoker
class RemoteControl {
  constructor() {
    this.commands = {};
    this.history = [];
  }
  
  setCommand(button, command) {
    this.commands[button] = command;
  }
  
  pressButton(button) {
    const command = this.commands[button];
    if (command) {
      command.execute();
      this.history.push(command);
    }
  }
  
  pressUndo() {
    const command = this.history.pop();
    if (command) {
      command.undo();
    }
  }
}

// Usage
const kitchenLight = new Light('Kitchen');
const bedroomLight = new Light('Bedroom');

const kitchenLightOn = new TurnOnCommand(kitchenLight);
const kitchenLightOff = new TurnOffCommand(kitchenLight);
const bedroomLightOn = new TurnOnCommand(bedroomLight);
const bedroomLightOff = new TurnOffCommand(bedroomLight);

const remote = new RemoteControl();
remote.setCommand('kitchen-on', kitchenLightOn);
remote.setCommand('kitchen-off', kitchenLightOff);
remote.setCommand('bedroom-on', bedroomLightOn);
remote.setCommand('bedroom-off', bedroomLightOff);

remote.pressButton('kitchen-on'); // Kitchen light turned on
remote.pressButton('bedroom-on'); // Bedroom light turned on
remote.pressUndo(); // Bedroom light turned off
remote.pressButton('kitchen-off'); // Kitchen light turned off

// Command pattern for asynchronous operations
class HttpRequest {
  constructor(url, method, data) {
    this.url = url;
    this.method = method;
    this.data = data;
  }
  
  async execute() {
    try {
      console.log(`Sending ${this.method} request to ${this.url}`);
      // In a real app, this would use fetch or axios
      const response = await new Promise(resolve => {
        setTimeout(() => {
          resolve({ status: 200, data: { success: true } });
        }, 500);
      });
      
      console.log(`Request completed with status: ${response.status}`);
      return response;
    } catch (error) {
      console.error('Request failed:', error);
      throw error;
    }
  }
}

class CommandQueue {
  constructor() {
    this.queue = [];
    this.isProcessing = false;
  }
  
  addCommand(command) {
    this.queue.push(command);
    if (!this.isProcessing) {
      this.processQueue();
    }
  }
  
  async processQueue() {
    if (this.queue.length === 0) {
      this.isProcessing = false;
      return;
    }
    
    this.isProcessing = true;
    const command = this.queue.shift();
    
    try {
      await command.execute();
    } catch (error) {
      console.error('Command execution failed:', error);
    }
    
    this.processQueue();
  }
}

// Usage
const queue = new CommandQueue();

queue.addCommand(new HttpRequest('https://api.example.com/users', 'GET'));
queue.addCommand(new HttpRequest('https://api.example.com/posts', 'POST', { title: 'New Post' }));
```

**When to use:** When you want to parameterize objects with operations, queue operations, implement undo/redo functionality, or structure a system around high-level operations built on primitive operations.

**4. Other Important Patterns**

**a) Mediator Pattern**

Defines an object that encapsulates how a set of objects interact, promoting loose coupling by keeping objects from referring to each other explicitly.

```javascript
// Mediator
class ChatRoom {
  constructor() {
    this.users = {};
  }
  
  register(user) {
    this.users[user.name] = user;
    user.chatroom = this;
  }
  
  send(message, from, to) {
    if (to) {
      // Direct message to a specific user
      this.users[to].receive(message, from);
    } else {
      // Broadcast message to all users except sender
      for (const key in this.users) {
        if (this.users[key] !== from) {
          this.users[key].receive(message, from);
        }
      }
    }
  }
}

// Colleagues
class User {
  constructor(name) {
    this.name = name;
    this.chatroom = null;
  }
  
  send(message, to) {
    this.chatroom.send(message, this, to);
  }
  
  receive(message, from) {
    console.log(`${from.name} to ${this.name}: ${message}`);
  }
}

// Usage
const chatroom = new ChatRoom();

const john = new User('John');
const jane = new User('Jane');
const bob = new User('Bob');

chatroom.register(john);
chatroom.register(jane);
chatroom.register(bob);

john.send('Hello everyone!'); // Broadcast message
// John to Jane: Hello everyone!
// John to Bob: Hello everyone!

jane.send('Hi John, how are you?', 'John'); // Direct message
// Jane to John: Hi John, how are you?
```

**When to use:** When a set of objects communicate in well-defined but complex ways, or when you want to customize behavior distributed between several objects without creating too many subclasses.

**b) Chain of Responsibility Pattern**

Passes a request along a chain of handlers, with each handler deciding either to process the request or pass it to the next handler in the chain.

```javascript
// Handler interface (implicit in JavaScript)
// Each handler must implement handle method

// Concrete handlers
class AuthenticationHandler {
  constructor(next = null) {
    this.next = next;
  }
  
  setNext(handler) {
    this.next = handler;
    return handler;
  }
  
  handle(request) {
    if (!request.token) {
      return { success: false, error: 'Authentication failed: No token provided' };
    }
    
    // Validate token (simplified)
    if (request.token !== 'valid-token') {
      return { success: false, error: 'Authentication failed: Invalid token' };
    }
    
    console.log('Authentication successful');
    
    // Pass to the next handler if it exists
    if (this.next) {
      return this.next.handle(request);
    }
    
    return { success: true };
  }
}

class AuthorizationHandler {
  constructor(next = null) {
    this.next = next;
  }
  
  setNext(handler) {
    this.next = handler;
    return handler;
  }
  
  handle(request) {
    if (!request.user || !request.user.permissions) {
      return { success: false, error: 'Authorization failed: No user permissions' };
    }
    
    // Check if user has required permission
    if (!request.user.permissions.includes(request.requiredPermission)) {
      return { success: false, error: `Authorization failed: Missing permission ${request.requiredPermission}` };
    }
    
    console.log('Authorization successful');
    
    // Pass to the next handler if it exists
    if (this.next) {
      return this.next.handle(request);
    }
    
    return { success: true };
  }
}

class ValidationHandler {
  constructor(next = null) {
    this.next = next;
  }
  
  setNext(handler) {
    this.next = handler;
    return handler;
  }
  
  handle(request) {
    if (!request.data) {
      return { success: false, error: 'Validation failed: No data provided' };
    }
    
    // Validate required fields
    if (!request.data.name || !request.data.email) {
      return { success: false, error: 'Validation failed: Missing required fields' };
    }
    
    // Validate email format
    const emailRegex = /^[^@\s]+@[^@\s]+\.[^@\s]+$/;
    if (!emailRegex.test(request.data.email)) {
      return { success: false, error: 'Validation failed: Invalid email format' };
    }
    
    console.log('Validation successful');
    
    // Pass to the next handler if it exists
    if (this.next) {
      return this.next.handle(request);
    }
    
    return { success: true };
  }
}

// Usage
const authHandler = new AuthenticationHandler();
const authorizationHandler = new AuthorizationHandler();
const validationHandler = new ValidationHandler();

// Set up the chain
authHandler.setNext(authorizationHandler).setNext(validationHandler);

// Process request
const request = {
  token: 'valid-token',
  user: {
    id: 123,
    permissions: ['read', 'write']
  },
  requiredPermission: 'write',
  data: {
    name: 'John Doe',
    email: 'john@example.com'
  }
};

const result = authHandler.handle(request);
console.log(result); // { success: true }

// Failed request
const invalidRequest = {
  token: 'valid-token',
  user: {
    id: 123,
    permissions: ['read']
  },
  requiredPermission: 'write',
  data: {
    name: 'John Doe',
    email: 'john@example.com'
  }
};

const failedResult = authHandler.handle(invalidRequest);
console.log(failedResult); // { success: false, error: 'Authorization failed: Missing permission write' }
```

**When to use:** When more than one object may handle a request, and the handler isn't known in advance, or when you want to issue a request to one of several objects without specifying the receiver explicitly.

**c) Mixin Pattern**

Allows objects to borrow functionality from multiple sources, promoting code reuse.

```javascript
// Mixins
const loggingMixin = {
  log(message) {
    console.log(`[${new Date().toISOString()}] ${message}`);
  },
  warn(message) {
    console.warn(`[${new Date().toISOString()}] WARNING: ${message}`);
  },
  error(message) {
    console.error(`[${new Date().toISOString()}] ERROR: ${message}`);
  }
};

const eventMixin = {
  events: {},
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
    return this;
  },
  trigger(event, ...args) {
    if (this.events[event]) {
      this.events[event].forEach(callback => callback(...args));
    }
    return this;
  },
  off(event, callback) {
    if (this.events[event]) {
      this.events[event] = callback 
        ? this.events[event].filter(cb => cb !== callback)
        : [];
    }
    return this;
  }
};

// Usage with Object.assign
class UserService {
  constructor() {
    this.users = [];
  }
  
  addUser(user) {
    this.users.push(user);
    this.log(`User added: ${user.name}`);
    this.trigger('userAdded', user);
  }
  
  removeUser(userId) {
    const index = this.users.findIndex(user => user.id === userId);
    if (index !== -1) {
      const user = this.users[index];
      this.users.splice(index, 1);
      this.log(`User removed: ${user.name}`);
      this.trigger('userRemoved', user);
      return true;
    }
    this.warn(`User not found: ${userId}`);
    return false;
  }
}

// Apply mixins
Object.assign(UserService.prototype, loggingMixin, eventMixin);

// Usage
const userService = new UserService();

userService.on('userAdded', user => {
  console.log(`Event: User ${user.name} was added`);
});

userService.addUser({ id: 1, name: 'John' });
// [2023-...] User added: John
// Event: User John was added

// Using mixins with ES6 classes
function applyMixins(derivedCtor, baseCtors) {
  baseCtors.forEach(baseCtor => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
      if (name !== 'constructor') {
        derivedCtor.prototype[name] = baseCtor.prototype[name];
      }
    });
  });
}

class Loggable {
  log(message) {
    console.log(`[${this.constructor.name}] ${message}`);
  }
}

class Serializable {
  serialize() {
    return JSON.stringify(this);
  }
  
  deserialize(json) {
    const data = JSON.parse(json);
    Object.assign(this, data);
  }
}

class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  greet() {
    this.log(`Hello, my name is ${this.name}`);
  }
}

// Apply mixins
applyMixins(Person, [Loggable, Serializable]);

// Usage
const person = new Person('Alice', 30);
person.greet(); // [Person] Hello, my name is Alice

const serialized = person.serialize();
console.log(serialized); // {"name":"Alice","age":30}

const newPerson = new Person();
newPerson.deserialize(serialized);
console.log(newPerson.name); // Alice
```

**When to use:** When you want to add functionality to objects or classes without using inheritance, or when you need to share behavior between unrelated classes.

**Key Takeaways:**

1. Design patterns provide proven solutions to common software design problems, making code more maintainable and scalable
2. Creational patterns like Factory, Singleton, and Module help manage object creation and organization
3. Structural patterns like Decorator, Adapter, and Proxy focus on object composition and relationships
4. Behavioral patterns like Observer, Strategy, and Command deal with communication between objects
5. JavaScript's dynamic nature and functional capabilities allow for flexible implementation of design patterns
6. Modern JavaScript (ES6+) provides features like classes, modules, and proxies that make implementing certain patterns more elegant
7. Choose patterns based on specific problems rather than trying to force patterns into your code
8. Understanding design patterns helps communicate architecture decisions with other developers
9. Many frameworks and libraries use design patterns extensively (React's component model, Redux's store, etc.)
10. Patterns should simplify your code, not complicate it - if a pattern makes your code harder to understand, reconsider its use

## JavaScript Performance and Testing

### Q92: What are the best practices for optimizing JavaScript performance? How would you identify and fix performance bottlenecks?
**Difficulty: Hard**

**Answer:**
Optimizing JavaScript performance is crucial for creating responsive web applications that provide a smooth user experience. Performance optimization involves understanding how JavaScript engines work, identifying bottlenecks, and applying appropriate techniques to address them.

**1. Understanding JavaScript Performance**

**a) JavaScript Engine Basics**

Modern JavaScript engines (like V8 in Chrome, SpiderMonkey in Firefox) use Just-In-Time (JIT) compilation to convert JavaScript into optimized machine code. Understanding how these engines work can help write more optimizable code:

- **Parsing**: Converting source code into an Abstract Syntax Tree (AST)
- **Compilation**: Converting AST into bytecode and then optimized machine code
- **Execution**: Running the compiled code
- **Garbage Collection**: Reclaiming memory from objects no longer in use
- **Optimization/Deoptimization**: Dynamically optimizing hot code paths and reverting optimizations when assumptions are invalidated

**b) Common Performance Bottlenecks**

- **Rendering Performance**: Layout thrashing, expensive repaints, and reflows
- **JavaScript Execution**: Long-running scripts, inefficient algorithms
- **Memory Usage**: Memory leaks, excessive allocations
- **Network Performance**: Large bundles, excessive API calls
- **Startup Time**: Code that blocks the main thread during initial load

**2. Measuring Performance**

Before optimizing, you need to measure and identify actual bottlenecks:

**a) Browser DevTools**

```javascript
// Performance measurement using the Performance API
performance.mark('myFunction-start');

// Code to measure
function myExpensiveOperation() {
  // Expensive operation here
  const result = [];
  for (let i = 0; i < 10000; i++) {
    result.push(Math.sqrt(i));
  }
  return result;
}

const result = myExpensiveOperation();

performance.mark('myFunction-end');
performance.measure('myFunction', 'myFunction-start', 'myFunction-end');

// Log the measurement
console.log(performance.getEntriesByName('myFunction')[0].duration + 'ms');
```

**b) Profiling Tools**

- **Chrome DevTools Performance Panel**: Records and analyzes runtime performance
- **Lighthouse**: Audits web apps for performance, accessibility, and more
- **WebPageTest**: Analyzes page load performance across different devices and networks

**c) Custom Timing Measurements**

```javascript
// Simple timing with console.time
console.time('Array initialization');
const arr = new Array(1000000).fill(0).map((_, i) => i);
console.timeEnd('Array initialization');

// Using Date for Node.js environments without performance API
function measureExecutionTime(fn, ...args) {
  const start = Date.now();
  const result = fn(...args);
  const end = Date.now();
  console.log(`Execution time: ${end - start}ms`);
  return result;
}

// Usage
const sortedArray = measureExecutionTime(array => {
  return [...array].sort((a, b) => a - b);
}, [5, 3, 1, 4, 2]);
```

**3. JavaScript Optimization Techniques**

**a) Optimizing Loops and Iterations**

```javascript
// Inefficient
for (let i = 0; i < array.length; i++) {
  // array.length is recalculated in each iteration
}

// More efficient - cache the length
for (let i = 0, len = array.length; i < len; i++) {
  // length is calculated once
}

// Often more readable with modern syntax
array.forEach(item => {
  // process item
});

// Even better for many operations - use appropriate array methods
const doubled = array.map(x => x * 2);
const evens = array.filter(x => x % 2 === 0);
const sum = array.reduce((acc, val) => acc + val, 0);

// For simple iterations where index isn't needed
for (const item of array) {
  // process item
}
```

**b) Efficient DOM Manipulation**

```javascript
// Inefficient - causes multiple reflows
function addItems(items) {
  const list = document.getElementById('myList');
  items.forEach(item => {
    list.appendChild(document.createElement('li')).textContent = item;
    // Each appendChild causes a reflow
  });
}

// More efficient - use DocumentFragment
function addItemsOptimized(items) {
  const fragment = document.createDocumentFragment();
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    fragment.appendChild(li);
  });
  document.getElementById('myList').appendChild(fragment);
  // Only one reflow at the end
}

// Batch DOM reads and writes
function updateElementDimensions(elements) {
  // Read phase - gather all measurements
  const measurements = elements.map(el => ({
    width: el.offsetWidth,
    height: el.offsetHeight
  }));
  
  // Write phase - apply updates
  elements.forEach((el, i) => {
    const { width, height } = measurements[i];
    el.style.width = `${width * 2}px`;
    el.style.height = `${height * 2}px`;
  });
}
```

**c) Optimizing Object and Array Operations**

```javascript
// Object property access optimization
function processUser(user) {
  // Cache deeply nested properties
  const address = user.contact.address;
  
  // Now use the cached reference
  const formattedAddress = `${address.street}, ${address.city}, ${address.country}`;
  
  return formattedAddress;
}

// Array optimization - preallocate when size is known
function createMatrix(size) {
  // Preallocate the array with correct size
  const matrix = new Array(size);
  
  for (let i = 0; i < size; i++) {
    matrix[i] = new Array(size).fill(0);
  }
  
  return matrix;
}

// Use appropriate data structures
function findFrequentItems(items) {
  // Using Map instead of plain object for frequency counting
  const frequency = new Map();
  
  for (const item of items) {
    frequency.set(item, (frequency.get(item) || 0) + 1);
  }
  
  return frequency;
}

// Use Set for unique values
function uniqueValues(array) {
  return [...new Set(array)];
}
```

**d) Function Optimization**

```javascript
// Avoid creating functions in loops
// Bad
for (let i = 0; i < 1000; i++) {
  element.addEventListener('click', function() {
    console.log('Clicked element', i);
  });
}

// Good - define the function outside the loop
function handleClick(i) {
  return function() {
    console.log('Clicked element', i);
  };
}

for (let i = 0; i < 1000; i++) {
  element.addEventListener('click', handleClick(i));
}

// Use memoization for expensive calculations
function memoize(fn) {
  const cache = new Map();
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
}

// Usage
const expensiveCalculation = memoize((n) => {
  console.log('Computing...');
  return fibonacci(n); // Some expensive calculation
});

expensiveCalculation(40); // Computes and caches
expensiveCalculation(40); // Returns cached result
```

**e) Debouncing and Throttling**

```javascript
// Debounce - execute function only after a certain time has passed
function debounce(fn, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// Usage
const debouncedSearch = debounce((query) => {
  fetchSearchResults(query);
}, 300);

searchInput.addEventListener('input', (e) => {
  debouncedSearch(e.target.value);
});

// Throttle - execute function at most once per specified time
function throttle(fn, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;
      setTimeout(() => {
        inThrottle = false;
      }, limit);
    }
  };
}

// Usage
const throttledScroll = throttle(() => {
  updateScrollAnimation();
}, 100);

window.addEventListener('scroll', throttledScroll);
```

**4. Memory Optimization**

**a) Preventing Memory Leaks**

```javascript
// Common memory leak - forgotten event listeners
function setupEventHandlers() {
  const button = document.getElementById('myButton');
  const data = loadLargeData();
  
  // This creates a closure that holds a reference to 'data'
  button.addEventListener('click', function() {
    processData(data);
  });
}

// Fix: Remove event listeners when no longer needed
function setupEventHandlersFixed() {
  const button = document.getElementById('myButton');
  const data = loadLargeData();
  
  const handleClick = function() {
    processData(data);
  };
  
  button.addEventListener('click', handleClick);
  
  // Store the cleanup function
  return function cleanup() {
    button.removeEventListener('click', handleClick);
    // Allow data to be garbage collected
    data = null;
  };
}

// Memory leak with setInterval
function startTimer() {
  const largeData = new Array(1000000).fill('x');
  
  setInterval(() => {
    console.log(largeData.length);
  }, 1000);
}

// Fix: Store interval ID and provide a way to clear it
function startTimerFixed() {
  const largeData = new Array(1000000).fill('x');
  
  const intervalId = setInterval(() => {
    console.log(largeData.length);
  }, 1000);
  
  return function stopTimer() {
    clearInterval(intervalId);
  };
}
```

**b) Efficient Object Creation and Reuse**

```javascript
// Object pooling for frequently created/destroyed objects
class ObjectPool {
  constructor(createFn, initialSize = 10) {
    this.createFn = createFn;
    this.pool = [];
    
    // Pre-fill the pool
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.createFn());
    }
  }
  
  get() {
    return this.pool.length > 0 ? this.pool.pop() : this.createFn();
  }
  
  release(obj) {
    this.pool.push(obj);
  }
}

// Usage
const particlePool = new ObjectPool(() => ({
  x: 0,
  y: 0,
  velocity: { x: 0, y: 0 },
  active: false,
  reset() {
    this.x = 0;
    this.y = 0;
    this.velocity.x = 0;
    this.velocity.y = 0;
    this.active = false;
  }
}), 100);

function createParticleEffect() {
  const particles = [];
  
  for (let i = 0; i < 50; i++) {
    const particle = particlePool.get();
    // Configure particle
    particle.x = Math.random() * 100;
    particle.y = Math.random() * 100;
    particle.active = true;
    particles.push(particle);
  }
  
  // Later, when done with particles
  particles.forEach(p => {
    p.reset();
    particlePool.release(p);
  });
}
```

**5. Rendering Performance**

**a) Optimizing Animations**

```javascript
// Use requestAnimationFrame for smooth animations
function animateElement(element) {
  let position = 0;
  let direction = 1;
  
  function step() {
    position += direction;
    
    if (position >= 300) direction = -1;
    if (position <= 0) direction = 1;
    
    // Use transform instead of left/top for better performance
    element.style.transform = `translateX(${position}px)`;
    
    requestAnimationFrame(step);
  }
  
  requestAnimationFrame(step);
}

// Optimize animations with CSS properties that don't trigger layout
// Good properties: transform, opacity
// Avoid: width, height, top, left, margin, padding

// Use will-change for elements that will animate
function prepareForAnimation(element) {
  // Inform browser this element will change
  element.style.willChange = 'transform';
  
  // Later, when animation is complete
  function cleanupAfterAnimation() {
    element.style.willChange = 'auto';
  }
}
```

**b) Avoiding Layout Thrashing**

```javascript
// Bad - causes layout thrashing
function resizeAllElements(elements) {
  elements.forEach(el => {
    const height = el.offsetHeight; // Forces layout/reflow
    el.style.height = (height * 2) + 'px'; // Forces another reflow
  });
}

// Good - batch reads and writes
function resizeAllElementsOptimized(elements) {
  // Read phase
  const heights = elements.map(el => el.offsetHeight);
  
  // Write phase
  elements.forEach((el, i) => {
    el.style.height = (heights[i] * 2) + 'px';
  });
}
```

**6. Network Optimization**

**a) Code Splitting and Lazy Loading**

```javascript
// Modern bundlers support dynamic imports
button.addEventListener('click', async () => {
  // Load module only when needed
  const { default: VideoPlayer } = await import('./video-player.js');
  
  const player = new VideoPlayer();
  player.initialize('#video-container');
});

// React lazy loading example
import React, { Suspense, lazy } from 'react';

// Lazy load the component
const HeavyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <HeavyComponent />
      </Suspense>
    </div>
  );
}
```

**b) Caching and Memoization**

```javascript
// Cache API responses
const apiCache = new Map();

async function fetchWithCache(url, options = {}) {
  const cacheKey = `${url}-${JSON.stringify(options)}`;
  
  // Check cache first
  if (apiCache.has(cacheKey)) {
    return apiCache.get(cacheKey);
  }
  
  // If not in cache, make the request
  const response = await fetch(url, options);
  const data = await response.json();
  
  // Store in cache
  apiCache.set(cacheKey, data);
  
  return data;
}

// React useMemo example
import { useMemo } from 'react';

function ExpensiveComponent({ data, filter }) {
  // Only recalculate when dependencies change
  const filteredData = useMemo(() => {
    console.log('Filtering data...');
    return data.filter(item => item.name.includes(filter));
  }, [data, filter]);
  
  return (
    <ul>
      {filteredData.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```

**7. Advanced Optimization Techniques**

**a) Web Workers for CPU-Intensive Tasks**

```javascript
// main.js
function startHeavyComputation() {
  const worker = new Worker('worker.js');
  
  worker.onmessage = function(e) {
    console.log('Result from worker:', e.data);
    // Update UI with result
    document.getElementById('result').textContent = e.data.result;
  };
  
  worker.postMessage({
    numbers: Array.from({ length: 10000000 }, (_, i) => i)
  });
}

// worker.js
self.onmessage = function(e) {
  const numbers = e.data.numbers;
  
  // Perform CPU-intensive calculation
  const sum = numbers.reduce((acc, val) => acc + val, 0);
  const average = sum / numbers.length;
  
  self.postMessage({
    result: average
  });
};
```

**b) Using OffscreenCanvas for Graphics**

```javascript
// Main thread
const canvas = document.getElementById('myCanvas');
const offscreen = canvas.transferControlToOffscreen();

const worker = new Worker('canvas-worker.js');
worker.postMessage({ canvas: offscreen }, [offscreen]);

// In canvas-worker.js
self.onmessage = function(e) {
  const canvas = e.data.canvas;
  const ctx = canvas.getContext('2d');
  
  // Now you can draw on the canvas from the worker
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Complex drawing operations
    // ...
    
    requestAnimationFrame(draw);
  }
  
  draw();
};
```

**c) Using WebAssembly for Performance-Critical Code**

```javascript
// JavaScript code calling WebAssembly
async function initializeWasm() {
  const response = await fetch('math_operations.wasm');
  const buffer = await response.arrayBuffer();
  const wasmModule = await WebAssembly.instantiate(buffer);
  
  const { factorial } = wasmModule.instance.exports;
  
  // Now use the WASM function
  console.log('Factorial of 10:', factorial(10));
  
  // Compare performance
  const start = performance.now();
  for (let i = 0; i < 1000000; i++) {
    factorial(10);
  }
  console.log(`WASM took: ${performance.now() - start}ms`);
  
  const jsStart = performance.now();
  for (let i = 0; i < 1000000; i++) {
    jsFactorial(10);
  }
  console.log(`JS took: ${performance.now() - jsStart}ms`);
}

// JavaScript implementation for comparison
function jsFactorial(n) {
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}
```

**8. Framework-Specific Optimizations**

**a) React Performance Optimization**

```jsx
// Use React.memo for component memoization
const ExpensiveComponent = React.memo(function ExpensiveComponent(props) {
  // Component implementation
  return <div>{/* ... */}</div>;
});

// Use useCallback for stable function references
function ParentComponent() {
  const [count, setCount] = useState(0);
  
  // This function reference remains stable across renders
  const handleClick = useCallback(() => {
    console.log('Button clicked');
    setCount(c => c + 1);
  }, []); // Empty dependency array means it never changes
  
  return <ChildComponent onClick={handleClick} count={count} />;
}

// Use virtualization for long lists
import { FixedSizeList } from 'react-window';

function VirtualizedList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      Item {items[index]}
    </div>
  );
  
  return (
    <FixedSizeList
      height={500}
      width={300}
      itemCount={items.length}
      itemSize={35}
    >
      {Row}
    </FixedSizeList>
  );
}
```

**b) Angular Performance Optimization**

```typescript
// Use OnPush change detection strategy
@Component({
  selector: 'app-item',
  template: `<div>{{item.name}}</div>`,
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ItemComponent {
  @Input() item: any;
}

// Use trackBy with ngFor
@Component({
  selector: 'app-list',
  template: `
    <div *ngFor="let item of items; trackBy: trackByFn">
      {{item.name}}
    </div>
  `
})
export class ListComponent {
  items: any[] = [];
  
  trackByFn(index: number, item: any): number {
    return item.id; // Unique identifier
  }
}
```

**9. Performance Testing and Monitoring**

**a) Automated Performance Testing**

```javascript
// Using Lighthouse programmatically
const lighthouse = require('lighthouse');
const chromeLauncher = require('chrome-launcher');

async function runLighthouseTest() {
  const chrome = await chromeLauncher.launch();
  const options = {
    port: chrome.port,
    onlyCategories: ['performance']
  };
  
  const result = await lighthouse('https://example.com', options);
  console.log('Performance score:', result.lhr.categories.performance.score * 100);
  
  await chrome.kill();
}

// Using Performance Observer API
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    console.log('Long task:', entry.duration, 'ms');
  }
});

observer.observe({ entryTypes: ['longtask'] });
```

**b) Real User Monitoring (RUM)**

```javascript
// Basic RUM implementation
function capturePerformanceMetrics() {
  // Wait for the page to fully load
  window.addEventListener('load', () => {
    setTimeout(() => {
      const navigationTiming = performance.getEntriesByType('navigation')[0];
      const paintTiming = performance.getEntriesByType('paint');
      
      const metrics = {
        // Navigation timing
        dnsLookup: navigationTiming.domainLookupEnd - navigationTiming.domainLookupStart,
        tcpConnection: navigationTiming.connectEnd - navigationTiming.connectStart,
        serverResponse: navigationTiming.responseStart - navigationTiming.requestStart,
        domComplete: navigationTiming.domComplete - navigationTiming.responseEnd,
        pageLoad: navigationTiming.loadEventEnd - navigationTiming.startTime,
        
        // Paint timing
        firstPaint: paintTiming.find(entry => entry.name === 'first-paint')?.startTime,
        firstContentfulPaint: paintTiming.find(entry => entry.name === 'first-contentful-paint')?.startTime,
      };
      
      // Send metrics to analytics server
      navigator.sendBeacon('/analytics', JSON.stringify(metrics));
    }, 0);
  });
}
```

**10. Performance Optimization Checklist**

1. **Measure First**: Use profiling tools to identify actual bottlenecks before optimizing
2. **Optimize Critical Rendering Path**: Minimize render-blocking resources
3. **Reduce JavaScript Bundle Size**: Use code splitting, tree shaking, and minification
4. **Optimize Images and Media**: Use proper formats, compression, and lazy loading
5. **Implement Efficient DOM Operations**: Minimize reflows and repaints
6. **Use Appropriate Data Structures and Algorithms**: Choose the right tool for the job
7. **Implement Caching Strategies**: Cache API responses, computation results
8. **Optimize Event Handlers**: Use debouncing and throttling for frequent events
9. **Prevent Memory Leaks**: Clean up event listeners and references
10. **Consider Advanced Techniques**: Web Workers, WebAssembly for CPU-intensive tasks

**Key Takeaways:**

1. Always measure performance before and after optimization to ensure your changes are effective
2. Focus on optimizing the critical rendering path to improve perceived performance
3. Use appropriate data structures and algorithms for your specific use case
4. Batch DOM operations and minimize reflows/repaints for better rendering performance
5. Implement debouncing and throttling for event handlers that fire frequently
6. Use code splitting and lazy loading to reduce initial JavaScript bundle size
7. Leverage browser caching and memoization to avoid redundant operations
8. Offload CPU-intensive tasks to Web Workers to keep the main thread responsive
9. Implement memory management best practices to prevent leaks
10. Consider framework-specific optimizations for React, Angular, Vue, etc.

### Q93: What are the different testing strategies for JavaScript applications? How would you implement a comprehensive testing approach?
**Difficulty: Hard**

**Answer:**
Testing is a critical aspect of JavaScript application development that ensures code quality, prevents regressions, and facilitates safe refactoring. A comprehensive testing strategy typically involves multiple testing types and levels, each serving different purposes in the development lifecycle.

**1. Types of Testing in JavaScript Applications**

**a) Unit Testing**

Unit tests focus on testing individual functions, methods, or components in isolation, typically mocking any dependencies.

```javascript
// Function to test
function calculateTotal(items) {
  return items.reduce((total, item) => total + item.price * item.quantity, 0);
}

// Jest unit test
describe('calculateTotal', () => {
  test('calculates the total price correctly', () => {
    const items = [
      { name: 'Item 1', price: 10, quantity: 2 },
      { name: 'Item 2', price: 15, quantity: 1 }
    ];
    
    expect(calculateTotal(items)).toBe(35); // 10*2 + 15*1 = 35
  });
  
  test('returns 0 for empty array', () => {
    expect(calculateTotal([])).toBe(0);
  });
});
```

**b) Integration Testing**

Integration tests verify that different parts of the application work together correctly.

```javascript
// Integration test for a user service and authentication module
describe('User Authentication Flow', () => {
  test('authenticates user and updates user profile', async () => {
    // Setup
    const credentials = { username: 'testuser', password: 'password123' };
    const userProfile = { id: 123, name: 'Test User', email: 'test@example.com' };
    
    // Mock API responses
    mockAuthApi.login.mockResolvedValue({ token: 'fake-token' });
    mockUserApi.getProfile.mockResolvedValue(userProfile);
    
    // Execute the authentication flow
    const authService = new AuthService(mockAuthApi);
    const userService = new UserService(mockUserApi, authService);
    
    await authService.login(credentials);
    const profile = await userService.getUserProfile();
    
    // Assertions
    expect(mockAuthApi.login).toHaveBeenCalledWith(credentials);
    expect(mockUserApi.getProfile).toHaveBeenCalledWith('fake-token');
    expect(profile).toEqual(userProfile);
    expect(authService.isAuthenticated()).toBe(true);
  });
});
```

**c) End-to-End (E2E) Testing**

E2E tests simulate real user scenarios across the entire application stack.

```javascript
// Cypress E2E test
describe('Shopping Cart', () => {
  beforeEach(() => {
    cy.visit('/');
    cy.login('testuser', 'password123'); // Custom command for login
  });
  
  it('allows adding items to cart and checking out', () => {
    // Navigate to products page
    cy.get('nav').contains('Products').click();
    
    // Add item to cart
    cy.get('.product-card').first().within(() => {
      cy.get('button').contains('Add to Cart').click();
    });
    
    // Verify cart updated
    cy.get('.cart-count').should('contain', '1');
    
    // Go to cart
    cy.get('nav').contains('Cart').click();
    
    // Verify item in cart
    cy.get('.cart-items').should('contain', 'Product Name');
    
    // Proceed to checkout
    cy.get('button').contains('Checkout').click();
    
    // Fill shipping info
    cy.get('#shipping-form').within(() => {
      cy.get('input[name=address]').type('123 Test St');
      cy.get('input[name=city]').type('Test City');
      cy.get('button[type=submit]').click();
    });
    
    // Complete order
    cy.get('button').contains('Place Order').click();
    
    // Verify success message
    cy.get('.order-confirmation').should('contain', 'Order Successful');
  });
});
```

**d) Component Testing**

Component tests focus on testing UI components in isolation.

```jsx
// React component to test
function Counter({ initialCount = 0 }) {
  const [count, setCount] = useState(initialCount);
  
  return (
    <div>
      <span data-testid="count-value">{count}</span>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
    </div>
  );
}

// React Testing Library test
import { render, screen, fireEvent } from '@testing-library/react';

describe('Counter', () => {
  test('renders with initial count', () => {
    render(<Counter initialCount={5} />);
    expect(screen.getByTestId('count-value')).toHaveTextContent('5');
  });
  
  test('increments count when increment button is clicked', () => {
    render(<Counter initialCount={5} />);
    fireEvent.click(screen.getByText('Increment'));
    expect(screen.getByTestId('count-value')).toHaveTextContent('6');
  });
  
  test('decrements count when decrement button is clicked', () => {
    render(<Counter initialCount={5} />);
    fireEvent.click(screen.getByText('Decrement'));
    expect(screen.getByTestId('count-value')).toHaveTextContent('4');
  });
});
```

**e) Visual Regression Testing**

Visual regression tests capture screenshots of components or pages and compare them to baseline images to detect visual changes.

```javascript
// Using Storybook and Chromatic for visual testing
// Component story
export default {
  title: 'Components/Button',
  component: Button,
};

export const Primary = () => <Button variant="primary">Primary Button</Button>;
export const Secondary = () => <Button variant="secondary">Secondary Button</Button>;
export const Large = () => <Button size="large">Large Button</Button>;

// Chromatic configuration (chromatic.config.js)
module.exports = {
  projectToken: 'your-project-token',
  storybookBuildDir: 'storybook-static',
};

// In CI pipeline
// $ npx chromatic --project-token=your-project-token
```

**f) Performance Testing**

Performance tests measure the responsiveness and stability of your application under various conditions.

```javascript
// Using Lighthouse programmatically
const lighthouse = require('lighthouse');
const chromeLauncher = require('chrome-launcher');

async function runPerformanceTest() {
  const chrome = await chromeLauncher.launch();
  const options = {
    port: chrome.port,
    onlyCategories: ['performance'],
  };
  
  const result = await lighthouse('https://your-app.com', options);
  const performanceScore = result.lhr.categories.performance.score * 100;
  
  console.log(`Performance score: ${performanceScore}`);
  
  // Assert minimum performance score
  expect(performanceScore).toBeGreaterThanOrEqual(90);
  
  await chrome.kill();
}
```

**g) Security Testing**

Security tests identify vulnerabilities in your application.

```javascript
// Using OWASP ZAP for security scanning
const ZapClient = require('zaproxy');

async function runSecurityScan() {
  const zapOptions = {
    apiKey: 'your-api-key',
    proxy: {
      host: 'localhost',
      port: 8080
    }
  };
  
  const zaproxy = new ZapClient(zapOptions);
  
  // Start a scan
  const scanId = await zaproxy.ascan.scan({
    url: 'https://your-app.com',
    recurse: true
  });
  
  // Wait for scan to complete
  let status;
  do {
    await new Promise(resolve => setTimeout(resolve, 5000));
    status = await zaproxy.ascan.status(scanId);
  } while (status < 100);
  
  // Get alerts
  const alerts = await zaproxy.core.alerts();
  
  // Assert no high-risk vulnerabilities
  const highRiskAlerts = alerts.filter(alert => alert.risk === 'High');
  expect(highRiskAlerts.length).toBe(0);
}
```

**2. Testing Frameworks and Tools**

**a) Unit and Integration Testing Frameworks**

- **Jest**: Full-featured testing framework with built-in assertion library, mocking, and code coverage
- **Mocha**: Flexible testing framework that requires additional libraries like Chai for assertions
- **Jasmine**: Behavior-driven development framework with built-in assertion and mocking capabilities
- **Vitest**: Fast unit testing framework optimized for Vite projects

```javascript
// Jest example with mocking
jest.mock('./api');

import { fetchUserData } from './api';
import { UserService } from './user-service';

describe('UserService', () => {
  beforeEach(() => {
    fetchUserData.mockClear();
  });
  
  test('getUserInfo calls API and formats data', async () => {
    // Setup mock
    fetchUserData.mockResolvedValue({
      id: 1,
      name: 'John Doe',
      email: 'john@example.com'
    });
    
    const userService = new UserService();
    const result = await userService.getUserInfo(1);
    
    expect(fetchUserData).toHaveBeenCalledWith(1);
    expect(result).toEqual({
      id: 1,
      displayName: 'John Doe',
      contact: 'john@example.com'
    });
  });
});
```

**b) E2E Testing Tools**

- **Cypress**: Modern E2E testing framework with real-time reloading and time-travel debugging
- **Playwright**: Cross-browser automation library that supports Chromium, Firefox, and WebKit
- **Selenium**: Established browser automation tool with wide language support
- **TestCafe**: No-installation cross-browser testing solution

```javascript
// Playwright example
const { test, expect } = require('@playwright/test');

test.describe('Authentication', () => {
  test('successful login', async ({ page }) => {
    await page.goto('https://example.com/login');
    
    await page.fill('input[name="username"]', 'testuser');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    
    // Wait for navigation
    await page.waitForURL('https://example.com/dashboard');
    
    // Verify user is logged in
    const welcomeMessage = await page.textContent('.welcome-message');
    expect(welcomeMessage).toContain('Welcome, Test User');
    
    // Verify localStorage token
    const token = await page.evaluate(() => localStorage.getItem('auth_token'));
    expect(token).toBeTruthy();
  });
});
```

**c) Component Testing Libraries**

- **React Testing Library**: DOM-focused testing utilities for React components
- **Vue Test Utils**: Official testing library for Vue.js
- **Angular Testing Utilities**: Built-in testing utilities for Angular
- **Enzyme**: React testing utility with DOM manipulation capabilities

```javascript
// Vue Test Utils example
import { mount } from '@vue/test-utils';
import TodoItem from './TodoItem.vue';

describe('TodoItem', () => {
  test('emits complete event when checkbox is clicked', async () => {
    const wrapper = mount(TodoItem, {
      props: {
        todo: {
          id: 1,
          text: 'Learn Vue Testing',
          completed: false
        }
      }
    });
    
    await wrapper.find('input[type="checkbox"]').setValue(true);
    
    expect(wrapper.emitted('update:completed')).toBeTruthy();
    expect(wrapper.emitted('update:completed')[0]).toEqual([true]);
  });
  
  test('applies completed class when todo is completed', () => {
    const wrapper = mount(TodoItem, {
      props: {
        todo: {
          id: 1,
          text: 'Learn Vue Testing',
          completed: true
        }
      }
    });
    
    expect(wrapper.find('.todo-item').classes()).toContain('completed');
  });
});
```

**d) Mocking Libraries**

- **Sinon.js**: Standalone test spies, stubs, and mocks
- **MSW (Mock Service Worker)**: API mocking library that uses service workers
- **Nock**: HTTP server mocking and expectations library
- **Jest Mock Functions**: Built-in mocking capabilities in Jest

```javascript
// MSW example for API mocking
import { rest } from 'msw';
import { setupServer } from 'msw/node';

// Define request handlers
const handlers = [
  rest.get('/api/users', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json([
        { id: 1, name: 'John' },
        { id: 2, name: 'Jane' }
      ])
    );
  }),
  
  rest.post('/api/users', (req, res, ctx) => {
    const { name } = req.body;
    
    return res(
      ctx.status(201),
      ctx.json({ id: 3, name })
    );
  })
];

// Setup MSW server
const server = setupServer(...handlers);

// Start server before tests
beforeAll(() => server.listen());

// Reset handlers after each test
afterEach(() => server.resetHandlers());

// Close server after all tests
afterAll(() => server.close());

// Test that uses the mocked API
test('fetches users successfully', async () => {
  const response = await fetch('/api/users');
  const data = await response.json();
  
  expect(response.status).toBe(200);
  expect(data).toHaveLength(2);
  expect(data[0].name).toBe('John');
});
```

**3. Test-Driven Development (TDD)**

TDD is a development methodology where tests are written before the implementation code.

```javascript
// TDD example for a password validator

// 1. Write the test first
describe('passwordValidator', () => {
  test('returns true for valid passwords', () => {
    expect(passwordValidator('Abcdef1!')).toBe(true);
    expect(passwordValidator('P@ssw0rd')).toBe(true);
  });
  
  test('returns false if password is less than 8 characters', () => {
    expect(passwordValidator('Abc1!')).toBe(false);
  });
  
  test('returns false if password has no uppercase letters', () => {
    expect(passwordValidator('abcdef1!')).toBe(false);
  });
  
  test('returns false if password has no lowercase letters', () => {
    expect(passwordValidator('ABCDEF1!')).toBe(false);
  });
  
  test('returns false if password has no numbers', () => {
    expect(passwordValidator('Abcdefg!')).toBe(false);
  });
  
  test('returns false if password has no special characters', () => {
    expect(passwordValidator('Abcdef12')).toBe(false);
  });
});

// 2. Implement the function to make tests pass
function passwordValidator(password) {
  // At least 8 characters
  if (password.length < 8) return false;
  
  // At least one uppercase letter
  if (!/[A-Z]/.test(password)) return false;
  
  // At least one lowercase letter
  if (!/[a-z]/.test(password)) return false;
  
  // At least one number
  if (!/[0-9]/.test(password)) return false;
  
  // At least one special character
  if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) return false;
  
  return true;
}
```

**4. Behavior-Driven Development (BDD)**

BDD extends TDD by focusing on the behavior of the application from the user's perspective.

```javascript
// BDD style test with Cucumber.js
// Feature file: features/login.feature
/*
Feature: User Login
  As a registered user
  I want to log in to the application
  So that I can access my account

  Scenario: Successful login
    Given I am on the login page
    When I enter valid credentials
    And I click the login button
    Then I should be redirected to the dashboard
    And I should see a welcome message

  Scenario: Failed login
    Given I am on the login page
    When I enter invalid credentials
    And I click the login button
    Then I should see an error message
    And I should remain on the login page
*/

// Step definitions: features/step_definitions/login_steps.js
const { Given, When, Then } = require('@cucumber/cucumber');
const { expect } = require('chai');
const { Builder, By, until } = require('selenium-webdriver');

let driver;

Given('I am on the login page', async function() {
  driver = await new Builder().forBrowser('chrome').build();
  await driver.get('https://example.com/login');
});

When('I enter valid credentials', async function() {
  await driver.findElement(By.id('username')).sendKeys('testuser');
  await driver.findElement(By.id('password')).sendKeys('password123');
});

When('I enter invalid credentials', async function() {
  await driver.findElement(By.id('username')).sendKeys('testuser');
  await driver.findElement(By.id('password')).sendKeys('wrongpassword');
});

When('I click the login button', async function() {
  await driver.findElement(By.id('login-button')).click();
});

Then('I should be redirected to the dashboard', async function() {
  await driver.wait(until.urlContains('/dashboard'), 5000);
  const currentUrl = await driver.getCurrentUrl();
  expect(currentUrl).to.include('/dashboard');
});

Then('I should see a welcome message', async function() {
  const welcomeElement = await driver.findElement(By.className('welcome-message'));
  const welcomeText = await welcomeElement.getText();
  expect(welcomeText).to.include('Welcome');
});

Then('I should see an error message', async function() {
  const errorElement = await driver.findElement(By.className('error-message'));
  const errorText = await errorElement.getText();
  expect(errorText).to.include('Invalid credentials');
});

Then('I should remain on the login page', async function() {
  const currentUrl = await driver.getCurrentUrl();
  expect(currentUrl).to.include('/login');
});
```

**5. Testing Best Practices**

**a) Test Organization**

```javascript
// Organize tests by feature or module
// user/
//   user.service.js
//   user.service.test.js
// auth/
//   auth.service.js
//   auth.service.test.js

// Group related tests with describe blocks
describe('AuthService', () => {
  describe('login', () => {
    test('successful login with valid credentials', () => {
      // Test implementation
    });
    
    test('fails with invalid credentials', () => {
      // Test implementation
    });
    
    test('handles network errors', () => {
      // Test implementation
    });
  });
  
  describe('logout', () => {
    test('clears user session', () => {
      // Test implementation
    });
    
    test('redirects to login page', () => {
      // Test implementation
    });
  });
});
```

**b) Test Setup and Teardown**

```javascript
// Jest setup and teardown
describe('Database operations', () => {
  // Run once before all tests
  beforeAll(async () => {
    await connectToDatabase();
  });
  
  // Run before each test
  beforeEach(async () => {
    await seedTestData();
  });
  
  // Run after each test
  afterEach(async () => {
    await clearTestData();
  });
  
  // Run once after all tests
  afterAll(async () => {
    await disconnectFromDatabase();
  });
  
  test('creates a new record', async () => {
    // Test implementation
  });
  
  test('updates an existing record', async () => {
    // Test implementation
  });
});
```

**c) Test Coverage**

```javascript
// Jest coverage configuration in package.json
{
  "jest": {
    "collectCoverage": true,
    "collectCoverageFrom": [
      "src/**/*.{js,jsx}",
      "!**/node_modules/**",
      "!**/vendor/**"
    ],
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}

// Running tests with coverage
// $ npm test -- --coverage
```

**d) Snapshot Testing**

```javascript
// React component snapshot test
import renderer from 'react-test-renderer';
import Button from './Button';

describe('Button', () => {
  test('renders correctly', () => {
    const tree = renderer
      .create(<Button label="Click me" onClick={() => {}} />)
      .toJSON();
    expect(tree).toMatchSnapshot();
  });
  
  test('renders disabled state correctly', () => {
    const tree = renderer
      .create(<Button label="Click me" disabled onClick={() => {}} />)
      .toJSON();
    expect(tree).toMatchSnapshot();
  });
});
```

**6. Testing in CI/CD Pipeline**

```yaml
# GitHub Actions workflow example
name: Test and Deploy

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Setup Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '16'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Lint
      run: npm run lint
      
    - name: Unit and integration tests
      run: npm test
      
    - name: E2E tests
      run: npm run test:e2e
      
    - name: Upload coverage reports
      uses: codecov/codecov-action@v2
      
  deploy:
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Setup Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '16'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Build
      run: npm run build
      
    - name: Deploy
      run: npm run deploy
```

**7. Advanced Testing Techniques**

**a) Property-Based Testing**

```javascript
// Using fast-check for property-based testing
const fc = require('fast-check');

// Function to test
function sortNumbers(numbers) {
  return [...numbers].sort((a, b) => a - b);
}

test('sortNumbers maintains the same elements', () => {
  fc.assert(
    fc.property(
      fc.array(fc.integer()),
      (numbers) => {
        const sorted = sortNumbers(numbers);
        // Check that sorted has the same elements as input
        expect(sorted.length).toBe(numbers.length);
        
        // Check that every element in numbers is in sorted
        numbers.forEach(num => {
          const countInOriginal = numbers.filter(n => n === num).length;
          const countInSorted = sorted.filter(n => n === num).length;
          expect(countInSorted).toBe(countInOriginal);
        });
      }
    )
  );
});

test('sortNumbers produces a sorted array', () => {
  fc.assert(
    fc.property(
      fc.array(fc.integer()),
      (numbers) => {
        const sorted = sortNumbers(numbers);
        
        // Check that array is sorted
        for (let i = 1; i < sorted.length; i++) {
          expect(sorted[i]).toBeGreaterThanOrEqual(sorted[i-1]);
        }
      }
    )
  );
});
```

**b) Mutation Testing**

```javascript
// Stryker Mutator configuration (stryker.conf.js)
module.exports = {
  packageManager: 'npm',
  reporters: ['html', 'clear-text', 'progress'],
  testRunner: 'jest',
  coverageAnalysis: 'perTest',
  jest: {
    projectType: 'custom',
    configFile: './jest.config.js',
  },
  mutate: ['src/**/*.js', '!src/**/*.test.js'],
};

// Running mutation tests
// $ npx stryker run
```

**c) Contract Testing**

```javascript
// Using Pact.js for consumer-driven contract testing
// Consumer test
const { Pact } = require('@pact-foundation/pact');
const { UserService } = require('./user-service');

describe('User Service', () => {
  const provider = new Pact({
    consumer: 'MyFrontend',
    provider: 'UserAPI',
    port: 8888,
  });
  
  beforeAll(() => provider.setup());
  afterAll(() => provider.finalize());
  
  describe('get user', () => {
    beforeEach(() => {
      return provider.addInteraction({
        state: 'a user with id 1 exists',
        uponReceiving: 'a request for user 1',
        withRequest: {
          method: 'GET',
          path: '/api/users/1',
        },
        willRespondWith: {
          status: 200,
          headers: { 'Content-Type': 'application/json' },
          body: {
            id: 1,
            name: 'John Doe',
            email: 'john@example.com',
          },
        },
      });
    });
    
    test('returns user data', async () => {
      const userService = new UserService(`http://localhost:8888`);
      const user = await userService.getUser(1);
      
      expect(user).toEqual({
        id: 1,
        name: 'John Doe',
        email: 'john@example.com',
      });
    });
    
    afterEach(() => provider.verify());
  });
});
```

**8. Implementing a Comprehensive Testing Strategy**

**a) Testing Pyramid**

The testing pyramid suggests having:
- Many unit tests (fast, focused)
- Fewer integration tests (more complex, slower)
- Even fewer E2E tests (most complex, slowest)

```javascript
// Example test distribution in package.json
{
  "scripts": {
    "test": "jest",
    "test:unit": "jest --testMatch='**/*.unit.test.js'",
    "test:integration": "jest --testMatch='**/*.integration.test.js'",
    "test:e2e": "cypress run",
    "test:all": "npm run test:unit && npm run test:integration && npm run test:e2e"
  }
}
```

**b) Test Environment Configuration**

```javascript
// Jest environment configuration (jest.config.js)
module.exports = {
  // Different test environments
  testEnvironment: 'jsdom', // For browser-like environment
  // testEnvironment: 'node', // For Node.js environment
  
  // Environment setup files
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  
  // Mock file transformations
  moduleNameMapper: {
    '\\.(css|less|scss)$': '<rootDir>/__mocks__/styleMock.js',
    '\\.(jpg|jpeg|png|gif|svg)$': '<rootDir>/__mocks__/fileMock.js'
  },
  
  // Coverage configuration
  collectCoverageFrom: [
    'src/**/*.{js,jsx}',
    '!src/**/*.test.{js,jsx}',
    '!**/node_modules/**'
  ],
  
  // Test path configuration
  testMatch: [
    '<rootDir>/src/**/__tests__/**/*.{js,jsx}',
    '<rootDir>/src/**/*.{spec,test}.{js,jsx}'
  ]
};

// Jest setup file (jest.setup.js)
require('@testing-library/jest-dom');

// Mock localStorage
Object.defineProperty(window, 'localStorage', {
  value: {
    getItem: jest.fn(),
    setItem: jest.fn(),
    removeItem: jest.fn(),
    clear: jest.fn()
  },
  writable: true
});

// Mock fetch API
global.fetch = jest.fn();
```

**c) Test Data Management**

```javascript
// Test data factory
const userFactory = {
  createUser: (overrides = {}) => ({
    id: Math.floor(Math.random() * 10000),
    name: 'Test User',
    email: 'test@example.com',
    role: 'user',
    createdAt: new Date().toISOString(),
    ...overrides
  }),
  
  createAdmin: (overrides = {}) => ({
    ...userFactory.createUser(overrides),
    role: 'admin'
  }),
  
  createUserList: (count = 3, overrides = {}) => (
    Array.from({ length: count }, (_, index) => 
      userFactory.createUser({ id: index + 1, ...overrides })
    )
  )
};

// Using the factory in tests
test('filters users by role', () => {
  const users = [
    userFactory.createUser(),
    userFactory.createAdmin(),
    userFactory.createUser({ role: 'editor' })
  ];
  
  const filteredUsers = filterUsersByRole(users, 'admin');
  expect(filteredUsers).toHaveLength(1);
  expect(filteredUsers[0].role).toBe('admin');
});
```

**9. Testing Challenges and Solutions**

**a) Testing Asynchronous Code**

```javascript
// Testing Promises
test('fetchUserData resolves with user data', () => {
  return fetchUserData(1).then(data => {
    expect(data).toEqual({ id: 1, name: 'John' });
  });
});

// Using async/await
test('fetchUserData resolves with user data', async () => {
  const data = await fetchUserData(1);
  expect(data).toEqual({ id: 1, name: 'John' });
});

// Testing rejected promises
test('fetchUserData rejects when user not found', async () => {
  expect.assertions(1); // Ensure the assertion in the catch block is called
  try {
    await fetchUserData(999);
  } catch (error) {
    expect(error.message).toMatch(/not found/);
  }
});

// Alternative approach with rejects
test('fetchUserData rejects when user not found', () => {
  return expect(fetchUserData(999)).rejects.toThrow(/not found/);
});
```

**b) Testing Time-Dependent Code**

```javascript
// Using Jest fake timers
test('setTimeout callback is called after 1 second', () => {
  jest.useFakeTimers();
  
  const callback = jest.fn();
  setTimeout(callback, 1000);
  
  // Fast-forward time
  jest.advanceTimersByTime(1000);
  
  expect(callback).toHaveBeenCalled();
  
  jest.useRealTimers();
});

// Testing debounced functions
test('debounced function is called once after multiple rapid calls', () => {
  jest.useFakeTimers();
  
  const mockFn = jest.fn();
  const debouncedFn = debounce(mockFn, 300);
  
  // Call the debounced function multiple times
  debouncedFn();
  debouncedFn();
  debouncedFn();
  
  // Fast-forward time
  jest.advanceTimersByTime(300);
  
  expect(mockFn).toHaveBeenCalledTimes(1);
  
  jest.useRealTimers();
});
```

**c) Testing Random Behavior**

```javascript
// Mocking Math.random
test('generates random ID between 1000 and 9999', () => {
  // Mock Math.random to return a fixed value
  const mockMath = Object.create(global.Math);
  mockMath.random = () => 0.5; // Will give 5000 in our range
  global.Math = mockMath;
  
  const id = generateRandomId();
  expect(id).toBe(5000);
  
  // Restore original Math
  global.Math = Object.create(Math);
});
```

**10. Testing Checklist**

1. **Unit Tests**:
   - Test individual functions and components
   - Mock dependencies
   - Focus on edge cases and error handling

2. **Integration Tests**:
   - Test interactions between modules
   - Use realistic test data
   - Test API integrations

3. **E2E Tests**:
   - Cover critical user flows
   - Test across browsers if needed
   - Include form submissions and navigation

4. **Component Tests**:
   - Test rendering and user interactions
   - Verify component props and state
   - Test accessibility features

5. **Performance Tests**:
   - Measure load times and responsiveness
   - Test with realistic data volumes
   - Identify bottlenecks

6. **Security Tests**:
   - Test for common vulnerabilities
   - Validate input sanitization
   - Check authentication and authorization

7. **Accessibility Tests**:
   - Verify keyboard navigation
   - Test screen reader compatibility
   - Check color contrast and text size

8. **Cross-Browser Tests**:
   - Test on major browsers
   - Check responsive design
   - Verify polyfills for older browsers

**Key Takeaways:**

1. Implement a balanced testing strategy with unit, integration, and E2E tests
2. Choose testing tools and frameworks that match your project's needs
3. Automate tests in your CI/CD pipeline to catch issues early
4. Write maintainable tests with clear setup, execution, and assertion phases
5. Use mocking and stubbing to isolate the code being tested
6. Implement test-driven development (TDD) for critical features
7. Maintain good test coverage but focus on quality over quantity
8. Test both happy paths and edge cases, including error handling
9. Keep tests fast to encourage frequent running
10. Regularly review and refactor tests alongside application code

## Functional Programming and Web APIs

### Q94: Explain functional programming concepts in JavaScript. How can they improve code quality?
**Difficulty: Hard**

**Answer:**
Functional programming (FP) is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. JavaScript, being a multi-paradigm language, supports many functional programming concepts that can lead to more predictable, testable, and maintainable code.

**1. Core Functional Programming Concepts in JavaScript**

**a) First-Class Functions**

In JavaScript, functions are first-class citizens, meaning they can be:
- Assigned to variables
- Passed as arguments to other functions
- Returned from other functions
- Stored in data structures

```javascript
// Assigning a function to a variable
const greet = function(name) {
  return `Hello, ${name}!`;
};

// Passing a function as an argument
function executeFunction(fn, value) {
  return fn(value);
}

const result = executeFunction(greet, 'Alice'); // "Hello, Alice!"

// Returning a function from another function
function createMultiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15

// Storing functions in data structures
const functionArray = [
  x => x * 2,
  x => x * x,
  x => Math.sqrt(x)
];

const number = 4;
const transformations = functionArray.map(fn => fn(number));
console.log(transformations); // [8, 16, 2]
```

**b) Pure Functions**

Pure functions are functions that:
- Given the same input, always return the same output
- Have no side effects (don't modify external state)
- Don't depend on external state

```javascript
// Pure function
function add(a, b) {
  return a + b;
}

// Impure function (depends on external state)
let counter = 0;
function incrementCounter() {
  counter++;
  return counter;
}

// Impure function (modifies external state)
function addToArray(arr, item) {
  arr.push(item); // Modifies the original array
  return arr;
}

// Pure alternative to addToArray
function pureAddToArray(arr, item) {
  return [...arr, item]; // Returns a new array
}

const originalArray = [1, 2, 3];
const newArray = pureAddToArray(originalArray, 4);

console.log(originalArray); // [1, 2, 3] - unchanged
console.log(newArray);      // [1, 2, 3, 4] - new array
```

**c) Immutability**

Immutability means not changing data once it's created. Instead of modifying existing data, you create new copies with the desired changes.

```javascript
// Mutable approach
const mutableUser = { name: 'John', age: 30 };
mutableUser.age = 31; // Directly modifying the object

// Immutable approach
const user = { name: 'John', age: 30 };
const updatedUser = { ...user, age: 31 }; // Creating a new object

// Immutable array operations
const numbers = [1, 2, 3, 4, 5];

// Instead of numbers.push(6)
const withAddedNumber = [...numbers, 6];

// Instead of numbers.splice(2, 1)
const withoutThirdNumber = numbers.filter((_, index) => index !== 2);

// Instead of numbers[0] = 10
const withReplacedFirst = [10, ...numbers.slice(1)];

// Using Object.freeze for shallow immutability
const frozenUser = Object.freeze({ name: 'John', age: 30 });
// frozenUser.age = 31; // This will fail in strict mode or be silently ignored
```

**d) Higher-Order Functions**

Higher-order functions either take functions as arguments or return functions as results, or both.

```javascript
// Array methods as higher-order functions
const numbers = [1, 2, 3, 4, 5];

// map takes a function and returns a new array
const doubled = numbers.map(n => n * 2);

// filter takes a predicate function and returns a new array
const evens = numbers.filter(n => n % 2 === 0);

// reduce takes a reducer function and returns a single value
const sum = numbers.reduce((acc, n) => acc + n, 0);

// Creating a higher-order function
function compose(f, g) {
  return function(x) {
    return f(g(x));
  };
}

const addOne = x => x + 1;
const square = x => x * x;

const addOneThenSquare = compose(square, addOne);
console.log(addOneThenSquare(2)); // 9 (square(addOne(2)) = square(3) = 9)
```

**e) Function Composition**

Function composition is the process of combining two or more functions to produce a new function.

```javascript
// Basic function composition
const add10 = x => x + 10;
const multiply2 = x => x * 2;

// Manual composition
const add10ThenMultiply2 = x => multiply2(add10(x));
console.log(add10ThenMultiply2(5)); // 30

// Generic compose function (right to left)
const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);

// Generic pipe function (left to right)
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);

const add10AndMultiply2 = compose(multiply2, add10);
console.log(add10AndMultiply2(5)); // 30

const processNumber = pipe(
  x => x + 1,    // First add 1
  x => x * 2,    // Then multiply by 2
  x => x ** 2    // Then square it
);

console.log(processNumber(3)); // 64: ((3 + 1) * 2)² = (4 * 2)² = 8² = 64
```

**f) Recursion**

Recursion is a technique where a function calls itself to solve a problem.

```javascript
// Factorial using recursion
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}

console.log(factorial(5)); // 120

// Fibonacci sequence using recursion
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(6)); // 8

// Tail-recursive factorial (optimized)
function tailFactorial(n, accumulator = 1) {
  if (n <= 1) return accumulator;
  return tailFactorial(n - 1, n * accumulator);
}

console.log(tailFactorial(5)); // 120
```

**g) Currying**

Currying is the technique of translating a function that takes multiple arguments into a sequence of functions that each take a single argument.

```javascript
// Regular function with multiple arguments
function add(a, b, c) {
  return a + b + c;
}

// Curried version
function curriedAdd(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

// Using arrow functions for more concise syntax
const arrowCurriedAdd = a => b => c => a + b + c;

console.log(add(1, 2, 3)); // 6
console.log(curriedAdd(1)(2)(3)); // 6
console.log(arrowCurriedAdd(1)(2)(3)); // 6

// Partial application with currying
const addTo10 = arrowCurriedAdd(10);
const add15And = addTo10(5);
console.log(add15And(3)); // 18

// Generic curry function
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    return function(...moreArgs) {
      return curried.apply(this, args.concat(moreArgs));
    };
  };
}

const curriedSum = curry((a, b, c) => a + b + c);
console.log(curriedSum(1)(2)(3)); // 6
console.log(curriedSum(1, 2)(3)); // 6
console.log(curriedSum(1)(2, 3)); // 6
```

**h) Functors and Monads**

Functors are objects that implement a map method. Monads are functors that also implement flatMap (chain) operations.

```javascript
// Maybe monad - handles null/undefined values safely
class Maybe {
  constructor(value) {
    this.value = value;
  }
  
  static of(value) {
    return new Maybe(value);
  }
  
  isNothing() {
    return this.value === null || this.value === undefined;
  }
  
  map(fn) {
    return this.isNothing() ? Maybe.of(null) : Maybe.of(fn(this.value));
  }
  
  flatMap(fn) {
    return this.isNothing() ? Maybe.of(null) : fn(this.value);
  }
  
  getOrElse(defaultValue) {
    return this.isNothing() ? defaultValue : this.value;
  }
}

// Using Maybe to safely access nested properties
function getNestedProperty(obj, path) {
  return path.split('.')
    .reduce((acc, prop) => acc.flatMap(val => Maybe.of(val[prop])), Maybe.of(obj))
    .getOrElse(undefined);
}

const user = {
  name: 'John',
  address: {
    street: '123 Main St',
    city: 'Anytown'
  }
};

console.log(getNestedProperty(user, 'address.city')); // 'Anytown'
console.log(getNestedProperty(user, 'address.zipCode')); // undefined
console.log(getNestedProperty(user, 'contact.email')); // undefined
```

**2. Benefits of Functional Programming**

**a) Predictability and Testability**

Pure functions are predictable and easy to test because they always produce the same output for the same input and have no side effects.

```javascript
// Pure function - easy to test
function calculateTax(amount, taxRate) {
  return amount * taxRate;
}

// Tests are straightforward
test('calculateTax calculates tax correctly', () => {
  expect(calculateTax(100, 0.1)).toBe(10);
  expect(calculateTax(200, 0.2)).toBe(40);
});
```

**b) Modularity and Composability**

Functional programming encourages breaking down complex operations into small, reusable functions that can be composed together.

```javascript
// Small, focused functions
const normalize = str => str.trim().toLowerCase();
const capitalize = str => str.charAt(0).toUpperCase() + str.slice(1);
const appendPeriod = str => str.endsWith('.') ? str : `${str}.`;

// Composing them together
const formatSentence = pipe(normalize, capitalize, appendPeriod);

console.log(formatSentence('  hello world  ')); // 'Hello world.'
```

**c) Concurrency and Parallelism**

Immutability and pure functions make concurrent programming safer and more predictable.

```javascript
// Safe for concurrent operations because it doesn't modify shared state
function processData(data) {
  return data.map(item => transformItem(item));
}

// Can be safely used with parallel processing
async function processInParallel(items, processFn, batchSize = 5) {
  const results = [];
  
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    const batchPromises = batch.map(processFn);
    const batchResults = await Promise.all(batchPromises);
    results.push(...batchResults);
  }
  
  return results;
}
```

**d) Debugging and Maintenance**

Functional code is often easier to debug and maintain because functions are isolated and have clear inputs and outputs.

```javascript
// Traditional approach with shared state
let total = 0;
let taxRate = 0.1;

function updateTotal(price) {
  total += price + (price * taxRate); // Depends on external state
}

// Functional approach
function calculateTotal(items, taxRate) {
  return items.reduce((total, item) => {
    const itemWithTax = item + (item * taxRate);
    return total + itemWithTax;
  }, 0);
}

// If there's a bug, it's contained within the function
// and we can trace exactly what inputs produced what outputs
```

**3. Functional Programming Libraries in JavaScript**

**a) Lodash/FP and Ramda**

These libraries provide utility functions that follow functional programming principles.

```javascript
// Using Ramda
const R = require('ramda');

const users = [
  { name: 'John', age: 25, active: true },
  { name: 'Jane', age: 32, active: false },
  { name: 'Bob', age: 17, active: true }
];

// Get names of active users over 18
const getActiveAdultNames = R.pipe(
  R.filter(user => user.active && user.age >= 18),
  R.map(R.prop('name')),
  R.sort
);

console.log(getActiveAdultNames(users)); // ['John']

// Using Lodash/FP
const _ = require('lodash/fp');

const getActiveAdultNamesLodash = _.flow(
  _.filter(user => user.active && user.age >= 18),
  _.map('name'),
  _.sortBy(_.identity)
);

console.log(getActiveAdultNamesLodash(users)); // ['John']
```

**b) Immutable.js**

Immutable.js provides immutable data structures for JavaScript.

```javascript
const { Map, List } = require('immutable');

// Creating immutable data structures
const user = Map({ name: 'John', age: 30 });
const hobbies = List(['reading', 'running']);

// Attempting to modify returns a new instance
const updatedUser = user.set('age', 31);
const updatedHobbies = hobbies.push('swimming');

console.log(user.get('age')); // 30 - original unchanged
console.log(updatedUser.get('age')); // 31

console.log(hobbies.toJS()); // ['reading', 'running'] - original unchanged
console.log(updatedHobbies.toJS()); // ['reading', 'running', 'swimming']
```

**4. Practical Applications of Functional Programming**

**a) State Management in React with Redux**

Redux follows functional programming principles for predictable state management.

```javascript
// Redux reducer (pure function)
function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
}

// Action creators
const increment = () => ({ type: 'INCREMENT' });
const decrement = () => ({ type: 'DECREMENT' });

// Usage with React hooks
function Counter() {
  const count = useSelector(state => state.count);
  const dispatch = useDispatch();
  
  return (
    <div>
      <button onClick={() => dispatch(decrement())}>-</button>
      <span>{count}</span>
      <button onClick={() => dispatch(increment())}>+</button>
    </div>
  );
}
```

**b) Data Transformation Pipelines**

Functional programming is excellent for creating data transformation pipelines.

```javascript
// Processing a list of transactions
const transactions = [
  { id: 1, type: 'debit', amount: 100, currency: 'USD', status: 'completed' },
  { id: 2, type: 'credit', amount: 50, currency: 'EUR', status: 'pending' },
  { id: 3, type: 'debit', amount: 200, currency: 'USD', status: 'completed' },
  { id: 4, type: 'credit', amount: 150, currency: 'USD', status: 'failed' },
  { id: 5, type: 'debit', amount: 75, currency: 'EUR', status: 'completed' }
];

// Exchange rates
const exchangeRates = {
  USD: 1,
  EUR: 1.1
};

// Data transformation pipeline
const processTransactions = pipe(
  // Filter only completed transactions
  filter(tx => tx.status === 'completed'),
  
  // Convert all amounts to USD
  map(tx => ({
    ...tx,
    originalAmount: tx.amount,
    originalCurrency: tx.currency,
    amount: tx.amount * (exchangeRates[tx.currency] || 1),
    currency: 'USD'
  })),
  
  // Group by transaction type
  reduce((acc, tx) => {
    const { type } = tx;
    return {
      ...acc,
      [type]: [...(acc[type] || []), tx]
    };
  }, {}),
  
  // Calculate totals for each type
  map(transactions => ({
    transactions,
    total: transactions.reduce((sum, tx) => sum + tx.amount, 0)
  }))
);

const result = processTransactions(transactions);
console.log(result);
/*
{
  debit: {
    transactions: [transformed debit transactions],
    total: 375 // 100 + 200 + (75 * 1.1)
  },
  credit: {
    transactions: [],
    total: 0 // No completed credit transactions
  }
}
*/
```

**c) Event Handling and Async Operations**

Functional programming can make async code more manageable.

```javascript
// Using functional composition for API calls
const fetchUserData = userId => fetch(`/api/users/${userId}`).then(res => res.json());
const fetchUserPosts = userId => fetch(`/api/users/${userId}/posts`).then(res => res.json());

// Composing async operations
const getUserWithPosts = async userId => {
  const user = await fetchUserData(userId);
  const posts = await fetchUserPosts(userId);
  return { ...user, posts };
};

// Using functional approach with promises
const enhanceUser = user => 
  fetchUserPosts(user.id)
    .then(posts => ({ ...user, posts }));

const getUserWithPostsFP = userId =>
  fetchUserData(userId).then(enhanceUser);

// Event handling with composition
const handleSubmit = pipe(
  preventDefault,
  extractFormData,
  validateFormData,
  submitToApi,
  handleResponse
);

form.addEventListener('submit', handleSubmit);

function preventDefault(event) {
  event.preventDefault();
  return event;
}

function extractFormData(event) {
  return new FormData(event.target);
}

// And so on...
```

**5. Balancing Functional and Imperative Programming**

**a) Pragmatic Functional Programming**

In real-world applications, a pragmatic approach often works best, using functional concepts where they provide the most benefit.

```javascript
// Mixing paradigms pragmatically
class UserService {
  constructor(apiClient) {
    this.apiClient = apiClient;
  }
  
  // Using functional concepts within a class
  async getActiveUsers() {
    const users = await this.apiClient.getUsers();
    
    // Functional approach for data transformation
    return users
      .filter(user => user.active)
      .map(user => this.formatUser(user))
      .sort((a, b) => a.name.localeCompare(b.name));
  }
  
  // Pure function within the class
  formatUser(user) {
    return {
      id: user.id,
      name: user.name,
      displayName: `${user.name} (${user.role})`,
      email: user.email.toLowerCase()
    };
  }
}
```

**b) Performance Considerations**

Sometimes pure functional approaches can have performance implications that need to be balanced.

```javascript
// Immutable approach (creates new arrays)
function addItemImmutable(array, item) {
  return [...array, item];
}

// Mutable approach (modifies original array)
function addItemMutable(array, item) {
  array.push(item);
  return array;
}

// Performance test
const largeArray = Array(1000000).fill(0);
const newItem = 1;

console.time('immutable');
let resultImmutable = addItemImmutable(largeArray, newItem);
console.timeEnd('immutable');

console.time('mutable');
let resultMutable = addItemMutable([...largeArray], newItem);
console.timeEnd('mutable');

// Compromise: use immutable approaches for smaller data sets or where predictability is critical
// Use mutable approaches for performance-critical sections with large data sets
```

**6. Best Practices for Functional Programming in JavaScript**

**a) Keep Functions Small and Focused**

```javascript
// Bad: Function does too many things
function processUserData(user) {
  // Validate user
  if (!user.name) throw new Error('Name is required');
  if (!user.email) throw new Error('Email is required');
  
  // Format user data
  const formattedUser = {
    name: user.name.trim(),
    email: user.email.toLowerCase(),
    createdAt: new Date().toISOString()
  };
  
  // Save to database
  database.save('users', formattedUser);
  
  return formattedUser;
}

// Good: Split into focused functions
const validateUser = user => {
  if (!user.name) throw new Error('Name is required');
  if (!user.email) throw new Error('Email is required');
  return user;
};

const formatUser = user => ({
  name: user.name.trim(),
  email: user.email.toLowerCase(),
  createdAt: new Date().toISOString()
});

const saveUser = user => database.save('users', user);

// Compose them
const processUserData = pipe(validateUser, formatUser, tap(saveUser));

// Helper for side effects
function tap(fn) {
  return function(value) {
    fn(value);
    return value;
  };
}
```

**b) Avoid Mutating Arguments**

```javascript
// Bad: Mutates the input argument
function sortUsersByName(users) {
  return users.sort((a, b) => a.name.localeCompare(b.name));
}

// Good: Creates a new array instead of mutating
function sortUsersByName(users) {
  return [...users].sort((a, b) => a.name.localeCompare(b.name));
}
```

**c) Use Function Composition**

```javascript
// Without composition
function processPayment(payment) {
  const validated = validatePayment(payment);
  const normalized = normalizePayment(validated);
  const processed = sendToPaymentGateway(normalized);
  const recorded = recordTransaction(processed);
  return notifyUser(recorded);
}

// With composition
const processPayment = pipe(
  validatePayment,
  normalizePayment,
  sendToPaymentGateway,
  recordTransaction,
  notifyUser
);
```

**d) Handle Side Effects Carefully**

```javascript
// Isolate side effects
const fetchData = url => fetch(url).then(res => res.json());

// Pure business logic
const processData = data => data.filter(item => item.active).map(transformItem);

// Composition with side effect at the edges
const getProcessedData = url => fetchData(url).then(processData);
```

**e) Use Functional Error Handling**

```javascript
// Using Either monad for error handling
class Either {
  static left(value) {
    return new Left(value);
  }
  
  static right(value) {
    return new Right(value);
  }
  
  static fromNullable(value) {
    return value != null ? Either.right(value) : Either.left(null);
  }
  
  static try(fn) {
    try {
      return Either.right(fn());
    } catch (e) {
      return Either.left(e);
    }
  }
}

class Left extends Either {
  constructor(value) {
    super();
    this.value = value;
  }
  
  map() {
    return this;
  }
  
  flatMap() {
    return this;
  }
  
  getOrElse(defaultValue) {
    return defaultValue;
  }
  
  orElse(fn) {
    return fn(this.value);
  }
}

class Right extends Either {
  constructor(value) {
    super();
    this.value = value;
  }
  
  map(fn) {
    return Either.try(() => fn(this.value));
  }
  
  flatMap(fn) {
    return fn(this.value);
  }
  
  getOrElse() {
    return this.value;
  }
  
  orElse() {
    return this;
  }
}

// Using Either for error handling
function divide(a, b) {
  return b === 0 
    ? Either.left(new Error('Division by zero'))
    : Either.right(a / b);
}

function processCalculation(a, b) {
  return divide(a, b)
    .map(result => result * 2)
    .map(result => `Result: ${result}`)
    .getOrElse('Error in calculation');
}

console.log(processCalculation(10, 2)); // "Result: 10"
console.log(processCalculation(10, 0)); // "Error in calculation"
```

**7. Functional Programming in Modern JavaScript**

**a) Using Modern JavaScript Features**

```javascript
// Destructuring for immutable operations
const user = { name: 'John', age: 30, role: 'admin' };

// Update properties immutably
const updatedUser = { ...user, age: 31 };

// Extract properties
const { name, ...userWithoutName } = user;

// Array operations
const numbers = [1, 2, 3, 4, 5];

// Immutable operations with spread
const addedNumbers = [...numbers, 6];
const removedFirst = numbers.slice(1);

// Optional chaining and nullish coalescing for safer access
const getUserDisplayName = user => user?.displayName ?? user?.name ?? 'Anonymous';
```

**b) Async/Await with Functional Patterns**

```javascript
// Functional async composition
const fetchWithTimeout = async (url, ms) => {
  const controller = new AbortController();
  const { signal } = controller;
  
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      controller.abort();
      reject(new Error('Request timed out'));
    }, ms);
  });
  
  return Promise.race([
    fetch(url, { signal }),
    timeoutPromise
  ]);
};

// Composing async operations
const fetchJson = async url => {
  const response = await fetch(url);
  if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
  return response.json();
};

const fetchUserData = userId => fetchJson(`/api/users/${userId}`);
const fetchUserPosts = userId => fetchJson(`/api/users/${userId}/posts`);

// Functional composition with async/await
const getUserWithPosts = async userId => {
  try {
    const [user, posts] = await Promise.all([
      fetchUserData(userId),
      fetchUserPosts(userId)
    ]);
    
    return { ...user, posts };
  } catch (error) {
    console.error('Failed to fetch user data:', error);
    return null;
  }
};
```

**c) Functional React Components**

```jsx
// Functional component with hooks
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchUser = async () => {
      try {
        setLoading(true);
        const userData = await fetchUserData(userId);
        setUser(userData);
        setError(null);
      } catch (err) {
        setError(err.message);
        setUser(null);
      } finally {
        setLoading(false);
      }
    };
    
    fetchUser();
  }, [userId]);
  
  // Pure rendering function
  const renderUserDetails = user => (
    <div className="user-details">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      {user.bio && <p>{user.bio}</p>}
    </div>
  );
  
  // Conditional rendering with function composition
  return (
    <div className="user-profile">
      {loading && <LoadingSpinner />}
      {error && <ErrorMessage message={error} />}
      {!loading && !error && user && renderUserDetails(user)}
    </div>
  );
}
```

**Key Takeaways:**

1. Functional programming promotes immutability, pure functions, and function composition for more predictable code
2. First-class functions in JavaScript enable powerful functional programming techniques
3. Pure functions improve testability by producing consistent outputs for the same inputs
4. Higher-order functions like map, filter, and reduce enable expressive data transformations
5. Immutability helps prevent bugs related to unexpected state changes
6. Function composition allows building complex operations from simple functions
7. Currying and partial application create specialized functions from general ones
8. Functional programming libraries like Ramda and Lodash/FP provide useful utilities
9. Balancing functional and imperative approaches leads to pragmatic, maintainable code
10. Modern JavaScript features like destructuring, spread syntax, and optional chaining complement functional programming

### Q95: Explain JavaScript Web APIs and browser interactions. How do they enhance web applications?
**Difficulty: Medium**

**Answer:**
JavaScript Web APIs (Application Programming Interfaces) are interfaces provided by browsers that allow JavaScript to interact with the browser environment and perform various operations beyond core language capabilities. These APIs enable developers to create rich, interactive web applications by providing access to browser features, device capabilities, and external resources.

**1. Core Browser APIs**

**a) DOM (Document Object Model) API**

The DOM API allows JavaScript to access and manipulate the structure, content, and styles of HTML documents.

```javascript
// Selecting elements
const element = document.getElementById('myElement');
const elements = document.querySelectorAll('.my-class');

// Modifying content
element.textContent = 'New text content';
element.innerHTML = '<strong>HTML content</strong>';

// Creating and appending elements
const newDiv = document.createElement('div');
newDiv.className = 'new-element';
newDiv.textContent = 'Dynamically created element';
document.body.appendChild(newDiv);

// Event handling
element.addEventListener('click', function(event) {
  console.log('Element clicked', event);
});

// Traversing the DOM
const parent = element.parentNode;
const children = element.children;
const nextSibling = element.nextElementSibling;

// Manipulating styles
element.style.color = 'blue';
element.style.backgroundColor = '#f0f0f0';

// Working with attributes
element.setAttribute('data-custom', 'value');
const attrValue = element.getAttribute('data-custom');
element.removeAttribute('data-custom');

// CSS classes manipulation
element.classList.add('active');
element.classList.remove('inactive');
element.classList.toggle('highlighted');
const hasClass = element.classList.contains('active');
```

**b) BOM (Browser Object Model) API**

The BOM provides access to browser-specific objects and functionality.

```javascript
// Window object (global context)
window.alert('Hello world!');
window.confirm('Are you sure?');
const name = window.prompt('Enter your name');

// Location (URL manipulation)
console.log(window.location.href);     // Full URL
console.log(window.location.hostname); // Domain name
console.log(window.location.pathname); // Path
console.log(window.location.search);   // Query string

// Navigate to a new URL
window.location.href = 'https://example.com';

// History navigation
window.history.back();     // Go back
window.history.forward();  // Go forward
window.history.go(-2);     // Go back 2 pages

// History API for SPA navigation
window.history.pushState({ page: 'home' }, 'Home', '/home');
window.history.replaceState({ page: 'about' }, 'About', '/about');

// Screen information
const screenWidth = window.screen.width;
const screenHeight = window.screen.height;
const colorDepth = window.screen.colorDepth;

// Timers
const timeoutId = setTimeout(() => {
  console.log('Executed after 2 seconds');
}, 2000);
clearTimeout(timeoutId);

const intervalId = setInterval(() => {
  console.log('Executes every 1 second');
}, 1000);
clearInterval(intervalId);

// requestAnimationFrame for smooth animations
function animate() {
  // Animation code
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
```

**2. Storage APIs**

**a) Web Storage API**

Provides mechanisms for storing data in the browser.

```javascript
// localStorage (persists until explicitly cleared)
localStorage.setItem('username', 'john_doe');
const username = localStorage.getItem('username');
localStorage.removeItem('username');
localStorage.clear(); // Clear all items

// sessionStorage (persists for the session)
sessionStorage.setItem('sessionId', '12345');
const sessionId = sessionStorage.getItem('sessionId');
sessionStorage.removeItem('sessionId');
sessionStorage.clear();

// Storage event (triggered when storage changes in another tab/window)
window.addEventListener('storage', (event) => {
  console.log('Storage changed:', event.key, event.oldValue, event.newValue, event.storageArea);
});

// Storage size limits and checking
function getStorageUsage() {
  let total = 0;
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    const value = localStorage.getItem(key);
    total += key.length + value.length;
  }
  return total; // Approximate size in bytes
}
```

**b) IndexedDB API**

A low-level API for client-side storage of significant amounts of structured data.

```javascript
// Opening a database
const request = indexedDB.open('myDatabase', 1);

request.onerror = (event) => {
  console.error('Database error:', event.target.error);
};

request.onupgradeneeded = (event) => {
  const db = event.target.result;
  
  // Create an object store (similar to a table)
  const store = db.createObjectStore('users', { keyPath: 'id' });
  
  // Create indexes
  store.createIndex('name', 'name', { unique: false });
  store.createIndex('email', 'email', { unique: true });
};

request.onsuccess = (event) => {
  const db = event.target.result;
  
  // Add data
  const transaction = db.transaction(['users'], 'readwrite');
  const store = transaction.objectStore('users');
  
  store.add({
    id: 1,
    name: 'John Doe',
    email: 'john@example.com',
    age: 30
  });
  
  // Read data
  const getRequest = store.get(1);
  getRequest.onsuccess = () => {
    console.log('User:', getRequest.result);
  };
  
  // Query with an index
  const nameIndex = store.index('name');
  const nameQuery = nameIndex.getAll('John Doe');
  nameQuery.onsuccess = () => {
    console.log('Users named John Doe:', nameQuery.result);
  };
  
  transaction.oncomplete = () => {
    console.log('Transaction completed');
  };
};
```

**c) Cache API**

Provides a storage mechanism for HTTP responses, primarily used with Service Workers.

```javascript
// Opening a cache
caches.open('v1').then(cache => {
  // Add resources to the cache
  cache.add('/index.html');
  
  // Add multiple resources
  cache.addAll([
    '/styles/main.css',
    '/scripts/app.js',
    '/images/logo.png'
  ]);
  
  // Custom response caching
  cache.put('/api/data', new Response(JSON.stringify({ key: 'value' }), {
    headers: { 'Content-Type': 'application/json' }
  }));
});

// Retrieving from cache
caches.match('/index.html').then(response => {
  if (response) {
    console.log('Found in cache:', response);
  } else {
    console.log('Not found in cache');
  }
});

// Delete from cache
caches.open('v1').then(cache => {
  cache.delete('/old-script.js');
});

// Delete entire cache
caches.delete('v1').then(success => {
  if (success) {
    console.log('Cache deleted');
  }
});
```

**3. Communication APIs**

**a) Fetch API**

Modern API for making HTTP requests.

```javascript
// Basic GET request
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log('Data:', data))
  .catch(error => console.error('Fetch error:', error));

// POST request with JSON data
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token123'
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  })
})
.then(response => response.json())
.then(data => console.log('Created user:', data));

// Using async/await
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Fetch error:', error);
  }
}

// Aborting fetch requests
const controller = new AbortController();
const { signal } = controller;

fetch('https://api.example.com/large-data', { signal })
  .then(response => response.json())
  .then(data => console.log('Data:', data))
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('Fetch aborted');
    } else {
      console.error('Fetch error:', error);
    }
  });

// Abort after 5 seconds
setTimeout(() => controller.abort(), 5000);
```

**b) WebSocket API**

Enables two-way interactive communication between the browser and server.

```javascript
// Establishing a WebSocket connection
const socket = new WebSocket('wss://echo.websocket.org');

// Connection opened
socket.addEventListener('open', (event) => {
  console.log('WebSocket connection established');
  socket.send('Hello Server!');
});

// Listen for messages
socket.addEventListener('message', (event) => {
  console.log('Message from server:', event.data);
});

// Handle errors
socket.addEventListener('error', (event) => {
  console.error('WebSocket error:', event);
});

// Connection closed
socket.addEventListener('close', (event) => {
  console.log('WebSocket connection closed:', event.code, event.reason);
});

// Sending different types of data
socket.send('Plain text message');
socket.send(JSON.stringify({ type: 'message', content: 'Hello!' }));

// Binary data
const fileInput = document.querySelector('input[type="file"]');
fileInput.addEventListener('change', (event) => {
  const file = event.target.files[0];
  const reader = new FileReader();
  
  reader.onload = (e) => {
    socket.send(e.target.result); // Send binary data
  };
  
  reader.readAsArrayBuffer(file);
});

// Closing the connection
socket.close(1000, 'Closing normally');
```

**c) Server-Sent Events (SSE)**

Allows a server to push updates to the browser.

```javascript
// Creating an EventSource
const eventSource = new EventSource('/events');

// Handling messages
eventSource.addEventListener('message', (event) => {
  console.log('Received message:', event.data);
});

// Handling custom events
eventSource.addEventListener('userConnected', (event) => {
  const userData = JSON.parse(event.data);
  console.log('User connected:', userData);
});

// Error handling
eventSource.addEventListener('error', (event) => {
  if (event.readyState === EventSource.CLOSED) {
    console.log('Connection was closed');
  } else {
    console.error('EventSource error:', event);
  }
});

// Closing the connection
eventSource.close();
```

**4. Media and Device APIs**

**a) Media Capture and Streams API**

Provides access to media streams from cameras, microphones, and screens.

```javascript
// Accessing the webcam
async function getWebcamStream() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: true,
      audio: false
    });
    
    // Display in a video element
    const videoElement = document.querySelector('video');
    videoElement.srcObject = stream;
    
    return stream;
  } catch (error) {
    console.error('Error accessing webcam:', error);
  }
}

// Accessing the microphone
async function getMicrophoneStream() {
  try {
    return await navigator.mediaDevices.getUserMedia({
      audio: true,
      video: false
    });
  } catch (error) {
    console.error('Error accessing microphone:', error);
  }
}

// Screen sharing
async function getScreenStream() {
  try {
    return await navigator.mediaDevices.getDisplayMedia({
      video: true
    });
  } catch (error) {
    console.error('Error sharing screen:', error);
  }
}

// Enumerating available devices
async function listMediaDevices() {
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    
    const cameras = devices.filter(device => device.kind === 'videoinput');
    const microphones = devices.filter(device => device.kind === 'audioinput');
    const speakers = devices.filter(device => device.kind === 'audiooutput');
    
    console.log('Cameras:', cameras);
    console.log('Microphones:', microphones);
    console.log('Speakers:', speakers);
  } catch (error) {
    console.error('Error listing devices:', error);
  }
}

// Media recorder (for recording streams)
function recordStream(stream) {
  const mediaRecorder = new MediaRecorder(stream);
  const chunks = [];
  
  mediaRecorder.addEventListener('dataavailable', (event) => {
    if (event.data.size > 0) {
      chunks.push(event.data);
    }
  });
  
  mediaRecorder.addEventListener('stop', () => {
    const blob = new Blob(chunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    
    // Create download link
    const a = document.createElement('a');
    a.href = url;
    a.download = 'recording.webm';
    a.textContent = 'Download Recording';
    document.body.appendChild(a);
  });
  
  // Start recording (record for 5 seconds)
  mediaRecorder.start();
  setTimeout(() => mediaRecorder.stop(), 5000);
}
```

**b) Web Audio API**

Provides powerful audio processing capabilities.

```javascript
// Creating an audio context
const audioContext = new (window.AudioContext || window.webkitAudioContext)();

// Loading and playing a sound file
async function playSound(url) {
  try {
    // Fetch the audio file
    const response = await fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    
    // Decode the audio data
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
    
    // Create a buffer source node
    const source = audioContext.createBufferSource();
    source.buffer = audioBuffer;
    
    // Connect to the destination (speakers)
    source.connect(audioContext.destination);
    
    // Play the sound
    source.start(0);
    
    return source;
  } catch (error) {
    console.error('Error playing sound:', error);
  }
}

// Creating a simple synthesizer
function createSynthesizer() {
  // Create oscillator (sound generator)
  const oscillator = audioContext.createOscillator();
  oscillator.type = 'sine'; // sine, square, sawtooth, triangle
  oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4 note
  
  // Create gain node (volume control)
  const gainNode = audioContext.createGain();
  gainNode.gain.setValueAtTime(0, audioContext.currentTime); // Start silent
  
  // Connect nodes: oscillator -> gain -> speakers
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  
  // Start the oscillator
  oscillator.start();
  
  // Return controls
  return {
    playNote(frequency, duration = 0.5) {
      oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
      gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
    },
    stop() {
      oscillator.stop();
    }
  };
}

// Audio processing with filters
function createFilteredAudio(audioElement) {
  // Create media element source
  const source = audioContext.createMediaElementSource(audioElement);
  
  // Create filters
  const lowpassFilter = audioContext.createBiquadFilter();
  lowpassFilter.type = 'lowpass';
  lowpassFilter.frequency.value = 1000;
  
  const highpassFilter = audioContext.createBiquadFilter();
  highpassFilter.type = 'highpass';
  highpassFilter.frequency.value = 200;
  
  // Create analyzer for visualizations
  const analyzer = audioContext.createAnalyser();
  analyzer.fftSize = 2048;
  
  // Connect the nodes
  source.connect(lowpassFilter);
  lowpassFilter.connect(highpassFilter);
  highpassFilter.connect(analyzer);
  analyzer.connect(audioContext.destination);
  
  return {
    source,
    lowpassFilter,
    highpassFilter,
    analyzer
  };
}
```

**5. Geolocation and Sensor APIs**

**a) Geolocation API**

Provides access to the user's geographical location.

```javascript
// Get current position
function getCurrentPosition() {
  if ('geolocation' in navigator) {
    navigator.geolocation.getCurrentPosition(
      // Success callback
      (position) => {
        const { latitude, longitude, accuracy } = position.coords;
        console.log(`Location: ${latitude}, ${longitude} (accuracy: ${accuracy} meters)`);
      },
      // Error callback
      (error) => {
        switch (error.code) {
          case error.PERMISSION_DENIED:
            console.error('User denied geolocation permission');
            break;
          case error.POSITION_UNAVAILABLE:
            console.error('Location information unavailable');
            break;
          case error.TIMEOUT:
            console.error('Location request timed out');
            break;
          default:
            console.error('Unknown geolocation error:', error.message);
        }
      },
      // Options
      {
        enableHighAccuracy: true, // Use GPS if available
        timeout: 5000,           // Time limit for request
        maximumAge: 0            // Don't use cached position
      }
    );
  } else {
    console.error('Geolocation is not supported by this browser');
  }
}

// Watch position (continuous updates)
let watchId;

function startWatchingPosition() {
  if ('geolocation' in navigator) {
    watchId = navigator.geolocation.watchPosition(
      (position) => {
        const { latitude, longitude } = position.coords;
        console.log(`Updated location: ${latitude}, ${longitude}`);
      },
      (error) => {
        console.error('Geolocation error:', error.message);
      },
      { enableHighAccuracy: true }
    );
  }
}

function stopWatchingPosition() {
  if (watchId) {
    navigator.geolocation.clearWatch(watchId);
    console.log('Stopped watching position');
  }
}
```

**b) Device Orientation and Motion APIs**

Provide access to the device's physical orientation and motion sensors.

```javascript
// Device orientation (compass, accelerometer)
window.addEventListener('deviceorientation', (event) => {
  // Alpha: rotation around z-axis (0-360 degrees)
  const alpha = event.alpha;
  
  // Beta: front-to-back tilt (-180 to 180 degrees)
  const beta = event.beta;
  
  // Gamma: left-to-right tilt (-90 to 90 degrees)
  const gamma = event.gamma;
  
  console.log(`Orientation - alpha: ${alpha}, beta: ${beta}, gamma: ${gamma}`);
});

// Device motion (accelerometer, gyroscope)
window.addEventListener('devicemotion', (event) => {
  // Acceleration (meters per second squared)
  const acceleration = event.acceleration;
  console.log(`Acceleration - x: ${acceleration.x}, y: ${acceleration.y}, z: ${acceleration.z}`);
  
  // Acceleration including gravity
  const accelerationWithGravity = event.accelerationIncludingGravity;
  
  // Rotation rate (degrees per second)
  const rotationRate = event.rotationRate;
  console.log(`Rotation - alpha: ${rotationRate.alpha}, beta: ${rotationRate.beta}, gamma: ${rotationRate.gamma}`);
  
  // Interval between updates (milliseconds)
  const interval = event.interval;
});

// Requesting permission (required in iOS 13+)
async function requestMotionPermission() {
  if (typeof DeviceOrientationEvent.requestPermission === 'function') {
    try {
      const permissionState = await DeviceOrientationEvent.requestPermission();
      if (permissionState === 'granted') {
        console.log('Motion sensors permission granted');
      } else {
        console.error('Motion sensors permission denied');
      }
    } catch (error) {
      console.error('Error requesting motion permission:', error);
    }
  }
}
```

**6. Background and Offline APIs**

**a) Service Worker API**

Enables offline capabilities, background sync, and push notifications.

```javascript
// Registering a service worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/service-worker.js')
    .then(registration => {
      console.log('Service Worker registered with scope:', registration.scope);
    })
    .catch(error => {
      console.error('Service Worker registration failed:', error);
    });
}

// Example service-worker.js file
// Cache name and assets to cache
const CACHE_NAME = 'my-site-cache-v1';
const urlsToCache = [
  '/',
  '/styles/main.css',
  '/scripts/app.js',
  '/images/logo.png'
];

// Install event - cache assets
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.filter(name => name !== CACHE_NAME)
          .map(name => caches.delete(name))
      );
    })
  );
});

// Fetch event - serve from cache, fall back to network
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // Cache hit - return response
        if (response) {
          return response;
        }
        
        // Clone the request
        const fetchRequest = event.request.clone();
        
        // Make network request and cache the response
        return fetch(fetchRequest).then(response => {
          // Check if valid response
          if (!response || response.status !== 200 || response.type !== 'basic') {
            return response;
          }
          
          // Clone the response
          const responseToCache = response.clone();
          
          caches.open(CACHE_NAME)
            .then(cache => {
              cache.put(event.request, responseToCache);
            });
            
          return response;
        });
      })
  );
});
```

**b) Background Sync API**

Allows deferred actions to be performed when the user has connectivity.

```javascript
// Registering for background sync in your web app
if ('serviceWorker' in navigator && 'SyncManager' in window) {
  navigator.serviceWorker.ready
    .then(registration => {
      // Register a sync event
      return registration.sync.register('sync-messages');
    })
    .then(() => {
      console.log('Background sync registered');
    })
    .catch(error => {
      console.error('Background sync registration failed:', error);
    });
}

// In service worker: handling the sync event
self.addEventListener('sync', event => {
  if (event.tag === 'sync-messages') {
    event.waitUntil(syncMessages());
  }
});

// Function to sync data from IndexedDB to server
async function syncMessages() {
  try {
    // Open IndexedDB
    const db = await openDB('messages-store', 1);
    
    // Get all unsent messages
    const unsentMessages = await db.getAll('outbox');
    
    // Send each message to the server
    for (const message of unsentMessages) {
      await fetch('/api/messages', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(message)
      });
      
      // Remove from outbox after successful send
      await db.delete('outbox', message.id);
    }
    
    console.log('All messages synced successfully');
  } catch (error) {
    console.error('Message sync failed:', error);
    throw error; // Retry sync later
  }
}
```

**c) Push API**

Enables web applications to receive push messages from a server.

```javascript
// Requesting permission and subscribing to push notifications
async function subscribeToPushNotifications() {
  try {
    // Request permission
    const permission = await Notification.requestPermission();
    if (permission !== 'granted') {
      throw new Error('Notification permission denied');
    }
    
    // Get service worker registration
    const registration = await navigator.serviceWorker.ready;
    
    // Get push subscription
    const subscription = await registration.pushManager.subscribe({
      userVisibleOnly: true, // Must be true for browsers to accept
      applicationServerKey: urlBase64ToUint8Array('YOUR_PUBLIC_VAPID_KEY')
    });
    
    // Send subscription to server
    await fetch('/api/subscribe', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(subscription)
    });
    
    console.log('Push notification subscription successful');
    return subscription;
  } catch (error) {
    console.error('Push subscription failed:', error);
  }
}

// Helper function to convert base64 to Uint8Array
function urlBase64ToUint8Array(base64String) {
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding)
    .replace(/-/g, '+')
    .replace(/_/g, '/');
    
  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  
  return outputArray;
}

// In service worker: handling push events
self.addEventListener('push', event => {
  if (!event.data) return;
  
  const data = event.data.json();
  
  event.waitUntil(
    self.registration.showNotification(data.title, {
      body: data.body,
      icon: data.icon,
      badge: data.badge,
      data: data.data,
      actions: data.actions
    })
  );
});

// Handling notification clicks
self.addEventListener('notificationclick', event => {
  event.notification.close();
  
  // Handle notification click
  event.waitUntil(
    clients.openWindow(event.notification.data.url)
  );
});
```

**7. Performance and Optimization APIs**

**a) Performance API**

Provides access to performance-related information.

```javascript
// Basic performance measurements
const pageLoadTime = window.performance.timing.loadEventEnd - window.performance.timing.navigationStart;
console.log(`Page load time: ${pageLoadTime}ms`);

// Custom performance marks and measures
performance.mark('start-process');

// Do some work
for (let i = 0; i < 1000000; i++) {
  // Simulate work
}

performance.mark('end-process');
performance.measure('process-duration', 'start-process', 'end-process');

const measures = performance.getEntriesByType('measure');
console.log(`Process took ${measures[0].duration}ms`);

// Clearing performance entries
performance.clearMarks();
performance.clearMeasures();

// Resource timing
const resources = performance.getEntriesByType('resource');
resources.forEach(resource => {
  console.log(`${resource.name} took ${resource.duration}ms to load`);
});

// Navigation timing
const navTiming = performance.getEntriesByType('navigation')[0];
console.log({
  dnsLookup: navTiming.domainLookupEnd - navTiming.domainLookupStart,
  tcpConnection: navTiming.connectEnd - navTiming.connectStart,
  requestResponse: navTiming.responseEnd - navTiming.requestStart,
  domProcessing: navTiming.domComplete - navTiming.domInteractive,
  pageLoad: navTiming.loadEventEnd - navTiming.loadEventStart
});

// Performance Observer
const observer = new PerformanceObserver(list => {
  list.getEntries().forEach(entry => {
    console.log('Long task detected:', entry.duration, 'ms');
  });
});

observer.observe({ entryTypes: ['longtask'] });
```

**b) Intersection Observer API**

Provides a way to asynchronously observe changes in the intersection of a target element with its parent or the viewport.

```javascript
// Creating an intersection observer
const options = {
  root: null, // Use viewport as root
  rootMargin: '0px', // No margin
  threshold: 0.5 // Trigger when 50% visible
};

const observer = new IntersectionObserver((entries, observer) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log('Element is visible:', entry.target);
      
      // Load image if it's a lazy-loaded image
      if (entry.target.dataset.src) {
        entry.target.src = entry.target.dataset.src;
        entry.target.removeAttribute('data-src');
        observer.unobserve(entry.target); // Stop observing once loaded
      }
    } else {
      console.log('Element is not visible:', entry.target);
    }
  });
}, options);

// Observe elements
const elements = document.querySelectorAll('.lazy-load');
elements.forEach(element => {
  observer.observe(element);
});

// Implementing infinite scroll
function setupInfiniteScroll() {
  const sentinel = document.querySelector('#sentinel');
  
  const scrollObserver = new IntersectionObserver(entries => {
    if (entries[0].isIntersecting) {
      // Load more content
      loadMoreContent()
        .then(hasMoreContent => {
          if (!hasMoreContent) {
            scrollObserver.unobserve(sentinel);
          }
        });
    }
  });
  
  scrollObserver.observe(sentinel);
}

async function loadMoreContent() {
  // Fetch and append more content
  // Return false when no more content is available
}
```

**c) Resize Observer API**

Provides notifications when an element's size changes.

```javascript
// Creating a resize observer
const resizeObserver = new ResizeObserver(entries => {
  for (const entry of entries) {
    const { width, height } = entry.contentRect;
    console.log(`Element size: ${width}px × ${height}px`);
    
    // Respond to size changes
    if (width < 600) {
      entry.target.classList.add('compact');
    } else {
      entry.target.classList.remove('compact');
    }
  }
});

// Start observing an element
const element = document.querySelector('.responsive-element');
resizeObserver.observe(element);

// Stop observing
// resizeObserver.unobserve(element);
// resizeObserver.disconnect();
```

**8. Web APIs for Modern Applications**

**a) Web Share API**

Provides a way to trigger the native sharing mechanism of the device.

```javascript
async function shareContent() {
  if (navigator.share) {
    try {
      await navigator.share({
        title: 'Check out this article',
        text: 'An interesting article about Web APIs',
        url: window.location.href
      });
      console.log('Content shared successfully');
    } catch (error) {
      console.error('Error sharing content:', error);
    }
  } else {
    console.log('Web Share API not supported');
    // Fallback sharing mechanism
  }
}

// Share files
async function shareFiles(files) {
  if (navigator.canShare && navigator.canShare({ files })) {
    try {
      await navigator.share({
        files,
        title: 'Shared files',
        text: 'Check out these files'
      });
      console.log('Files shared successfully');
    } catch (error) {
      console.error('Error sharing files:', error);
    }
  } else {
    console.log('File sharing not supported');
  }
}
```

**b) Web Notifications API**

Enables web pages to control the display of system notifications to the user.

```javascript
// Requesting permission
async function requestNotificationPermission() {
  try {
    const permission = await Notification.requestPermission();
    return permission === 'granted';
  } catch (error) {
    console.error('Error requesting notification permission:', error);
    return false;
  }
}

// Displaying a notification
function showNotification(title, options = {}) {
  if (Notification.permission === 'granted') {
    const notification = new Notification(title, {
      body: options.body || '',
      icon: options.icon || '/images/notification-icon.png',
      badge: options.badge,
      image: options.image,
      tag: options.tag, // For notification grouping
      data: options.data,
      requireInteraction: options.requireInteraction || false,
      actions: options.actions || []
    });
    
    // Event handlers
    notification.onclick = function() {
      window.focus();
      notification.close();
      if (options.onClick) options.onClick();
    };
    
    notification.onclose = function() {
      if (options.onClose) options.onClose();
    };
    
    notification.onerror = function(error) {
      console.error('Notification error:', error);
      if (options.onError) options.onError(error);
    };
    
    return notification;
  } else {
    console.warn('Notification permission not granted');
    return null;
  }
}

// Example usage
async function notifyUser(message) {
  const hasPermission = await requestNotificationPermission();
  
  if (hasPermission) {
    showNotification('New Message', {
      body: message,
      icon: '/images/message-icon.png',
      requireInteraction: true,
      onClick: () => console.log('Notification clicked')
    });
  }
}
```

**c) Payment Request API**

Provides a consistent way to handle payments across different browsers.

```javascript
async function processPayment(productDetails) {
  if (!window.PaymentRequest) {
    console.error('Payment Request API not supported');
    return false;
  }
  
  try {
    // Define payment methods
    const supportedPaymentMethods = [
      {
        supportedMethods: 'basic-card',
        data: {
          supportedNetworks: ['visa', 'mastercard', 'amex'],
          supportedTypes: ['credit', 'debit']
        }
      }
    ];
    
    // Define payment details
    const paymentDetails = {
      total: {
        label: 'Total',
        amount: {
          currency: 'USD',
          value: productDetails.price.toString()
        }
      },
      displayItems: [
        {
          label: productDetails.name,
          amount: {
            currency: 'USD',
            value: productDetails.price.toString()
          }
        }
      ]
    };
    
    // Additional options
    const options = {
      requestShipping: true,
      requestPayerName: true,
      requestPayerEmail: true,
      requestPayerPhone: true,
      shippingType: 'shipping'
    };
    
    // Create payment request
    const request = new PaymentRequest(
      supportedPaymentMethods,
      paymentDetails,
      options
    );
    
    // Handle shipping address changes
    request.addEventListener('shippingaddresschange', event => {
      event.updateWith(calculateShippingOptions(request.shippingAddress));
    });
    
    // Show payment UI
    const response = await request.show();
    
    // Process payment
    const paymentData = {
      paymentMethod: response.methodName,
      paymentDetails: response.details,
      shippingAddress: response.shippingAddress,
      shippingOption: response.shippingOption,
      payerName: response.payerName,
      payerEmail: response.payerEmail,
      payerPhone: response.payerPhone
    };
    
    // Send payment data to server
    const result = await sendPaymentToServer(paymentData);
    
    if (result.success) {
      await response.complete('success');
      return true;
    } else {
      await response.complete('fail');
      return false;
    }
  } catch (error) {
    console.error('Payment error:', error);
    return false;
  }
}

function calculateShippingOptions(shippingAddress) {
  // Calculate shipping options based on address
  // Return updated payment details
}

async function sendPaymentToServer(paymentData) {
  // Send payment data to server for processing
  // Return result
}
```

**9. Best Practices for Using Web APIs**

**a) Feature Detection**

Always check if an API is supported before using it.

```javascript
// Bad: Assuming API availability
navigator.geolocation.getCurrentPosition(successCallback, errorCallback);

// Good: Feature detection
if ('geolocation' in navigator) {
  navigator.geolocation.getCurrentPosition(successCallback, errorCallback);
} else {
  console.log('Geolocation not supported');
  // Provide fallback or alternative UI
}

// Creating a utility for feature detection
const features = {
  geolocation: 'geolocation' in navigator,
  serviceWorker: 'serviceWorker' in navigator,
  webShare: 'share' in navigator,
  webP: () => {
    return new Promise(resolve => {
      const webP = new Image();
      webP.onload = webP.onerror = function() {
        resolve(webP.height === 2);
      };
      webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';
    });
  }
};

// Usage
if (features.webShare) {
  showShareButton();
}

features.webP().then(supported => {
  if (supported) {
    loadWebPImages();
  } else {
    loadFallbackImages();
  }
});
```

**b) Progressive Enhancement**

Build applications that work without advanced APIs, then enhance with them when available.

```javascript
// Basic form submission without JavaScript
<form action="/submit" method="post">
  <input type="text" name="message" required>
  <button type="submit">Send</button>
</form>

// Enhanced with JavaScript and modern APIs
const form = document.querySelector('form');
const input = document.querySelector('input[name="message"]');

if (form && 'serviceWorker' in navigator && 'SyncManager' in window) {
  // Override default form submission
  form.addEventListener('submit', async event => {
    event.preventDefault();
    
    try {
      // Store message in IndexedDB for background sync
      await storeMessage(input.value);
      
      // Register for background sync
      const registration = await navigator.serviceWorker.ready;
      await registration.sync.register('sync-messages');
      
      // Clear form and show success message
      input.value = '';
      showNotification('Message will be sent when online');
    } catch (error) {
      console.error('Error:', error);
      // Fall back to traditional form submission
      form.submit();
    }
  });
}
```

**c) Performance Considerations**

Use APIs efficiently to avoid performance issues.

```javascript
// Bad: Inefficient DOM manipulation
function addItems(items) {
  const container = document.getElementById('container');
  
  items.forEach(item => {
    const element = document.createElement('div');
    element.textContent = item;
    container.appendChild(element); // Causes reflow each time
  });
}

// Good: Batch DOM operations
function addItems(items) {
  const container = document.getElementById('container');
  const fragment = document.createDocumentFragment();
  
  items.forEach(item => {
    const element = document.createElement('div');
    element.textContent = item;
    fragment.appendChild(element);
  });
  
  container.appendChild(fragment); // Single reflow
}

// Bad: Inefficient event handling
window.addEventListener('scroll', function() {
  // Heavy computation on each scroll event
  updateElementPositions();
});

// Good: Throttled event handling
function throttle(func, limit) {
  let inThrottle;
  return function() {
    const args = arguments;
    const context = this;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

window.addEventListener('scroll', throttle(function() {
  updateElementPositions();
}, 100));

// Using requestAnimationFrame for visual updates
let ticking = false;

window.addEventListener('scroll', function() {
  if (!ticking) {
    window.requestAnimationFrame(function() {
      updateElementPositions();
      ticking = false;
    });
    ticking = true;
  }
});
```

**d) Security and Privacy**

Handle sensitive APIs with care.

```javascript
// Requesting permissions at the right time
function setupCameraButton() {
  const button = document.getElementById('camera-button');
  
  button.addEventListener('click', async () => {
    try {
      // Request camera access when user initiates action
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      startVideoRecording(stream);
    } catch (error) {
      console.error('Camera access error:', error);
      showPermissionDeniedMessage();
    }
  });
}

// Secure data storage
function storeUserPreferences(preferences) {
  // Don't store sensitive data in localStorage
  const safePreferences = {
    theme: preferences.theme,
    language: preferences.language,
    notifications: preferences.notifications
  };
  
  // Store non-sensitive data
  localStorage.setItem('userPreferences', JSON.stringify(safePreferences));
  
  // Store sensitive data in more secure storage
  if (preferences.authToken) {
    // Use sessionStorage for temporary sensitive data
    sessionStorage.setItem('authToken', preferences.authToken);
  }
}

// Validate and sanitize data from APIs
function displayUserContent(content) {
  const container = document.getElementById('user-content');
  
  // Sanitize content to prevent XSS
  const sanitizedContent = DOMPurify.sanitize(content);
  container.innerHTML = sanitizedContent;
}
```

**e) Error Handling and Fallbacks**

Gracefully handle API failures.

```javascript
// Comprehensive error handling
async function loadUserData() {
  try {
    // Try to get from cache first
    const cachedData = await getCachedUserData();
    if (cachedData) {
      return cachedData;
    }
    
    // Fetch from network with timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5000);
    
    const response = await fetch('/api/user', { signal: controller.signal });
    clearTimeout(timeoutId);
    
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    const userData = await response.json();
    
    // Cache the successful response
    await cacheUserData(userData);
    
    return userData;
  } catch (error) {
    console.error('Error loading user data:', error);
    
    // Different handling based on error type
    if (error.name === 'AbortError') {
      showTimeoutMessage();
    } else if (error instanceof TypeError) {
      showNetworkErrorMessage();
    } else {
      showGenericErrorMessage();
    }
    
    // Return fallback data
    return getDefaultUserData();
  }
}

// Feature fallbacks
function getLocation() {
  return new Promise((resolve, reject) => {
    if ('geolocation' in navigator) {
      navigator.geolocation.getCurrentPosition(
        position => resolve({
          lat: position.coords.latitude,
          lng: position.coords.longitude,
          accuracy: position.coords.accuracy
        }),
        error => {
          console.warn('Geolocation error:', error);
          // Fall back to IP-based geolocation
          fetchIPBasedLocation().then(resolve).catch(reject);
        }
      );
    } else {
      // Geolocation not supported
      fetchIPBasedLocation().then(resolve).catch(reject);
    }
  });
}

async function fetchIPBasedLocation() {
  const response = await fetch('https://ipapi.co/json/');
  const data = await response.json();
  return {
    lat: data.latitude,
    lng: data.longitude,
    accuracy: 5000, // Approximate accuracy in meters
    source: 'ip'
  };
}
```

**Key Takeaways:**

1. Web APIs extend JavaScript's capabilities by providing interfaces to browser features and device hardware
2. The DOM API is fundamental for manipulating HTML document structure and content
3. Storage APIs like localStorage, sessionStorage, and IndexedDB enable client-side data persistence
4. Communication APIs like Fetch, WebSocket, and Server-Sent Events facilitate data exchange with servers
5. Media and Device APIs provide access to cameras, microphones, and audio processing capabilities
6. Service Workers enable offline functionality, background sync, and push notifications
7. Performance APIs help measure and optimize application performance
8. Always implement feature detection before using APIs that may not be universally supported
9. Follow progressive enhancement principles to ensure functionality across different browsers
10. Handle permissions, security, and privacy concerns appropriately when using sensitive APIs

## Accessibility and Internationalization

### Q96: Explain JavaScript accessibility best practices. How can developers create more inclusive web applications?
**Difficulty: Medium**

**Answer:**
Accessibility (often abbreviated as a11y) refers to the practice of designing and developing web applications that can be used by everyone, including people with disabilities. JavaScript plays a crucial role in creating accessible web experiences, as it can both enhance and hinder accessibility depending on how it's implemented.

**1. Understanding Web Accessibility**

**a) Why Accessibility Matters**

- **Legal requirements**: Many countries have laws requiring digital accessibility (e.g., ADA in the US, EAA in Europe)
- **Larger audience**: Approximately 15-20% of the world's population has some form of disability
- **Better user experience**: Accessible sites are generally more usable for everyone
- **SEO benefits**: Many accessibility practices improve search engine optimization

**b) Common Accessibility Standards**

- **WCAG (Web Content Accessibility Guidelines)**: The most widely recognized standard, with three levels of conformance (A, AA, AAA)
- **WAI-ARIA (Web Accessibility Initiative - Accessible Rich Internet Applications)**: Specifications for making dynamic content more accessible
- **Section 508**: US federal regulations for accessibility

**2. Semantic HTML as Foundation**

Before diving into JavaScript-specific practices, it's important to emphasize that accessibility starts with proper HTML structure.

```javascript
// Bad: Non-semantic elements with JavaScript behavior
const div = document.createElement('div');
div.textContent = 'Submit Form';
div.addEventListener('click', submitForm);
document.body.appendChild(div);

// Good: Using semantic elements
const button = document.createElement('button');
button.textContent = 'Submit Form';
button.addEventListener('click', submitForm);
document.body.appendChild(button);
```

**3. Keyboard Accessibility**

Ensuring that all interactive elements can be accessed and operated using only a keyboard.

**a) Focus Management**

```javascript
// Making a custom component focusable
const customWidget = document.getElementById('custom-widget');
customWidget.tabIndex = 0; // Makes the element focusable

// Programmatically setting focus
function openDialog() {
  const dialog = document.getElementById('dialog');
  dialog.classList.add('visible');
  
  // Set focus to the first focusable element in the dialog
  const firstFocusable = dialog.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
  if (firstFocusable) {
    firstFocusable.focus();
  }
}

// Trapping focus within a modal dialog
function trapFocus(element) {
  const focusableElements = element.querySelectorAll(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  );
  
  const firstFocusable = focusableElements[0];
  const lastFocusable = focusableElements[focusableElements.length - 1];
  
  // Handle Tab key to keep focus within the element
  element.addEventListener('keydown', function(e) {
    if (e.key === 'Tab') {
      if (e.shiftKey) { // Shift + Tab
        if (document.activeElement === firstFocusable) {
          lastFocusable.focus();
          e.preventDefault();
        }
      } else { // Tab
        if (document.activeElement === lastFocusable) {
          firstFocusable.focus();
          e.preventDefault();
        }
      }
    }
  });
}
```

**b) Keyboard Event Handling**

```javascript
// Adding keyboard support to custom components
const accordion = document.querySelector('.accordion');
accordion.addEventListener('keydown', function(event) {
  if (event.key === 'Enter' || event.key === ' ') {
    // Activate the accordion on Enter or Space key
    event.preventDefault(); // Prevent page scroll on Space
    toggleAccordion(this);
  }
});

// Implementing arrow key navigation for a custom dropdown
const dropdown = document.querySelector('.dropdown');
const options = dropdown.querySelectorAll('.option');
let currentIndex = -1;

dropdown.addEventListener('keydown', function(event) {
  switch (event.key) {
    case 'ArrowDown':
      event.preventDefault();
      currentIndex = Math.min(currentIndex + 1, options.length - 1);
      options[currentIndex].focus();
      break;
    case 'ArrowUp':
      event.preventDefault();
      currentIndex = Math.max(currentIndex - 1, 0);
      options[currentIndex].focus();
      break;
    case 'Home':
      event.preventDefault();
      currentIndex = 0;
      options[currentIndex].focus();
      break;
    case 'End':
      event.preventDefault();
      currentIndex = options.length - 1;
      options[currentIndex].focus();
      break;
  }
});
```

**4. WAI-ARIA Implementation**

WAI-ARIA attributes provide additional semantics to make dynamic content more accessible.

**a) ARIA Roles, States, and Properties**

```javascript
// Adding ARIA attributes to a custom tab component
function setupTabs() {
  const tabList = document.querySelector('.tab-list');
  const tabs = tabList.querySelectorAll('.tab');
  const panels = document.querySelectorAll('.tab-panel');
  
  // Set ARIA roles
  tabList.setAttribute('role', 'tablist');
  
  tabs.forEach((tab, index) => {
    // Set tab attributes
    tab.setAttribute('role', 'tab');
    tab.setAttribute('id', `tab-${index}`);
    tab.setAttribute('aria-selected', index === 0 ? 'true' : 'false');
    tab.setAttribute('aria-controls', `panel-${index}`);
    
    // Set panel attributes
    panels[index].setAttribute('role', 'tabpanel');
    panels[index].setAttribute('id', `panel-${index}`);
    panels[index].setAttribute('aria-labelledby', `tab-${index}`);
    
    if (index !== 0) {
      panels[index].setAttribute('hidden', '');
    }
    
    // Add event listener
    tab.addEventListener('click', () => activateTab(index, tabs, panels));
    tab.addEventListener('keydown', (e) => handleTabKeyboard(e, tabs));
  });
}

function activateTab(index, tabs, panels) {
  // Update ARIA states and show/hide panels
  tabs.forEach((tab, i) => {
    const isSelected = i === index;
    tab.setAttribute('aria-selected', isSelected ? 'true' : 'false');
    tab.setAttribute('tabindex', isSelected ? '0' : '-1');
    
    if (isSelected) {
      panels[i].removeAttribute('hidden');
    } else {
      panels[i].setAttribute('hidden', '');
    }
  });
}

function handleTabKeyboard(event, tabs) {
  // Implement left/right arrow navigation between tabs
  // ...
}
```

**b) Dynamic ARIA Updates**

```javascript
// Updating ARIA attributes for a loading state
function showLoading(buttonElement) {
  // Save original text for later
  buttonElement.dataset.originalText = buttonElement.textContent;
  
  // Update button to indicate loading
  buttonElement.textContent = 'Loading...';
  buttonElement.setAttribute('aria-busy', 'true');
  buttonElement.setAttribute('disabled', '');
}

function hideLoading(buttonElement) {
  // Restore button to original state
  buttonElement.textContent = buttonElement.dataset.originalText;
  buttonElement.removeAttribute('aria-busy');
  buttonElement.removeAttribute('disabled');
}

// Live regions for dynamic content updates
function showNotification(message, type = 'info') {
  const notification = document.getElementById('notification');
  notification.textContent = message;
  notification.className = `notification ${type}`;
  
  // Make screen readers announce the message
  notification.setAttribute('aria-live', type === 'error' ? 'assertive' : 'polite');
  
  // Hide after 5 seconds
  setTimeout(() => {
    notification.textContent = '';
    notification.className = 'notification';
  }, 5000);
}
```

**5. Managing Focus for Dynamic Content**

```javascript
// Restoring focus after an action
function deleteItem(itemId) {
  const item = document.getElementById(itemId);
  const parent = item.parentNode;
  const nextItem = item.nextElementSibling || item.previousElementSibling;
  
  // Store focus target before removing the element
  const focusTarget = nextItem || parent;
  
  // Remove the item
  parent.removeChild(item);
  
  // Restore focus to maintain keyboard navigation
  focusTarget.focus();
  
  // Announce the change
  showNotification('Item deleted');
}

// Managing focus when loading new content
async function loadMoreItems() {
  const loadMoreButton = document.getElementById('load-more');
  
  // Show loading state
  showLoading(loadMoreButton);
  
  try {
    // Fetch and append new items
    const newItems = await fetchItems();
    const container = document.getElementById('items-container');
    
    // Remember the first new item for focus management
    let firstNewItem;
    
    newItems.forEach((itemData, index) => {
      const item = createItemElement(itemData);
      container.appendChild(item);
      
      if (index === 0) {
        firstNewItem = item;
      }
    });
    
    // Hide loading state
    hideLoading(loadMoreButton);
    
    // Set focus to the first new item
    if (firstNewItem) {
      firstNewItem.focus();
      
      // Announce to screen readers
      showNotification(`${newItems.length} new items loaded`);
    }
  } catch (error) {
    hideLoading(loadMoreButton);
    showNotification('Failed to load items', 'error');
  }
}
```

**6. Handling Dynamic Content Changes**

```javascript
// Creating an accessible infinite scroll
function setupInfiniteScroll() {
  const container = document.getElementById('content');
  const loadingIndicator = document.createElement('div');
  
  loadingIndicator.id = 'loading-indicator';
  loadingIndicator.setAttribute('aria-live', 'polite');
  container.appendChild(loadingIndicator);
  
  // Set up intersection observer
  const observer = new IntersectionObserver(entries => {
    if (entries[0].isIntersecting) {
      loadMoreContent();
    }
  });
  
  observer.observe(loadingIndicator);
}

async function loadMoreContent() {
  const loadingIndicator = document.getElementById('loading-indicator');
  loadingIndicator.textContent = 'Loading more items...';
  
  try {
    const newItems = await fetchItems();
    const container = document.getElementById('content');
    
    // Create and append new items
    newItems.forEach(item => {
      const element = createItemElement(item);
      // Insert before the loading indicator
      container.insertBefore(element, loadingIndicator);
    });
    
    // Update screen reader
    loadingIndicator.textContent = `${newItems.length} new items loaded`;
    setTimeout(() => {
      loadingIndicator.textContent = '';
    }, 1000);
  } catch (error) {
    loadingIndicator.textContent = 'Failed to load more items';
  }
}

// Accessible toast notifications
class AccessibleToast {
  constructor() {
    this.container = document.createElement('div');
    this.container.className = 'toast-container';
    this.container.setAttribute('aria-live', 'polite');
    this.container.setAttribute('aria-atomic', 'true');
    document.body.appendChild(this.container);
  }
  
  show(message, type = 'info', duration = 3000) {
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.textContent = message;
    
    // Add a close button
    const closeButton = document.createElement('button');
    closeButton.className = 'toast-close';
    closeButton.innerHTML = '&times;';
    closeButton.setAttribute('aria-label', 'Close notification');
    closeButton.addEventListener('click', () => this.hide(toast));
    
    toast.appendChild(closeButton);
    this.container.appendChild(toast);
    
    // Auto-hide after duration
    if (duration > 0) {
      setTimeout(() => this.hide(toast), duration);
    }
    
    return toast;
  }
  
  hide(toast) {
    toast.classList.add('toast-hiding');
    setTimeout(() => {
      if (toast.parentNode === this.container) {
        this.container.removeChild(toast);
      }
    }, 300); // Match CSS transition duration
  }
}
```

**7. Form Accessibility**

```javascript
// Client-side form validation with accessibility
function setupFormValidation(formId) {
  const form = document.getElementById(formId);
  const inputs = form.querySelectorAll('input, select, textarea');
  
  // Create error message container
  const errorSummary = document.createElement('div');
  errorSummary.className = 'error-summary';
  errorSummary.setAttribute('aria-live', 'assertive');
  form.prepend(errorSummary);
  
  // Add validation to each input
  inputs.forEach(input => {
    // Create individual error message container
    const errorContainer = document.createElement('div');
    errorContainer.className = 'error-message';
    errorContainer.id = `${input.id}-error`;
    input.insertAdjacentElement('afterend', errorContainer);
    
    // Associate error message with input
    input.setAttribute('aria-describedby', errorContainer.id);
    
    // Validate on blur
    input.addEventListener('blur', () => validateInput(input));
  });
  
  // Form submission
  form.addEventListener('submit', event => {
    let isValid = true;
    const errors = [];
    
    inputs.forEach(input => {
      if (!validateInput(input)) {
        isValid = false;
        errors.push({
          field: input.name,
          message: input.dataset.errorMessage
        });
      }
    });
    
    if (!isValid) {
      event.preventDefault();
      
      // Update error summary
      errorSummary.innerHTML = '';
      if (errors.length > 0) {
        const heading = document.createElement('h2');
        heading.textContent = 'Please fix the following errors:';
        errorSummary.appendChild(heading);
        
        const list = document.createElement('ul');
        errors.forEach(error => {
          const item = document.createElement('li');
          const link = document.createElement('a');
          link.href = `#${error.field}`;
          link.textContent = error.message;
          item.appendChild(link);
          list.appendChild(item);
        });
        errorSummary.appendChild(list);
      }
      
      // Focus the first invalid input
      const firstInvalid = form.querySelector('.invalid');
      if (firstInvalid) {
        firstInvalid.focus();
      }
    }
  });
}

function validateInput(input) {
  const errorContainer = document.getElementById(`${input.id}-error`);
  let isValid = true;
  let errorMessage = '';
  
  // Clear previous state
  input.classList.remove('invalid');
  input.setAttribute('aria-invalid', 'false');
  
  // Check validity based on type and attributes
  if (input.hasAttribute('required') && !input.value.trim()) {
    isValid = false;
    errorMessage = `${input.name} is required`;
  } else if (input.type === 'email' && input.value && !isValidEmail(input.value)) {
    isValid = false;
    errorMessage = 'Please enter a valid email address';
  } else if (input.type === 'tel' && input.value && !isValidPhone(input.value)) {
    isValid = false;
    errorMessage = 'Please enter a valid phone number';
  } else if (input.hasAttribute('pattern') && input.value) {
    const pattern = new RegExp(input.getAttribute('pattern'));
    if (!pattern.test(input.value)) {
      isValid = false;
      errorMessage = input.dataset.patternMessage || 'Please match the requested format';
    }
  }
  
  // Update input state and error message
  if (!isValid) {
    input.classList.add('invalid');
    input.setAttribute('aria-invalid', 'true');
    errorContainer.textContent = errorMessage;
    input.dataset.errorMessage = errorMessage;
  } else {
    errorContainer.textContent = '';
    delete input.dataset.errorMessage;
  }
  
  return isValid;
}

// Helper validation functions
function isValidEmail(email) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

function isValidPhone(phone) {
  return /^[\d\+\-\(\)\s]+$/.test(phone);
}
```

**8. Accessible Rich Text Editors**

```javascript
// Basic accessible rich text editor
class AccessibleEditor {
  constructor(containerId) {
    this.container = document.getElementById(containerId);
    this.setupEditor();
  }
  
  setupEditor() {
    // Create toolbar
    const toolbar = document.createElement('div');
    toolbar.className = 'editor-toolbar';
    toolbar.setAttribute('role', 'toolbar');
    toolbar.setAttribute('aria-label', 'Formatting options');
    
    // Add toolbar buttons
    const buttons = [
      { command: 'bold', label: 'Bold', icon: 'B' },
      { command: 'italic', label: 'Italic', icon: 'I' },
      { command: 'createLink', label: 'Insert link', icon: '🔗' }
    ];
    
    buttons.forEach(btn => {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'editor-btn';
      button.textContent = btn.icon;
      button.setAttribute('aria-label', btn.label);
      button.addEventListener('click', () => this.execCommand(btn.command));
      toolbar.appendChild(button);
    });
    
    // Create editable area
    const editArea = document.createElement('div');
    editArea.className = 'editor-content';
    editArea.setAttribute('contenteditable', 'true');
    editArea.setAttribute('role', 'textbox');
    editArea.setAttribute('aria-multiline', 'true');
    editArea.setAttribute('aria-label', 'Text editor content');
    
    // Add keyboard shortcuts help
    const shortcuts = document.createElement('div');
    shortcuts.className = 'editor-shortcuts';
    shortcuts.textContent = 'Keyboard shortcuts: Ctrl+B (Bold), Ctrl+I (Italic), Ctrl+K (Link)';
    
    // Assemble editor
    this.container.appendChild(toolbar);
    this.container.appendChild(editArea);
    this.container.appendChild(shortcuts);
    
    // Store reference to editable area
    this.editArea = editArea;
    
    // Add keyboard shortcut handling
    this.editArea.addEventListener('keydown', this.handleKeyboardShortcuts.bind(this));
  }
  
  execCommand(command, value = null) {
    // Focus the edit area if not already focused
    if (document.activeElement !== this.editArea) {
      this.editArea.focus();
    }
    
    // Handle special cases
    if (command === 'createLink') {
      value = prompt('Enter the URL:');
      if (!value) return; // Cancelled
    }
    
    // Execute command
    document.execCommand(command, false, value);
    
    // Announce change to screen readers
    this.announceAction(command);
  }
  
  handleKeyboardShortcuts(event) {
    // Check for Ctrl/Cmd key combinations
    if (event.ctrlKey || event.metaKey) {
      switch (event.key.toLowerCase()) {
        case 'b':
          event.preventDefault();
          this.execCommand('bold');
          break;
        case 'i':
          event.preventDefault();
          this.execCommand('italic');
          break;
        case 'k':
          event.preventDefault();
          this.execCommand('createLink');
          break;
      }
    }
  }
  
  announceAction(command) {
    // Create or get announcement area
    let announcer = document.getElementById('editor-announcer');
    if (!announcer) {
      announcer = document.createElement('div');
      announcer.id = 'editor-announcer';
      announcer.setAttribute('aria-live', 'polite');
      announcer.className = 'sr-only'; // Screen reader only
      document.body.appendChild(announcer);
    }
    
    // Map commands to human-readable messages
    const messages = {
      bold: 'Text bolded',
      italic: 'Text italicized',
      createLink: 'Link inserted'
    };
    
    // Announce the action
    announcer.textContent = messages[command] || `Applied ${command}`;
  }
  
  getValue() {
    return this.editArea.innerHTML;
  }
  
  setValue(html) {
    this.editArea.innerHTML = html;
  }
}
```

**9. Testing and Auditing Accessibility**

```javascript
// Simple accessibility checker
function checkAccessibility() {
  const issues = [];
  
  // Check for images without alt text
  const images = document.querySelectorAll('img:not([alt])');
  images.forEach(img => {
    issues.push({
      element: img,
      issue: 'Image missing alt attribute',
      impact: 'Critical',
      wcag: '1.1.1 Non-text Content'
    });
  });
  
  // Check for form inputs without labels
  const inputs = document.querySelectorAll('input, select, textarea');
  inputs.forEach(input => {
    if (!input.hasAttribute('aria-label') && 
        !input.hasAttribute('aria-labelledby') && 
        !document.querySelector(`label[for="${input.id}"]`)) {
      issues.push({
        element: input,
        issue: 'Form control missing label',
        impact: 'Critical',
        wcag: '3.3.2 Labels or Instructions'
      });
    }
  });
  
  // Check for insufficient color contrast (simplified)
  // Note: A real implementation would need to calculate contrast ratios
  const elements = document.querySelectorAll('*');
  elements.forEach(el => {
    const style = window.getComputedStyle(el);
    if (style.color === 'rgb(128, 128, 128)' && style.backgroundColor === 'rgb(240, 240, 240)') {
      issues.push({
        element: el,
        issue: 'Potential insufficient color contrast',
        impact: 'Serious',
        wcag: '1.4.3 Contrast (Minimum)'
      });
    }
  });
  
  // Check for missing document language
  if (!document.documentElement.hasAttribute('lang')) {
    issues.push({
      element: document.documentElement,
      issue: 'Document language not specified',
      impact: 'Serious',
      wcag: '3.1.1 Language of Page'
    });
  }
  
  return issues;
}

// Highlight accessibility issues on the page
function showAccessibilityIssues() {
  const issues = checkAccessibility();
  
  // Remove previous highlights
  document.querySelectorAll('.a11y-highlight').forEach(el => {
    el.classList.remove('a11y-highlight');
  });
  
  // Highlight elements with issues
  issues.forEach(issue => {
    issue.element.classList.add('a11y-highlight');
    issue.element.setAttribute('title', `${issue.issue} (${issue.wcag})`);
  });
  
  // Log issues to console
  console.table(issues.map(i => ({
    Issue: i.issue,
    Impact: i.impact,
    WCAG: i.wcag,
    Element: i.element.outerHTML.substring(0, 100) + '...'
  })));
  
  return issues;
}
```

**10. Accessibility Best Practices**

**a) Progressive Enhancement**

```javascript
// Progressive enhancement for a tabbed interface
function setupTabbedInterface() {
  const container = document.querySelector('.tabs-container');
  
  // Check if JavaScript is available
  if (!container) return;
  
  const tabList = document.createElement('ul');
  tabList.className = 'tabs-list';
  tabList.setAttribute('role', 'tablist');
  
  // Get all sections that will become tabs
  const sections = container.querySelectorAll('section');
  
  // Create tabs and set up panels
  sections.forEach((section, index) => {
    // Get heading to use as tab text
    const heading = section.querySelector('h2, h3');
    if (!heading) return;
    
    // Create tab
    const tab = document.createElement('li');
    tab.setAttribute('role', 'tab');
    tab.id = `tab-${index}`;
    tab.setAttribute('aria-controls', `panel-${index}`);
    tab.setAttribute('aria-selected', index === 0 ? 'true' : 'false');
    tab.tabIndex = index === 0 ? 0 : -1;
    tab.textContent = heading.textContent;
    tabList.appendChild(tab);
    
    // Set up panel
    section.setAttribute('role', 'tabpanel');
    section.id = `panel-${index}`;
    section.setAttribute('aria-labelledby', `tab-${index}`);
    section.tabIndex = 0;
    
    // Hide non-active panels
    if (index !== 0) {
      section.hidden = true;
    }
    
    // Remove the heading as it's now redundant
    heading.parentNode.removeChild(heading);
  });
  
  // Insert tab list before the first section
  container.insertBefore(tabList, container.firstChild);
  
  // Add event listeners
  tabList.addEventListener('click', handleTabClick);
  tabList.addEventListener('keydown', handleTabKeydown);
}

function handleTabClick(event) {
  const tab = event.target.closest('[role="tab"]');
  if (!tab) return;
  
  activateTab(tab);
}

function handleTabKeydown(event) {
  const tab = event.target.closest('[role="tab"]');
  if (!tab) return;
  
  const tabs = Array.from(tab.parentNode.children);
  const index = tabs.indexOf(tab);
  
  // Handle arrow keys
  switch (event.key) {
    case 'ArrowRight':
    case 'ArrowDown':
      event.preventDefault();
      activateTab(tabs[(index + 1) % tabs.length]);
      break;
    case 'ArrowLeft':
    case 'ArrowUp':
      event.preventDefault();
      activateTab(tabs[(index - 1 + tabs.length) % tabs.length]);
      break;
    case 'Home':
      event.preventDefault();
      activateTab(tabs[0]);
      break;
    case 'End':
      event.preventDefault();
      activateTab(tabs[tabs.length - 1]);
      break;
  }
}

function activateTab(tab) {
  const tabList = tab.parentNode;
  const container = tabList.parentNode;
  
  // Deactivate all tabs
  Array.from(tabList.children).forEach(t => {
    t.setAttribute('aria-selected', 'false');
    t.tabIndex = -1;
  });
  
  // Hide all panels
  Array.from(container.querySelectorAll('[role="tabpanel"]')).forEach(p => {
    p.hidden = true;
  });
  
  // Activate the selected tab
  tab.setAttribute('aria-selected', 'true');
  tab.tabIndex = 0;
  tab.focus();
  
  // Show the selected panel
  const panelId = tab.getAttribute('aria-controls');
  const panel = document.getElementById(panelId);
  panel.hidden = false;
}
```

**b) Responsive and Mobile Accessibility**

```javascript
// Making touch targets accessible
function improveTouch() {
  const smallButtons = document.querySelectorAll('.small-button');
  
  smallButtons.forEach(button => {
    // Ensure minimum touch target size (44x44px recommended)
    if (button.offsetWidth < 44 || button.offsetHeight < 44) {
      button.style.minWidth = '44px';
      button.style.minHeight = '44px';
      
      // If visual size needs to stay small, use padding and negative margin
      if (button.classList.contains('visually-small')) {
        const currentPadding = parseInt(window.getComputedStyle(button).padding);
        const requiredPadding = Math.max(0, (44 - button.offsetWidth + currentPadding * 2) / 2);
        
        button.style.padding = `${requiredPadding}px`;
        button.style.margin = `-${requiredPadding}px`;
      }
    }
  });
}

// Handle orientation changes
window.addEventListener('orientationchange', function() {
  // Announce orientation change to screen readers
  const announcer = document.getElementById('orientation-announcer') || 
                   document.createElement('div');
  
  if (!document.getElementById('orientation-announcer')) {
    announcer.id = 'orientation-announcer';
    announcer.setAttribute('aria-live', 'polite');
    announcer.className = 'sr-only';
    document.body.appendChild(announcer);
  }
  
  const orientation = window.orientation === 0 || window.orientation === 180 ? 
                     'portrait' : 'landscape';
  
  announcer.textContent = `Screen orientation changed to ${orientation}`;
  
  // Adjust UI for new orientation if needed
  adjustUIForOrientation(orientation);
});

function adjustUIForOrientation(orientation) {
  const menu = document.querySelector('.mobile-menu');
  
  if (orientation === 'landscape') {
    // In landscape, show menu inline if there's enough space
    menu.classList.remove('dropdown');
    menu.classList.add('horizontal');
  } else {
    // In portrait, use dropdown menu to save vertical space
    menu.classList.remove('horizontal');
    menu.classList.add('dropdown');
  }
}
```

**c) Accessibility for Single Page Applications (SPAs)**

```javascript
// Announcing page changes in SPAs
class RouteAnnouncer {
  constructor() {
    this.announcer = document.createElement('div');
    this.announcer.setAttribute('aria-live', 'assertive');
    this.announcer.setAttribute('aria-atomic', 'true');
    this.announcer.className = 'sr-only';
    document.body.appendChild(this.announcer);
    
    // Keep track of the current route
    this.currentRoute = window.location.pathname;
    
    // Listen for history changes
    window.addEventListener('popstate', this.handleRouteChange.bind(this));
  }
  
  // Call this method when your SPA changes routes programmatically
  announceRouteChange(newPath, title) {
    this.currentRoute = newPath;
    
    // Update the page title
    document.title = title;
    
    // Announce the page change
    this.announcer.textContent = `Navigated to ${title}`;
    
    // Update focus management
    this.manageFocus();
  }
  
  handleRouteChange() {
    // This handles browser back/forward navigation
    if (window.location.pathname !== this.currentRoute) {
      this.currentRoute = window.location.pathname;
      
      // Get the title from the current view
      const title = document.title;
      
      // Announce the change
      this.announcer.textContent = `Navigated to ${title}`;
      
      // Update focus management
      this.manageFocus();
    }
  }
  
  manageFocus() {
    // Find the main content area
    const main = document.querySelector('main, [role="main"]');
    
    if (main) {
      // Set focus to the main content area
      // First, make it focusable if it isn't already
      if (!main.hasAttribute('tabindex')) {
        main.setAttribute('tabindex', '-1');
      }
      
      // Focus the element
      main.focus();
    }
  }
}

// Usage
const routeAnnouncer = new RouteAnnouncer();

// In your router implementation
function navigateTo(path, title) {
  // Update the URL
  history.pushState({}, title, path);
  
  // Load the new content
  loadContent(path);
  
  // Announce the route change
  routeAnnouncer.announceRouteChange(path, title);
}
```

**Key Takeaways:**

1. Accessibility is essential for creating inclusive web applications that can be used by everyone
2. Start with semantic HTML as the foundation for accessible JavaScript applications
3. Ensure keyboard accessibility for all interactive elements and custom components
4. Use WAI-ARIA attributes to enhance the accessibility of dynamic content
5. Manage focus carefully when content changes dynamically
6. Implement proper form validation with clear error messages
7. Test with screen readers and keyboard-only navigation to identify accessibility issues
8. Follow progressive enhancement principles to ensure functionality without JavaScript
9. Consider mobile and touch accessibility in responsive designs
10. In SPAs, announce page changes and manage focus when routes change

### Q97: Explain JavaScript internationalization (i18n) and localization (l10n). How can you build applications that support multiple languages and regions?
**Difficulty: Medium**

**Answer:**
Internationalization (i18n) and localization (l10n) are essential aspects of modern web development that enable applications to reach global audiences. Internationalization refers to designing and developing applications that can be adapted to different languages and regions, while localization is the process of adapting the application to a specific locale or market.

**1. Understanding i18n and l10n**

**a) Key Concepts**

- **Internationalization (i18n)**: The process of designing and developing an application that can be adapted to various languages and regions without engineering changes.
- **Localization (l10n)**: The process of adapting internationalized software for a specific region or language by translating text and adding locale-specific components.
- **Locale**: A set of parameters that defines a user's language, region, and any special variant preferences.
- **Character Encoding**: Ensures proper display of characters from different writing systems (UTF-8 is the recommended standard).

**b) Benefits of i18n and l10n**

- Expanded market reach and user base
- Improved user experience for non-native speakers
- Compliance with local regulations and requirements
- Competitive advantage in global markets
- Easier maintenance compared to creating separate versions for each locale

**2. JavaScript Internationalization API (Intl)**

The ECMAScript Internationalization API (Intl) provides language-sensitive string comparison, number formatting, date and time formatting, and more.

**a) Formatting Numbers**

```javascript
// Basic number formatting
const number = 123456.789;

// US English format (default in US browsers)
const usFormatter = new Intl.NumberFormat('en-US');
console.log(usFormatter.format(number)); // "123,456.789"

// German format
const deFormatter = new Intl.NumberFormat('de-DE');
console.log(deFormatter.format(number)); // "123.456,789"

// Currency formatting
const eurFormatter = new Intl.NumberFormat('de-DE', {
  style: 'currency',
  currency: 'EUR'
});
console.log(eurFormatter.format(number)); // "123.456,79 €"

const jpyFormatter = new Intl.NumberFormat('ja-JP', {
  style: 'currency',
  currency: 'JPY'
});
console.log(jpyFormatter.format(number)); // "¥123,457"

// Percentage formatting
const percentFormatter = new Intl.NumberFormat('en-US', {
  style: 'percent',
  minimumFractionDigits: 1,
  maximumFractionDigits: 1
});
console.log(percentFormatter.format(0.2345)); // "23.5%"
```

**b) Formatting Dates and Times**

```javascript
const date = new Date(Date.UTC(2023, 11, 20, 3, 23, 16));

// US English format
const usDateFormatter = new Intl.DateTimeFormat('en-US');
console.log(usDateFormatter.format(date)); // "12/20/2023"

// British English format
const gbDateFormatter = new Intl.DateTimeFormat('en-GB');
console.log(gbDateFormatter.format(date)); // "20/12/2023"

// Korean format
const krDateFormatter = new Intl.DateTimeFormat('ko-KR');
console.log(krDateFormatter.format(date)); // "2023. 12. 20."

// With time
const dateTimeFormatter = new Intl.DateTimeFormat('en-US', {
  year: 'numeric',
  month: 'long',
  day: 'numeric',
  hour: 'numeric',
  minute: 'numeric',
  second: 'numeric',
  timeZone: 'America/Los_Angeles',
  timeZoneName: 'short'
});
console.log(dateTimeFormatter.format(date)); // "December 19, 2023, 7:23:16 PM PST"

// Relative time formatting
const rtf = new Intl.RelativeTimeFormat('en', { style: 'long' });
console.log(rtf.format(-1, 'day')); // "1 day ago"
console.log(rtf.format(2, 'day')); // "in 2 days"
console.log(rtf.format(-1, 'week')); // "1 week ago"
```

**c) String Comparison and Sorting**

```javascript
// String comparison for different locales
const strings = ['Z', 'a', 'z', 'A'];

// Default sort (based on Unicode code points)
console.log([...strings].sort());
// ['A', 'Z', 'a', 'z']

// Case-insensitive sort in English
const enCollator = new Intl.Collator('en', { sensitivity: 'base' });
console.log([...strings].sort(enCollator.compare));
// ['a', 'A', 'z', 'Z'] or ['A', 'a', 'Z', 'z']

// Sort with locale-specific rules
const svCollator = new Intl.Collator('sv'); // Swedish
const deCollator = new Intl.Collator('de-DE-u-co-phonebk'); // German phonebook sorting

// Example with special characters
const germanNames = ['Müller', 'Mayer', 'Märtz'];
console.log([...germanNames].sort(deCollator.compare));
// Sorts according to German phonebook rules
```

**d) Pluralization with PluralRules**

```javascript
// Determine plural category for a number
const pr = new Intl.PluralRules('en-US');
console.log(pr.select(0)); // 'other'
console.log(pr.select(1)); // 'one'
console.log(pr.select(2)); // 'other'

// Practical example with ordinal numbers
const ordinalRules = new Intl.PluralRules('en-US', { type: 'ordinal' });

function formatOrdinal(number) {
  const suffix = {
    one: 'st',
    two: 'nd',
    few: 'rd',
    other: 'th'
  };
  return `${number}${suffix[ordinalRules.select(number)]}`;
}

console.log(formatOrdinal(1)); // "1st"
console.log(formatOrdinal(2)); // "2nd"
console.log(formatOrdinal(3)); // "3rd"
console.log(formatOrdinal(4)); // "4th"
console.log(formatOrdinal(21)); // "21st"
console.log(formatOrdinal(42)); // "42nd"
```

**e) List Formatting**

```javascript
const fruits = ['Apple', 'Orange', 'Banana'];

// Format as a list in different locales
const enListFormatter = new Intl.ListFormat('en', { style: 'long', type: 'conjunction' });
console.log(enListFormatter.format(fruits)); // "Apple, Orange, and Banana"

const esListFormatter = new Intl.ListFormat('es', { style: 'long', type: 'conjunction' });
console.log(esListFormatter.format(fruits)); // "Apple, Orange y Banana"

// Different types
const disjunctionFormatter = new Intl.ListFormat('en', { style: 'short', type: 'disjunction' });
console.log(disjunctionFormatter.format(fruits)); // "Apple, Orange, or Banana"

const unitFormatter = new Intl.ListFormat('en', { style: 'narrow', type: 'unit' });
console.log(unitFormatter.format(fruits)); // "Apple Orange Banana"
```

**3. Translation and Message Formatting**

**a) Basic Translation with Object Dictionaries**

```javascript
// Simple translation dictionary
const translations = {
  'en': {
    'greeting': 'Hello, {name}!',
    'farewell': 'Goodbye!',
    'items_selected': '{count, plural, =0{No items} one{1 item} other{# items}} selected.'
  },
  'es': {
    'greeting': '¡Hola, {name}!',
    'farewell': '¡Adiós!',
    'items_selected': '{count, plural, =0{Ningún elemento} one{1 elemento} other{# elementos}} seleccionados.'
  },
  'fr': {
    'greeting': 'Bonjour, {name} !',
    'farewell': 'Au revoir !',
    'items_selected': '{count, plural, =0{Aucun élément} one{1 élément} other{# éléments}} sélectionnés.'
  }
};

// Simple translation function
function translate(key, locale = 'en', params = {}) {
  const message = translations[locale]?.[key] || translations['en'][key] || key;
  
  return message.replace(/{([^}]+)}/g, (match, p1) => {
    return params[p1] !== undefined ? params[p1] : match;
  });
}

console.log(translate('greeting', 'es', { name: 'Miguel' })); // "¡Hola, Miguel!"
console.log(translate('farewell', 'fr')); // "Au revoir !"
```

**b) Advanced Message Formatting with ICU MessageFormat**

For more complex translations, especially those involving pluralization, gender, and selections, libraries like `intl-messageformat` or `format-message` are commonly used.

```javascript
// Using intl-messageformat library
import IntlMessageFormat from 'intl-messageformat';

const messages = {
  en: {
    photos: '{name} {numPhotos, plural, =0 {has no photos} =1 {has one photo} other {has # photos}}.',
    select_example: '{gender, select, male {He} female {She} other {They}} liked this.',
    price: 'The price is {price, number, currency}.'
  }
};

// Format a message
const msgFormatter = new IntlMessageFormat(messages.en.photos, 'en');
console.log(msgFormatter.format({ name: 'Alex', numPhotos: 0 })); // "Alex has no photos."
console.log(msgFormatter.format({ name: 'Alex', numPhotos: 1 })); // "Alex has one photo."
console.log(msgFormatter.format({ name: 'Alex', numPhotos: 5 })); // "Alex has 5 photos."

// Gender selection
const genderFormatter = new IntlMessageFormat(messages.en.select_example, 'en');
console.log(genderFormatter.format({ gender: 'male' })); // "He liked this."
console.log(genderFormatter.format({ gender: 'female' })); // "She liked this."
console.log(genderFormatter.format({ gender: 'non-binary' })); // "They liked this."

// Currency formatting
const priceFormatter = new IntlMessageFormat(messages.en.price, 'en');
console.log(priceFormatter.format({ price: 1000 })); // "The price is $1,000.00."
```

**4. Building an i18n System**

**a) Setting Up a Basic i18n System**

```javascript
class I18n {
  constructor(defaultLocale = 'en') {
    this.locale = defaultLocale;
    this.messages = {};
    this.formatters = {};
  }
  
  setLocale(locale) {
    this.locale = locale;
    // Update document language for screen readers
    document.documentElement.setAttribute('lang', locale.split('-')[0]);
    // Trigger event for components to update
    window.dispatchEvent(new CustomEvent('localechange', { detail: { locale } }));
    return this;
  }
  
  addMessages(locale, messages) {
    this.messages[locale] = { ...this.messages[locale], ...messages };
    return this;
  }
  
  getLocale() {
    return this.locale;
  }
  
  translate(key, params = {}) {
    const message = this.messages[this.locale]?.[key] || 
                   this.messages['en']?.[key] || 
                   key;
    
    // Simple replacement for basic variables
    return message.replace(/{([^}]+)}/g, (match, p1) => {
      return params[p1] !== undefined ? params[p1] : match;
    });
  }
  
  // Shorthand method
  t(key, params = {}) {
    return this.translate(key, params);
  }
  
  // Format a number according to locale conventions
  formatNumber(number, options = {}) {
    const formatter = new Intl.NumberFormat(this.locale, options);
    return formatter.format(number);
  }
  
  // Format a date according to locale conventions
  formatDate(date, options = {}) {
    const formatter = new Intl.DateTimeFormat(this.locale, options);
    return formatter.format(date);
  }
  
  // Format a relative time
  formatRelativeTime(value, unit, options = {}) {
    const formatter = new Intl.RelativeTimeFormat(this.locale, options);
    return formatter.format(value, unit);
  }
}

// Usage
const i18n = new I18n('en');

i18n.addMessages('en', {
  welcome: 'Welcome, {name}!',
  items_in_cart: 'You have {count} items in your cart.',
  order_placed: 'Your order was placed on {date}.'
});

i18n.addMessages('es', {
  welcome: '¡Bienvenido, {name}!',
  items_in_cart: 'Tienes {count} artículos en tu carrito.',
  order_placed: 'Tu pedido fue realizado el {date}.'
});

// English
console.log(i18n.t('welcome', { name: 'John' })); // "Welcome, John!"

// Switch to Spanish
i18n.setLocale('es');
console.log(i18n.t('welcome', { name: 'John' })); // "¡Bienvenido, John!"

// Format a date in the current locale
const orderDate = new Date();
console.log(i18n.t('order_placed', { 
  date: i18n.formatDate(orderDate, { dateStyle: 'long' })
})); // "Tu pedido fue realizado el 20 de diciembre de 2023." (in Spanish)
```

**b) Detecting User's Preferred Language**

```javascript
function detectUserLanguage() {
  // Check for language preference in URL parameters
  const urlParams = new URLSearchParams(window.location.search);
  const urlLocale = urlParams.get('lang');
  if (urlLocale) {
    return urlLocale;
  }
  
  // Check for language in localStorage (user's previous choice)
  const storedLocale = localStorage.getItem('userLocale');
  if (storedLocale) {
    return storedLocale;
  }
  
  // Use browser's language preferences
  if (navigator.languages && navigator.languages.length) {
    // Navigator.languages is an array of user's preferred languages
    return navigator.languages[0];
  }
  
  // Fallbacks
  return navigator.language || navigator.userLanguage || 'en';
}

// Usage
const userLocale = detectUserLanguage();
i18n.setLocale(userLocale);

// Save user's language choice
function saveLanguagePreference(locale) {
  localStorage.setItem('userLocale', locale);
  i18n.setLocale(locale);
}

// Example language switcher
function setupLanguageSwitcher() {
  const switcher = document.getElementById('language-switcher');
  
  switcher.addEventListener('change', (event) => {
    const selectedLocale = event.target.value;
    saveLanguagePreference(selectedLocale);
    // Reload content with new locale
    updatePageContent();
  });
  
  // Set initial value
  switcher.value = i18n.getLocale();
}
```

**5. Handling Locale-Specific Content**

**a) Text Direction (RTL vs LTR)**

```javascript
function setTextDirection(locale) {
  // RTL languages
  const rtlLanguages = ['ar', 'he', 'fa', 'ur'];
  
  // Get the base language code
  const baseLanguage = locale.split('-')[0];
  
  // Set direction attribute on html or body
  const direction = rtlLanguages.includes(baseLanguage) ? 'rtl' : 'ltr';
  document.documentElement.setAttribute('dir', direction);
  
  // You might also want to add a class for additional styling
  document.documentElement.classList.remove('rtl', 'ltr');
  document.documentElement.classList.add(direction);
  
  return direction;
}

// Usage
const direction = setTextDirection(i18n.getLocale());
console.log(`Text direction is ${direction}`);

// CSS considerations for RTL support
/*
.container {
  padding-left: 20px;
  padding-right: 10px;
}

// In RTL, we want to flip these
.rtl .container {
  padding-left: 10px;
  padding-right: 20px;
}

// Better approach using logical properties
.container {
  padding-inline-start: 20px;
  padding-inline-end: 10px;
}
*/
```

**b) Locale-Specific Formatting**

```javascript
function formatAddressForLocale(address, locale) {
  // Different locales have different address formats
  switch(locale) {
    case 'en-US':
      return `${address.name}
${address.street}
${address.city}, ${address.state} ${address.zip}
${address.country}`;
    
    case 'en-GB':
      return `${address.name}
${address.street}
${address.city}
${address.county}
${address.postcode}
${address.country}`;
    
    case 'ja-JP':
      return `〒${address.postcode}
${address.prefecture}${address.city}${address.street}
${address.name}`;
    
    default:
      // Default format
      return `${address.name}
${address.street}
${address.city}
${address.postcode}
${address.country}`;
  }
}

// Example usage
const address = {
  name: 'John Smith',
  street: '123 Main St',
  city: 'Anytown',
  state: 'CA',
  zip: '12345',
  postcode: '12345',
  county: 'Countyshire',
  prefecture: '東京都',
  country: 'United States'
};

console.log(formatAddressForLocale(address, 'en-US'));
/*
John Smith
123 Main St
Anytown, CA 12345
United States
*/

console.log(formatAddressForLocale(address, 'ja-JP'));
/*
〒12345
東京都Anytown123 Main St
John Smith
*/
```

**6. Loading Translations Dynamically**

```javascript
class I18nLoader extends I18n {
  constructor(defaultLocale = 'en', translationPath = '/locales/') {
    super(defaultLocale);
    this.translationPath = translationPath;
    this.loadedLocales = new Set();
  }
  
  async loadLocale(locale) {
    if (this.loadedLocales.has(locale)) {
      return Promise.resolve();
    }
    
    try {
      const response = await fetch(`${this.translationPath}${locale}.json`);
      
      if (!response.ok) {
        throw new Error(`Failed to load translations for ${locale}`);
      }
      
      const messages = await response.json();
      this.addMessages(locale, messages);
      this.loadedLocales.add(locale);
      
      return messages;
    } catch (error) {
      console.error(`Error loading translations for ${locale}:`, error);
      // Fallback to default locale if it's not the one that failed
      if (locale !== this.defaultLocale) {
        return this.loadLocale(this.defaultLocale);
      }
      return Promise.reject(error);
    }
  }
  
  async setLocaleAndLoad(locale) {
    await this.loadLocale(locale);
    this.setLocale(locale);
    return this;
  }
}

// Usage
const i18nLoader = new I18nLoader('en', '/assets/locales/');

async function initializeApp() {
  const userLocale = detectUserLanguage();
  
  try {
    await i18nLoader.setLocaleAndLoad(userLocale);
    updatePageContent();
  } catch (error) {
    console.error('Failed to initialize translations:', error);
    // Continue with default hardcoded strings as fallback
  }
}

// Update all translatable elements on the page
function updatePageContent() {
  // Update elements with data-i18n attribute
  document.querySelectorAll('[data-i18n]').forEach(element => {
    const key = element.getAttribute('data-i18n');
    element.textContent = i18nLoader.t(key);
  });
  
  // Update elements with data-i18n-placeholder attribute
  document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
    const key = element.getAttribute('data-i18n-placeholder');
    element.placeholder = i18nLoader.t(key);
  });
  
  // Update elements with data-i18n-html attribute (for HTML content)
  document.querySelectorAll('[data-i18n-html]').forEach(element => {
    const key = element.getAttribute('data-i18n-html');
    element.innerHTML = i18nLoader.t(key);
  });
}
```

**7. i18n with Modern JavaScript Frameworks**

**a) React with react-intl**

```jsx
import React from 'react';
import { IntlProvider, FormattedMessage, FormattedNumber, FormattedDate } from 'react-intl';

// Messages for different locales
const messages = {
  en: {
    'app.greeting': 'Hello, {name}!',
    'app.intro': 'Welcome to our application',
    'app.items': 'You have {itemCount} {itemCount, plural, one {item} other {items}} in your cart',
    'app.lastLogin': 'Last login: {lastLogin, date, medium}'
  },
  es: {
    'app.greeting': '¡Hola, {name}!',
    'app.intro': 'Bienvenido a nuestra aplicación',
    'app.items': 'Tienes {itemCount} {itemCount, plural, one {artículo} other {artículos}} en tu carrito',
    'app.lastLogin': 'Último inicio de sesión: {lastLogin, date, medium}'
  }
};

// App component
function App() {
  const [locale, setLocale] = React.useState('en');
  
  const handleLanguageChange = (e) => {
    setLocale(e.target.value);
  };
  
  return (
    <IntlProvider locale={locale} messages={messages[locale]}>
      <div className="app">
        <header>
          <select value={locale} onChange={handleLanguageChange}>
            <option value="en">English</option>
            <option value="es">Español</option>
          </select>
        </header>
        
        <main>
          <h1>
            <FormattedMessage id="app.greeting" values={{ name: 'User' }} />
          </h1>
          
          <p>
            <FormattedMessage id="app.intro" />
          </p>
          
          <div>
            <FormattedMessage 
              id="app.items" 
              values={{ itemCount: 3 }} 
            />
          </div>
          
          <div>
            <FormattedMessage 
              id="app.lastLogin" 
              values={{ lastLogin: new Date() }} 
            />
          </div>
          
          <div>
            Price: <FormattedNumber 
              value={1234.56} 
              style="currency" 
              currency="USD" 
            />
          </div>
        </main>
      </div>
    </IntlProvider>
  );
}
```

**b) Vue with vue-i18n**

```javascript
import Vue from 'vue';
import VueI18n from 'vue-i18n';

Vue.use(VueI18n);

const i18n = new VueI18n({
  locale: 'en',
  fallbackLocale: 'en',
  messages: {
    en: {
      greeting: 'Hello, {name}!',
      items: 'You have | 1 item | {count} items',
      price: 'Price: {price}'
    },
    fr: {
      greeting: 'Bonjour, {name} !',
      items: 'Vous avez | 1 article | {count} articles',
      price: 'Prix : {price}'
    }
  },
  numberFormats: {
    en: {
      currency: {
        style: 'currency',
        currency: 'USD'
      }
    },
    fr: {
      currency: {
        style: 'currency',
        currency: 'EUR'
      }
    }
  },
  dateTimeFormats: {
    en: {
      short: {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      }
    },
    fr: {
      short: {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      }
    }
  }
});

// Vue component
export default {
  template: `
    <div>
      <select v-model="$i18n.locale">
        <option value="en">English</option>
        <option value="fr">Français</option>
      </select>
      
      <h1>{{ $t('greeting', { name: 'User' }) }}</h1>
      
      <p>{{ $tc('items', itemCount, { count: itemCount }) }}</p>
      
      <p>{{ $t('price', { price: $n(price, 'currency') }) }}</p>
      
      <p>{{ $d(date, 'short') }}</p>
    </div>
  `,
  data() {
    return {
      itemCount: 5,
      price: 99.99,
      date: new Date()
    };
  }
};

// Create Vue instance
new Vue({
  i18n,
  // ...
});
```

**c) Angular with ngx-translate or built-in i18n**

```typescript
// Using Angular's built-in i18n
// In component template
/*
<h1 i18n="@@greeting">Hello, {{name}}!</h1>
<p i18n="@@items">You have {{itemCount}} items in your cart.</p>
<p i18n="@@lastLogin">Last login: {{lastLogin | date}}</p>
*/

// Using ngx-translate
import { Component } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';

@Component({
  selector: 'app-root',
  template: `
    <div>
      <select [(ngModel)]="currentLang" (change)="switchLanguage()">
        <option *ngFor="let lang of languages" [value]="lang">{{ lang }}</option>
      </select>
      
      <h1>{{ 'greeting' | translate:{ name: userName } }}</h1>
      
      <p>{{ 'items' | translate:{ count: itemCount } }}</p>
      
      <p>{{ 'price' | translate:{ price: price | currency } }}</p>
      
      <p>{{ 'lastLogin' | translate:{ date: lastLogin | date } }}</p>
    </div>
  `
})
export class AppComponent {
  languages = ['en', 'fr', 'es'];
  currentLang = 'en';
  userName = 'User';
  itemCount = 5;
  price = 99.99;
  lastLogin = new Date();
  
  constructor(private translate: TranslateService) {
    translate.setDefaultLang('en');
    translate.use(this.currentLang);
  }
  
  switchLanguage() {
    this.translate.use(this.currentLang);
  }
}
```

**8. Best Practices for i18n and l10n**

**a) Design and Development**

- **Start early**: Design with internationalization in mind from the beginning
- **Separate content from code**: Never hardcode strings in your application
- **Context matters**: Provide context for translators with comments
- **Handle pluralization**: Use proper plural forms for different languages
- **Avoid concatenation**: Don't build sentences by concatenating strings
- **Use Unicode**: Always use UTF-8 encoding for proper character support
- **Consider text expansion**: Some languages require more space than English (up to 30-40% more)

**b) Translation Management**

- **Use translation management systems**: Tools like Phrase, Lokalise, or Crowdin
- **Provide context**: Add screenshots and descriptions for translators
- **Maintain a glossary**: Ensure consistency in terminology
- **Implement a review process**: Have native speakers review translations
- **Version your translations**: Track changes to translations over time

**c) Performance Considerations**

- **Lazy load translations**: Only load translations for the current locale
- **Cache translations**: Store translations in localStorage or IndexedDB
- **Bundle by locale**: Create separate bundles for each locale
- **Consider using CDNs**: Deliver locale-specific assets from edge servers

**d) Testing and Quality Assurance**

- **Test with pseudo-localization**: Replace strings with modified versions to catch hardcoded text
- **Test with RTL languages**: Ensure layouts work correctly with right-to-left text
- **Test with various character sets**: Especially for languages with non-Latin scripts
- **Automate screenshot testing**: Compare UI across different languages
- **Test date and number formats**: Ensure proper formatting across locales

**9. Common Challenges and Solutions**

**a) Handling Bidirectional Text**

```javascript
// Helper function to determine if text contains RTL characters
function containsRTLText(text) {
  const rtlChars = /[\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC]/;
  return rtlChars.test(text);
}

// Apply appropriate direction to elements
function applyTextDirection() {
  document.querySelectorAll('[data-i18n-auto-dir]').forEach(element => {
    const text = element.textContent;
    if (containsRTLText(text)) {
      element.setAttribute('dir', 'rtl');
    } else {
      element.setAttribute('dir', 'ltr');
    }
  });
}

// Call after updating content
updatePageContent();
applyTextDirection();
```

**b) Handling Date and Time Zones**

```javascript
// Format date considering both locale and time zone
function formatLocalDateTime(date, locale, timeZone, options = {}) {
  const defaultOptions = {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
    timeZoneName: 'short'
  };
  
  const formatter = new Intl.DateTimeFormat(
    locale, 
    { ...defaultOptions, ...options, timeZone }
  );
  
  return formatter.format(date);
}

// Example: Show event time in user's local time zone and specified time zone
function displayEventTime(eventDate, eventTimeZone, userLocale) {
  const userTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  
  const localTime = formatLocalDateTime(
    eventDate, 
    userLocale, 
    userTimeZone
  );
  
  const eventTime = formatLocalDateTime(
    eventDate, 
    userLocale, 
    eventTimeZone
  );
  
  return {
    localTime,
    eventTime,
    isSameTimeZone: userTimeZone === eventTimeZone
  };
}

// Usage
const event = new Date('2023-12-20T18:00:00Z'); // UTC time
const eventInfo = displayEventTime(event, 'America/New_York', 'en-US');

console.log(`Your local time: ${eventInfo.localTime}`);
console.log(`Event time (New York): ${eventInfo.eventTime}`);
```

**c) Handling Currency and Number Formats**

```javascript
// Format currency with appropriate symbol and decimal places
function formatCurrency(amount, currencyCode, locale) {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency: currencyCode,
    currencyDisplay: 'symbol'
  }).format(amount);
}

// Format currency with appropriate symbol and decimal places
function formatCurrencyWithFallback(amount, preferredCurrency, userLocale) {
  // Format in the preferred currency
  const preferredFormat = formatCurrency(amount, preferredCurrency, userLocale);
  
  // If the preferred currency is different from the user's local currency,
  // also show the amount in their local currency
  const localCurrency = getLocalCurrencyForLocale(userLocale);
  
  if (localCurrency && localCurrency !== preferredCurrency) {
    // In a real app, you would use an exchange rate API
    const exchangeRate = getExchangeRate(preferredCurrency, localCurrency);
    const localAmount = amount * exchangeRate;
    
    const localFormat = formatCurrency(localAmount, localCurrency, userLocale);
    
    return `${preferredFormat} (approximately ${localFormat})`;
  }
  
  return preferredFormat;
}

// Helper function to get local currency for a locale (simplified)
function getLocalCurrencyForLocale(locale) {
  const currencies = {
    'en-US': 'USD',
    'en-GB': 'GBP',
    'fr-FR': 'EUR',
    'ja-JP': 'JPY',
    // Add more mappings as needed
  };
  
  return currencies[locale] || 'USD';
}

// Simplified exchange rate function (in a real app, use an API)
function getExchangeRate(from, to) {
  const rates = {
    'USD_EUR': 0.92,
    'USD_GBP': 0.79,
    'USD_JPY': 143.5,
    // Add more rates as needed
  };
  
  const key = `${from}_${to}`;
  return rates[key] || 1;
}

// Usage
const price = 29.99;
const formattedPrice = formatCurrencyWithFallback(price, 'USD', 'fr-FR');
console.log(formattedPrice); // "$29.99 (approximately 27,59 €)"
```

**Key Takeaways:**

1. Internationalization (i18n) and localization (l10n) are essential for creating globally accessible applications
2. The JavaScript Intl API provides powerful built-in tools for formatting dates, numbers, and strings according to locale conventions
3. Translation management requires separating content from code and providing context for translators
4. Dynamic loading of translations improves performance by only loading the necessary language resources
5. Modern JavaScript frameworks offer robust i18n libraries that integrate with their component systems
6. Consider text direction (RTL vs LTR) and layout implications when supporting multiple languages
7. Handle pluralization, gender, and other grammatical variations appropriately for different languages
8. Format dates, times, and numbers according to local conventions using the Intl API
9. Test thoroughly with different locales, especially those with different writing systems and text directions
10. Start implementing i18n early in the development process to avoid costly refactoring later

## Build Tools and Frameworks

### Q98: Explain JavaScript build tools and module bundlers. How do they improve the development workflow and application performance?
**Difficulty: Medium**

**Answer:**
JavaScript build tools and module bundlers are essential components of modern web development workflows. They transform, bundle, and optimize code to improve developer experience and application performance. Understanding these tools is crucial for any JavaScript developer working on non-trivial applications.

**1. Understanding Build Tools and Module Bundlers**

**a) What are Build Tools?**

Build tools automate repetitive tasks in the development workflow, such as:
- Compiling/transpiling code (e.g., TypeScript to JavaScript, ES6+ to ES5)
- Optimizing assets (minification, compression)
- Running tests
- Linting code
- Managing dependencies
- Generating production builds

**b) What are Module Bundlers?**

Module bundlers specifically focus on packaging JavaScript modules and their dependencies into files that are optimized for browsers. They:
- Resolve dependencies between modules
- Combine multiple modules into fewer files
- Eliminate unused code
- Create optimized bundles for production

**c) Why They're Necessary**

- Modern JavaScript uses modular code (ES modules, CommonJS)
- Browsers have historically had limited support for module systems
- Performance optimization requires bundling, code splitting, and tree shaking
- Development workflows benefit from automation
- Modern features often require transpilation for older browsers

**2. Popular Build Tools and Bundlers**

**a) Webpack**

Webpack is a powerful and highly configurable module bundler that has become the industry standard.

*Key Features:*
- Comprehensive dependency resolution
- Code splitting and dynamic imports
- Rich plugin ecosystem
- Hot Module Replacement (HMR)
- Asset optimization
- Support for various module formats

*Basic Configuration Example:*

```javascript
// webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js'
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env']
          }
        }
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      },
      {
        test: /\.(png|svg|jpg|gif)$/,
        type: 'asset/resource'
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html'
    })
  ],
  optimization: {
    splitChunks: {
      chunks: 'all'
    }
  },
  devServer: {
    static: './dist',
    hot: true
  }
};
```

**b) Vite**

Vite is a newer build tool that leverages native ES modules for extremely fast development server startup and hot module replacement.

*Key Features:*
- Lightning-fast development server
- Built-in support for TypeScript, JSX, CSS modules
- Optimized builds with Rollup
- No bundling during development
- Smart HMR that preserves state

*Basic Configuration Example:*

```javascript
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  build: {
    outDir: 'dist',
    minify: 'terser',
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom']
        }
      }
    }
  },
  server: {
    port: 3000,
    open: true
  }
});
```

**c) Rollup**

Rollup specializes in creating highly optimized bundles, particularly for libraries and packages.

*Key Features:*
- Tree shaking (dead code elimination)
- Efficient bundling for libraries
- ES module output
- Small footprint
- Plugin-based architecture

*Basic Configuration Example:*

```javascript
// rollup.config.js
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import babel from '@rollup/plugin-babel';
import terser from '@rollup/plugin-terser';

export default {
  input: 'src/main.js',
  output: [
    {
      file: 'dist/bundle.cjs.js',
      format: 'cjs'
    },
    {
      file: 'dist/bundle.esm.js',
      format: 'es'
    },
    {
      file: 'dist/bundle.min.js',
      format: 'iife',
      name: 'myLibrary',
      plugins: [terser()]
    }
  ],
  plugins: [
    resolve(),
    commonjs(),
    babel({
      babelHelpers: 'bundled',
      exclude: 'node_modules/**'
    })
  ],
  external: ['react', 'react-dom']
};
```

**d) Parcel**

Parcel focuses on zero-configuration bundling for quick setup and ease of use.

*Key Features:*
- Zero configuration
- Fast builds with multicore processing
- Automatic dependency resolution
- Built-in support for various file types
- Development server with hot reloading

*Usage Example:*

```bash
# Install Parcel
npm install --save-dev parcel

# Run development server
npx parcel src/index.html

# Build for production
npx parcel build src/index.html
```

**e) esbuild**

esbuild is an extremely fast JavaScript bundler written in Go, focusing on build speed.

*Key Features:*
- Extremely fast bundling (10-100x faster than alternatives)
- Built-in minification and transpilation
- TypeScript and JSX support without additional plugins
- API for JavaScript and Go

*Basic Usage Example:*

```javascript
// build.js
require('esbuild').build({
  entryPoints: ['src/index.js'],
  bundle: true,
  minify: true,
  sourcemap: true,
  target: ['chrome58', 'firefox57', 'safari11', 'edge16'],
  outfile: 'dist/bundle.js',
}).catch(() => process.exit(1));
```

**f) Task Runners: npm scripts, Grunt, and Gulp**

These tools focus on automating development tasks rather than bundling.

*npm scripts:*
```json
// package.json
{
  "scripts": {
    "start": "webpack serve --mode development",
    "build": "webpack --mode production",
    "test": "jest",
    "lint": "eslint src/**/*.js",
    "format": "prettier --write 'src/**/*.{js,css,html}'"
  }
}
```

*Gulp Example:*
```javascript
// gulpfile.js
const { src, dest, watch, series, parallel } = require('gulp');
const sass = require('gulp-sass')(require('sass'));
const autoprefixer = require('gulp-autoprefixer');
const cssnano = require('gulp-cssnano');
const babel = require('gulp-babel');
const terser = require('gulp-terser');

function styles() {
  return src('./src/scss/**/*.scss')
    .pipe(sass())
    .pipe(autoprefixer())
    .pipe(cssnano())
    .pipe(dest('./dist/css'));
}

function scripts() {
  return src('./src/js/**/*.js')
    .pipe(babel({
      presets: ['@babel/preset-env']
    }))
    .pipe(terser())
    .pipe(dest('./dist/js'));
}

function watchFiles() {
  watch('./src/scss/**/*.scss', styles);
  watch('./src/js/**/*.js', scripts);
}

exports.build = parallel(styles, scripts);
exports.watch = watchFiles;
exports.default = series(parallel(styles, scripts), watchFiles);
```

**3. Key Features and Benefits**

**a) Module Resolution and Bundling**

```javascript
// src/utils.js
export function formatDate(date) {
  return new Date(date).toLocaleDateString();
}

export function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// src/app.js
import { formatDate } from './utils';

const orderDate = formatDate(new Date());
console.log(`Order date: ${orderDate}`);
```

Bundlers resolve these imports and combine them into optimized output files.

**b) Code Splitting**

```javascript
// Dynamic import for code splitting
import React from 'react';

const Dashboard = React.lazy(() => import('./Dashboard'));
const Settings = React.lazy(() => import('./Settings'));

function App() {
  return (
    <React.Suspense fallback={<div>Loading...</div>}>
      <Router>
        <Route path="/dashboard" component={Dashboard} />
        <Route path="/settings" component={Settings} />
      </Router>
    </React.Suspense>
  );
}
```

Bundlers recognize these dynamic imports and create separate chunks that are loaded on demand.

**c) Tree Shaking**

```javascript
// library.js
export function feature1() { /* ... */ }
export function feature2() { /* ... */ }
export function feature3() { /* ... */ }

// app.js
import { feature1 } from './library';

feature1(); // Only feature1 will be included in the bundle
```

Tree shaking eliminates unused exports, reducing bundle size.

**d) Asset Optimization**

```javascript
// webpack.config.js (excerpt)
module.exports = {
  // ...
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true,
          },
        },
      }),
      new CssMinimizerPlugin(),
    ],
  },
  // ...
};
```

**e) Development Server and HMR**

```javascript
// webpack.config.js (excerpt)
module.exports = {
  // ...
  devServer: {
    static: path.join(__dirname, 'dist'),
    compress: true,
    port: 9000,
    hot: true,
    historyApiFallback: true,
    proxy: {
      '/api': 'http://localhost:3000'
    }
  },
  // ...
};
```

**4. Advanced Concepts**

**a) Environment-Specific Builds**

```javascript
// webpack.config.js
const { merge } = require('webpack-merge');
const commonConfig = require('./webpack.common.js');

module.exports = (env) => {
  const isProduction = env.production === true;
  const envConfig = isProduction 
    ? require('./webpack.prod.js')
    : require('./webpack.dev.js');
  
  return merge(commonConfig, envConfig);
};
```

**b) Module Federation**

Module Federation allows multiple separate builds to share code at runtime.

```javascript
// host application webpack.config.js
const { ModuleFederationPlugin } = require('webpack').container;

module.exports = {
  // ...
  plugins: [
    new ModuleFederationPlugin({
      name: 'host',
      remotes: {
        app1: 'app1@http://localhost:3001/remoteEntry.js',
        app2: 'app2@http://localhost:3002/remoteEntry.js'
      },
      shared: ['react', 'react-dom']
    })
  ]
};

// Remote application webpack.config.js
const { ModuleFederationPlugin } = require('webpack').container;

module.exports = {
  // ...
  plugins: [
    new ModuleFederationPlugin({
      name: 'app1',
      filename: 'remoteEntry.js',
      exposes: {
        './Button': './src/components/Button',
        './Header': './src/components/Header'
      },
      shared: ['react', 'react-dom']
    })
  ]
};
```

**c) Custom Loaders and Plugins**

```javascript
// Custom webpack loader example
module.exports = function(source) {
  // Transform the source code
  const transformed = source.replace(/console\.log\([^)]*\);?/g, '');
  return transformed;
};

// Custom webpack plugin example
class MyCustomPlugin {
  apply(compiler) {
    compiler.hooks.emit.tapAsync('MyCustomPlugin', (compilation, callback) => {
      // Create a new asset
      compilation.assets['build-info.json'] = {
        source: () => JSON.stringify({
          buildTime: new Date().toISOString(),
          version: process.env.npm_package_version
        }),
        size: () => 42
      };
      callback();
    });
  }
}
```

**5. Optimizing Build Performance**

**a) Bundle Analysis**

```javascript
// webpack.config.js
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');

module.exports = {
  // ...
  plugins: [
    new BundleAnalyzerPlugin({
      analyzerMode: 'static',
      reportFilename: 'bundle-report.html',
      openAnalyzer: false
    })
  ]
};
```

**b) Caching Strategies**

```javascript
// webpack.config.js
module.exports = {
  // ...
  output: {
    filename: '[name].[contenthash].js',
    path: path.resolve(__dirname, 'dist')
  },
  optimization: {
    moduleIds: 'deterministic',
    runtimeChunk: 'single',
    splitChunks: {
      cacheGroups: {
        vendor: {
          test: /[\\\\]/node_modules[\\\\]/,
          name: 'vendors',
          chunks: 'all'
        }
      }
    }
  }
};
```

**c) Incremental Builds**

```javascript
// webpack.config.js
module.exports = {
  // ...
  cache: {
    type: 'filesystem',
    buildDependencies: {
      config: [__filename]
    }
  }
};
```

**6. Common Workflows and Patterns**

**a) Modern/Legacy Browser Support**

```javascript
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              ['@babel/preset-env', {
                targets: {
                  esmodules: true // For modern browsers
                  // Alternative: specific browsers
                  // browsers: ['last 2 versions', 'not dead']
                },
                useBuiltIns: 'usage',
                corejs: 3
              }]
            ]
          }
        }
      }
    ]
  }
};
```

**b) CSS Processing**

```javascript
// webpack.config.js
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.scss$/,
        use: [
          process.env.NODE_ENV === 'production'
            ? MiniCssExtractPlugin.loader
            : 'style-loader',
          {
            loader: 'css-loader',
            options: {
              modules: true,
              importLoaders: 2
            }
          },
          'postcss-loader',
          'sass-loader'
        ]
      }
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name].[contenthash].css'
    })
  ]
};
```

**c) TypeScript Integration**

```javascript
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/
      }
    ]
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js']
  }
};

// tsconfig.json
{
  "compilerOptions": {
    "target": "es5",
    "module": "esnext",
    "moduleResolution": "node",
    "strict": true,
    "jsx": "react",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"]
}
```

**d) Testing Setup**

```javascript
// jest.config.js
module.exports = {
  transform: {
    '^.+\\.jsx?$': 'babel-jest',
    '^.+\\.tsx?$': 'ts-jest'
  },
  moduleNameMapper: {
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
    '\\.(jpg|jpeg|png|gif|webp|svg)$': '<rootDir>/__mocks__/fileMock.js'
  },
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.js'],
  testEnvironment: 'jsdom'
};
```

**7. Choosing the Right Tools**

**a) Selection Criteria**

- **Project size and complexity**: Larger projects benefit from more configurable tools like Webpack
- **Development experience**: Tools like Vite optimize for fast feedback loops
- **Bundle size concerns**: Rollup and esbuild excel at creating optimized bundles
- **Learning curve**: Parcel offers zero-config setup for beginners
- **Ecosystem compatibility**: Some frameworks have preferred bundlers
- **Team familiarity**: Consider your team's existing knowledge

**b) Framework-Specific Considerations**

- **React**: Create React App (uses Webpack), Next.js (custom Webpack/Turbopack)
- **Vue**: Vue CLI (Webpack), Vite (official recommendation)
- **Angular**: Angular CLI (Webpack)
- **Svelte**: Rollup (default), can use others

**c) Migration Strategies**

When migrating between build tools:

1. Start with a comprehensive audit of current build features
2. Create a parallel build setup with the new tool
3. Compare output bundles and performance
4. Migrate one feature at a time
5. Run both systems in parallel during transition

**8. Future Trends**

- **Build-less development**: Native ES modules in browsers
- **Rust-based tools**: Faster compilation (e.g., SWC, Turbopack)
- **Improved caching**: Persistent and shared caching
- **Distributed builds**: Cloud-based build systems
- **AI-assisted optimization**: Smart code splitting and tree shaking

**Key Takeaways:**

1. Build tools and module bundlers are essential for modern JavaScript development
2. They improve developer experience through automation and fast feedback loops
3. They enhance application performance through optimization techniques like code splitting and tree shaking
4. Different tools have different strengths: Webpack (flexibility), Vite (speed), Rollup (optimization), Parcel (simplicity)
5. Advanced features like module federation enable micro-frontend architectures
6. Proper configuration can significantly improve build performance and output quality
7. The ecosystem continues to evolve toward faster, more efficient tools
8. The right tool depends on project requirements, team expertise, and specific use cases
9. Understanding the underlying concepts helps in configuring any build tool effectively
10. Future trends point toward even faster builds and more native browser capabilities

### Q99: Compare and contrast popular JavaScript frameworks and libraries. How do you choose the right one for a project?
**Difficulty: Medium**

**Answer:**
The JavaScript ecosystem offers numerous frameworks and libraries, each with distinct philosophies, strengths, and trade-offs. Understanding these differences is crucial for making informed decisions when selecting technologies for your projects.

**1. Major JavaScript Frameworks and Libraries Overview**

**a) React**

*Core Philosophy:* Declarative UI components with a virtual DOM and unidirectional data flow.

*Key Features:*
- Component-based architecture
- Virtual DOM for efficient rendering
- JSX syntax
- One-way data binding
- Extensive ecosystem
- Maintained by Facebook/Meta

*Code Example:*
```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

**b) Angular**

*Core Philosophy:* Full-featured framework with comprehensive tooling and opinionated structure.

*Key Features:*
- Complete MVC/MVVM framework
- TypeScript-first development
- Two-way data binding
- Dependency injection
- RxJS integration
- Comprehensive CLI
- Maintained by Google

*Code Example:*
```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-counter',
  template: `
    <div>
      <p>You clicked {{count}} times</p>
      <button (click)="increment()">Click me</button>
    </div>
  `
})
export class CounterComponent {
  count = 0;
  
  increment() {
    this.count++;
  }
}
```

**c) Vue**

*Core Philosophy:* Progressive framework that's approachable, versatile, and performant.

*Key Features:*
- Gentle learning curve
- Template-based rendering
- Reactive data binding
- Single-file components
- Flexible integration options
- Community-driven development

*Code Example:*
```vue
<template>
  <div>
    <p>You clicked {{ count }} times</p>
    <button @click="count++">Click me</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      count: 0
    };
  }
};
</script>
```

**d) Svelte**

*Core Philosophy:* Compile-time framework that shifts work from runtime to build time.

*Key Features:*
- No virtual DOM
- True reactivity at compile time
- Less boilerplate code
- Smaller bundle sizes
- Built-in transitions and animations

*Code Example:*
```svelte
<script>
  let count = 0;
  
  function increment() {
    count += 1;
  }
</script>

<div>
  <p>You clicked {count} times</p>
  <button on:click={increment}>Click me</button>
</div>
```

**e) Preact**

*Core Philosophy:* Lightweight alternative to React with the same modern API.

*Key Features:*
- Tiny size (3KB gzipped)
- React-compatible API
- Fast performance
- Focused on core functionality

*Code Example:*
```jsx
import { h, render } from 'preact';
import { useState } from 'preact/hooks';

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

render(<Counter />, document.body);
```

**f) Solid**

*Core Philosophy:* Fine-grained reactivity without a virtual DOM.

*Key Features:*
- True reactivity (like Vue/Svelte)
- JSX syntax (like React)
- No virtual DOM diffing
- Extremely performant
- Small bundle size

*Code Example:*
```jsx
import { createSignal } from 'solid-js';

function Counter() {
  const [count, setCount] = createSignal(0);
  
  return (
    <div>
      <p>You clicked {count()} times</p>
      <button onClick={() => setCount(count() + 1)}>
        Click me
      </button>
    </div>
  );
}
```

**g) jQuery**

*Core Philosophy:* Simplify DOM manipulation and event handling.

*Key Features:*
- DOM traversal and manipulation
- Event handling
- Animation effects
- Ajax support
- Cross-browser compatibility

*Code Example:*
```javascript
$(document).ready(function() {
  let count = 0;
  
  $('#counter-button').click(function() {
    count++;
    $('#counter-display').text('You clicked ' + count + ' times');
  });
});
```

**2. Specialized Libraries**

**a) State Management**

*Redux:*
```javascript
// Action types
const INCREMENT = 'INCREMENT';

// Action creator
const increment = () => ({ type: INCREMENT });

// Reducer
const counterReducer = (state = { count: 0 }, action) => {
  switch (action.type) {
    case INCREMENT:
      return { count: state.count + 1 };
    default:
      return state;
  }
};

// Store
const store = Redux.createStore(counterReducer);

// Subscribe to changes
store.subscribe(() => console.log(store.getState()));

// Dispatch action
store.dispatch(increment()); // { count: 1 }
```

*MobX:*
```javascript
import { makeAutoObservable } from 'mobx';

class CounterStore {
  count = 0;
  
  constructor() {
    makeAutoObservable(this);
  }
  
  increment() {
    this.count++;
  }
}

const counterStore = new CounterStore();
```

*Zustand:*
```javascript
import create from 'zustand';

const useCounterStore = create(set => ({
  count: 0,
  increment: () => set(state => ({ count: state.count + 1 })),
}));

// In a component
function Counter() {
  const { count, increment } = useCounterStore();
  return (
    <button onClick={increment}>
      Count: {count}
    </button>
  );
}
```

**b) Routing Libraries**

*React Router:*
```jsx
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
      </nav>
      
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </BrowserRouter>
  );
}
```

*Vue Router:*
```javascript
const routes = [
  { path: '/', component: Home },
  { path: '/about', component: About }
];

const router = VueRouter.createRouter({
  history: VueRouter.createWebHistory(),
  routes
});

const app = Vue.createApp({});
app.use(router);
```

**c) Form Handling**

*Formik (React):*
```jsx
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';

const validationSchema = Yup.object({
  email: Yup.string().email('Invalid email').required('Required'),
  password: Yup.string().min(8, 'Must be 8 characters or more').required('Required')
});

function LoginForm() {
  return (
    <Formik
      initialValues={{ email: '', password: '' }}
      validationSchema={validationSchema}
      onSubmit={(values) => {
        console.log(values);
      }}
    >
      <Form>
        <div>
          <label htmlFor="email">Email</label>
          <Field name="email" type="email" />
          <ErrorMessage name="email" component="div" />
        </div>
        
        <div>
          <label htmlFor="password">Password</label>
          <Field name="password" type="password" />
          <ErrorMessage name="password" component="div" />
        </div>
        
        <button type="submit">Submit</button>
      </Form>
    </Formik>
  );
}
```

*React Hook Form:*
```jsx
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';

const schema = yup.object({
  email: yup.string().email().required(),
  password: yup.string().min(8).required()
});

function LoginForm() {
  const { register, handleSubmit, formState: { errors } } = useForm({
    resolver: yupResolver(schema)
  });
  
  const onSubmit = data => console.log(data);
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>Email</label>
        <input {...register('email')} />
        {errors.email && <p>{errors.email.message}</p>}
      </div>
      
      <div>
        <label>Password</label>
        <input type="password" {...register('password')} />
        {errors.password && <p>{errors.password.message}</p>}
      </div>
      
      <button type="submit">Submit</button>
    </form>
  );
}
```

**3. Meta-Frameworks and Full-Stack Solutions**

**a) Next.js (React)**

*Key Features:*
- Server-side rendering
- Static site generation
- API routes
- File-based routing
- Image optimization
- Incremental static regeneration

*Basic Page Example:*
```jsx
// pages/index.js
import { useState } from 'react';

export default function Home() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <h1>Welcome to Next.js</h1>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

// Data fetching example
export async function getStaticProps() {
  const res = await fetch('https://api.example.com/data');
  const data = await res.json();
  
  return {
    props: { data },
    revalidate: 60 // Regenerate page every 60 seconds
  };
}
```

**b) Nuxt.js (Vue)**

*Key Features:*
- Server-side rendering
- Static site generation
- Auto-imported components
- File-based routing
- Module system

*Basic Page Example:*
```vue
<!-- pages/index.vue -->
<template>
  <div>
    <h1>Welcome to Nuxt.js</h1>
    <p>Count: {{ count }}</p>
    <button @click="count++">Increment</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      count: 0
    };
  },
  async asyncData() {
    const { data } = await this.$axios.get('/api/data');
    return { apiData: data };
  }
};
</script>
```

**c) SvelteKit (Svelte)**

*Key Features:*
- Server-side rendering
- Static site generation
- File-based routing
- Endpoint handlers
- Progressive enhancement

*Basic Page Example:*
```svelte
<!-- routes/index.svelte -->
<script>
  import { onMount } from 'svelte';
  let count = 0;
  let data = {};
  
  onMount(async () => {
    const response = await fetch('/api/data');
    data = await response.json();
  });
</script>

<h1>Welcome to SvelteKit</h1>
<p>Count: {count}</p>
<button on:click={() => count++}>Increment</button>

<!-- routes/api/data.js -->
<script context="module">
  export async function get() {
    return {
      body: { message: 'Hello from API' }
    };
  }
</script>
```

**d) Remix (React)**

*Key Features:*
- Nested routing
- Server-side rendering
- Progressive enhancement
- Error boundaries
- Data loading/mutations

*Basic Page Example:*
```jsx
// app/routes/index.jsx
import { useLoaderData, Form } from '@remix-run/react';

export async function loader() {
  const data = await fetchData();
  return { data };
}

export async function action({ request }) {
  const formData = await request.formData();
  const name = formData.get('name');
  await saveData(name);
  return null;
}

export default function Index() {
  const { data } = useLoaderData();
  
  return (
    <div>
      <h1>Welcome to Remix</h1>
      <p>Data: {data.message}</p>
      
      <Form method="post">
        <input name="name" />
        <button type="submit">Save</button>
      </Form>
    </div>
  );
}
```

**4. Comparing Frameworks: Key Differentiators**

**a) Performance Metrics**

*Rendering Performance:*
- React: Virtual DOM diffing
- Svelte/Solid: Compile-time reactivity, no virtual DOM
- Angular: Change detection with zones
- Vue: Virtual DOM with optimized diffing

*Bundle Size (Hello World):*
- React + ReactDOM: ~40KB (gzipped)
- Angular: ~60KB (gzipped)
- Vue: ~20KB (gzipped)
- Svelte: ~3KB (gzipped)
- Preact: ~3KB (gzipped)
- Solid: ~5KB (gzipped)

**b) Developer Experience**

*Learning Curve:*
- Steeper: Angular (comprehensive framework with many concepts)
- Moderate: React (JSX, hooks, component lifecycle)
- Gentler: Vue (template syntax, progressive adoption)
- Easiest: Svelte (minimal new syntax to learn)

*Tooling:*
- Angular: Comprehensive CLI, strong TypeScript integration
- React: Create React App, Next.js, extensive ecosystem
- Vue: Vue CLI, Vite, Vue DevTools
- Svelte: SvelteKit, minimal configuration

**c) Community and Ecosystem**

*Community Size (approximate):*
- React: Largest community, extensive third-party libraries
- Angular: Large enterprise adoption, comprehensive built-in features
- Vue: Growing community, strong in certain regions (especially China)
- Svelte: Smaller but enthusiastic community

*Job Market:*
- React: Highest demand
- Angular: Strong in enterprise settings
- Vue: Growing demand, especially in startups
- Newer frameworks (Svelte, Solid): Emerging opportunities

**5. Selection Criteria: How to Choose**

**a) Project Requirements Assessment**

*Questions to Ask:*
- What is the project's scale and complexity?
- What are the performance requirements?
- Is SEO important (requiring SSR/SSG)?
- What's the team's existing expertise?
- What's the timeline for development?
- Are there specific integration requirements?

**b) Decision Matrix Example**

| Criteria | Weight | React | Angular | Vue | Svelte |
|---------|--------|-------|---------|-----|--------|
| Performance | 3 | 4 (12) | 3 (9) | 4 (12) | 5 (15) |
| Ecosystem | 4 | 5 (20) | 4 (16) | 3 (12) | 2 (8) |
| Learning Curve | 2 | 3 (6) | 2 (4) | 4 (8) | 5 (10) |
| Community Support | 3 | 5 (15) | 4 (12) | 4 (12) | 3 (9) |
| TypeScript Support | 2 | 4 (8) | 5 (10) | 4 (8) | 3 (6) |
| **Total** | | **61** | **51** | **52** | **48** |

*Note: This is just an example. Weights and scores should be adjusted based on specific project needs.*

**c) Framework Selection Guidelines**

*Choose React when:*
- You need a flexible, component-based library
- You have complex UI with frequent updates
- You want access to the largest ecosystem of libraries
- You're building a large-scale application
- You need strong community support

*Choose Angular when:*
- You need a comprehensive, opinionated framework
- You're building enterprise-level applications
- You want built-in solutions for common needs
- Your team prefers TypeScript
- You need strong consistency across a large team

*Choose Vue when:*
- You want a gentle learning curve
- You need a balance between structure and flexibility
- You're migrating from a traditional web app
- You want excellent documentation
- You prefer template-based syntax

*Choose Svelte when:*
- Performance is a top priority
- You want minimal boilerplate code
- Bundle size is critical
- You're building smaller to medium applications
- You want built-in animation capabilities

*Choose a meta-framework when:*
- SEO is important
- You need server-side rendering
- You're building a content-heavy site
- You need API routes alongside your frontend
- Initial load performance is critical

**6. Migration and Coexistence Strategies**

**a) Incremental Adoption**

*React in an Existing App:*
```html
<!-- Existing app -->
<div id="react-container"></div>

<script>
  // Load React components into a specific container
  ReactDOM.render(
    React.createElement(MyReactComponent),
    document.getElementById('react-container')
  );
</script>
```

*Vue in an Existing App:*
```html
<!-- Existing app -->
<div id="vue-container">
  <button @click="count++">{{ count }}</button>
</div>

<script>
  new Vue({
    el: '#vue-container',
    data: { count: 0 }
  });
</script>
```

**b) Micro-Frontend Architecture**

```javascript
// Using Module Federation (Webpack 5)
// App 1 (React)
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'app1',
      filename: 'remoteEntry.js',
      exposes: {
        './Header': './src/Header'
      },
      shared: ['react', 'react-dom']
    })
  ]
};

// App 2 (Vue)
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'app2',
      filename: 'remoteEntry.js',
      remotes: {
        app1: 'app1@http://localhost:3001/remoteEntry.js'
      },
      shared: ['vue']
    })
  ]
};

// In App 2
import('app1/Header').then(HeaderModule => {
  // Use React component in Vue app
  const Header = HeaderModule.default;
  // Mount with custom wrapper
});
```

**7. Future Trends and Considerations**

**a) Emerging Patterns**

- Islands Architecture (partial hydration)
- Server Components (React Server Components)
- Edge rendering (Cloudflare Workers, Deno Deploy)
- Resumability vs. Hydration

**b) Framework Evolution**

*React Server Components:*
```jsx
// server-component.jsx - runs only on the server
import { db } from './database';

async function ServerComponent({ userId }) {
  const user = await db.user.findUnique({ where: { id: userId } });
  
  return (
    <div>
      <h1>{user.name}'s Profile</h1>
      <ClientComponent userData={user} />
    </div>
  );
}

// client-component.jsx - runs in the browser
'use client';

function ClientComponent({ userData }) {
  const [isEditing, setIsEditing] = useState(false);
  
  return (
    <div>
      {isEditing ? (
        <EditForm userData={userData} />
      ) : (
        <button onClick={() => setIsEditing(true)}>Edit Profile</button>
      )}
    </div>
  );
}
```

**Key Takeaways:**

1. No single framework or library is best for all situations—each has strengths and trade-offs
2. React offers flexibility and a vast ecosystem but requires additional libraries for a complete solution
3. Angular provides a comprehensive, opinionated framework ideal for large enterprise applications
4. Vue balances approachability with power, making it excellent for teams transitioning to modern JS
5. Svelte and Solid represent the compile-time approach, offering excellent performance with less code
6. Meta-frameworks like Next.js and Nuxt.js address common requirements like SSR and routing
7. Consider project requirements, team expertise, and long-term maintenance when selecting a framework
8. Performance characteristics vary: runtime vs. compile-time, virtual DOM vs. direct DOM manipulation
9. The ecosystem continues to evolve with trends toward server components and partial hydration
10. For large projects, consider a decision matrix that weights factors according to specific needs

## WebAssembly and JavaScript Integration

### Q100: Explain WebAssembly (Wasm) and how it integrates with JavaScript. What are its use cases and limitations?
**Difficulty: Hard**

**Answer:**
WebAssembly (Wasm) represents a significant evolution in web development, bringing near-native performance to the browser. Understanding how it works with JavaScript opens up new possibilities for web applications that were previously impractical due to performance constraints.

**1. Understanding WebAssembly**

**a) What is WebAssembly?**

WebAssembly is a binary instruction format designed as a portable compilation target for high-level languages like C, C++, Rust, and others. It allows code written in these languages to run in web browsers at near-native speed.

*Key Characteristics:*
- Low-level binary format (not meant to be written by hand)
- Compact size for efficient transmission
- Near-native execution speed
- Memory-safe, sandboxed execution environment
- Platform-independent
- Compatible with the web platform

**b) How WebAssembly Works**

1. Code is written in a language like C++, Rust, or AssemblyScript
2. Compiled to WebAssembly binary format (.wasm files)
3. Loaded and instantiated by JavaScript
4. Executed in the browser's WebAssembly virtual machine

**c) WebAssembly vs. JavaScript**

| Aspect | WebAssembly | JavaScript |
|--------|------------|------------|
| Format | Binary | Text |
| Execution | Pre-compiled | JIT-compiled |
| Performance | Near-native | Variable (depends on JIT) |
| Memory Model | Manual (linear memory) | Automatic (garbage collected) |
| Type System | Statically typed | Dynamically typed |
| Debugging | More complex | Well-supported |
| DOM Access | Only via JavaScript | Direct |
| Development | Requires compilation | Interpreted |

**2. JavaScript and WebAssembly Integration**

**a) Loading and Instantiating WebAssembly**

```javascript
// Modern approach using ES modules
async function loadWasm() {
  try {
    // Import the WebAssembly module
    const wasmModule = await import('./module.wasm');
    
    // Access exported functions
    const result = wasmModule.add(5, 3);
    console.log('Result:', result); // 8
  } catch (err) {
    console.error('Failed to load WebAssembly module:', err);
  }
}

// Traditional approach
async function loadWasmTraditional() {
  try {
    // Fetch the WebAssembly module
    const response = await fetch('./module.wasm');
    const buffer = await response.arrayBuffer();
    
    // Compile and instantiate
    const wasmModule = await WebAssembly.instantiate(buffer);
    
    // Access exported functions
    const instance = wasmModule.instance;
    const result = instance.exports.add(5, 3);
    console.log('Result:', result); // 8
  } catch (err) {
    console.error('Failed to load WebAssembly module:', err);
  }
}
```

**b) Passing Data Between JavaScript and WebAssembly**

*Primitive Values:*

```javascript
// WebAssembly module exports a function that takes integers
const result = wasmInstance.exports.multiplyIntegers(5, 7); // 35
```

*Arrays and Memory Access:*

```javascript
// Accessing WebAssembly memory from JavaScript
const memory = wasmInstance.exports.memory;
const buffer = new Uint8Array(memory.buffer);

// Writing to memory that WebAssembly can access
function passArrayToWasm(array) {
  // Allocate memory in the WebAssembly instance
  const ptr = wasmInstance.exports.allocate(array.length);
  
  // Get a view of the WebAssembly memory
  const heap = new Uint8Array(wasmInstance.exports.memory.buffer);
  
  // Copy the array into WebAssembly memory
  for (let i = 0; i < array.length; i++) {
    heap[ptr + i] = array[i];
  }
  
  // Call WebAssembly function with pointer and length
  const sum = wasmInstance.exports.sumArray(ptr, array.length);
  
  // Free the allocated memory
  wasmInstance.exports.deallocate(ptr, array.length);
  
  return sum;
}

const result = passArrayToWasm([1, 2, 3, 4, 5]); // 15
```

*Strings:*

```javascript
// Passing a string to WebAssembly
function passStringToWasm(str) {
  const encoder = new TextEncoder();
  const bytes = encoder.encode(str);
  
  // Allocate memory in WebAssembly
  const ptr = wasmInstance.exports.allocate(bytes.length + 1); // +1 for null terminator
  
  // Get a view of the WebAssembly memory
  const heap = new Uint8Array(wasmInstance.exports.memory.buffer);
  
  // Copy the string bytes to WebAssembly memory
  for (let i = 0; i < bytes.length; i++) {
    heap[ptr + i] = bytes[i];
  }
  
  // Add null terminator
  heap[ptr + bytes.length] = 0;
  
  // Call WebAssembly function with pointer
  const result = wasmInstance.exports.processString(ptr);
  
  // Free the allocated memory
  wasmInstance.exports.deallocate(ptr, bytes.length + 1);
  
  return result;
}
```

**c) JavaScript Callbacks from WebAssembly**

```javascript
// Define a function table to allow WebAssembly to call JavaScript functions
const importObject = {
  env: {
    memory: new WebAssembly.Memory({ initial: 1 }),
    table: new WebAssembly.Table({ initial: 2, element: 'anyfunc' }),
    logNumber: function(num) {
      console.log('Number from WebAssembly:', num);
    },
    alertMessage: function(ptr, len) {
      const memory = new Uint8Array(importObject.env.memory.buffer);
      let message = '';
      for (let i = 0; i < len; i++) {
        message += String.fromCharCode(memory[ptr + i]);
      }
      alert(message);
    }
  }
};

// Instantiate WebAssembly with imports
WebAssembly.instantiateStreaming(fetch('module.wasm'), importObject)
  .then(obj => {
    // WebAssembly can now call the imported JavaScript functions
    obj.instance.exports.runComputation();
  });
```

**3. Development Workflow**

**a) Compiling to WebAssembly**

*From C/C++ using Emscripten:*

```bash
# Install Emscripten
git clone https://github.com/emscripten-core/emsdk.git
cd emsdk
./emsdk install latest
./emsdk activate latest
source ./emsdk_env.sh

# Compile C to WebAssembly
emcc -O3 -s WASM=1 -s EXPORTED_FUNCTIONS='["_add", "_multiply"]' -o math.js math.c
```

*C/C++ Source Example:*

```c
// math.c
#include <emscripten.h>

EMSCRIPTEN_KEEPALIVE
int add(int a, int b) {
  return a + b;
}

EMSCRIPTEN_KEEPALIVE
int multiply(int a, int b) {
  return a * b;
}
```

*From Rust:*

```bash
# Install wasm-pack
cargo install wasm-pack

# Create a new Rust library
cargo new --lib rust-wasm
cd rust-wasm
```

*Rust Source Example:*

```rust
// lib.rs
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[wasm_bindgen]
pub fn fibonacci(n: i32) -> i32 {
    if n <= 1 {
        return n;
    }
    fibonacci(n - 1) + fibonacci(n - 2)
}
```

```bash
# Build the WebAssembly module
wasm-pack build --target web
```

*Using AssemblyScript (TypeScript-like):*

```bash
# Install AssemblyScript
npm install -g assemblyscript

# Initialize a project
npx asinit .
```

*AssemblyScript Source Example:*

```typescript
// assembly/index.ts
export function add(a: i32, b: i32): i32 {
  return a + b;
}

export function factorial(n: i32): i32 {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}
```

```bash
# Compile to WebAssembly
npm run asbuild
```

**b) Tooling and Frameworks**

*WebAssembly Studio:* Online IDE for WebAssembly development

*Emscripten:* Compiles C/C++ to WebAssembly

*wasm-bindgen:* Facilitates high-level interactions between Wasm modules and JavaScript

*wasm-pack:* Build and publish Rust-generated WebAssembly

*AssemblyScript:* TypeScript-like language for WebAssembly

*Wasmtime/Wasmer:* WebAssembly runtimes for server-side execution

**4. Real-World Use Cases**

**a) Computation-Intensive Tasks**

*Image and Video Processing:*

```javascript
// Using WebAssembly for image processing
async function applyFilter(imageData) {
  const { processImage } = await import('./image_processing.wasm');
  
  // Create a copy of the image data in WebAssembly memory
  const ptr = copyToWasmMemory(imageData.data);
  
  // Process the image with WebAssembly
  processImage(ptr, imageData.width, imageData.height);
  
  // Copy the processed data back to the imageData
  copyFromWasmMemory(ptr, imageData.data);
  
  // Update the canvas with the processed image
  ctx.putImageData(imageData, 0, 0);
}
```

*Audio Processing:*

```javascript
// Audio worklet using WebAssembly for real-time audio processing
class WasmAudioProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.wasmInstance = null;
    this.port.onmessage = this.handleMessage.bind(this);
  }
  
  async handleMessage(event) {
    if (event.data.type === 'loadWasm') {
      const { wasmModule } = event.data;
      this.wasmInstance = await WebAssembly.instantiate(wasmModule);
    }
  }
  
  process(inputs, outputs, parameters) {
    if (!this.wasmInstance) return true;
    
    const input = inputs[0][0];
    const output = outputs[0][0];
    
    // Process audio with WebAssembly
    this.wasmInstance.exports.processAudio(input, output, input.length);
    
    return true;
  }
}

registerProcessor('wasm-audio-processor', WasmAudioProcessor);
```

**b) Games and Graphics**

*3D Rendering:*

```javascript
// Using WebAssembly for 3D math operations in a WebGL context
async function initRenderer() {
  const { initializeEngine, renderFrame } = await loadWasmModule('./graphics_engine.wasm');
  
  // Initialize the 3D engine
  const enginePtr = initializeEngine(canvas.width, canvas.height);
  
  // Animation loop
  function animate() {
    // Update scene data in shared memory
    updateSceneData();
    
    // Render frame using WebAssembly
    renderFrame(enginePtr);
    
    requestAnimationFrame(animate);
  }
  
  animate();
}
```

*Physics Simulation:*

```javascript
// Using a WebAssembly physics engine
async function initPhysics() {
  const physics = await import('./physics_engine.wasm');
  
  // Create a physics world
  const worldPtr = physics.createWorld(9.8); // gravity
  
  // Add bodies to the simulation
  const boxPtr = physics.createBox(worldPtr, 1.0, 1.0, 1.0, 5.0); // dimensions and mass
  physics.setPosition(boxPtr, 0, 10, 0); // position
  
  // Run simulation loop
  function simulate(timestamp) {
    // Step the physics simulation
    physics.stepSimulation(worldPtr, 1/60);
    
    // Get updated positions
    const positions = new Float32Array(physics.exports.memory.buffer, 
                                      physics.getPositionsPtr(worldPtr), 
                                      physics.getBodyCount(worldPtr) * 3);
    
    // Update visual representations
    updateVisuals(positions);
    
    requestAnimationFrame(simulate);
  }
  
  requestAnimationFrame(simulate);
}
```

**c) Porting Existing Libraries**

*Example: Using SQLite in the browser:*

```javascript
// Using sql.js (SQLite compiled to WebAssembly)
import initSqlJs from 'sql.js';

async function runDatabase() {
  // Initialize the SQL.js library
  const SQL = await initSqlJs();
  
  // Create a database
  const db = new SQL.Database();
  
  // Run SQL queries
  db.run('CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)');
  db.run('INSERT INTO users VALUES (1, "John Doe", "john@example.com")');
  
  // Query data
  const result = db.exec('SELECT * FROM users');
  console.log(result[0].values); // [[1, "John Doe", "john@example.com"]]
  
  // Export the database to a Uint8Array
  const data = db.export();
  
  // Clean up
  db.close();
  
  return data;
}
```

**d) Cryptography and Security**

```javascript
// Using WebAssembly for cryptographic operations
import { argon2id } from 'hash-wasm';

async function hashPassword(password) {
  try {
    const hash = await argon2id({
      password,
      salt: 'somesalt',
      iterations: 2,
      memorySize: 65536, // 64 MB
      hashLength: 32,
      parallelism: 1
    });
    
    return hash;
  } catch (err) {
    console.error('Error hashing password:', err);
    throw err;
  }
}

// Usage
hashPassword('mySecurePassword')
  .then(hash => console.log('Password hash:', hash))
  .catch(err => console.error(err));
```

**5. Performance Considerations**

**a) When to Use WebAssembly**

*Good candidates for WebAssembly:*
- CPU-intensive computations
- Complex algorithms
- Processing large data sets
- Real-time applications (audio, video, graphics)
- Porting existing C/C++/Rust libraries

*Not ideal for WebAssembly:*
- Simple DOM manipulations
- UI logic
- Small, infrequently called functions
- Code that frequently interacts with JavaScript

**b) Benchmarking Example**

```javascript
// Comparing JavaScript vs WebAssembly performance
async function runBenchmark() {
  // Load WebAssembly module
  const wasmModule = await import('./benchmark.wasm');
  
  // JavaScript implementation
  function fibonacciJS(n) {
    if (n <= 1) return n;
    return fibonacciJS(n - 1) + fibonacciJS(n - 2);
  }
  
  // WebAssembly implementation is imported from the module
  const fibonacciWasm = wasmModule.fibonacci;
  
  // Benchmark JavaScript
  const jsStart = performance.now();
  const jsResult = fibonacciJS(40);
  const jsEnd = performance.now();
  
  // Benchmark WebAssembly
  const wasmStart = performance.now();
  const wasmResult = fibonacciWasm(40);
  const wasmEnd = performance.now();
  
  console.log(`JavaScript result: ${jsResult}, time: ${jsEnd - jsStart}ms`);
  console.log(`WebAssembly result: ${wasmResult}, time: ${wasmEnd - wasmStart}ms`);
  console.log(`WebAssembly is ${(jsEnd - jsStart) / (wasmEnd - wasmStart)}x faster`);
}
```

**c) Memory Management**

```javascript
// Manual memory management with WebAssembly
async function memoryManagementExample() {
  const { instance } = await WebAssembly.instantiate(wasmModule);
  
  // Get exports
  const { 
    memory, 
    allocate, 
    deallocate, 
    processData 
  } = instance.exports;
  
  // Create a large array
  const size = 1000000;
  const data = new Float32Array(size);
  for (let i = 0; i < size; i++) {
    data[i] = Math.random();
  }
  
  // Allocate memory in WebAssembly
  const ptr = allocate(size * Float32Array.BYTES_PER_ELEMENT);
  
  // Copy data to WebAssembly memory
  new Float32Array(memory.buffer).set(data, ptr / Float32Array.BYTES_PER_ELEMENT);
  
  // Process data in WebAssembly
  processData(ptr, size);
  
  // Read results back
  const results = new Float32Array(memory.buffer, ptr, size);
  
  // Free memory when done
  deallocate(ptr, size * Float32Array.BYTES_PER_ELEMENT);
  
  return results;
}
```

**6. Limitations and Challenges**

**a) DOM Access**

WebAssembly cannot directly access the DOM; it must go through JavaScript:

```javascript
// WebAssembly module with imported DOM functions
const importObject = {
  env: {
    memory: new WebAssembly.Memory({ initial: 10 }),
    updateDOMElement: function(id, value) {
      document.getElementById(id).textContent = value;
    },
    createElement: function(tagPtr, tagLen) {
      const memory = new Uint8Array(importObject.env.memory.buffer);
      let tag = '';
      for (let i = 0; i < tagLen; i++) {
        tag += String.fromCharCode(memory[tagPtr + i]);
      }
      const element = document.createElement(tag);
      // Store element reference somehow for future use
      return storeElementReference(element);
    }
  }
};
```

**b) Debugging Challenges**

```javascript
// Adding debugging capabilities to WebAssembly
const importObject = {
  env: {
    memory: new WebAssembly.Memory({ initial: 10 }),
    consoleLog: function(value) {
      console.log('WASM log:', value);
    },
    consoleLogString: function(ptr, len) {
      const memory = new Uint8Array(importObject.env.memory.buffer);
      let message = '';
      for (let i = 0; i < len; i++) {
        message += String.fromCharCode(memory[ptr + i]);
      }
      console.log('WASM log:', message);
    }
  }
};

// In C/C++ code
// extern void consoleLog(int value);
// extern void consoleLogString(const char* str, int length);
// 
// void debug_function() {
//   consoleLog(42);
//   const char* message = "Hello from WebAssembly";
//   consoleLogString(message, strlen(message));
// }
```

**c) Threading and Concurrency**

```javascript
// Using shared memory and atomics with WebAssembly
async function threadingExample() {
  // Check for SharedArrayBuffer support
  if (typeof SharedArrayBuffer === 'undefined') {
    console.error('SharedArrayBuffer is not supported in this browser');
    return;
  }
  
  // Create a shared memory
  const memory = new WebAssembly.Memory({
    initial: 10,
    maximum: 100,
    shared: true
  });
  
  // Create a shared array buffer view
  const sharedArray = new Int32Array(memory.buffer);
  
  // Create worker
  const worker = new Worker('wasm-worker.js');
  
  // Send the shared memory to the worker
  worker.postMessage({
    memory,
    module: await fetch('./threading.wasm').then(res => res.arrayBuffer())
  });
  
  // Main thread can now use Atomics to coordinate with the worker
  Atomics.store(sharedArray, 0, 1); // Signal worker to start
  
  // Wait for worker to complete
  while (Atomics.load(sharedArray, 1) !== 1) {
    // Either busy wait or use Atomics.wait in real code
  }
  
  console.log('Worker completed, result:', Atomics.load(sharedArray, 2));
}

// In wasm-worker.js
self.onmessage = async function(e) {
  const { memory, module } = e.data;
  
  // Instantiate the WebAssembly module with the shared memory
  const instance = await WebAssembly.instantiate(module, {
    env: { memory }
  });
  
  const sharedArray = new Int32Array(memory.buffer);
  
  // Wait for main thread signal
  while (Atomics.load(sharedArray, 0) !== 1) {
    // Either busy wait or use Atomics.wait in real code
  }
  
  // Run computation
  const result = instance.exports.computeInWorker();
  
  // Store result and signal completion
  Atomics.store(sharedArray, 2, result);
  Atomics.store(sharedArray, 1, 1);
};
```

**7. Future of WebAssembly**

**a) Upcoming Features**

- *Garbage Collection:* Native integration with JavaScript's garbage collector
- *Exception Handling:* Standardized exception handling across languages
- *Reference Types:* Direct references to host objects
- *SIMD:* Single Instruction, Multiple Data for parallel processing
- *Threads:* Standardized threading model
- *Tail Calls:* Optimization for recursive functions
- *Multiple Return Values:* Functions returning multiple values efficiently

**b) WebAssembly System Interface (WASI)**

```javascript
// Using WASI for file system access (in a WASI-enabled environment)
async function wasiExample() {
  // Create a WASI instance
  const wasi = new WASI({
    args: ['wasm-module', 'input.txt'],
    env: {},
    preopens: {
      '/sandbox': '/some/path' // Map virtual path to real path
    }
  });
  
  // Instantiate the WebAssembly module with WASI imports
  const { instance } = await WebAssembly.instantiate(wasmModule, {
    wasi_snapshot_preview1: wasi.wasiImport
  });
  
  // Initialize WASI
  wasi.initialize(instance);
  
  // Run the WebAssembly module's main function
  const exitCode = instance.exports._start();
  console.log('Program exited with code:', exitCode);
}
```

**Key Takeaways:**

1. WebAssembly brings near-native performance to the web, complementing JavaScript rather than replacing it
2. It excels at computation-intensive tasks like image processing, cryptography, and physics simulations
3. WebAssembly modules are loaded, instantiated, and called from JavaScript, creating a bridge between languages
4. Data exchange between JavaScript and WebAssembly requires careful memory management
5. Development typically involves writing code in languages like C++, Rust, or AssemblyScript and compiling to .wasm
6. WebAssembly has limitations, including no direct DOM access and more complex debugging
7. Performance benefits are most significant for CPU-intensive operations, not for DOM manipulation
8. Memory management is manual in WebAssembly, requiring explicit allocation and deallocation
9. Threading support is emerging but requires SharedArrayBuffer and careful synchronization
10. The future of WebAssembly includes garbage collection, exception handling, and standardized system interfaces